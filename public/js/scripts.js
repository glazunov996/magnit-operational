(function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function get_store_value(store) {
        let value;
        subscribe(store, _ => value = _)();
        return value;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_svg_attributes(node, attributes) {
        for (const key in attributes) {
            attr(node, key, attributes[key]);
        }
    }
    function xlink_attr(node, attribute, value) {
        node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);
    }
    function get_binding_group_value(group, __value, checked) {
        const value = new Set();
        for (let i = 0; i < group.length; i += 1) {
            if (group[i].checked)
                value.add(group[i].__value);
        }
        if (!checked) {
            value.delete(__value);
        }
        return Array.from(value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        const z_index = (parseInt(computed_style.zIndex) || 0) - 1;
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', `display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ` +
            `overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: ${z_index};`);
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = `data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>`;
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    function setContext(key, context) {
        get_current_component().$$.context.set(key, context);
    }
    function getContext(key) {
        return get_current_component().$$.context.get(key);
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error(`Cannot have duplicate keys in a keyed each`);
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if ($$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set() {
            // overridden by instance, if it has props
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.24.0' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev("SvelteDOMInsert", { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev("SvelteDOMInsert", { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev("SvelteDOMRemove", { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
        else
            dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function prop_dev(node, property, value) {
        node[property] = value;
        dispatch_dev("SvelteDOMSetProperty", { node, property, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev("SvelteDOMSetData", { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier}start start and stop notifications for subscriptions
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe,
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let inited = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (inited) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            inited = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
            };
        });
    }

    function isMultiple(keys) {
      return Array.isArray(keys);
    }

    function collectAsKey(object, key, store, getter) {
      const result = object;
      if (store[key]) result[key] = getter(store, key);
      return result;
    }

    function generateCollectorWidthStore(store, collector) {
      return (result, key) => collector(result, key, store);
    }

    function getMultipleKeysFromStore(store, keys, collector) {
      const collectorWithStore = generateCollectorWidthStore(store, collector);
      return keys.reduce(collectorWithStore, {});
    }

    function getKeysFromStore(store, request, collector, getter) {
      const keys = request || Object.keys(store);
      if (isMultiple(keys)) return getMultipleKeysFromStore(store, keys, collector);
      return getter(store, keys);
    }

    function getSvelteStoreData(store, key) {
      if (store && store[key]) return get_store_value(store[key]);
      return null;
    }

    function collectSvelteStoreData(object, key, store) {
      return collectAsKey(object, key, store, getSvelteStoreData);
    }

    function getStateData(state, keys) {
      return getKeysFromStore(state, keys, collectSvelteStoreData, getSvelteStoreData);
    }

    function getSvelteStore(store, key) {
      return store[key];
    }

    function collectSvelteStore(object, key, store) {
      return collectAsKey(object, key, store, getSvelteStore);
    }

    function getState(state, keys) {
      return getKeysFromStore(state, keys, collectSvelteStore, getSvelteStore);
    }

    function updateSvelteStore(key, value, store) {
      const svelteStore = getSvelteStore(store, key);
      if (svelteStore) svelteStore.set(value);
      else initSvelteStore(store, key, value);
    }

    function updateData(store, update) {
      Object.entries(update).forEach(([ key, value ]) => { updateSvelteStore(key, value, store); });
    }

    function subscribeWithKey(key, store, task) {
      return store.subscribe(update => task(key, update));
    }

    function subscribeAll(store, task) {
      return Object.entries(store).map(([key, svelteStore]) => subscribeWithKey(key, svelteStore, task));
    }

    function subscribe$1(store, key, task) {
      const svelteStore = getSvelteStore(store, key);
      if (svelteStore) return svelteStore.subscribe(task);
      return null;
    }

    function initSvelteStore(object, key, value) {
      const result = object;
      result[key] = writable(value);
      return result;
    }

    function initState(options) {
      return Object.entries(options).reduce((result, [ key, value ]) => initSvelteStore(result, key, value), {});
    }

    const UI_INITIAL_STATE = {
      menu: false,
      menuDashNav: false,
      aside: false,
      indicators: false,
      comparisonIndicators: false,
      locale: 'ru',
      tooltip: null,
      confirmation: null,
      updating: 0,
      updatingMeta: 0,
      initialized: false,
      scrollY: 0,
      sectionScrollX: 0,
      templates: null,
      templateUpdate: 0,
      started: false,
    };

    let uiState;

    function initUI() {
      uiState = initState({ ...UI_INITIAL_STATE });
    }

    function updateUI(update) {
      updateData(uiState, update);
    }

    function getUIState(keys) {
      return getState(uiState, keys);
    }

    const precisionOptions = [
    	"D",
    	"W",
    	"M",
    	"Q",
    	"Y"
    ];
    var app = {
    	precisionOptions: precisionOptions
    };

    const modes = [
    	{
    		label: "Динамика",
    		value: "graphModeDynamics"
    	},
    	{
    		label: "Срез по округу/TO",
    		subLabel: "Округ",
    		value: "graphModeCounty",
    		options: "counties"
    	},
    	{
    		label: "Срез по формату",
    		subLabel: "Формат",
    		value: "graphModeFormat",
    		options: "formats"
    	},
    	{
    		label: "Срез по категориям",
    		subLabel: "Категория",
    		value: "graphModeCategory",
    		options: "categories"
    	},
    	{
    		label: "Структура чека",
    		subLabel: "Стр. чек.",
    		value: "graphModeReceipt"
    	}
    ];
    const dynamics = [
    	{
    		value: "graphDetailDay",
    		label: "D",
    		subLabel: "По дн."
    	},
    	{
    		value: "graphDetailWeek",
    		label: "W",
    		subLabel: "По нед."
    	},
    	{
    		value: "graphDetailMonth",
    		label: "M",
    		subLabel: "По мес."
    	},
    	{
    		value: "graphDetailQuarter",
    		label: "Q",
    		subLabel: "По кв."
    	},
    	{
    		value: "graphDetailYear",
    		label: "Y",
    		subLabel: "По годам"
    	}
    ];
    var graphs = {
    	modes: modes,
    	dynamics: dynamics
    };

    var financialColumn = [
    	{
    		label: "Периоды",
    		indicators: [
    			{
    				label: "QTD",
    				value: 3
    			},
    			{
    				label: "YTD",
    				value: 4
    			}
    		]
    	}
    ];

    var financialFilter = [
    	{
    		options: [
    			{
    				type: "controlledSelect",
    				data: {
    					name: "LFL",
    					label: "LFL",
    					pick: [
    					]
    				}
    			},
    			{
    				type: "controlledSelect",
    				data: {
    					label: "NonLFL",
    					name: "NonLFL",
    					pick: [
    					]
    				}
    			}
    		]
    	},
    	{
    		options: [
    			{
    				type: "picks",
    				data: {
    					name: "FRMT",
    					pick: [
    					]
    				}
    			},
    			{
    				type: "controlledSelect",
    				data: {
    					label: "Подформ.",
    					name: "SUBFRMT",
    					pick: [
    					]
    				}
    			}
    		]
    	},
    	{
    		options: [
    			{
    				type: "controlledSelect",
    				data: {
    					label: "Округ",
    					name: "Округ",
    					pick: [
    					]
    				}
    			},
    			{
    				type: "controlledSelect",
    				data: {
    					label: "Фил./гр.",
    					name: "Филиал",
    					pick: [
    					]
    				}
    			}
    		]
    	}
    ];

    var financialIndicators = [
    	{
    		label: "Финансовые показатели",
    		indicators: [
    			{
    				id: "7498",
    				order: 1,
    				label: "Выручка",
    				url: "revenue",
    				status: true
    			},
    			{
    				id: "7493",
    				order: 2,
    				label: "EBITDA",
    				url: "ebitda",
    				status: true
    			},
    			{
    				id: "7510",
    				order: 3,
    				label: "Себестоимость реализации",
    				url: "cost-of-sales",
    				status: false
    			},
    			{
    				id: "7526",
    				order: 4,
    				label: "CM",
    				url: "sm",
    				status: false
    			},
    			{
    				id: "7558",
    				order: 5,
    				label: "Валовый доход",
    				url: "gross-income",
    				status: true
    			},
    			{
    				id: "7504",
    				order: 6,
    				label: "Прочие реализационные доходы и расходы",
    				url: "sales-income",
    				status: false
    			},
    			{
    				id: "7369",
    				order: 7,
    				label: "Операционные расходы",
    				url: "operating-expenses",
    				status: false
    			},
    			{
    				id: "7486",
    				order: 8,
    				label: "EBITDAR",
    				url: "indicator-ebitdar",
    				status: false
    			},
    			{
    				id: "7487",
    				order: 9,
    				label: "Расходы аренды",
    				url: "rent",
    				status: false
    			},
    			{
    				id: "7491",
    				order: 10,
    				label: "EBITDA до LTI",
    				url: "before-lti",
    				status: false
    			},
    			{
    				id: "7492",
    				order: 11,
    				label: "LTI",
    				url: "lti",
    				status: false
    			},
    			{
    				id: "7494",
    				order: 12,
    				label: "Амортизация",
    				url: "depreciation",
    				status: false
    			},
    			{
    				id: "7572",
    				order: 13,
    				label: "Инвестиционные доходы",
    				url: "investment-income",
    				status: false
    			},
    			{
    				id: "7575",
    				order: 14,
    				label: "Финансовые доходы/расходы",
    				url: "finance-income-expenses",
    				status: false
    			},
    			{
    				id: "7589",
    				order: 15,
    				label: "Курсовые и суммовые разницы",
    				url: "rate-and-amount",
    				status: false
    			},
    			{
    				id: "7591",
    				order: 16,
    				label: "Налог на прибыль",
    				url: "income-tax",
    				status: false
    			},
    			{
    				id: "7594",
    				order: 17,
    				label: "Чистая прибыль",
    				url: "net-profit",
    				status: true
    			},
    			{
    				id: "7661",
    				order: 18,
    				label: "Доп. показатели",
    				url: "additional-indicators",
    				status: false
    			}
    		]
    	}
    ];

    var financialExport = [
    	{
    		value: "FRMT",
    		label: "Форматы",
    		bit: 4
    	},
    	{
    		value: "SUBFRMT",
    		label: "Подформаты",
    		bit: 3
    	},
    	{
    		value: "Округ",
    		label: "Округа",
    		bit: 6
    	},
    	{
    		value: "Филиал",
    		label: "Фил./гр.",
    		bit: 5
    	}
    ];

    var operationalExport = [
    	{
    		value: "FRMT",
    		label: "Формат",
    		bit: 1
    	},
    	{
    		value: "SUBFRMT",
    		label: "Подформат",
    		bit: 2
    	},
    	{
    		value: "REGION",
    		label: "Округ",
    		bit: 3
    	},
    	{
    		value: "BRANCH",
    		label: "Филиaл",
    		bit: 4
    	},
    	{
    		value: "ТУ",
    		label: "ТУ",
    		bit: 5
    	},
    	{
    		value: "СВ",
    		label: "СВ",
    		bit: 6
    	},
    	{
    		value: "ART_GRP_LVL_0_NAME",
    		label: "ГР20",
    		bit: 7
    	}
    ];

    var operationalColumn = [
    	{
    		label: "Периоды",
    		indicators: [
    			{
    				label: "WTD",
    				value: 1
    			},
    			{
    				label: "MTD",
    				value: 2
    			},
    			{
    				label: "QTD",
    				value: 3
    			},
    			{
    				label: "YTD",
    				value: 4
    			}
    		]
    	}
    ];

    var operationalFilter = [
    	{
    		options: [
    			{
    				type: "picks",
    				data: {
    					name: "FRMT",
    					pick: [
    					],
    					options: [
    						{
    							label: "ММ",
    							value: "ММ"
    						},
    						{
    							label: "МК",
    							value: "МК"
    						},
    						{
    							label: "МО",
    							value: "МО"
    						},
    						{
    							label: "МС",
    							value: "МС"
    						},
    						{
    							label: "МС+",
    							value: "МС+"
    						},
    						{
    							label: "МА",
    							value: "МА"
    						},
    						{
    							label: "СИА",
    							value: "СИА"
    						},
    						{
    							label: "HQ",
    							value: "HQ"
    						}
    					]
    				}
    			},
    			{
    				type: "controlledSelect",
    				data: {
    					label: "Подформ.",
    					name: "SUBFRMT",
    					pick: [
    					]
    				}
    			}
    		]
    	},
    	{
    		options: [
    			{
    				type: "controlledSelect",
    				data: {
    					label: "Округ",
    					name: "REGION",
    					pick: [
    					]
    				}
    			},
    			{
    				type: "controlledSelect",
    				data: {
    					label: "Фил./гр.",
    					name: "BRANCH",
    					pick: [
    					]
    				}
    			},
    			{
    				type: "controlledSelect",
    				data: {
    					label: "Магазин",
    					name: "WHS_NAME",
    					pick: [
    					]
    				}
    			}
    		]
    	},
    	{
    		options: [
    			{
    				type: "controlledSelect",
    				data: {
    					label: "Гр. 20",
    					name: "ART_GRP_LVL_0_NAME",
    					pick: [
    					]
    				}
    			}
    		]
    	},
    	{
    		options: [
    			{
    				type: "controlledSelect",
    				data: {
    					label: "ТУ",
    					name: "ТУ",
    					pick: [
    					]
    				}
    			},
    			{
    				type: "controlledSelect",
    				data: {
    					label: "СВ",
    					name: "СВ",
    					pick: [
    					]
    				}
    			}
    		]
    	}
    ];

    var indicators = [
    	{
    		label: "Продажи",
    		indicators: [
    			{
    				id: "6",
    				order: 1,
    				label: "Комплексность",
    				url: "complexity",
    				configName: "Компл",
    				subLabel: "",
    				subLabelUnit: "штук в чеке",
    				status: false
    			},
    			{
    				id: "1",
    				order: 2,
    				label: "РТО",
    				url: "rto",
    				configName: "РТО",
    				subLabel: "",
    				subLabelUnit: "млн. руб.",
    				status: true
    			},
    			{
    				id: "4",
    				order: 4,
    				label: "Средний Чек",
    				url: "average-check",
    				configName: "СрЧек",
    				subLabel: "",
    				subLabelUnit: "руб.",
    				status: false
    			},
    			{
    				id: "7",
    				order: 5,
    				label: "Трафик",
    				configName: "Трафик",
    				url: "traffic",
    				subLabel: "",
    				subLabelUnit: "тыс. шт.",
    				status: false
    			}
    		]
    	},
    	{
    		label: "LFL",
    		indicators: [
    			{
    				id: "20",
    				order: 6,
    				label: "Инфляция",
    				url: "inflation",
    				configName: "Инфл",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: false
    			},
    			{
    				id: "2",
    				order: 7,
    				label: "РТО LFL",
    				url: "rtolfl",
    				configName: "РТОLFL",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: true
    			},
    			{
    				id: "5",
    				order: 8,
    				label: "Средний чек LFL",
    				url: "average-check-lfl",
    				configName: "СрЧекLFL",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: true
    			},
    			{
    				id: "8",
    				order: 9,
    				label: "Трафик LFL",
    				url: "traffic-lfl",
    				configName: "ТрафикLFL",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: true
    			}
    		]
    	},
    	{
    		label: "Наценка",
    		indicators: [
    			{
    				id: "25",
    				order: 10,
    				label: "CM",
    				url: "commercial-margin",
    				configName: "KM",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: false
    			},
    			{
    				id: "24",
    				order: 11,
    				label: "FM",
    				url: "front-margin",
    				configName: "FM",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: true
    			},
    			{
    				id: "27",
    				order: 25,
    				label: "Доля Лояльности в FM",
    				url: "rto-vs-loyalty",
    				configName: "Лояльность",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: false
    			},
    			{
    				id: "26",
    				order: 26,
    				label: "Доля Мониторинга в FM",
    				url: "rto-vs-monitoring",
    				configName: "Монит",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: false
    			},
    			{
    				id: "29",
    				order: 27,
    				label: "Доля Промо в FM",
    				url: "rto-vs-promo",
    				configName: "Промо%",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: false
    			},
    			{
    				id: "31",
    				order: 28,
    				label: "Доля Прочего в FM",
    				url: "rto-vs-other",
    				configName: "Прочее",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: false
    			},
    			{
    				id: "30",
    				order: 29,
    				label: "Доля Регулярного в FM",
    				url: "rto-vs-regular",
    				configName: "Регул",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: false
    			},
    			{
    				id: "28",
    				order: 30,
    				label: "Доля Уценки в FM",
    				url: "rto-vs-markdown",
    				configName: "Уценка",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: false
    			}
    		]
    	},
    	{
    		label: "Промо",
    		indicators: [
    			{
    				id: "23",
    				order: 24,
    				label: "Промо",
    				url: "promo",
    				configName: "Промо",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: true
    			}
    		]
    	},
    	{
    		label: "Потери",
    		indicators: [
    			{
    				id: "17",
    				order: 12,
    				label: "Потери",
    				url: "abs-losses",
    				configName: "ПотерАБС",
    				subLabel: "",
    				subLabelUnit: "млн. руб.",
    				status: false
    			},
    			{
    				id: "15",
    				order: 13,
    				label: "Доля потерь в выручке",
    				url: "loss-to-revenue",
    				configName: "ПотерВыруч",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: true
    			},
    			{
    				id: "16",
    				order: 14,
    				label: "Доля потерь в себестоимости",
    				url: "loss-to-cost",
    				configName: "ПотерСебест",
    				subLabel: "",
    				subLabelUnit: "%",
    				status: false
    			}
    		]
    	},
    	{
    		label: "Ассортимент",
    		indicators: [
    			{
    				id: "19",
    				order: 35,
    				label: "Ассортимент",
    				url: "range",
    				configName: "Ассорт",
    				subLabel: "",
    				subLabelUnit: "шт.",
    				status: false
    			}
    		]
    	},
    	{
    		label: "Развитие",
    		indicators: [
    			{
    				id: "10",
    				order: 41,
    				label: "Количество закрытых объектов",
    				configName: "КолЗакрТО",
    				url: "number-of-closed-objects",
    				subLabel: "",
    				subLabelUnit: "шт.",
    				status: false
    			},
    			{
    				id: "9",
    				order: 42,
    				label: "Количество объектов",
    				configName: "КолРабТО",
    				url: "number-of-objects",
    				subLabel: "",
    				subLabelUnit: "шт.",
    				status: false
    			}
    		]
    	}
    ];

    let CONFIG = {
      ...app,
      graphs,
      dashboards: {
        financial: {
          column: financialColumn,
          filter: financialFilter,
          indicators: financialIndicators,
          export: financialExport,
        },
        operational: {
          column: operationalColumn,
          filter: operationalFilter,
          indicators: indicators,
          export: operationalExport
        },
      },
    };

    function updateConfig(update) {
      CONFIG = { ...CONFIG, ...update };
    }

    //import { default as mockMeta } from '../mocks/mockMeta.json';

    function dispatchRequestEvent(request) {
      const event = new CustomEvent('metarequest', { detail: request });
      window.dispatchEvent(event);
    }

    function requestMeta(request) {
      const promise = new Promise((resolve, reject) => {
        function onRequestResponse(response) {
          window.removeEventListener('metaresponse', onRequestResponse);
          window.removeEventListener('error', onRequestError);
          //console.log("META", response.detail)
          //resolve(mockMeta)
          resolve(response.detail);
        }

        function onRequestError() {
          window.removeEventListener('metaresponse', onRequestResponse);
          window.removeEventListener('error', onRequestError);
          reject(new Error('An error occured while making this request'));
        }

        window.addEventListener('metaresponse', onRequestResponse);
        window.addEventListener('error', onRequestError);
      });
      dispatchRequestEvent(request);
      return promise;
    }

    /**
     * @typedef {Object} WrappedComponent Object returned by the `wrap` method
     * @property {SvelteComponent} component - Component to load (this is always asynchronous)
     * @property {RoutePrecondition[]} [conditions] - Route pre-conditions to validate
     * @property {Object} [props] - Optional dictionary of static props
     * @property {Object} [userData] - Optional user data dictionary
     * @property {bool} _sveltesparouter - Internal flag; always set to true
     */

    /**
     * @callback AsyncSvelteComponent
     * @returns {Promise<SvelteComponent>} Returns a Promise that resolves with a Svelte component
     */

    /**
     * @callback RoutePrecondition
     * @param {RouteDetail} detail - Route detail object
     * @returns {boolean|Promise<boolean>} If the callback returns a false-y value, it's interpreted as the precondition failed, so it aborts loading the component (and won't process other pre-condition callbacks)
     */

    /**
     * @typedef {Object} WrapOptions Options object for the call to `wrap`
     * @property {SvelteComponent} [component] - Svelte component to load (this is incompatible with `asyncComponent`)
     * @property {AsyncSvelteComponent} [asyncComponent] - Function that returns a Promise that fulfills with a Svelte component (e.g. `{asyncComponent: () => import('Foo.svelte')}`)
     * @property {SvelteComponent} [loadingComponent] - Svelte component to be displayed while the async route is loading (as a placeholder); when unset or false-y, no component is shown while component
     * @property {object} [loadingParams] - Optional dictionary passed to the `loadingComponent` component as params (for an exported prop called `params`)
     * @property {object} [userData] - Optional object that will be passed to events such as `routeLoading`, `routeLoaded`, `conditionsFailed`
     * @property {object} [props] - Optional key-value dictionary of static props that will be passed to the component. The props are expanded with {...props}, so the key in the dictionary becomes the name of the prop.
     * @property {RoutePrecondition[]|RoutePrecondition} [conditions] - Route pre-conditions to add, which will be executed in order
     */

    /**
     * Wraps a component to enable multiple capabilities:
     * 1. Using dynamically-imported component, with (e.g. `{asyncComponent: () => import('Foo.svelte')}`), which also allows bundlers to do code-splitting.
     * 2. Adding route pre-conditions (e.g. `{conditions: [...]}`)
     * 3. Adding static props that are passed to the component
     * 4. Adding custom userData, which is passed to route events (e.g. route loaded events) or to route pre-conditions (e.g. `{userData: {foo: 'bar}}`)
     * 
     * @param {WrapOptions} args - Arguments object
     * @returns {WrappedComponent} Wrapped component
     */
    function wrap(args) {
        if (!args) {
            throw Error('Parameter args is required')
        }

        // We need to have one and only one of component and asyncComponent
        // This does a "XNOR"
        if (!args.component == !args.asyncComponent) {
            throw Error('One and only one of component and asyncComponent is required')
        }

        // If the component is not async, wrap it into a function returning a Promise
        if (args.component) {
            args.asyncComponent = () => Promise.resolve(args.component);
        }

        // Parameter asyncComponent and each item of conditions must be functions
        if (typeof args.asyncComponent != 'function') {
            throw Error('Parameter asyncComponent must be a function')
        }
        if (args.conditions) {
            // Ensure it's an array
            if (!Array.isArray(args.conditions)) {
                args.conditions = [args.conditions];
            }
            for (let i = 0; i < args.conditions.length; i++) {
                if (!args.conditions[i] || typeof args.conditions[i] != 'function') {
                    throw Error('Invalid parameter conditions[' + i + ']')
                }
            }
        }

        // Check if we have a placeholder component
        if (args.loadingComponent) {
            args.asyncComponent.loading = args.loadingComponent;
            args.asyncComponent.loadingParams = args.loadingParams || undefined;
        }

        // Returns an object that contains all the functions to execute too
        // The _sveltesparouter flag is to confirm the object was created by this router
        const obj = {
            component: args.asyncComponent,
            userData: args.userData,
            conditions: (args.conditions && args.conditions.length) ? args.conditions : undefined,
            props: (args.props && Object.keys(args.props).length) ? args.props : {},
            _sveltesparouter: true
        };

        return obj
    }

    function regexparam (str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules/svelte-spa-router/Router.svelte generated by Svelte v3.24.0 */

    const { Error: Error_1, Object: Object_1, console: console_1 } = globals;

    // (209:0) {:else}
    function create_else_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(209:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (202:0) {#if componentParams}
    function create_if_block(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(202:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function wrap$1(component, userData, ...conditions) {
    	// Use the new wrap method and show a deprecation warning
    	// eslint-disable-next-line no-console
    	console.warn("Method `wrap` from `svelte-spa-router` is deprecated and will be removed in a future version. Please use `svelte-spa-router/wrap` instead. See http://bit.ly/svelte-spa-router-upgrading");

    	return wrap({ component, userData, conditions });
    }

    /**
     * @typedef {Object} Location
     * @property {string} location - Location (page/view), for example `/book`
     * @property {string} [querystring] - Querystring from the hash, as a string not parsed
     */
    /**
     * Returns the current location from the hash.
     *
     * @returns {Location} Location object
     * @private
     */
    function getLocation() {
    	const hashPosition = window.location.href.indexOf("#/");

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: "/";

    	// Check if there's a querystring
    	const qsPosition = location.indexOf("?");

    	let querystring = "";

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener("hashchange", update, false);

    	return function stop() {
    		window.removeEventListener("hashchange", update, false);
    	};
    });

    const location = derived(loc, $loc => $loc.location);
    const querystring = derived(loc, $loc => $loc.querystring);

    async function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			scrollX: window.scrollX,
    			scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == "#" ? "" : "#") + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != "/" && location.indexOf("#/") !== 0) {
    		throw Error("Invalid parameter location");
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == "#" ? "" : "#") + location;

    	try {
    		window.history.replaceState(undefined, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn("Caught exception while replacing the current page. If you're running this in the Svelte REPL, please note that the `replace` method might not work in this environment.");
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event("hashchange"));
    }

    function link(node, hrefVar) {
    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != "a") {
    		throw Error("Action \"link\" can only be used with <a> tags");
    	}

    	updateLink(node, hrefVar || node.getAttribute("href"));

    	return {
    		update(updated) {
    			updateLink(node, updated);
    		}
    	};
    }

    // Internal function used by the link function
    function updateLink(node, href) {
    	// Destination must start with '/'
    	if (!href || href.length < 1 || href.charAt(0) != "/") {
    		throw Error("Invalid value for \"href\" attribute: " + href);
    	}

    	// Add # to the href attribute
    	node.setAttribute("href", "#" + href);

    	node.addEventListener("click", scrollstateHistoryHandler);
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {HTMLElementEventMap} event - an onclick event attached to an anchor tag
     */
    function scrollstateHistoryHandler(event) {
    	// Prevent default anchor onclick behaviour
    	event.preventDefault();

    	const href = event.currentTarget.getAttribute("href");

    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			scrollX: window.scrollX,
    			scrollY: window.scrollY
    		},
    		undefined,
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { routes = {} } = $$props;
    	let { prefix = "" } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != "function" && (typeof component != "object" || component._sveltesparouter !== true)) {
    				throw Error("Invalid component object");
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == "string" && (path.length < 1 || path.charAt(0) != "/" && path.charAt(0) != "*") || typeof path == "object" && !(path instanceof RegExp)) {
    				throw Error("Invalid value for \"path\" argument - strings must start with / or *");
    			}

    			const { pattern, keys } = regexparam(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == "object" && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, check if it matches the start of the path.
    			// If not, bail early, else remove it before we run the matching.
    			if (prefix) {
    				if (typeof prefix == "string") {
    					if (path.startsWith(prefix)) {
    						path = path.substr(prefix.length) || "/";
    					} else {
    						return null;
    					}
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || "/";
    					} else {
    						return null;
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || "") || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {bool} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	if (restoreScrollState) {
    		window.addEventListener("popstate", event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && event.state.scrollY) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		});

    		afterUpdate(() => {
    			// If this exists, then this is a back navigation: restore the scroll position
    			if (previousScrollState) {
    				window.scrollTo(previousScrollState.scrollX, previousScrollState.scrollY);
    			} else {
    				// Otherwise this is a forward navigation: scroll to top
    				window.scrollTo(0, 0);
    			}
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick("conditionsFailed", detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick("routeLoading", Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick("routeLoaded", Object.assign({}, detail, { component, name: component.name }));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == "object" && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick("routeLoaded", Object.assign({}, detail, { component, name: component.name }));

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    	});

    	const writable_props = ["routes", "prefix", "restoreScrollState"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Router", $$slots, []);

    	function routeEvent_handler(event) {
    		bubble($$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("routes" in $$props) $$invalidate(3, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ("restoreScrollState" in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		derived,
    		tick,
    		_wrap: wrap,
    		wrap: wrap$1,
    		getLocation,
    		loc,
    		location,
    		querystring,
    		push,
    		pop,
    		replace,
    		link,
    		updateLink,
    		scrollstateHistoryHandler,
    		createEventDispatcher,
    		afterUpdate,
    		regexparam,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		lastLoc,
    		componentObj
    	});

    	$$self.$inject_state = $$props => {
    		if ("routes" in $$props) $$invalidate(3, routes = $$props.routes);
    		if ("prefix" in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ("restoreScrollState" in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ("component" in $$props) $$invalidate(0, component = $$props.component);
    		if ("componentParams" in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ("props" in $$props) $$invalidate(2, props = $$props.props);
    		if ("previousScrollState" in $$props) previousScrollState = $$props.previousScrollState;
    		if ("lastLoc" in $$props) lastLoc = $$props.lastLoc;
    		if ("componentObj" in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			 history.scrollRestoration = restoreScrollState ? "manual" : "auto";
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance, create_fragment, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScrollState() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScrollState(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/defs/Defs.svelte generated by Svelte v3.24.0 */

    const file = "src/js/components/defs/Defs.svelte";

    function create_fragment$1(ctx) {
    	let svg;
    	let defs;
    	let linearGradient0;
    	let stop0;
    	let stop1;
    	let linearGradient1;
    	let stop2;
    	let stop3;
    	let pattern;
    	let path;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			defs = svg_element("defs");
    			linearGradient0 = svg_element("linearGradient");
    			stop0 = svg_element("stop");
    			stop1 = svg_element("stop");
    			linearGradient1 = svg_element("linearGradient");
    			stop2 = svg_element("stop");
    			stop3 = svg_element("stop");
    			pattern = svg_element("pattern");
    			path = svg_element("path");
    			attr_dev(stop0, "offset", "50%");
    			attr_dev(stop0, "stop-color", "#e30613");
    			add_location(stop0, file, 5, 10, 117);
    			attr_dev(stop1, "offset", "50%");
    			attr_dev(stop1, "stop-color", "#02a861");
    			add_location(stop1, file, 6, 10, 170);
    			attr_dev(linearGradient0, "id", "txcm-graphGradient-leftDeviations");
    			add_location(linearGradient0, file, 3, 6, 43);
    			attr_dev(stop2, "offset", "50%");
    			attr_dev(stop2, "stop-color", "#02a861");
    			add_location(stop2, file, 10, 10, 318);
    			attr_dev(stop3, "offset", "50%");
    			attr_dev(stop3, "stop-color", "#e30613");
    			add_location(stop3, file, 11, 10, 371);
    			attr_dev(linearGradient1, "id", "txcm-graphGradient-rightDeviations");
    			add_location(linearGradient1, file, 8, 6, 243);
    			attr_dev(path, "d", "M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2");
    			attr_dev(path, "stroke", "#848e99");
    			attr_dev(path, "strokewidth", "0.5");
    			add_location(path, file, 18, 10, 571);
    			attr_dev(pattern, "id", "txcm-diagonalHatch");
    			attr_dev(pattern, "patternUnits", "userSpaceOnUse");
    			attr_dev(pattern, "width", "4");
    			attr_dev(pattern, "height", "4");
    			add_location(pattern, file, 13, 6, 444);
    			add_location(defs, file, 2, 4, 30);
    			attr_dev(svg, "class", "txcm-defs");
    			add_location(svg, file, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, defs);
    			append_dev(defs, linearGradient0);
    			append_dev(linearGradient0, stop0);
    			append_dev(linearGradient0, stop1);
    			append_dev(defs, linearGradient1);
    			append_dev(linearGradient1, stop2);
    			append_dev(linearGradient1, stop3);
    			append_dev(defs, pattern);
    			append_dev(pattern, path);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Defs> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Defs", $$slots, []);
    	return [];
    }

    class Defs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Defs",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    const DASHBOARD_INITIAL_STATE = {
      units: 0,
      yoyMode: false,
    };

    let dashboardState;

    function generateDashboardInitialDatePrecision(dashboard) {
      if (dashboard === 'financial') return 2;
      return 0;
    }

    function generateDashboardInitialColumnPrecision(dashboard) {
      if (dashboard === 'financial') return 3;
      return 0;
    }

    function generateDates(dashboard) {
      const timestamp = CONFIG.dateStart;
      const date = new Date(timestamp);
      const timestampPoP = date.setFullYear(date.getFullYear() - 1);
      return {
        date: timestamp,
        datePoP: timestampPoP < CONFIG.dateMin ? CONFIG.dateMin : timestampPoP,
        datePrecision: generateDashboardInitialDatePrecision(dashboard),
        columnPrecision: generateDashboardInitialColumnPrecision(dashboard),
      };
    }

    function generateInititalState(dashboard) {
      return {
        ...generateDates(dashboard),
        ...DASHBOARD_INITIAL_STATE,
      };
    }

    function initDashboard(dashboard) {
      if (!!dashboardState)
        return;
      dashboardState = initState(generateInititalState(dashboard));
    }

    function updateDashboard(update) {
      updateData(dashboardState, update);
    }

    function getDashboardState(keys) {
      return getState(dashboardState, keys);
    }

    const EXPORT_INITIAL_STATE = {
      downloading: 0,
      slices: [],
      slicesValue: '00000000000',
      slicesFilter: {},
      indicators: [],
      expressionsValue: '00000000000',
    };

    let exportState;

    function generateInitialState() {
      return {
        ...EXPORT_INITIAL_STATE,
      };
    }

    function initExport() {
      const initialState = generateInitialState();
      exportState = initState(initialState);
    }

    function updateExport(update) {
      updateData(exportState, update);
    }

    function getExportState(keys) {
      return getState(exportState, keys);
    }

    let filterState;

    function generateOptionState(state, { data }) {
      const { name, pick } = data;
      return {
        ...state,
        [`${name}`]: pick,
      };
    }

    function generateComponentState(state, { options }) {
      return {
        ...state,
        ...options.reduce(generateOptionState, {}),
      };
    }

    function generateInitialState$1(config) {
      return config.reduce(generateComponentState, {});
    }

    function initFilter(config) {
      const initialState = generateInitialState$1(config);
      filterState = initState(initialState);
    }

    function updateFilter(update) {
      updateData(filterState, update);
    }

    function subscribeFilterAll(task) {
      return subscribeAll(filterState, task);
    }

    function getFilterState(keys) {
      return getState(filterState, keys);
    }

    let indicatorsState;
    let indicatorKeys;
    let activeIndicatorsState;

    function generateComponentState$1(state, { id, status }) {
      return {
        ...state,
        [id]: status,
      };
    }

    function generateInitialState$2(config) {
      return config
        .reduce((flat, group) => [...flat, ...group.indicators], [])
        .reduce(generateComponentState$1, {});
    }

    function initActiveIndicators() {
      const stores = Object.values(getIndicatorsState());
      activeIndicatorsState = derived(stores, updateActive);
    }

    function initIndicators(config) {
      if (!!indicatorsState)
        return;
      const initialState = generateInitialState$2(config);
      indicatorsState = initState(initialState);
      indicatorKeys = Object.keys(indicatorsState);
      initActiveIndicators();
    }

    function updateIndicators(update) {
      updateData(indicatorsState, update);
    }

    function subscribeIndicators(key, task) {
      return subscribe$1(indicatorsState, key, task);
    }

    function getIndicatorsData(keys) {
      return getStateData(indicatorsState, keys);
    }

    function getIndicatorsState(keys) {
      return getState(indicatorsState, keys);
    }

    function updateActiveKey(active, value, index) {
      if (value) active.push(indicatorKeys[index]);
      return active;
    }

    function updateActive(update) {
      return update.reduce(updateActiveKey, []);
    }

    function getActiveIndicatorsState() {
      return activeIndicatorsState;
    }

    const GRAPH_INITIAL_STATE = {
      count: 0,
      highlighted: null,
      step: 0,
      shift: 0,
      status: 0,
      dynamics: 'graphDetailQuarter',
      kind: 0,
      optionWidthMax: 0,
      scroll: 0,
      scrollMax: 0
    };

    let graphsState;

    function generateInitialState$3(graphsConfig, dashboard) {
      const dynamics = dashboard === 'financial' ? 3 : 0;
      return {
        ...GRAPH_INITIAL_STATE,
        mode: graphsConfig.modes[0].value,
        dynamics: graphsConfig.dynamics[dynamics].value,
      };
    }

    function initGraphs(graphsConfig, dashboard) {
      const initialState = generateInitialState$3(graphsConfig, dashboard);
      graphsState = initState(initialState);
    }

    function getGraphsState(keys) {
      return getState(graphsState, keys);
    }

    let currentRequest;

    function resetRequest() {
      currentRequest = null;
    }

    function requestUpdate(dashboard, indicator, detail, filters, type, id) {
      console.log("REQUEST UPDATE");
      const promise = new Promise((resolve, reject) => {
        function onDataResponse(response) {
          window.removeEventListener('dataresponse', onDataResponse);
          window.removeEventListener('error', onDataError);
          resetRequest();
          resolve(response.detail);
        }

        function onDataError() {
          window.removeEventListener('dataresponse', onDataResponse);
          window.removeEventListener('error', onDataError);
          resetRequest();
          reject(new Error('an error occured while fetching data'));
        }

        window.addEventListener('dataresponse', onDataResponse);
        window.addEventListener('error', onDataError);
      });
      currentRequest = { detail: { dashboard, indicator, detail, filters, type, id } };
      const event = new CustomEvent('datarequest', currentRequest);
      window.dispatchEvent(event);
      return promise;
    }

    /* eslint max-lines-per-function: 'off' */

    function detectPointerPosition(event) {
      if (event.touches) return event.touches[0].clientX;
      return event.clientX;
    }

    function sectionScroll(object, shoudUpdateUI) {
      const node = object;

      let scrollStart;
      let pointerClientXStart;

      function updateSectionScroll(scroll) {
        node.scrollLeft = scroll;
        if (shoudUpdateUI) updateUI({ sectionScrollX: scroll });
      }

      function resetPointer() {
        pointerClientXStart = null;
      }

      function onWheel(event) {
        const { deltaX } = event;
        if (Math.abs(deltaX) > 0) {
          event.preventDefault();
          updateSectionScroll(node.scrollLeft + deltaX);
        }
      }

      function onPointerMove(event) {
        const clientX = detectPointerPosition(event);
        const deltaX = pointerClientXStart - clientX;
        updateSectionScroll(scrollStart + deltaX);
      }

      function onPointerUp() {
        resetPointer();
        unsubscribeWindow();
      }

      function subscribeWindow() {
        window.addEventListener('touchmove', onPointerMove);
        window.addEventListener('touchend', onPointerUp);
        window.addEventListener('mousemove', onPointerMove);
        window.addEventListener('mouseup', onPointerUp);
      }

      function unsubscribeWindow() {
        window.removeEventListener('touchmove', onPointerMove);
        window.removeEventListener('touchend', onPointerUp);
        window.removeEventListener('mousemove', onPointerMove);
        window.removeEventListener('mouseup', onPointerUp);
      }

      function onPointerDown(event) {
        pointerClientXStart = detectPointerPosition(event);
        scrollStart = node.scrollLeft;
        subscribeWindow();
      }

      function subscribe() {
        node.addEventListener('wheel', onWheel);
        node.addEventListener('mousedown', onPointerDown);
        node.addEventListener('touchstart', onPointerDown);
      }

      function unsubscribe() {
        node.removeEventListener('wheel', onWheel);
        node.removeEventListener('mousedown', onPointerDown);
        node.removeEventListener('touchstart', onPointerDown);
      }

      function init() {
        subscribe();
      }

      function destroy() {
        unsubscribe();
      }

      init();

      return {
        destroy,
      };
    }

    const CM = "CM";
    const FM = "FM";
    const EBITDAR = "EBITDAR";
    const LTI = "LTI";
    const EBITDA = "EBITDA";
    var englishDictionary = {
    	"Доля Промо %": "Interest promo",
    	"Товарные Запасы": "Inventory",
    	"Уровень Сервиса РЦ": "Distribution center service level at stores",
    	"Потери": "Losses",
    	"Потери к выручке": "Loss to revenue",
    	"Доля потерь в выручке": "Losses in revenue, %",
    	"Потери в себестоимости": "Loss to cost",
    	"Доля потерь в себестоимости": "Losses in cost of production, %",
    	"Продажи Промо": "Sqles Promo",
    	"Ком. Маржа": "CM",
    	"РТО": "Retail turnover",
    	"РТО, руб": "Retail turnover",
    	"РТО LFL": "LFL Retail turnover",
    	"Доля РТО по Регулярным %": "Interest Regular sales types",
    	"Доля РТО по Мониторингам %": "Interest Monitoring sales types",
    	"Доля РТО по Основному промо %": "Interest Main Promo sales types",
    	"Доля РТО по Доп. Промо %": "Interest others Promo sales types",
    	"Доля РТО по Уценке %": "Interest Markdowns sales types",
    	"Доля РТО по прочим типам продаж %": "Interest \"Other\" sales types",
    	"Доля РТО по Картам лояльности %": "Interest Loyalty Cards sales types",
    	"ФМ%": "FM",
    	"ФМ% (Влияние Регулярных продаж)": "InfluenceRegular sales types",
    	"ФМ% (влияние Основного Промо)": "InfluenceMonitoring sales types",
    	"ФМ% (влияние Мониторингов)": "InfluenceMain Promo sales types",
    	"ФМ% (влияние Доп. Промо)": "Influenceothers Promo sales types",
    	"ФМ% (влияние Уценки)": "InfluenceMarkdowns sales types",
    	"ФМ% (влияние Картам лояльности)": "Influence\"Other\" sales types",
    	"ФМ% (влияние  Прочих типов продаж)": "InfluenceLoyalty Cards sales types",
    	"Текучесть": "Employee turnover rates",
    	"ФОТ": "Payroll",
    	"Выручка": "Revenue",
    	"Выручка от реализации": "Sales revenue",
    	"Себестоимость реализации": "Cost of sales",
    	"Себеcтоимость товаров": "Production cost",
    	"Бонусы от поставщиков": "Supplier bonuses",
    	"Логистические затраты": "Logistics costs",
    	"Резерв на обесценение активов": "Allowance for impairment of assets",
    	CM: CM,
    	FM: FM,
    	"Back Margin": "Back Margin",
    	"Валовый доход": "Gross profit",
    	"Прочие реализационные доходы": "Other sales income",
    	"Выручка от рекламных агентств": "Revenue from advertising agencies",
    	"Доходы от субаренды": "Rental income",
    	"Выручка от услуг не поставщикам товара": "Revenue from services not to suppliers of goods",
    	"Операционные расходы": "Operating expenses",
    	"Расходы на персонал": "Personnel costs",
    	"Компенсации и льготы": "Compensation and benefits",
    	"Корпоративные мероприятия": "Corporate events",
    	"Расходы на внутренние коммуникации": "Internal communications costs",
    	"Расходы на годовое вознаграждение": "Annual fee expenses",
    	"Расходы на немонетарную мотивацию": "Non-monetary incentive costs",
    	"Расходы на обязательное медобслуживание": "Compulsory health care costs",
    	"Расходы на обязательное обучение": "Compulsory education costs",
    	"Расходы на оценку персонала": "Staff appraisal costs",
    	"Расходы на развивающие обучение (в том числе отраслевые конференции)": "Expenses for developmental training",
    	"Расходы на регулярную оплату труда": "Regular labor costs",
    	"Расходы по подбору персонала": "Recruitment costs",
    	"Коммунальные расходы и услуги связи": "Utilities and communication services",
    	"Маркетинговые расходы": "Marketing expenses",
    	"Расходные материалы и хозяйственные расходы": "Consumables and Household Expenses",
    	"Ремонт и техническое обслуживание основных средств": "Repair and maintenance of fixed assets",
    	"Расходы на охрану": "Security costs",
    	"Консультационные, информационные услуги и страхование": "Consulting, information services and insurance",
    	"Услуги логистических операторов - 3PL": "Logistic operator services - 3PL",
    	"Прочие доходы и расходы": "Other income and expenses",
    	EBITDAR: EBITDAR,
    	"Расходы аренды": "Rental expenses",
    	"Аренда зданий": "Rent of buildings",
    	"Аренда земли": "Rent of Lands",
    	"Прочая аренда": "Other rent",
    	"EBITDA до LTI": "EBITDA before LTI",
    	LTI: LTI,
    	EBITDA: EBITDA,
    	"Амортизация": "Amortisation",
    	"Инвестиционные доходы": "Investment income",
    	"Финансовые доходы/расходы": "Finance income / expenses",
    	"Процентные расходы долгосрочные": "Long-term interest expenses",
    	"Процентные расходы краткосрочные": "Short-term interest expenses",
    	"Прочие процентные расходы": "Other interest expenses",
    	"Прочие финансовые доходы/расходы": "Other finance income / expenses",
    	"Курсовые и суммовые разницы": "Exchange rate and amount differences",
    	"Налог на прибыль": "Tax on income",
    	"Текущий налог на прибыль": "Current income tax",
    	"Отложенный налог на прибыль": "Deferred income tax",
    	"Чистая прибыль": "Net income",
    	"Продажи": "Sales",
    	"Наценка": "Margin",
    	"Запасы": "Stock",
    	"Промо": "Promo",
    	"Доступность": "Availability",
    	"Уровень сервиса": "Delivery in Full",
    	"Ассортимент": "Assortment",
    	"Персонал": "Staff",
    	"Базовые": "Basic",
    	"Развитие": "Development",
    	"Коммерческая маржа": "CM",
    	"Комплексность": "Average product quantity per ticket",
    	"Перештат": "Exceeding the state limit",
    	"Укомплектованность": "Staffing",
    	"Себестоимость": "Production cost",
    	"Средний Чек": "Average Ticket",
    	"Средний чек LFL": "LFL Average Ticket",
    	"Трафик": "Traffic",
    	"Трафик LFL": "LFL Traffic",
    	"Количество объектов": "Quantity of stores",
    	"Количество закрытых объектов": "Quantity of closed stores",
    	"ТЗ": "Trade inventory",
    	"Оборачиваемость": "Inventory",
    	"УС РЦ": "Delivery in Full DC",
    	"УС поставщиков": "Delivery in Full suppliers",
    	"Потери к себестоимости": "Loss to cost",
    	"Потери АБС": "Losses",
    	"Потери ШТ": "Losses qnty",
    	"Инфляция": "Inflation",
    	"Доступность по остаткам": "On stock availability",
    	"Доступность по продажам": "On shelf availability",
    	"Доля Мониторинга в FM": "Interest Monitoring sales types",
    	"Доля Лояльности в FM": "Interest Loyalty Cards sales types",
    	"Доля Уценки в FM": "Interest Markdowns sales types",
    	"Доля Промо в FM": "Interest Main Promo sales types",
    	"Доля Регулярного в FM": "Interest Regular sales types",
    	"Доля Прочего в FM": "Interest Other sales types",
    	"Влияние мониторинга на FM": "Influence Monitoring sales types",
    	"Влияние Лояльности на FM": "Influence Loyalty Cards sales types",
    	"Влияние Уценки на FM": "Influence Markdowns sales types",
    	"Влияние Промо на FM": "Influence Main Promo sales types",
    	"Влияние Регулярного на FM": "Influence Regular sales types",
    	"Влияние Прочее на FM": "Influence Other sales types",
    	"Штатная численность": "Staff",
    	"Фактическая численность": "Quantity of employees",
    	"АТП": "Motor Transport Enterprise",
    	"РЦ": "Distribution Center",
    	"ТУ": "Territory Manager",
    	"СВ": "Supervisor",
    	"Гр. 20/23": "Group 20/23",
    	"Гр. 20": "Group 20",
    	"Категории": "Categories",
    	"Волжский округ": "Volzhsky region",
    	"Кавказский округ": "Caucasus region",
    	"Центральный округ": "Central region",
    	"Северо-Западный округ": "Northwestern region",
    	"Московский округ": "Moscow region",
    	"Сибирский округ": "Siberian region",
    	"Уральский округ": "Ural region",
    	"Южный округ": "South region",
    	"Камский округ": "Kama region",
    	"Приволжский округ": "Volga region",
    	"Черноземный округ": "Chernozem region",
    	"Южно-Уральский округ": "South Ural region",
    	"Западный округ": "Western region",
    	"Не привязано": "No reference to group",
    	"Великие Луки": "Velikiye Luki",
    	"Не товарные позиции": "Non-marketable items",
    	"Хлеб и хлебобулочные изделия": "Bread and bakery products",
    	"Сыры": "Cheeses",
    	"Орбита": "Orbita",
    	"Вторсырье": "Recyclables",
    	"Детское питание": "Baby food",
    	"Слабоалкогольные напитки": "Low-alcohol beverages",
    	"Чай": "Tea",
    	"Птица": "Poultry",
    	"Промышленные товары": "Manufactured products",
    	"Снэки": "Snacks",
    	"Кулинария": "Prepared foods",
    	"Непрофильный товар": "Non-food products",
    	"Молочная продукция": "Milk products",
    	"Бакалея": "Grocery",
    	"Свежие фрукты": "Fresh fruit",
    	"Уход и гигиена": "Personal care and hygiene",
    	"Вино": "Wines",
    	"Замороженная продукция": "Frozen products",
    	"Табачные изделия": "Tobacco products",
    	"Бытовая химия": "Household care",
    	"Оборудование объектов Компании": "Equipment for Company's facilities",
    	"Лекарственные средства": "Pharmaceutical products",
    	"Программа промоактивность": "Promotional program",
    	"Тандем": "Tandem",
    	"Кондитерские изделия": "Confectionery products",
    	"Мясо и мясные продукты": "Meat and meat products",
    	"Услуги": "Services",
    	"Живые растения": "Live plants",
    	"Консервированные продукты": "Preserved products",
    	"Мясо": "Meat",
    	"Яичные товары": "Egg products",
    	"Крепкий алкоголь": "Spirits",
    	"Материалы, комплектующие, инвентарь": "Materials, components, accessories",
    	"Глобус": "Globus",
    	"Свежие овощи": "Fresh vegetables",
    	"Парфюмерия и декоративная косметика": "Perfumes & Decorative cosmetics",
    	"Сырье": "Raw materials",
    	"Изделия медицинского назначения": "Medical commodities",
    	"Рыба": "Fish",
    	"Продукция для животных": "Pet products",
    	"Кофе, какао": "Coffee, cocoa",
    	"Специальное питание": "Special food",
    	"Безалкогольные напитки": "Soft drinks",
    	"Тара": "Tare",
    	"Мучные кондитерские изделия": "Flour confectionery",
    	"Мясная гастрономия": "Meat delicatessen",
    	"Рыбная гастрономия": "Fish delicatessen",
    	"Без формата": "No format",
    	"ВМ": "MFs (Magnit Fuel Station)",
    	"ГМ": "MH (Magnit Hypermarket)",
    	"МА": "MPh (Magnit Pharmacy)",
    	"МК": "MCos (Magnit Cosmetic)",
    	"ММ": "MCon (Magnit Convenience)",
    	"МО": "MC&C (Magnit Cash&Carry)",
    	"МС": "MF (Magnit Family)",
    	"ПР": "MPt (Magnit Post)",
    	"СИА": "SIA",
    	"Подформ.": "Subform. (Subformat)",
    	"Округ": "District",
    	"Фил/гр.": "Br./Gr. (Branch/Group)",
    	"Срезы": "Views",
    	"Показатели": "Indicators",
    	"Добавить": "Add",
    	"Подформаты": "Subformats",
    	"Фил./гр.": "Br./Gr.",
    	"Сбросить": "Reset",
    	"Филиал": "Branch",
    	"Добавить показатели": "Add indicators",
    	"Шаблоны": "Templates",
    	"Добавить в шаблоны": "Add to templates",
    	"Выбрать показатели": "Choose indicators",
    	"Факторы": "Factors",
    	"Факт / Бюджет": "Actual / budget",
    	"Форматы": "Formats",
    	"Округа": "Districts",
    	"Все": "All",
    	"Отклонения": "Deviations",
    	"Доп. показатели": "Additional indicators",
    	"Прочие реализационные доходы и расходы": "Other sales income and expenses",
    	"Финансовый дашборд": "Financial dashboard",
    	"Операционный дашборд": "Operational dashboard",
    	"Отклонения по форматам": "Deviations in formats",
    	"Отклонения по регионам": "Deviations in districts",
    	"млн. руб.": "mln rub",
    	"млн. руб": "mln rub",
    	"руб.": "rub",
    	"тыс. шт.": "thousand pcs.",
    	"шт.": "pcs.",
    	"дн.": "days",
    	"чел.": "people",
    	"от бюд.": "budget",
    	"% от выр.": "% from revenue",
    	"Поиск": "Search",
    	"Отмена": "Cancel",
    	"Применить фильтр": "Apply filter",
    	"Перейти в показатель": "Go to indicator",
    	"Грануляция": "Granulation",
    	"По мес.": "Month",
    	"По кв.": "Quarters",
    	"квартал": "quarter",
    	"Квартал": "Quarter",
    	"По годам": "Years",
    	"Факт": "Fact",
    	"Бюд.": "Budget",
    	"∆ от": "∆ from",
    	"∆ от бюд.": "∆ from budget",
    	"рубли": "rubles",
    	"∆ от выр.": "∆ from revenue",
    	"Пн": "Mon",
    	"Вт": "Tue",
    	"Ср": "Wed",
    	"Чт": "Thu",
    	"Пт": "Fri",
    	"Сб": "Sat",
    	"Вс": "Sun",
    	"Выбрать все": "Select all",
    	"Выбрать срез": "Select slice",
    	"Выбрать": "Select",
    	"Выбрать PoP": "Select PoP",
    	"месяц": "month",
    	"год": "year",
    	"Количество отклонений": "Deviation count",
    	"Выгрузка данных": "Export",
    	"Скачать": "Download",
    	"План": "Plan",
    	"∆ от плана": "∆ from plan",
    	"в %/п.п.": "in %/p.p.",
    	"абсолют": "absolute",
    	"плана": "plan",
    	"По нед.": "Weeks",
    	"По дн.": "Days",
    	"ДС": "Dark store"
    };

    /**
     * lodash (Custom Build) <https://lodash.com/>
     * Build: `lodash modularize exports="npm" -o ./`
     * Copyright jQuery Foundation and other contributors <https://jquery.org/>
     * Released under MIT license <https://lodash.com/license>
     * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
     * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
     */

    /** Used as references for various `Number` constants. */
    var MAX_SAFE_INTEGER = 9007199254740991;

    /** `Object#toString` result references. */
    var argsTag = '[object Arguments]',
        funcTag = '[object Function]',
        genTag = '[object GeneratorFunction]';

    /** Used to detect unsigned integer values. */
    var reIsUint = /^(?:0|[1-9]\d*)$/;

    /**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */
    function baseTimes(n, iteratee) {
      var index = -1,
          result = Array(n);

      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }

    /**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }

    /** Used for built-in method references. */
    var objectProto = Object.prototype;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var objectToString = objectProto.toString;

    /** Built-in value references. */
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeKeys = overArg(Object.keys, Object);

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
      // Safari 9 makes `arguments.length` enumerable in strict mode.
      var result = (isArray(value) || isArguments(value))
        ? baseTimes(value.length, String)
        : [];

      var length = result.length,
          skipIndexes = !!length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length &&
        (typeof value == 'number' || reIsUint.test(value)) &&
        (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    function isArguments(value) {
      // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
      return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
        (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
    }

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 8-9 which returns 'object' for typed array and other constructors.
      var tag = isObject(value) ? objectToString.call(value) : '';
      return tag == funcTag || tag == genTag;
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return !!value && typeof value == 'object';
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      result[value] = key;
    }, constant(identity$1));

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity$1(value) {
      return value;
    }

    var lodash_invert = invert;

    var CyrillicToTranslit = function cyrillicToTranslit(config) {
      const invert = lodash_invert;
      const _preset = config ? config.preset : "ru";

      /*
      ASSOCIATIONS FOR INITIAL POSITION
      */

      // letters shared between languages
      const _firstLetters = {
        "а": "a",
        "б": "b",
        "в": "v",
        "д": "d",
        "з": "z",
        "й": "y",
        "к": "k",
        "л": "l",
        "м": "m",
        "н": "n",
        "о": "o",
        "п": "p",
        "р": "r",
        "с": "s",
        "т": "t",
        "у": "u",
        "ф": "f",
        "ь": ""
      };

      // language-specific letters
      if (_preset === "ru") {
        Object.assign(_firstLetters, {
          "г": "g",
          "и": "i",
          "ъ": "",
          "ы": "i",
          "э": "e",
        });
      } else if (_preset === "uk") {
        Object.assign(_firstLetters, {
          "г": "h",
          "ґ": "g",
          "е": "e",
          "и": "y",
          "і": "i",
          "'": "",
          "’": "",
          "ʼ": "",
        });
      }

      let _reversedFirstLetters;
      if (_preset === "ru") {
        // Russian: i > always и, y > й in initial position, e > э in initial position
        _reversedFirstLetters = Object.assign(invert(_firstLetters), { "i": "и", "": "" });
      } else if (_preset === "uk") {
        // Ukrainian: i > always i, y > always и, e > always е
        _reversedFirstLetters = Object.assign(invert(_firstLetters), { "": "" });
      }

      // digraphs appearing only in initial position
      const _initialDigraphs = (_preset === "ru") ? { "е": "ye" } : { "є": "ye", "ї": "yi" };

      // digraphs appearing in all positions
      const _regularDigraphs = {
        "ё": "yo",
        "ж": "zh",
        "х": "kh",
        "ц": "ts",
        "ч": "ch",
        "ш": "sh",
        "щ": "shch",
        "ю": "yu",
        "я": "ya",
      };

      const _firstDigraphs = Object.assign({}, _regularDigraphs, _initialDigraphs);

      const _reversedFirstDigraphs = Object.assign(invert(_firstDigraphs));

      const _firstAssociations = Object.assign(_firstLetters, _firstDigraphs);

      /*
      ASSOCIATIONS FOR NON-INITIAL POSITION
      */

      const _nonFirstLetters = Object.assign({}, _firstLetters, { "й": "i" });
      if (_preset === "ru") {
        Object.assign(_nonFirstLetters, { "е": "e" });
      } else if (_preset === "uk") {
        Object.assign(_nonFirstLetters, { "ї": "i" });
      }

      let _reversedNonFirstLetters;
      if (_preset === "ru") {
        // Russian: i > always и, y > ы in non-initial position, e > е in non-initial position
        _reversedNonFirstLetters = Object.assign(invert(_firstLetters), {
          "i": "и", 
          "y": "ы",
          "e": "е",
          "": "" 
        });
      } else if (_preset === "uk") {
        // Ukrainian: i > always i, y > always и, e > always е
        _reversedNonFirstLetters = Object.assign(invert(_firstLetters), { "": "" });
      }

      // digraphs appearing only in non-initial positions
      let _nonInitialDigraphs = {};
      if (_preset === "uk") {
        _nonInitialDigraphs = {
          "є": "ie",
          "ю": "iu",
          "я": "ia",
        };
      }

      const _nonFirstDigraphs = Object.assign(_regularDigraphs, _nonInitialDigraphs);

      const _reversedNonFirstDigraphs = Object.assign(invert(_nonFirstDigraphs));

      const _nonFirstAssociations = Object.assign(_nonFirstLetters, _nonFirstDigraphs);


      function transform(input, spaceReplacement) {
        if (!input) {
          return "";
        }

        // We must normalize string for transform all unicode chars to uniform form
        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize
        const normalizedInput = input.normalize();

        let newStr = "";
        let isWordBoundary = false;

        for (let i = 0; i < normalizedInput.length; i++) {
          const isUpperCaseOrWhatever = normalizedInput[i] === normalizedInput[i].toUpperCase();
          let strLowerCase = normalizedInput[i].toLowerCase();

          if (strLowerCase === " ") {
            newStr += spaceReplacement ? spaceReplacement :  " ";
            isWordBoundary = true;
            continue;
          }

          let newLetter;

          if ( _preset === "uk" && normalizedInput.slice(i-1, i+1).toLowerCase() === "зг") {
            // handle ukrainian special case зг > zgh
            newLetter = "gh";
          } else if (i === 0 || isWordBoundary) {
            newLetter = _firstAssociations[strLowerCase];
            isWordBoundary = false;
          } else {
            newLetter = _nonFirstAssociations[strLowerCase];
          }

          if ("undefined" === typeof newLetter) {
            newStr += isUpperCaseOrWhatever ? strLowerCase.toUpperCase() : strLowerCase;
          } else if (isUpperCaseOrWhatever) {
            // handle multi-symbol letters
            newLetter.length > 1
              ? newStr += newLetter[0].toUpperCase() + newLetter.slice(1)
              : newStr += newLetter.toUpperCase();
          } else {
            newStr += newLetter;
          }
        }
        return newStr;
      }

      function reverse(input, spaceReplacement) {

        if (!input) return "";

        const normalizedInput = input.normalize();

        let newStr = "";
        let isWordBoundary = false;
        let i = 0;

        while (i < normalizedInput.length) {
          const isUpperCaseOrWhatever = normalizedInput[i] === normalizedInput[i].toUpperCase();
          let strLowerCase = normalizedInput[i].toLowerCase();
          let currentIndex = i;

          if (strLowerCase === " " || strLowerCase === spaceReplacement) {
            newStr += " ";
            isWordBoundary = true;
            i++;
            continue;
          }
          
          let newLetter;

          let digraph = normalizedInput.slice(i, i + 2).toLowerCase();
          if (i === 0 || isWordBoundary) {
            newLetter = _reversedFirstDigraphs[digraph];
            if (newLetter) {
              i += 2;
            } else {
              newLetter = _reversedFirstLetters[strLowerCase];
              i++;
            }
            isWordBoundary = false;
          } else {
            newLetter = _reversedNonFirstDigraphs[digraph];
            if (newLetter) {
              i += 2;
            } else {
              newLetter = _reversedNonFirstLetters[strLowerCase];
              i++;
            }
          }

          // special cases: щ and зг
          if (normalizedInput.slice(currentIndex, currentIndex + 4).toLowerCase() === "shch") {
            newLetter = "щ";
            i = currentIndex + 4;
          } else if (normalizedInput.slice(currentIndex - 1, currentIndex + 2).toLowerCase() === "zgh") {
            newLetter = "г";
            i = currentIndex + 2;
          }

          if ("undefined" === typeof newLetter) {
            newStr += isUpperCaseOrWhatever ? strLowerCase.toUpperCase() : strLowerCase;
          }
          else {
            if (isUpperCaseOrWhatever) {
                // handle multi-symbol letters
                newLetter.length > 1
                  ? newStr += newLetter[0].toUpperCase() + newLetter.slice(1)
                  : newStr += newLetter.toUpperCase();
            } else {
                newStr += newLetter;
            }
          }
        }

        return newStr;
      }

      return {
        transform: transform,
        reverse: reverse
      };
    };

    const cyrillicToTranslit = new CyrillicToTranslit();

    function translate(key, locale) {
      if (locale === 'en') {
        if (englishDictionary[key]) 
          return englishDictionary[key];
        return cyrillicToTranslit.transform(String(key));
      }
      return key;
    }

    /* src/js/components/core/internationalization/Int.svelte generated by Svelte v3.24.0 */

    function create_fragment$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*label*/ ctx[0]);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*label*/ 1) set_data_dev(t, /*label*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $locale;
    	let { key } = $$props;
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(3, $locale = value));
    	const writable_props = ["key"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Int> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Int", $$slots, []);

    	$$self.$set = $$props => {
    		if ("key" in $$props) $$invalidate(2, key = $$props.key);
    	};

    	$$self.$capture_state = () => ({
    		getUIState,
    		translate,
    		key,
    		locale,
    		label,
    		$locale
    	});

    	$$self.$inject_state = $$props => {
    		if ("key" in $$props) $$invalidate(2, key = $$props.key);
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    	};

    	let label;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*key, $locale*/ 12) {
    			 $$invalidate(0, label = translate(key, $locale));
    		}
    	};

    	return [label, locale, key];
    }

    class Int extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { key: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Int",
    			options,
    			id: create_fragment$2.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*key*/ ctx[2] === undefined && !("key" in props)) {
    			console.warn("<Int> was created without expected prop 'key'");
    		}
    	}

    	get key() {
    		throw new Error("<Int>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<Int>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    	  path: basedir,
    	  exports: {},
    	  require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
        }
    	}, fn(module, module.exports), module.exports;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var moment = createCommonjsModule(function (module, exports) {
    (function (global, factory) {
         module.exports = factory() ;
    }(commonjsGlobal, (function () {
        var hookCallback;

        function hooks() {
            return hookCallback.apply(null, arguments);
        }

        // This is done to register the method called with moment()
        // without creating circular dependencies.
        function setHookCallback(callback) {
            hookCallback = callback;
        }

        function isArray(input) {
            return (
                input instanceof Array ||
                Object.prototype.toString.call(input) === '[object Array]'
            );
        }

        function isObject(input) {
            // IE8 will treat undefined and null as object if it wasn't for
            // input != null
            return (
                input != null &&
                Object.prototype.toString.call(input) === '[object Object]'
            );
        }

        function hasOwnProp(a, b) {
            return Object.prototype.hasOwnProperty.call(a, b);
        }

        function isObjectEmpty(obj) {
            if (Object.getOwnPropertyNames) {
                return Object.getOwnPropertyNames(obj).length === 0;
            } else {
                var k;
                for (k in obj) {
                    if (hasOwnProp(obj, k)) {
                        return false;
                    }
                }
                return true;
            }
        }

        function isUndefined(input) {
            return input === void 0;
        }

        function isNumber(input) {
            return (
                typeof input === 'number' ||
                Object.prototype.toString.call(input) === '[object Number]'
            );
        }

        function isDate(input) {
            return (
                input instanceof Date ||
                Object.prototype.toString.call(input) === '[object Date]'
            );
        }

        function map(arr, fn) {
            var res = [],
                i;
            for (i = 0; i < arr.length; ++i) {
                res.push(fn(arr[i], i));
            }
            return res;
        }

        function extend(a, b) {
            for (var i in b) {
                if (hasOwnProp(b, i)) {
                    a[i] = b[i];
                }
            }

            if (hasOwnProp(b, 'toString')) {
                a.toString = b.toString;
            }

            if (hasOwnProp(b, 'valueOf')) {
                a.valueOf = b.valueOf;
            }

            return a;
        }

        function createUTC(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, true).utc();
        }

        function defaultParsingFlags() {
            // We need to deep clone this object.
            return {
                empty: false,
                unusedTokens: [],
                unusedInput: [],
                overflow: -2,
                charsLeftOver: 0,
                nullInput: false,
                invalidEra: null,
                invalidMonth: null,
                invalidFormat: false,
                userInvalidated: false,
                iso: false,
                parsedDateParts: [],
                era: null,
                meridiem: null,
                rfc2822: false,
                weekdayMismatch: false,
            };
        }

        function getParsingFlags(m) {
            if (m._pf == null) {
                m._pf = defaultParsingFlags();
            }
            return m._pf;
        }

        var some;
        if (Array.prototype.some) {
            some = Array.prototype.some;
        } else {
            some = function (fun) {
                var t = Object(this),
                    len = t.length >>> 0,
                    i;

                for (i = 0; i < len; i++) {
                    if (i in t && fun.call(this, t[i], i, t)) {
                        return true;
                    }
                }

                return false;
            };
        }

        function isValid(m) {
            if (m._isValid == null) {
                var flags = getParsingFlags(m),
                    parsedParts = some.call(flags.parsedDateParts, function (i) {
                        return i != null;
                    }),
                    isNowValid =
                        !isNaN(m._d.getTime()) &&
                        flags.overflow < 0 &&
                        !flags.empty &&
                        !flags.invalidEra &&
                        !flags.invalidMonth &&
                        !flags.invalidWeekday &&
                        !flags.weekdayMismatch &&
                        !flags.nullInput &&
                        !flags.invalidFormat &&
                        !flags.userInvalidated &&
                        (!flags.meridiem || (flags.meridiem && parsedParts));

                if (m._strict) {
                    isNowValid =
                        isNowValid &&
                        flags.charsLeftOver === 0 &&
                        flags.unusedTokens.length === 0 &&
                        flags.bigHour === undefined;
                }

                if (Object.isFrozen == null || !Object.isFrozen(m)) {
                    m._isValid = isNowValid;
                } else {
                    return isNowValid;
                }
            }
            return m._isValid;
        }

        function createInvalid(flags) {
            var m = createUTC(NaN);
            if (flags != null) {
                extend(getParsingFlags(m), flags);
            } else {
                getParsingFlags(m).userInvalidated = true;
            }

            return m;
        }

        // Plugins that add properties should also add the key here (null value),
        // so we can properly clone ourselves.
        var momentProperties = (hooks.momentProperties = []),
            updateInProgress = false;

        function copyConfig(to, from) {
            var i, prop, val;

            if (!isUndefined(from._isAMomentObject)) {
                to._isAMomentObject = from._isAMomentObject;
            }
            if (!isUndefined(from._i)) {
                to._i = from._i;
            }
            if (!isUndefined(from._f)) {
                to._f = from._f;
            }
            if (!isUndefined(from._l)) {
                to._l = from._l;
            }
            if (!isUndefined(from._strict)) {
                to._strict = from._strict;
            }
            if (!isUndefined(from._tzm)) {
                to._tzm = from._tzm;
            }
            if (!isUndefined(from._isUTC)) {
                to._isUTC = from._isUTC;
            }
            if (!isUndefined(from._offset)) {
                to._offset = from._offset;
            }
            if (!isUndefined(from._pf)) {
                to._pf = getParsingFlags(from);
            }
            if (!isUndefined(from._locale)) {
                to._locale = from._locale;
            }

            if (momentProperties.length > 0) {
                for (i = 0; i < momentProperties.length; i++) {
                    prop = momentProperties[i];
                    val = from[prop];
                    if (!isUndefined(val)) {
                        to[prop] = val;
                    }
                }
            }

            return to;
        }

        // Moment prototype object
        function Moment(config) {
            copyConfig(this, config);
            this._d = new Date(config._d != null ? config._d.getTime() : NaN);
            if (!this.isValid()) {
                this._d = new Date(NaN);
            }
            // Prevent infinite loop in case updateOffset creates new moment
            // objects.
            if (updateInProgress === false) {
                updateInProgress = true;
                hooks.updateOffset(this);
                updateInProgress = false;
            }
        }

        function isMoment(obj) {
            return (
                obj instanceof Moment || (obj != null && obj._isAMomentObject != null)
            );
        }

        function warn(msg) {
            if (
                hooks.suppressDeprecationWarnings === false &&
                typeof console !== 'undefined' &&
                console.warn
            ) {
                console.warn('Deprecation warning: ' + msg);
            }
        }

        function deprecate(msg, fn) {
            var firstTime = true;

            return extend(function () {
                if (hooks.deprecationHandler != null) {
                    hooks.deprecationHandler(null, msg);
                }
                if (firstTime) {
                    var args = [],
                        arg,
                        i,
                        key;
                    for (i = 0; i < arguments.length; i++) {
                        arg = '';
                        if (typeof arguments[i] === 'object') {
                            arg += '\n[' + i + '] ';
                            for (key in arguments[0]) {
                                if (hasOwnProp(arguments[0], key)) {
                                    arg += key + ': ' + arguments[0][key] + ', ';
                                }
                            }
                            arg = arg.slice(0, -2); // Remove trailing comma and space
                        } else {
                            arg = arguments[i];
                        }
                        args.push(arg);
                    }
                    warn(
                        msg +
                            '\nArguments: ' +
                            Array.prototype.slice.call(args).join('') +
                            '\n' +
                            new Error().stack
                    );
                    firstTime = false;
                }
                return fn.apply(this, arguments);
            }, fn);
        }

        var deprecations = {};

        function deprecateSimple(name, msg) {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(name, msg);
            }
            if (!deprecations[name]) {
                warn(msg);
                deprecations[name] = true;
            }
        }

        hooks.suppressDeprecationWarnings = false;
        hooks.deprecationHandler = null;

        function isFunction(input) {
            return (
                (typeof Function !== 'undefined' && input instanceof Function) ||
                Object.prototype.toString.call(input) === '[object Function]'
            );
        }

        function set(config) {
            var prop, i;
            for (i in config) {
                if (hasOwnProp(config, i)) {
                    prop = config[i];
                    if (isFunction(prop)) {
                        this[i] = prop;
                    } else {
                        this['_' + i] = prop;
                    }
                }
            }
            this._config = config;
            // Lenient ordinal parsing accepts just a number in addition to
            // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
            // TODO: Remove "ordinalParse" fallback in next major release.
            this._dayOfMonthOrdinalParseLenient = new RegExp(
                (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                    '|' +
                    /\d{1,2}/.source
            );
        }

        function mergeConfigs(parentConfig, childConfig) {
            var res = extend({}, parentConfig),
                prop;
            for (prop in childConfig) {
                if (hasOwnProp(childConfig, prop)) {
                    if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                        res[prop] = {};
                        extend(res[prop], parentConfig[prop]);
                        extend(res[prop], childConfig[prop]);
                    } else if (childConfig[prop] != null) {
                        res[prop] = childConfig[prop];
                    } else {
                        delete res[prop];
                    }
                }
            }
            for (prop in parentConfig) {
                if (
                    hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])
                ) {
                    // make sure changes to properties don't modify parent config
                    res[prop] = extend({}, res[prop]);
                }
            }
            return res;
        }

        function Locale(config) {
            if (config != null) {
                this.set(config);
            }
        }

        var keys;

        if (Object.keys) {
            keys = Object.keys;
        } else {
            keys = function (obj) {
                var i,
                    res = [];
                for (i in obj) {
                    if (hasOwnProp(obj, i)) {
                        res.push(i);
                    }
                }
                return res;
            };
        }

        var defaultCalendar = {
            sameDay: '[Today at] LT',
            nextDay: '[Tomorrow at] LT',
            nextWeek: 'dddd [at] LT',
            lastDay: '[Yesterday at] LT',
            lastWeek: '[Last] dddd [at] LT',
            sameElse: 'L',
        };

        function calendar(key, mom, now) {
            var output = this._calendar[key] || this._calendar['sameElse'];
            return isFunction(output) ? output.call(mom, now) : output;
        }

        function zeroFill(number, targetLength, forceSign) {
            var absNumber = '' + Math.abs(number),
                zerosToFill = targetLength - absNumber.length,
                sign = number >= 0;
            return (
                (sign ? (forceSign ? '+' : '') : '-') +
                Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) +
                absNumber
            );
        }

        var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
            localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
            formatFunctions = {},
            formatTokenFunctions = {};

        // token:    'M'
        // padded:   ['MM', 2]
        // ordinal:  'Mo'
        // callback: function () { this.month() + 1 }
        function addFormatToken(token, padded, ordinal, callback) {
            var func = callback;
            if (typeof callback === 'string') {
                func = function () {
                    return this[callback]();
                };
            }
            if (token) {
                formatTokenFunctions[token] = func;
            }
            if (padded) {
                formatTokenFunctions[padded[0]] = function () {
                    return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
                };
            }
            if (ordinal) {
                formatTokenFunctions[ordinal] = function () {
                    return this.localeData().ordinal(
                        func.apply(this, arguments),
                        token
                    );
                };
            }
        }

        function removeFormattingTokens(input) {
            if (input.match(/\[[\s\S]/)) {
                return input.replace(/^\[|\]$/g, '');
            }
            return input.replace(/\\/g, '');
        }

        function makeFormatFunction(format) {
            var array = format.match(formattingTokens),
                i,
                length;

            for (i = 0, length = array.length; i < length; i++) {
                if (formatTokenFunctions[array[i]]) {
                    array[i] = formatTokenFunctions[array[i]];
                } else {
                    array[i] = removeFormattingTokens(array[i]);
                }
            }

            return function (mom) {
                var output = '',
                    i;
                for (i = 0; i < length; i++) {
                    output += isFunction(array[i])
                        ? array[i].call(mom, format)
                        : array[i];
                }
                return output;
            };
        }

        // format date using native date object
        function formatMoment(m, format) {
            if (!m.isValid()) {
                return m.localeData().invalidDate();
            }

            format = expandFormat(format, m.localeData());
            formatFunctions[format] =
                formatFunctions[format] || makeFormatFunction(format);

            return formatFunctions[format](m);
        }

        function expandFormat(format, locale) {
            var i = 5;

            function replaceLongDateFormatTokens(input) {
                return locale.longDateFormat(input) || input;
            }

            localFormattingTokens.lastIndex = 0;
            while (i >= 0 && localFormattingTokens.test(format)) {
                format = format.replace(
                    localFormattingTokens,
                    replaceLongDateFormatTokens
                );
                localFormattingTokens.lastIndex = 0;
                i -= 1;
            }

            return format;
        }

        var defaultLongDateFormat = {
            LTS: 'h:mm:ss A',
            LT: 'h:mm A',
            L: 'MM/DD/YYYY',
            LL: 'MMMM D, YYYY',
            LLL: 'MMMM D, YYYY h:mm A',
            LLLL: 'dddd, MMMM D, YYYY h:mm A',
        };

        function longDateFormat(key) {
            var format = this._longDateFormat[key],
                formatUpper = this._longDateFormat[key.toUpperCase()];

            if (format || !formatUpper) {
                return format;
            }

            this._longDateFormat[key] = formatUpper
                .match(formattingTokens)
                .map(function (tok) {
                    if (
                        tok === 'MMMM' ||
                        tok === 'MM' ||
                        tok === 'DD' ||
                        tok === 'dddd'
                    ) {
                        return tok.slice(1);
                    }
                    return tok;
                })
                .join('');

            return this._longDateFormat[key];
        }

        var defaultInvalidDate = 'Invalid date';

        function invalidDate() {
            return this._invalidDate;
        }

        var defaultOrdinal = '%d',
            defaultDayOfMonthOrdinalParse = /\d{1,2}/;

        function ordinal(number) {
            return this._ordinal.replace('%d', number);
        }

        var defaultRelativeTime = {
            future: 'in %s',
            past: '%s ago',
            s: 'a few seconds',
            ss: '%d seconds',
            m: 'a minute',
            mm: '%d minutes',
            h: 'an hour',
            hh: '%d hours',
            d: 'a day',
            dd: '%d days',
            w: 'a week',
            ww: '%d weeks',
            M: 'a month',
            MM: '%d months',
            y: 'a year',
            yy: '%d years',
        };

        function relativeTime(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return isFunction(output)
                ? output(number, withoutSuffix, string, isFuture)
                : output.replace(/%d/i, number);
        }

        function pastFuture(diff, output) {
            var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
            return isFunction(format) ? format(output) : format.replace(/%s/i, output);
        }

        var aliases = {};

        function addUnitAlias(unit, shorthand) {
            var lowerCase = unit.toLowerCase();
            aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
        }

        function normalizeUnits(units) {
            return typeof units === 'string'
                ? aliases[units] || aliases[units.toLowerCase()]
                : undefined;
        }

        function normalizeObjectUnits(inputObject) {
            var normalizedInput = {},
                normalizedProp,
                prop;

            for (prop in inputObject) {
                if (hasOwnProp(inputObject, prop)) {
                    normalizedProp = normalizeUnits(prop);
                    if (normalizedProp) {
                        normalizedInput[normalizedProp] = inputObject[prop];
                    }
                }
            }

            return normalizedInput;
        }

        var priorities = {};

        function addUnitPriority(unit, priority) {
            priorities[unit] = priority;
        }

        function getPrioritizedUnits(unitsObj) {
            var units = [],
                u;
            for (u in unitsObj) {
                if (hasOwnProp(unitsObj, u)) {
                    units.push({ unit: u, priority: priorities[u] });
                }
            }
            units.sort(function (a, b) {
                return a.priority - b.priority;
            });
            return units;
        }

        function isLeapYear(year) {
            return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
        }

        function absFloor(number) {
            if (number < 0) {
                // -0 -> 0
                return Math.ceil(number) || 0;
            } else {
                return Math.floor(number);
            }
        }

        function toInt(argumentForCoercion) {
            var coercedNumber = +argumentForCoercion,
                value = 0;

            if (coercedNumber !== 0 && isFinite(coercedNumber)) {
                value = absFloor(coercedNumber);
            }

            return value;
        }

        function makeGetSet(unit, keepTime) {
            return function (value) {
                if (value != null) {
                    set$1(this, unit, value);
                    hooks.updateOffset(this, keepTime);
                    return this;
                } else {
                    return get(this, unit);
                }
            };
        }

        function get(mom, unit) {
            return mom.isValid()
                ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]()
                : NaN;
        }

        function set$1(mom, unit, value) {
            if (mom.isValid() && !isNaN(value)) {
                if (
                    unit === 'FullYear' &&
                    isLeapYear(mom.year()) &&
                    mom.month() === 1 &&
                    mom.date() === 29
                ) {
                    value = toInt(value);
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](
                        value,
                        mom.month(),
                        daysInMonth(value, mom.month())
                    );
                } else {
                    mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
                }
            }
        }

        // MOMENTS

        function stringGet(units) {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units]();
            }
            return this;
        }

        function stringSet(units, value) {
            if (typeof units === 'object') {
                units = normalizeObjectUnits(units);
                var prioritized = getPrioritizedUnits(units),
                    i;
                for (i = 0; i < prioritized.length; i++) {
                    this[prioritized[i].unit](units[prioritized[i].unit]);
                }
            } else {
                units = normalizeUnits(units);
                if (isFunction(this[units])) {
                    return this[units](value);
                }
            }
            return this;
        }

        var match1 = /\d/, //       0 - 9
            match2 = /\d\d/, //      00 - 99
            match3 = /\d{3}/, //     000 - 999
            match4 = /\d{4}/, //    0000 - 9999
            match6 = /[+-]?\d{6}/, // -999999 - 999999
            match1to2 = /\d\d?/, //       0 - 99
            match3to4 = /\d\d\d\d?/, //     999 - 9999
            match5to6 = /\d\d\d\d\d\d?/, //   99999 - 999999
            match1to3 = /\d{1,3}/, //       0 - 999
            match1to4 = /\d{1,4}/, //       0 - 9999
            match1to6 = /[+-]?\d{1,6}/, // -999999 - 999999
            matchUnsigned = /\d+/, //       0 - inf
            matchSigned = /[+-]?\d+/, //    -inf - inf
            matchOffset = /Z|[+-]\d\d:?\d\d/gi, // +00:00 -00:00 +0000 -0000 or Z
            matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi, // +00 -00 +00:00 -00:00 +0000 -0000 or Z
            matchTimestamp = /[+-]?\d+(\.\d{1,3})?/, // 123456789 123456789.123
            // any word (or two) characters or numbers including two/three word month in arabic.
            // includes scottish gaelic two word and hyphenated months
            matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
            regexes;

        regexes = {};

        function addRegexToken(token, regex, strictRegex) {
            regexes[token] = isFunction(regex)
                ? regex
                : function (isStrict, localeData) {
                      return isStrict && strictRegex ? strictRegex : regex;
                  };
        }

        function getParseRegexForToken(token, config) {
            if (!hasOwnProp(regexes, token)) {
                return new RegExp(unescapeFormat(token));
            }

            return regexes[token](config._strict, config._locale);
        }

        // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
        function unescapeFormat(s) {
            return regexEscape(
                s
                    .replace('\\', '')
                    .replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (
                        matched,
                        p1,
                        p2,
                        p3,
                        p4
                    ) {
                        return p1 || p2 || p3 || p4;
                    })
            );
        }

        function regexEscape(s) {
            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
        }

        var tokens = {};

        function addParseToken(token, callback) {
            var i,
                func = callback;
            if (typeof token === 'string') {
                token = [token];
            }
            if (isNumber(callback)) {
                func = function (input, array) {
                    array[callback] = toInt(input);
                };
            }
            for (i = 0; i < token.length; i++) {
                tokens[token[i]] = func;
            }
        }

        function addWeekParseToken(token, callback) {
            addParseToken(token, function (input, array, config, token) {
                config._w = config._w || {};
                callback(input, config._w, config, token);
            });
        }

        function addTimeToArrayFromToken(token, input, config) {
            if (input != null && hasOwnProp(tokens, token)) {
                tokens[token](input, config._a, config, token);
            }
        }

        var YEAR = 0,
            MONTH = 1,
            DATE = 2,
            HOUR = 3,
            MINUTE = 4,
            SECOND = 5,
            MILLISECOND = 6,
            WEEK = 7,
            WEEKDAY = 8;

        function mod(n, x) {
            return ((n % x) + x) % x;
        }

        var indexOf;

        if (Array.prototype.indexOf) {
            indexOf = Array.prototype.indexOf;
        } else {
            indexOf = function (o) {
                // I know
                var i;
                for (i = 0; i < this.length; ++i) {
                    if (this[i] === o) {
                        return i;
                    }
                }
                return -1;
            };
        }

        function daysInMonth(year, month) {
            if (isNaN(year) || isNaN(month)) {
                return NaN;
            }
            var modMonth = mod(month, 12);
            year += (month - modMonth) / 12;
            return modMonth === 1
                ? isLeapYear(year)
                    ? 29
                    : 28
                : 31 - ((modMonth % 7) % 2);
        }

        // FORMATTING

        addFormatToken('M', ['MM', 2], 'Mo', function () {
            return this.month() + 1;
        });

        addFormatToken('MMM', 0, 0, function (format) {
            return this.localeData().monthsShort(this, format);
        });

        addFormatToken('MMMM', 0, 0, function (format) {
            return this.localeData().months(this, format);
        });

        // ALIASES

        addUnitAlias('month', 'M');

        // PRIORITY

        addUnitPriority('month', 8);

        // PARSING

        addRegexToken('M', match1to2);
        addRegexToken('MM', match1to2, match2);
        addRegexToken('MMM', function (isStrict, locale) {
            return locale.monthsShortRegex(isStrict);
        });
        addRegexToken('MMMM', function (isStrict, locale) {
            return locale.monthsRegex(isStrict);
        });

        addParseToken(['M', 'MM'], function (input, array) {
            array[MONTH] = toInt(input) - 1;
        });

        addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
            var month = config._locale.monthsParse(input, token, config._strict);
            // if we didn't find a month name, mark the date as invalid.
            if (month != null) {
                array[MONTH] = month;
            } else {
                getParsingFlags(config).invalidMonth = input;
            }
        });

        // LOCALES

        var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split(
                '_'
            ),
            defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split(
                '_'
            ),
            MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
            defaultMonthsShortRegex = matchWord,
            defaultMonthsRegex = matchWord;

        function localeMonths(m, format) {
            if (!m) {
                return isArray(this._months)
                    ? this._months
                    : this._months['standalone'];
            }
            return isArray(this._months)
                ? this._months[m.month()]
                : this._months[
                      (this._months.isFormat || MONTHS_IN_FORMAT).test(format)
                          ? 'format'
                          : 'standalone'
                  ][m.month()];
        }

        function localeMonthsShort(m, format) {
            if (!m) {
                return isArray(this._monthsShort)
                    ? this._monthsShort
                    : this._monthsShort['standalone'];
            }
            return isArray(this._monthsShort)
                ? this._monthsShort[m.month()]
                : this._monthsShort[
                      MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'
                  ][m.month()];
        }

        function handleStrictParse(monthName, format, strict) {
            var i,
                ii,
                mom,
                llc = monthName.toLocaleLowerCase();
            if (!this._monthsParse) {
                // this is not used
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
                for (i = 0; i < 12; ++i) {
                    mom = createUTC([2000, i]);
                    this._shortMonthsParse[i] = this.monthsShort(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
                }
            }

            if (strict) {
                if (format === 'MMM') {
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._longMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                }
            } else {
                if (format === 'MMM') {
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._longMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._longMonthsParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortMonthsParse, llc);
                    return ii !== -1 ? ii : null;
                }
            }
        }

        function localeMonthsParse(monthName, format, strict) {
            var i, mom, regex;

            if (this._monthsParseExact) {
                return handleStrictParse.call(this, monthName, format, strict);
            }

            if (!this._monthsParse) {
                this._monthsParse = [];
                this._longMonthsParse = [];
                this._shortMonthsParse = [];
            }

            // TODO: add sorting
            // Sorting makes sure if one month (or abbr) is a prefix of another
            // see sorting in computeMonthsParse
            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, i]);
                if (strict && !this._longMonthsParse[i]) {
                    this._longMonthsParse[i] = new RegExp(
                        '^' + this.months(mom, '').replace('.', '') + '$',
                        'i'
                    );
                    this._shortMonthsParse[i] = new RegExp(
                        '^' + this.monthsShort(mom, '').replace('.', '') + '$',
                        'i'
                    );
                }
                if (!strict && !this._monthsParse[i]) {
                    regex =
                        '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                    this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (
                    strict &&
                    format === 'MMMM' &&
                    this._longMonthsParse[i].test(monthName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'MMM' &&
                    this._shortMonthsParse[i].test(monthName)
                ) {
                    return i;
                } else if (!strict && this._monthsParse[i].test(monthName)) {
                    return i;
                }
            }
        }

        // MOMENTS

        function setMonth(mom, value) {
            var dayOfMonth;

            if (!mom.isValid()) {
                // No op
                return mom;
            }

            if (typeof value === 'string') {
                if (/^\d+$/.test(value)) {
                    value = toInt(value);
                } else {
                    value = mom.localeData().monthsParse(value);
                    // TODO: Another silent failure?
                    if (!isNumber(value)) {
                        return mom;
                    }
                }
            }

            dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
            mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
            return mom;
        }

        function getSetMonth(value) {
            if (value != null) {
                setMonth(this, value);
                hooks.updateOffset(this, true);
                return this;
            } else {
                return get(this, 'Month');
            }
        }

        function getDaysInMonth() {
            return daysInMonth(this.year(), this.month());
        }

        function monthsShortRegex(isStrict) {
            if (this._monthsParseExact) {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    computeMonthsParse.call(this);
                }
                if (isStrict) {
                    return this._monthsShortStrictRegex;
                } else {
                    return this._monthsShortRegex;
                }
            } else {
                if (!hasOwnProp(this, '_monthsShortRegex')) {
                    this._monthsShortRegex = defaultMonthsShortRegex;
                }
                return this._monthsShortStrictRegex && isStrict
                    ? this._monthsShortStrictRegex
                    : this._monthsShortRegex;
            }
        }

        function monthsRegex(isStrict) {
            if (this._monthsParseExact) {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    computeMonthsParse.call(this);
                }
                if (isStrict) {
                    return this._monthsStrictRegex;
                } else {
                    return this._monthsRegex;
                }
            } else {
                if (!hasOwnProp(this, '_monthsRegex')) {
                    this._monthsRegex = defaultMonthsRegex;
                }
                return this._monthsStrictRegex && isStrict
                    ? this._monthsStrictRegex
                    : this._monthsRegex;
            }
        }

        function computeMonthsParse() {
            function cmpLenRev(a, b) {
                return b.length - a.length;
            }

            var shortPieces = [],
                longPieces = [],
                mixedPieces = [],
                i,
                mom;
            for (i = 0; i < 12; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, i]);
                shortPieces.push(this.monthsShort(mom, ''));
                longPieces.push(this.months(mom, ''));
                mixedPieces.push(this.months(mom, ''));
                mixedPieces.push(this.monthsShort(mom, ''));
            }
            // Sorting makes sure if one month (or abbr) is a prefix of another it
            // will match the longer piece.
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);
            for (i = 0; i < 12; i++) {
                shortPieces[i] = regexEscape(shortPieces[i]);
                longPieces[i] = regexEscape(longPieces[i]);
            }
            for (i = 0; i < 24; i++) {
                mixedPieces[i] = regexEscape(mixedPieces[i]);
            }

            this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._monthsShortRegex = this._monthsRegex;
            this._monthsStrictRegex = new RegExp(
                '^(' + longPieces.join('|') + ')',
                'i'
            );
            this._monthsShortStrictRegex = new RegExp(
                '^(' + shortPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        addFormatToken('Y', 0, 0, function () {
            var y = this.year();
            return y <= 9999 ? zeroFill(y, 4) : '+' + y;
        });

        addFormatToken(0, ['YY', 2], 0, function () {
            return this.year() % 100;
        });

        addFormatToken(0, ['YYYY', 4], 0, 'year');
        addFormatToken(0, ['YYYYY', 5], 0, 'year');
        addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

        // ALIASES

        addUnitAlias('year', 'y');

        // PRIORITIES

        addUnitPriority('year', 1);

        // PARSING

        addRegexToken('Y', matchSigned);
        addRegexToken('YY', match1to2, match2);
        addRegexToken('YYYY', match1to4, match4);
        addRegexToken('YYYYY', match1to6, match6);
        addRegexToken('YYYYYY', match1to6, match6);

        addParseToken(['YYYYY', 'YYYYYY'], YEAR);
        addParseToken('YYYY', function (input, array) {
            array[YEAR] =
                input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
        });
        addParseToken('YY', function (input, array) {
            array[YEAR] = hooks.parseTwoDigitYear(input);
        });
        addParseToken('Y', function (input, array) {
            array[YEAR] = parseInt(input, 10);
        });

        // HELPERS

        function daysInYear(year) {
            return isLeapYear(year) ? 366 : 365;
        }

        // HOOKS

        hooks.parseTwoDigitYear = function (input) {
            return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
        };

        // MOMENTS

        var getSetYear = makeGetSet('FullYear', true);

        function getIsLeapYear() {
            return isLeapYear(this.year());
        }

        function createDate(y, m, d, h, M, s, ms) {
            // can't just apply() to create a date:
            // https://stackoverflow.com/q/181348
            var date;
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                date = new Date(y + 400, m, d, h, M, s, ms);
                if (isFinite(date.getFullYear())) {
                    date.setFullYear(y);
                }
            } else {
                date = new Date(y, m, d, h, M, s, ms);
            }

            return date;
        }

        function createUTCDate(y) {
            var date, args;
            // the Date.UTC function remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                args = Array.prototype.slice.call(arguments);
                // preserve leap years using a full 400 year cycle, then reset
                args[0] = y + 400;
                date = new Date(Date.UTC.apply(null, args));
                if (isFinite(date.getUTCFullYear())) {
                    date.setUTCFullYear(y);
                }
            } else {
                date = new Date(Date.UTC.apply(null, arguments));
            }

            return date;
        }

        // start-of-first-week - start-of-year
        function firstWeekOffset(year, dow, doy) {
            var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
                fwd = 7 + dow - doy,
                // first-week day local weekday -- which local weekday is fwd
                fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

            return -fwdlw + fwd - 1;
        }

        // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
            var localWeekday = (7 + weekday - dow) % 7,
                weekOffset = firstWeekOffset(year, dow, doy),
                dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
                resYear,
                resDayOfYear;

            if (dayOfYear <= 0) {
                resYear = year - 1;
                resDayOfYear = daysInYear(resYear) + dayOfYear;
            } else if (dayOfYear > daysInYear(year)) {
                resYear = year + 1;
                resDayOfYear = dayOfYear - daysInYear(year);
            } else {
                resYear = year;
                resDayOfYear = dayOfYear;
            }

            return {
                year: resYear,
                dayOfYear: resDayOfYear,
            };
        }

        function weekOfYear(mom, dow, doy) {
            var weekOffset = firstWeekOffset(mom.year(), dow, doy),
                week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
                resWeek,
                resYear;

            if (week < 1) {
                resYear = mom.year() - 1;
                resWeek = week + weeksInYear(resYear, dow, doy);
            } else if (week > weeksInYear(mom.year(), dow, doy)) {
                resWeek = week - weeksInYear(mom.year(), dow, doy);
                resYear = mom.year() + 1;
            } else {
                resYear = mom.year();
                resWeek = week;
            }

            return {
                week: resWeek,
                year: resYear,
            };
        }

        function weeksInYear(year, dow, doy) {
            var weekOffset = firstWeekOffset(year, dow, doy),
                weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
            return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
        }

        // FORMATTING

        addFormatToken('w', ['ww', 2], 'wo', 'week');
        addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

        // ALIASES

        addUnitAlias('week', 'w');
        addUnitAlias('isoWeek', 'W');

        // PRIORITIES

        addUnitPriority('week', 5);
        addUnitPriority('isoWeek', 5);

        // PARSING

        addRegexToken('w', match1to2);
        addRegexToken('ww', match1to2, match2);
        addRegexToken('W', match1to2);
        addRegexToken('WW', match1to2, match2);

        addWeekParseToken(['w', 'ww', 'W', 'WW'], function (
            input,
            week,
            config,
            token
        ) {
            week[token.substr(0, 1)] = toInt(input);
        });

        // HELPERS

        // LOCALES

        function localeWeek(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week;
        }

        var defaultLocaleWeek = {
            dow: 0, // Sunday is the first day of the week.
            doy: 6, // The week that contains Jan 6th is the first week of the year.
        };

        function localeFirstDayOfWeek() {
            return this._week.dow;
        }

        function localeFirstDayOfYear() {
            return this._week.doy;
        }

        // MOMENTS

        function getSetWeek(input) {
            var week = this.localeData().week(this);
            return input == null ? week : this.add((input - week) * 7, 'd');
        }

        function getSetISOWeek(input) {
            var week = weekOfYear(this, 1, 4).week;
            return input == null ? week : this.add((input - week) * 7, 'd');
        }

        // FORMATTING

        addFormatToken('d', 0, 'do', 'day');

        addFormatToken('dd', 0, 0, function (format) {
            return this.localeData().weekdaysMin(this, format);
        });

        addFormatToken('ddd', 0, 0, function (format) {
            return this.localeData().weekdaysShort(this, format);
        });

        addFormatToken('dddd', 0, 0, function (format) {
            return this.localeData().weekdays(this, format);
        });

        addFormatToken('e', 0, 0, 'weekday');
        addFormatToken('E', 0, 0, 'isoWeekday');

        // ALIASES

        addUnitAlias('day', 'd');
        addUnitAlias('weekday', 'e');
        addUnitAlias('isoWeekday', 'E');

        // PRIORITY
        addUnitPriority('day', 11);
        addUnitPriority('weekday', 11);
        addUnitPriority('isoWeekday', 11);

        // PARSING

        addRegexToken('d', match1to2);
        addRegexToken('e', match1to2);
        addRegexToken('E', match1to2);
        addRegexToken('dd', function (isStrict, locale) {
            return locale.weekdaysMinRegex(isStrict);
        });
        addRegexToken('ddd', function (isStrict, locale) {
            return locale.weekdaysShortRegex(isStrict);
        });
        addRegexToken('dddd', function (isStrict, locale) {
            return locale.weekdaysRegex(isStrict);
        });

        addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
            var weekday = config._locale.weekdaysParse(input, token, config._strict);
            // if we didn't get a weekday name, mark the date as invalid
            if (weekday != null) {
                week.d = weekday;
            } else {
                getParsingFlags(config).invalidWeekday = input;
            }
        });

        addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
            week[token] = toInt(input);
        });

        // HELPERS

        function parseWeekday(input, locale) {
            if (typeof input !== 'string') {
                return input;
            }

            if (!isNaN(input)) {
                return parseInt(input, 10);
            }

            input = locale.weekdaysParse(input);
            if (typeof input === 'number') {
                return input;
            }

            return null;
        }

        function parseIsoWeekday(input, locale) {
            if (typeof input === 'string') {
                return locale.weekdaysParse(input) % 7 || 7;
            }
            return isNaN(input) ? null : input;
        }

        // LOCALES
        function shiftWeekdays(ws, n) {
            return ws.slice(n, 7).concat(ws.slice(0, n));
        }

        var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split(
                '_'
            ),
            defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_'),
            defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_'),
            defaultWeekdaysRegex = matchWord,
            defaultWeekdaysShortRegex = matchWord,
            defaultWeekdaysMinRegex = matchWord;

        function localeWeekdays(m, format) {
            var weekdays = isArray(this._weekdays)
                ? this._weekdays
                : this._weekdays[
                      m && m !== true && this._weekdays.isFormat.test(format)
                          ? 'format'
                          : 'standalone'
                  ];
            return m === true
                ? shiftWeekdays(weekdays, this._week.dow)
                : m
                ? weekdays[m.day()]
                : weekdays;
        }

        function localeWeekdaysShort(m) {
            return m === true
                ? shiftWeekdays(this._weekdaysShort, this._week.dow)
                : m
                ? this._weekdaysShort[m.day()]
                : this._weekdaysShort;
        }

        function localeWeekdaysMin(m) {
            return m === true
                ? shiftWeekdays(this._weekdaysMin, this._week.dow)
                : m
                ? this._weekdaysMin[m.day()]
                : this._weekdaysMin;
        }

        function handleStrictParse$1(weekdayName, format, strict) {
            var i,
                ii,
                mom,
                llc = weekdayName.toLocaleLowerCase();
            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
                this._shortWeekdaysParse = [];
                this._minWeekdaysParse = [];

                for (i = 0; i < 7; ++i) {
                    mom = createUTC([2000, 1]).day(i);
                    this._minWeekdaysParse[i] = this.weekdaysMin(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._shortWeekdaysParse[i] = this.weekdaysShort(
                        mom,
                        ''
                    ).toLocaleLowerCase();
                    this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
                }
            }

            if (strict) {
                if (format === 'dddd') {
                    ii = indexOf.call(this._weekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else if (format === 'ddd') {
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                }
            } else {
                if (format === 'dddd') {
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else if (format === 'ddd') {
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                } else {
                    ii = indexOf.call(this._minWeekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._weekdaysParse, llc);
                    if (ii !== -1) {
                        return ii;
                    }
                    ii = indexOf.call(this._shortWeekdaysParse, llc);
                    return ii !== -1 ? ii : null;
                }
            }
        }

        function localeWeekdaysParse(weekdayName, format, strict) {
            var i, mom, regex;

            if (this._weekdaysParseExact) {
                return handleStrictParse$1.call(this, weekdayName, format, strict);
            }

            if (!this._weekdaysParse) {
                this._weekdaysParse = [];
                this._minWeekdaysParse = [];
                this._shortWeekdaysParse = [];
                this._fullWeekdaysParse = [];
            }

            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already

                mom = createUTC([2000, 1]).day(i);
                if (strict && !this._fullWeekdaysParse[i]) {
                    this._fullWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdays(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                    this._shortWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                    this._minWeekdaysParse[i] = new RegExp(
                        '^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$',
                        'i'
                    );
                }
                if (!this._weekdaysParse[i]) {
                    regex =
                        '^' +
                        this.weekdays(mom, '') +
                        '|^' +
                        this.weekdaysShort(mom, '') +
                        '|^' +
                        this.weekdaysMin(mom, '');
                    this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
                }
                // test the regex
                if (
                    strict &&
                    format === 'dddd' &&
                    this._fullWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'ddd' &&
                    this._shortWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (
                    strict &&
                    format === 'dd' &&
                    this._minWeekdaysParse[i].test(weekdayName)
                ) {
                    return i;
                } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                    return i;
                }
            }
        }

        // MOMENTS

        function getSetDayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            if (input != null) {
                input = parseWeekday(input, this.localeData());
                return this.add(input - day, 'd');
            } else {
                return day;
            }
        }

        function getSetLocaleDayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return input == null ? weekday : this.add(input - weekday, 'd');
        }

        function getSetISODayOfWeek(input) {
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }

            // behaves the same as moment#day except
            // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
            // as a setter, sunday should belong to the previous week.

            if (input != null) {
                var weekday = parseIsoWeekday(input, this.localeData());
                return this.day(this.day() % 7 ? weekday : weekday - 7);
            } else {
                return this.day() || 7;
            }
        }

        function weekdaysRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysStrictRegex;
                } else {
                    return this._weekdaysRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    this._weekdaysRegex = defaultWeekdaysRegex;
                }
                return this._weekdaysStrictRegex && isStrict
                    ? this._weekdaysStrictRegex
                    : this._weekdaysRegex;
            }
        }

        function weekdaysShortRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysShortStrictRegex;
                } else {
                    return this._weekdaysShortRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                    this._weekdaysShortRegex = defaultWeekdaysShortRegex;
                }
                return this._weekdaysShortStrictRegex && isStrict
                    ? this._weekdaysShortStrictRegex
                    : this._weekdaysShortRegex;
            }
        }

        function weekdaysMinRegex(isStrict) {
            if (this._weekdaysParseExact) {
                if (!hasOwnProp(this, '_weekdaysRegex')) {
                    computeWeekdaysParse.call(this);
                }
                if (isStrict) {
                    return this._weekdaysMinStrictRegex;
                } else {
                    return this._weekdaysMinRegex;
                }
            } else {
                if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                    this._weekdaysMinRegex = defaultWeekdaysMinRegex;
                }
                return this._weekdaysMinStrictRegex && isStrict
                    ? this._weekdaysMinStrictRegex
                    : this._weekdaysMinRegex;
            }
        }

        function computeWeekdaysParse() {
            function cmpLenRev(a, b) {
                return b.length - a.length;
            }

            var minPieces = [],
                shortPieces = [],
                longPieces = [],
                mixedPieces = [],
                i,
                mom,
                minp,
                shortp,
                longp;
            for (i = 0; i < 7; i++) {
                // make the regex if we don't have it already
                mom = createUTC([2000, 1]).day(i);
                minp = regexEscape(this.weekdaysMin(mom, ''));
                shortp = regexEscape(this.weekdaysShort(mom, ''));
                longp = regexEscape(this.weekdays(mom, ''));
                minPieces.push(minp);
                shortPieces.push(shortp);
                longPieces.push(longp);
                mixedPieces.push(minp);
                mixedPieces.push(shortp);
                mixedPieces.push(longp);
            }
            // Sorting makes sure if one weekday (or abbr) is a prefix of another it
            // will match the longer piece.
            minPieces.sort(cmpLenRev);
            shortPieces.sort(cmpLenRev);
            longPieces.sort(cmpLenRev);
            mixedPieces.sort(cmpLenRev);

            this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._weekdaysShortRegex = this._weekdaysRegex;
            this._weekdaysMinRegex = this._weekdaysRegex;

            this._weekdaysStrictRegex = new RegExp(
                '^(' + longPieces.join('|') + ')',
                'i'
            );
            this._weekdaysShortStrictRegex = new RegExp(
                '^(' + shortPieces.join('|') + ')',
                'i'
            );
            this._weekdaysMinStrictRegex = new RegExp(
                '^(' + minPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        function hFormat() {
            return this.hours() % 12 || 12;
        }

        function kFormat() {
            return this.hours() || 24;
        }

        addFormatToken('H', ['HH', 2], 0, 'hour');
        addFormatToken('h', ['hh', 2], 0, hFormat);
        addFormatToken('k', ['kk', 2], 0, kFormat);

        addFormatToken('hmm', 0, 0, function () {
            return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
        });

        addFormatToken('hmmss', 0, 0, function () {
            return (
                '' +
                hFormat.apply(this) +
                zeroFill(this.minutes(), 2) +
                zeroFill(this.seconds(), 2)
            );
        });

        addFormatToken('Hmm', 0, 0, function () {
            return '' + this.hours() + zeroFill(this.minutes(), 2);
        });

        addFormatToken('Hmmss', 0, 0, function () {
            return (
                '' +
                this.hours() +
                zeroFill(this.minutes(), 2) +
                zeroFill(this.seconds(), 2)
            );
        });

        function meridiem(token, lowercase) {
            addFormatToken(token, 0, 0, function () {
                return this.localeData().meridiem(
                    this.hours(),
                    this.minutes(),
                    lowercase
                );
            });
        }

        meridiem('a', true);
        meridiem('A', false);

        // ALIASES

        addUnitAlias('hour', 'h');

        // PRIORITY
        addUnitPriority('hour', 13);

        // PARSING

        function matchMeridiem(isStrict, locale) {
            return locale._meridiemParse;
        }

        addRegexToken('a', matchMeridiem);
        addRegexToken('A', matchMeridiem);
        addRegexToken('H', match1to2);
        addRegexToken('h', match1to2);
        addRegexToken('k', match1to2);
        addRegexToken('HH', match1to2, match2);
        addRegexToken('hh', match1to2, match2);
        addRegexToken('kk', match1to2, match2);

        addRegexToken('hmm', match3to4);
        addRegexToken('hmmss', match5to6);
        addRegexToken('Hmm', match3to4);
        addRegexToken('Hmmss', match5to6);

        addParseToken(['H', 'HH'], HOUR);
        addParseToken(['k', 'kk'], function (input, array, config) {
            var kInput = toInt(input);
            array[HOUR] = kInput === 24 ? 0 : kInput;
        });
        addParseToken(['a', 'A'], function (input, array, config) {
            config._isPm = config._locale.isPM(input);
            config._meridiem = input;
        });
        addParseToken(['h', 'hh'], function (input, array, config) {
            array[HOUR] = toInt(input);
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmm', function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('hmmss', function (input, array, config) {
            var pos1 = input.length - 4,
                pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
            getParsingFlags(config).bigHour = true;
        });
        addParseToken('Hmm', function (input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos));
            array[MINUTE] = toInt(input.substr(pos));
        });
        addParseToken('Hmmss', function (input, array, config) {
            var pos1 = input.length - 4,
                pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1));
            array[MINUTE] = toInt(input.substr(pos1, 2));
            array[SECOND] = toInt(input.substr(pos2));
        });

        // LOCALES

        function localeIsPM(input) {
            // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
            // Using charAt should be more compatible.
            return (input + '').toLowerCase().charAt(0) === 'p';
        }

        var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
            // Setting the hour should keep the time, because the user explicitly
            // specified which hour they want. So trying to maintain the same hour (in
            // a new timezone) makes sense. Adding/subtracting hours does not follow
            // this rule.
            getSetHour = makeGetSet('Hours', true);

        function localeMeridiem(hours, minutes, isLower) {
            if (hours > 11) {
                return isLower ? 'pm' : 'PM';
            } else {
                return isLower ? 'am' : 'AM';
            }
        }

        var baseConfig = {
            calendar: defaultCalendar,
            longDateFormat: defaultLongDateFormat,
            invalidDate: defaultInvalidDate,
            ordinal: defaultOrdinal,
            dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
            relativeTime: defaultRelativeTime,

            months: defaultLocaleMonths,
            monthsShort: defaultLocaleMonthsShort,

            week: defaultLocaleWeek,

            weekdays: defaultLocaleWeekdays,
            weekdaysMin: defaultLocaleWeekdaysMin,
            weekdaysShort: defaultLocaleWeekdaysShort,

            meridiemParse: defaultLocaleMeridiemParse,
        };

        // internal storage for locale config files
        var locales = {},
            localeFamilies = {},
            globalLocale;

        function commonPrefix(arr1, arr2) {
            var i,
                minl = Math.min(arr1.length, arr2.length);
            for (i = 0; i < minl; i += 1) {
                if (arr1[i] !== arr2[i]) {
                    return i;
                }
            }
            return minl;
        }

        function normalizeLocale(key) {
            return key ? key.toLowerCase().replace('_', '-') : key;
        }

        // pick the locale from the array
        // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
        // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
        function chooseLocale(names) {
            var i = 0,
                j,
                next,
                locale,
                split;

            while (i < names.length) {
                split = normalizeLocale(names[i]).split('-');
                j = split.length;
                next = normalizeLocale(names[i + 1]);
                next = next ? next.split('-') : null;
                while (j > 0) {
                    locale = loadLocale(split.slice(0, j).join('-'));
                    if (locale) {
                        return locale;
                    }
                    if (
                        next &&
                        next.length >= j &&
                        commonPrefix(split, next) >= j - 1
                    ) {
                        //the next array item is better than a shallower substring of this one
                        break;
                    }
                    j--;
                }
                i++;
            }
            return globalLocale;
        }

        function loadLocale(name) {
            var oldLocale = null,
                aliasedRequire;
            // TODO: Find a better way to register and load all the locales in Node
            if (
                locales[name] === undefined &&
                'object' !== 'undefined' &&
                module &&
                module.exports
            ) {
                try {
                    oldLocale = globalLocale._abbr;
                    aliasedRequire = commonjsRequire;
                    aliasedRequire('./locale/' + name);
                    getSetGlobalLocale(oldLocale);
                } catch (e) {
                    // mark as not found to avoid repeating expensive file require call causing high CPU
                    // when trying to find en-US, en_US, en-us for every format call
                    locales[name] = null; // null means not found
                }
            }
            return locales[name];
        }

        // This function will load locale and then set the global locale.  If
        // no arguments are passed in, it will simply return the current global
        // locale key.
        function getSetGlobalLocale(key, values) {
            var data;
            if (key) {
                if (isUndefined(values)) {
                    data = getLocale(key);
                } else {
                    data = defineLocale(key, values);
                }

                if (data) {
                    // moment.duration._locale = moment._locale = data;
                    globalLocale = data;
                } else {
                    if (typeof console !== 'undefined' && console.warn) {
                        //warn user if arguments are passed but the locale could not be set
                        console.warn(
                            'Locale ' + key + ' not found. Did you forget to load it?'
                        );
                    }
                }
            }

            return globalLocale._abbr;
        }

        function defineLocale(name, config) {
            if (config !== null) {
                var locale,
                    parentConfig = baseConfig;
                config.abbr = name;
                if (locales[name] != null) {
                    deprecateSimple(
                        'defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                            'an existing locale. moment.defineLocale(localeName, ' +
                            'config) should only be used for creating a new locale ' +
                            'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.'
                    );
                    parentConfig = locales[name]._config;
                } else if (config.parentLocale != null) {
                    if (locales[config.parentLocale] != null) {
                        parentConfig = locales[config.parentLocale]._config;
                    } else {
                        locale = loadLocale(config.parentLocale);
                        if (locale != null) {
                            parentConfig = locale._config;
                        } else {
                            if (!localeFamilies[config.parentLocale]) {
                                localeFamilies[config.parentLocale] = [];
                            }
                            localeFamilies[config.parentLocale].push({
                                name: name,
                                config: config,
                            });
                            return null;
                        }
                    }
                }
                locales[name] = new Locale(mergeConfigs(parentConfig, config));

                if (localeFamilies[name]) {
                    localeFamilies[name].forEach(function (x) {
                        defineLocale(x.name, x.config);
                    });
                }

                // backwards compat for now: also set the locale
                // make sure we set the locale AFTER all child locales have been
                // created, so we won't end up with the child locale set.
                getSetGlobalLocale(name);

                return locales[name];
            } else {
                // useful for testing
                delete locales[name];
                return null;
            }
        }

        function updateLocale(name, config) {
            if (config != null) {
                var locale,
                    tmpLocale,
                    parentConfig = baseConfig;

                if (locales[name] != null && locales[name].parentLocale != null) {
                    // Update existing child locale in-place to avoid memory-leaks
                    locales[name].set(mergeConfigs(locales[name]._config, config));
                } else {
                    // MERGE
                    tmpLocale = loadLocale(name);
                    if (tmpLocale != null) {
                        parentConfig = tmpLocale._config;
                    }
                    config = mergeConfigs(parentConfig, config);
                    if (tmpLocale == null) {
                        // updateLocale is called for creating a new locale
                        // Set abbr so it will have a name (getters return
                        // undefined otherwise).
                        config.abbr = name;
                    }
                    locale = new Locale(config);
                    locale.parentLocale = locales[name];
                    locales[name] = locale;
                }

                // backwards compat for now: also set the locale
                getSetGlobalLocale(name);
            } else {
                // pass null for config to unupdate, useful for tests
                if (locales[name] != null) {
                    if (locales[name].parentLocale != null) {
                        locales[name] = locales[name].parentLocale;
                        if (name === getSetGlobalLocale()) {
                            getSetGlobalLocale(name);
                        }
                    } else if (locales[name] != null) {
                        delete locales[name];
                    }
                }
            }
            return locales[name];
        }

        // returns locale data
        function getLocale(key) {
            var locale;

            if (key && key._locale && key._locale._abbr) {
                key = key._locale._abbr;
            }

            if (!key) {
                return globalLocale;
            }

            if (!isArray(key)) {
                //short-circuit everything else
                locale = loadLocale(key);
                if (locale) {
                    return locale;
                }
                key = [key];
            }

            return chooseLocale(key);
        }

        function listLocales() {
            return keys(locales);
        }

        function checkOverflow(m) {
            var overflow,
                a = m._a;

            if (a && getParsingFlags(m).overflow === -2) {
                overflow =
                    a[MONTH] < 0 || a[MONTH] > 11
                        ? MONTH
                        : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH])
                        ? DATE
                        : a[HOUR] < 0 ||
                          a[HOUR] > 24 ||
                          (a[HOUR] === 24 &&
                              (a[MINUTE] !== 0 ||
                                  a[SECOND] !== 0 ||
                                  a[MILLISECOND] !== 0))
                        ? HOUR
                        : a[MINUTE] < 0 || a[MINUTE] > 59
                        ? MINUTE
                        : a[SECOND] < 0 || a[SECOND] > 59
                        ? SECOND
                        : a[MILLISECOND] < 0 || a[MILLISECOND] > 999
                        ? MILLISECOND
                        : -1;

                if (
                    getParsingFlags(m)._overflowDayOfYear &&
                    (overflow < YEAR || overflow > DATE)
                ) {
                    overflow = DATE;
                }
                if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                    overflow = WEEK;
                }
                if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                    overflow = WEEKDAY;
                }

                getParsingFlags(m).overflow = overflow;
            }

            return m;
        }

        // iso 8601 regex
        // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
        var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
            isoDates = [
                ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
                ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
                ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
                ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
                ['YYYY-DDD', /\d{4}-\d{3}/],
                ['YYYY-MM', /\d{4}-\d\d/, false],
                ['YYYYYYMMDD', /[+-]\d{10}/],
                ['YYYYMMDD', /\d{8}/],
                ['GGGG[W]WWE', /\d{4}W\d{3}/],
                ['GGGG[W]WW', /\d{4}W\d{2}/, false],
                ['YYYYDDD', /\d{7}/],
                ['YYYYMM', /\d{6}/, false],
                ['YYYY', /\d{4}/, false],
            ],
            // iso time formats and regexes
            isoTimes = [
                ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
                ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
                ['HH:mm:ss', /\d\d:\d\d:\d\d/],
                ['HH:mm', /\d\d:\d\d/],
                ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
                ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
                ['HHmmss', /\d\d\d\d\d\d/],
                ['HHmm', /\d\d\d\d/],
                ['HH', /\d\d/],
            ],
            aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
            // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
            rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
            obsOffsets = {
                UT: 0,
                GMT: 0,
                EDT: -4 * 60,
                EST: -5 * 60,
                CDT: -5 * 60,
                CST: -6 * 60,
                MDT: -6 * 60,
                MST: -7 * 60,
                PDT: -7 * 60,
                PST: -8 * 60,
            };

        // date from iso format
        function configFromISO(config) {
            var i,
                l,
                string = config._i,
                match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
                allowTime,
                dateFormat,
                timeFormat,
                tzFormat;

            if (match) {
                getParsingFlags(config).iso = true;

                for (i = 0, l = isoDates.length; i < l; i++) {
                    if (isoDates[i][1].exec(match[1])) {
                        dateFormat = isoDates[i][0];
                        allowTime = isoDates[i][2] !== false;
                        break;
                    }
                }
                if (dateFormat == null) {
                    config._isValid = false;
                    return;
                }
                if (match[3]) {
                    for (i = 0, l = isoTimes.length; i < l; i++) {
                        if (isoTimes[i][1].exec(match[3])) {
                            // match[2] should be 'T' or space
                            timeFormat = (match[2] || ' ') + isoTimes[i][0];
                            break;
                        }
                    }
                    if (timeFormat == null) {
                        config._isValid = false;
                        return;
                    }
                }
                if (!allowTime && timeFormat != null) {
                    config._isValid = false;
                    return;
                }
                if (match[4]) {
                    if (tzRegex.exec(match[4])) {
                        tzFormat = 'Z';
                    } else {
                        config._isValid = false;
                        return;
                    }
                }
                config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
                configFromStringAndFormat(config);
            } else {
                config._isValid = false;
            }
        }

        function extractFromRFC2822Strings(
            yearStr,
            monthStr,
            dayStr,
            hourStr,
            minuteStr,
            secondStr
        ) {
            var result = [
                untruncateYear(yearStr),
                defaultLocaleMonthsShort.indexOf(monthStr),
                parseInt(dayStr, 10),
                parseInt(hourStr, 10),
                parseInt(minuteStr, 10),
            ];

            if (secondStr) {
                result.push(parseInt(secondStr, 10));
            }

            return result;
        }

        function untruncateYear(yearStr) {
            var year = parseInt(yearStr, 10);
            if (year <= 49) {
                return 2000 + year;
            } else if (year <= 999) {
                return 1900 + year;
            }
            return year;
        }

        function preprocessRFC2822(s) {
            // Remove comments and folding whitespace and replace multiple-spaces with a single space
            return s
                .replace(/\([^)]*\)|[\n\t]/g, ' ')
                .replace(/(\s\s+)/g, ' ')
                .replace(/^\s\s*/, '')
                .replace(/\s\s*$/, '');
        }

        function checkWeekday(weekdayStr, parsedInput, config) {
            if (weekdayStr) {
                // TODO: Replace the vanilla JS Date object with an independent day-of-week check.
                var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                    weekdayActual = new Date(
                        parsedInput[0],
                        parsedInput[1],
                        parsedInput[2]
                    ).getDay();
                if (weekdayProvided !== weekdayActual) {
                    getParsingFlags(config).weekdayMismatch = true;
                    config._isValid = false;
                    return false;
                }
            }
            return true;
        }

        function calculateOffset(obsOffset, militaryOffset, numOffset) {
            if (obsOffset) {
                return obsOffsets[obsOffset];
            } else if (militaryOffset) {
                // the only allowed military tz is Z
                return 0;
            } else {
                var hm = parseInt(numOffset, 10),
                    m = hm % 100,
                    h = (hm - m) / 100;
                return h * 60 + m;
            }
        }

        // date and time from ref 2822 format
        function configFromRFC2822(config) {
            var match = rfc2822.exec(preprocessRFC2822(config._i)),
                parsedArray;
            if (match) {
                parsedArray = extractFromRFC2822Strings(
                    match[4],
                    match[3],
                    match[2],
                    match[5],
                    match[6],
                    match[7]
                );
                if (!checkWeekday(match[1], parsedArray, config)) {
                    return;
                }

                config._a = parsedArray;
                config._tzm = calculateOffset(match[8], match[9], match[10]);

                config._d = createUTCDate.apply(null, config._a);
                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

                getParsingFlags(config).rfc2822 = true;
            } else {
                config._isValid = false;
            }
        }

        // date from 1) ASP.NET, 2) ISO, 3) RFC 2822 formats, or 4) optional fallback if parsing isn't strict
        function configFromString(config) {
            var matched = aspNetJsonRegex.exec(config._i);
            if (matched !== null) {
                config._d = new Date(+matched[1]);
                return;
            }

            configFromISO(config);
            if (config._isValid === false) {
                delete config._isValid;
            } else {
                return;
            }

            configFromRFC2822(config);
            if (config._isValid === false) {
                delete config._isValid;
            } else {
                return;
            }

            if (config._strict) {
                config._isValid = false;
            } else {
                // Final attempt, use Input Fallback
                hooks.createFromInputFallback(config);
            }
        }

        hooks.createFromInputFallback = deprecate(
            'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
                'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
                'discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.',
            function (config) {
                config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
            }
        );

        // Pick the first defined of two or three arguments.
        function defaults(a, b, c) {
            if (a != null) {
                return a;
            }
            if (b != null) {
                return b;
            }
            return c;
        }

        function currentDateArray(config) {
            // hooks is actually the exported moment object
            var nowValue = new Date(hooks.now());
            if (config._useUTC) {
                return [
                    nowValue.getUTCFullYear(),
                    nowValue.getUTCMonth(),
                    nowValue.getUTCDate(),
                ];
            }
            return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
        }

        // convert an array to a date.
        // the array should mirror the parameters below
        // note: all values past the year are optional and will default to the lowest possible value.
        // [year, month, day , hour, minute, second, millisecond]
        function configFromArray(config) {
            var i,
                date,
                input = [],
                currentDate,
                expectedWeekday,
                yearToUse;

            if (config._d) {
                return;
            }

            currentDate = currentDateArray(config);

            //compute day of the year from weeks and weekdays
            if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
                dayOfYearFromWeekInfo(config);
            }

            //if the day of the year is set, figure out what it is
            if (config._dayOfYear != null) {
                yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

                if (
                    config._dayOfYear > daysInYear(yearToUse) ||
                    config._dayOfYear === 0
                ) {
                    getParsingFlags(config)._overflowDayOfYear = true;
                }

                date = createUTCDate(yearToUse, 0, config._dayOfYear);
                config._a[MONTH] = date.getUTCMonth();
                config._a[DATE] = date.getUTCDate();
            }

            // Default to current date.
            // * if no year, month, day of month are given, default to today
            // * if day of month is given, default month and year
            // * if month is given, default only year
            // * if year is given, don't default anything
            for (i = 0; i < 3 && config._a[i] == null; ++i) {
                config._a[i] = input[i] = currentDate[i];
            }

            // Zero out whatever was not defaulted, including time
            for (; i < 7; i++) {
                config._a[i] = input[i] =
                    config._a[i] == null ? (i === 2 ? 1 : 0) : config._a[i];
            }

            // Check for 24:00:00.000
            if (
                config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0
            ) {
                config._nextDay = true;
                config._a[HOUR] = 0;
            }

            config._d = (config._useUTC ? createUTCDate : createDate).apply(
                null,
                input
            );
            expectedWeekday = config._useUTC
                ? config._d.getUTCDay()
                : config._d.getDay();

            // Apply timezone offset from input. The actual utcOffset can be changed
            // with parseZone.
            if (config._tzm != null) {
                config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
            }

            if (config._nextDay) {
                config._a[HOUR] = 24;
            }

            // check for mismatching day of week
            if (
                config._w &&
                typeof config._w.d !== 'undefined' &&
                config._w.d !== expectedWeekday
            ) {
                getParsingFlags(config).weekdayMismatch = true;
            }
        }

        function dayOfYearFromWeekInfo(config) {
            var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;

            w = config._w;
            if (w.GG != null || w.W != null || w.E != null) {
                dow = 1;
                doy = 4;

                // TODO: We need to take the current isoWeekYear, but that depends on
                // how we interpret now (local, utc, fixed offset). So create
                // a now version of current config (take local/utc/offset flags, and
                // create now).
                weekYear = defaults(
                    w.GG,
                    config._a[YEAR],
                    weekOfYear(createLocal(), 1, 4).year
                );
                week = defaults(w.W, 1);
                weekday = defaults(w.E, 1);
                if (weekday < 1 || weekday > 7) {
                    weekdayOverflow = true;
                }
            } else {
                dow = config._locale._week.dow;
                doy = config._locale._week.doy;

                curWeek = weekOfYear(createLocal(), dow, doy);

                weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

                // Default to current week.
                week = defaults(w.w, curWeek.week);

                if (w.d != null) {
                    // weekday -- low day numbers are considered next week
                    weekday = w.d;
                    if (weekday < 0 || weekday > 6) {
                        weekdayOverflow = true;
                    }
                } else if (w.e != null) {
                    // local weekday -- counting starts from beginning of week
                    weekday = w.e + dow;
                    if (w.e < 0 || w.e > 6) {
                        weekdayOverflow = true;
                    }
                } else {
                    // default to beginning of week
                    weekday = dow;
                }
            }
            if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
                getParsingFlags(config)._overflowWeeks = true;
            } else if (weekdayOverflow != null) {
                getParsingFlags(config)._overflowWeekday = true;
            } else {
                temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
                config._a[YEAR] = temp.year;
                config._dayOfYear = temp.dayOfYear;
            }
        }

        // constant that refers to the ISO standard
        hooks.ISO_8601 = function () {};

        // constant that refers to the RFC 2822 form
        hooks.RFC_2822 = function () {};

        // date from string and format string
        function configFromStringAndFormat(config) {
            // TODO: Move this to another part of the creation flow to prevent circular deps
            if (config._f === hooks.ISO_8601) {
                configFromISO(config);
                return;
            }
            if (config._f === hooks.RFC_2822) {
                configFromRFC2822(config);
                return;
            }
            config._a = [];
            getParsingFlags(config).empty = true;

            // This array is used to make a Date, either with `new Date` or `Date.UTC`
            var string = '' + config._i,
                i,
                parsedInput,
                tokens,
                token,
                skipped,
                stringLength = string.length,
                totalParsedInputLength = 0,
                era;

            tokens =
                expandFormat(config._f, config._locale).match(formattingTokens) || [];

            for (i = 0; i < tokens.length; i++) {
                token = tokens[i];
                parsedInput = (string.match(getParseRegexForToken(token, config)) ||
                    [])[0];
                if (parsedInput) {
                    skipped = string.substr(0, string.indexOf(parsedInput));
                    if (skipped.length > 0) {
                        getParsingFlags(config).unusedInput.push(skipped);
                    }
                    string = string.slice(
                        string.indexOf(parsedInput) + parsedInput.length
                    );
                    totalParsedInputLength += parsedInput.length;
                }
                // don't parse if it's not a known token
                if (formatTokenFunctions[token]) {
                    if (parsedInput) {
                        getParsingFlags(config).empty = false;
                    } else {
                        getParsingFlags(config).unusedTokens.push(token);
                    }
                    addTimeToArrayFromToken(token, parsedInput, config);
                } else if (config._strict && !parsedInput) {
                    getParsingFlags(config).unusedTokens.push(token);
                }
            }

            // add remaining unparsed input length to the string
            getParsingFlags(config).charsLeftOver =
                stringLength - totalParsedInputLength;
            if (string.length > 0) {
                getParsingFlags(config).unusedInput.push(string);
            }

            // clear _12h flag if hour is <= 12
            if (
                config._a[HOUR] <= 12 &&
                getParsingFlags(config).bigHour === true &&
                config._a[HOUR] > 0
            ) {
                getParsingFlags(config).bigHour = undefined;
            }

            getParsingFlags(config).parsedDateParts = config._a.slice(0);
            getParsingFlags(config).meridiem = config._meridiem;
            // handle meridiem
            config._a[HOUR] = meridiemFixWrap(
                config._locale,
                config._a[HOUR],
                config._meridiem
            );

            // handle era
            era = getParsingFlags(config).era;
            if (era !== null) {
                config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR]);
            }

            configFromArray(config);
            checkOverflow(config);
        }

        function meridiemFixWrap(locale, hour, meridiem) {
            var isPm;

            if (meridiem == null) {
                // nothing to do
                return hour;
            }
            if (locale.meridiemHour != null) {
                return locale.meridiemHour(hour, meridiem);
            } else if (locale.isPM != null) {
                // Fallback
                isPm = locale.isPM(meridiem);
                if (isPm && hour < 12) {
                    hour += 12;
                }
                if (!isPm && hour === 12) {
                    hour = 0;
                }
                return hour;
            } else {
                // this is not supposed to happen
                return hour;
            }
        }

        // date from string and array of format strings
        function configFromStringAndArray(config) {
            var tempConfig,
                bestMoment,
                scoreToBeat,
                i,
                currentScore,
                validFormatFound,
                bestFormatIsValid = false;

            if (config._f.length === 0) {
                getParsingFlags(config).invalidFormat = true;
                config._d = new Date(NaN);
                return;
            }

            for (i = 0; i < config._f.length; i++) {
                currentScore = 0;
                validFormatFound = false;
                tempConfig = copyConfig({}, config);
                if (config._useUTC != null) {
                    tempConfig._useUTC = config._useUTC;
                }
                tempConfig._f = config._f[i];
                configFromStringAndFormat(tempConfig);

                if (isValid(tempConfig)) {
                    validFormatFound = true;
                }

                // if there is any input that was not parsed add a penalty for that format
                currentScore += getParsingFlags(tempConfig).charsLeftOver;

                //or tokens
                currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

                getParsingFlags(tempConfig).score = currentScore;

                if (!bestFormatIsValid) {
                    if (
                        scoreToBeat == null ||
                        currentScore < scoreToBeat ||
                        validFormatFound
                    ) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                        if (validFormatFound) {
                            bestFormatIsValid = true;
                        }
                    }
                } else {
                    if (currentScore < scoreToBeat) {
                        scoreToBeat = currentScore;
                        bestMoment = tempConfig;
                    }
                }
            }

            extend(config, bestMoment || tempConfig);
        }

        function configFromObject(config) {
            if (config._d) {
                return;
            }

            var i = normalizeObjectUnits(config._i),
                dayOrDate = i.day === undefined ? i.date : i.day;
            config._a = map(
                [i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond],
                function (obj) {
                    return obj && parseInt(obj, 10);
                }
            );

            configFromArray(config);
        }

        function createFromConfig(config) {
            var res = new Moment(checkOverflow(prepareConfig(config)));
            if (res._nextDay) {
                // Adding is smart enough around DST
                res.add(1, 'd');
                res._nextDay = undefined;
            }

            return res;
        }

        function prepareConfig(config) {
            var input = config._i,
                format = config._f;

            config._locale = config._locale || getLocale(config._l);

            if (input === null || (format === undefined && input === '')) {
                return createInvalid({ nullInput: true });
            }

            if (typeof input === 'string') {
                config._i = input = config._locale.preparse(input);
            }

            if (isMoment(input)) {
                return new Moment(checkOverflow(input));
            } else if (isDate(input)) {
                config._d = input;
            } else if (isArray(format)) {
                configFromStringAndArray(config);
            } else if (format) {
                configFromStringAndFormat(config);
            } else {
                configFromInput(config);
            }

            if (!isValid(config)) {
                config._d = null;
            }

            return config;
        }

        function configFromInput(config) {
            var input = config._i;
            if (isUndefined(input)) {
                config._d = new Date(hooks.now());
            } else if (isDate(input)) {
                config._d = new Date(input.valueOf());
            } else if (typeof input === 'string') {
                configFromString(config);
            } else if (isArray(input)) {
                config._a = map(input.slice(0), function (obj) {
                    return parseInt(obj, 10);
                });
                configFromArray(config);
            } else if (isObject(input)) {
                configFromObject(config);
            } else if (isNumber(input)) {
                // from milliseconds
                config._d = new Date(input);
            } else {
                hooks.createFromInputFallback(config);
            }
        }

        function createLocalOrUTC(input, format, locale, strict, isUTC) {
            var c = {};

            if (format === true || format === false) {
                strict = format;
                format = undefined;
            }

            if (locale === true || locale === false) {
                strict = locale;
                locale = undefined;
            }

            if (
                (isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)
            ) {
                input = undefined;
            }
            // object construction must be done this way.
            // https://github.com/moment/moment/issues/1423
            c._isAMomentObject = true;
            c._useUTC = c._isUTC = isUTC;
            c._l = locale;
            c._i = input;
            c._f = format;
            c._strict = strict;

            return createFromConfig(c);
        }

        function createLocal(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, false);
        }

        var prototypeMin = deprecate(
                'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
                function () {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                        return other < this ? this : other;
                    } else {
                        return createInvalid();
                    }
                }
            ),
            prototypeMax = deprecate(
                'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
                function () {
                    var other = createLocal.apply(null, arguments);
                    if (this.isValid() && other.isValid()) {
                        return other > this ? this : other;
                    } else {
                        return createInvalid();
                    }
                }
            );

        // Pick a moment m from moments so that m[fn](other) is true for all
        // other. This relies on the function fn to be transitive.
        //
        // moments should either be an array of moment objects or an array, whose
        // first element is an array of moment objects.
        function pickBy(fn, moments) {
            var res, i;
            if (moments.length === 1 && isArray(moments[0])) {
                moments = moments[0];
            }
            if (!moments.length) {
                return createLocal();
            }
            res = moments[0];
            for (i = 1; i < moments.length; ++i) {
                if (!moments[i].isValid() || moments[i][fn](res)) {
                    res = moments[i];
                }
            }
            return res;
        }

        // TODO: Use [].sort instead?
        function min() {
            var args = [].slice.call(arguments, 0);

            return pickBy('isBefore', args);
        }

        function max() {
            var args = [].slice.call(arguments, 0);

            return pickBy('isAfter', args);
        }

        var now = function () {
            return Date.now ? Date.now() : +new Date();
        };

        var ordering = [
            'year',
            'quarter',
            'month',
            'week',
            'day',
            'hour',
            'minute',
            'second',
            'millisecond',
        ];

        function isDurationValid(m) {
            var key,
                unitHasDecimal = false,
                i;
            for (key in m) {
                if (
                    hasOwnProp(m, key) &&
                    !(
                        indexOf.call(ordering, key) !== -1 &&
                        (m[key] == null || !isNaN(m[key]))
                    )
                ) {
                    return false;
                }
            }

            for (i = 0; i < ordering.length; ++i) {
                if (m[ordering[i]]) {
                    if (unitHasDecimal) {
                        return false; // only allow non-integers for smallest unit
                    }
                    if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                        unitHasDecimal = true;
                    }
                }
            }

            return true;
        }

        function isValid$1() {
            return this._isValid;
        }

        function createInvalid$1() {
            return createDuration(NaN);
        }

        function Duration(duration) {
            var normalizedInput = normalizeObjectUnits(duration),
                years = normalizedInput.year || 0,
                quarters = normalizedInput.quarter || 0,
                months = normalizedInput.month || 0,
                weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
                days = normalizedInput.day || 0,
                hours = normalizedInput.hour || 0,
                minutes = normalizedInput.minute || 0,
                seconds = normalizedInput.second || 0,
                milliseconds = normalizedInput.millisecond || 0;

            this._isValid = isDurationValid(normalizedInput);

            // representation for dateAddRemove
            this._milliseconds =
                +milliseconds +
                seconds * 1e3 + // 1000
                minutes * 6e4 + // 1000 * 60
                hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
            // Because of dateAddRemove treats 24 hours as different from a
            // day when working around DST, we need to store them separately
            this._days = +days + weeks * 7;
            // It is impossible to translate months into days without knowing
            // which months you are are talking about, so we have to store
            // it separately.
            this._months = +months + quarters * 3 + years * 12;

            this._data = {};

            this._locale = getLocale();

            this._bubble();
        }

        function isDuration(obj) {
            return obj instanceof Duration;
        }

        function absRound(number) {
            if (number < 0) {
                return Math.round(-1 * number) * -1;
            } else {
                return Math.round(number);
            }
        }

        // compare two arrays, return the number of differences
        function compareArrays(array1, array2, dontConvert) {
            var len = Math.min(array1.length, array2.length),
                lengthDiff = Math.abs(array1.length - array2.length),
                diffs = 0,
                i;
            for (i = 0; i < len; i++) {
                if (
                    (dontConvert && array1[i] !== array2[i]) ||
                    (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))
                ) {
                    diffs++;
                }
            }
            return diffs + lengthDiff;
        }

        // FORMATTING

        function offset(token, separator) {
            addFormatToken(token, 0, 0, function () {
                var offset = this.utcOffset(),
                    sign = '+';
                if (offset < 0) {
                    offset = -offset;
                    sign = '-';
                }
                return (
                    sign +
                    zeroFill(~~(offset / 60), 2) +
                    separator +
                    zeroFill(~~offset % 60, 2)
                );
            });
        }

        offset('Z', ':');
        offset('ZZ', '');

        // PARSING

        addRegexToken('Z', matchShortOffset);
        addRegexToken('ZZ', matchShortOffset);
        addParseToken(['Z', 'ZZ'], function (input, array, config) {
            config._useUTC = true;
            config._tzm = offsetFromString(matchShortOffset, input);
        });

        // HELPERS

        // timezone chunker
        // '+10:00' > ['10',  '00']
        // '-1530'  > ['-15', '30']
        var chunkOffset = /([\+\-]|\d\d)/gi;

        function offsetFromString(matcher, string) {
            var matches = (string || '').match(matcher),
                chunk,
                parts,
                minutes;

            if (matches === null) {
                return null;
            }

            chunk = matches[matches.length - 1] || [];
            parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
            minutes = +(parts[1] * 60) + toInt(parts[2]);

            return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
        }

        // Return a moment from input, that is local/utc/zone equivalent to model.
        function cloneWithOffset(input, model) {
            var res, diff;
            if (model._isUTC) {
                res = model.clone();
                diff =
                    (isMoment(input) || isDate(input)
                        ? input.valueOf()
                        : createLocal(input).valueOf()) - res.valueOf();
                // Use low-level api, because this fn is low-level api.
                res._d.setTime(res._d.valueOf() + diff);
                hooks.updateOffset(res, false);
                return res;
            } else {
                return createLocal(input).local();
            }
        }

        function getDateOffset(m) {
            // On Firefox.24 Date#getTimezoneOffset returns a floating point.
            // https://github.com/moment/moment/pull/1871
            return -Math.round(m._d.getTimezoneOffset());
        }

        // HOOKS

        // This function will be called whenever a moment is mutated.
        // It is intended to keep the offset in sync with the timezone.
        hooks.updateOffset = function () {};

        // MOMENTS

        // keepLocalTime = true means only change the timezone, without
        // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
        // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
        // +0200, so we adjust the time as needed, to be valid.
        //
        // Keeping the time actually adds/subtracts (one hour)
        // from the actual represented time. That is why we call updateOffset
        // a second time. In case it wants us to change the offset again
        // _changeInProgress == true case, then we have to adjust, because
        // there is no such time in the given timezone.
        function getSetOffset(input, keepLocalTime, keepMinutes) {
            var offset = this._offset || 0,
                localAdjust;
            if (!this.isValid()) {
                return input != null ? this : NaN;
            }
            if (input != null) {
                if (typeof input === 'string') {
                    input = offsetFromString(matchShortOffset, input);
                    if (input === null) {
                        return this;
                    }
                } else if (Math.abs(input) < 16 && !keepMinutes) {
                    input = input * 60;
                }
                if (!this._isUTC && keepLocalTime) {
                    localAdjust = getDateOffset(this);
                }
                this._offset = input;
                this._isUTC = true;
                if (localAdjust != null) {
                    this.add(localAdjust, 'm');
                }
                if (offset !== input) {
                    if (!keepLocalTime || this._changeInProgress) {
                        addSubtract(
                            this,
                            createDuration(input - offset, 'm'),
                            1,
                            false
                        );
                    } else if (!this._changeInProgress) {
                        this._changeInProgress = true;
                        hooks.updateOffset(this, true);
                        this._changeInProgress = null;
                    }
                }
                return this;
            } else {
                return this._isUTC ? offset : getDateOffset(this);
            }
        }

        function getSetZone(input, keepLocalTime) {
            if (input != null) {
                if (typeof input !== 'string') {
                    input = -input;
                }

                this.utcOffset(input, keepLocalTime);

                return this;
            } else {
                return -this.utcOffset();
            }
        }

        function setOffsetToUTC(keepLocalTime) {
            return this.utcOffset(0, keepLocalTime);
        }

        function setOffsetToLocal(keepLocalTime) {
            if (this._isUTC) {
                this.utcOffset(0, keepLocalTime);
                this._isUTC = false;

                if (keepLocalTime) {
                    this.subtract(getDateOffset(this), 'm');
                }
            }
            return this;
        }

        function setOffsetToParsedOffset() {
            if (this._tzm != null) {
                this.utcOffset(this._tzm, false, true);
            } else if (typeof this._i === 'string') {
                var tZone = offsetFromString(matchOffset, this._i);
                if (tZone != null) {
                    this.utcOffset(tZone);
                } else {
                    this.utcOffset(0, true);
                }
            }
            return this;
        }

        function hasAlignedHourOffset(input) {
            if (!this.isValid()) {
                return false;
            }
            input = input ? createLocal(input).utcOffset() : 0;

            return (this.utcOffset() - input) % 60 === 0;
        }

        function isDaylightSavingTime() {
            return (
                this.utcOffset() > this.clone().month(0).utcOffset() ||
                this.utcOffset() > this.clone().month(5).utcOffset()
            );
        }

        function isDaylightSavingTimeShifted() {
            if (!isUndefined(this._isDSTShifted)) {
                return this._isDSTShifted;
            }

            var c = {},
                other;

            copyConfig(c, this);
            c = prepareConfig(c);

            if (c._a) {
                other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                this._isDSTShifted =
                    this.isValid() && compareArrays(c._a, other.toArray()) > 0;
            } else {
                this._isDSTShifted = false;
            }

            return this._isDSTShifted;
        }

        function isLocal() {
            return this.isValid() ? !this._isUTC : false;
        }

        function isUtcOffset() {
            return this.isValid() ? this._isUTC : false;
        }

        function isUtc() {
            return this.isValid() ? this._isUTC && this._offset === 0 : false;
        }

        // ASP.NET json date format regex
        var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
            // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
            // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
            // and further modified to allow for strings containing both week and day
            isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

        function createDuration(input, key) {
            var duration = input,
                // matching against regexp is expensive, do it on demand
                match = null,
                sign,
                ret,
                diffRes;

            if (isDuration(input)) {
                duration = {
                    ms: input._milliseconds,
                    d: input._days,
                    M: input._months,
                };
            } else if (isNumber(input) || !isNaN(+input)) {
                duration = {};
                if (key) {
                    duration[key] = +input;
                } else {
                    duration.milliseconds = +input;
                }
            } else if ((match = aspNetRegex.exec(input))) {
                sign = match[1] === '-' ? -1 : 1;
                duration = {
                    y: 0,
                    d: toInt(match[DATE]) * sign,
                    h: toInt(match[HOUR]) * sign,
                    m: toInt(match[MINUTE]) * sign,
                    s: toInt(match[SECOND]) * sign,
                    ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign, // the millisecond decimal point is included in the match
                };
            } else if ((match = isoRegex.exec(input))) {
                sign = match[1] === '-' ? -1 : 1;
                duration = {
                    y: parseIso(match[2], sign),
                    M: parseIso(match[3], sign),
                    w: parseIso(match[4], sign),
                    d: parseIso(match[5], sign),
                    h: parseIso(match[6], sign),
                    m: parseIso(match[7], sign),
                    s: parseIso(match[8], sign),
                };
            } else if (duration == null) {
                // checks for null or undefined
                duration = {};
            } else if (
                typeof duration === 'object' &&
                ('from' in duration || 'to' in duration)
            ) {
                diffRes = momentsDifference(
                    createLocal(duration.from),
                    createLocal(duration.to)
                );

                duration = {};
                duration.ms = diffRes.milliseconds;
                duration.M = diffRes.months;
            }

            ret = new Duration(duration);

            if (isDuration(input) && hasOwnProp(input, '_locale')) {
                ret._locale = input._locale;
            }

            if (isDuration(input) && hasOwnProp(input, '_isValid')) {
                ret._isValid = input._isValid;
            }

            return ret;
        }

        createDuration.fn = Duration.prototype;
        createDuration.invalid = createInvalid$1;

        function parseIso(inp, sign) {
            // We'd normally use ~~inp for this, but unfortunately it also
            // converts floats to ints.
            // inp may be undefined, so careful calling replace on it.
            var res = inp && parseFloat(inp.replace(',', '.'));
            // apply sign while we're at it
            return (isNaN(res) ? 0 : res) * sign;
        }

        function positiveMomentsDifference(base, other) {
            var res = {};

            res.months =
                other.month() - base.month() + (other.year() - base.year()) * 12;
            if (base.clone().add(res.months, 'M').isAfter(other)) {
                --res.months;
            }

            res.milliseconds = +other - +base.clone().add(res.months, 'M');

            return res;
        }

        function momentsDifference(base, other) {
            var res;
            if (!(base.isValid() && other.isValid())) {
                return { milliseconds: 0, months: 0 };
            }

            other = cloneWithOffset(other, base);
            if (base.isBefore(other)) {
                res = positiveMomentsDifference(base, other);
            } else {
                res = positiveMomentsDifference(other, base);
                res.milliseconds = -res.milliseconds;
                res.months = -res.months;
            }

            return res;
        }

        // TODO: remove 'name' arg after deprecation is removed
        function createAdder(direction, name) {
            return function (val, period) {
                var dur, tmp;
                //invert the arguments, but complain about it
                if (period !== null && !isNaN(+period)) {
                    deprecateSimple(
                        name,
                        'moment().' +
                            name +
                            '(period, number) is deprecated. Please use moment().' +
                            name +
                            '(number, period). ' +
                            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.'
                    );
                    tmp = val;
                    val = period;
                    period = tmp;
                }

                dur = createDuration(val, period);
                addSubtract(this, dur, direction);
                return this;
            };
        }

        function addSubtract(mom, duration, isAdding, updateOffset) {
            var milliseconds = duration._milliseconds,
                days = absRound(duration._days),
                months = absRound(duration._months);

            if (!mom.isValid()) {
                // No op
                return;
            }

            updateOffset = updateOffset == null ? true : updateOffset;

            if (months) {
                setMonth(mom, get(mom, 'Month') + months * isAdding);
            }
            if (days) {
                set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
            }
            if (milliseconds) {
                mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
            }
            if (updateOffset) {
                hooks.updateOffset(mom, days || months);
            }
        }

        var add = createAdder(1, 'add'),
            subtract = createAdder(-1, 'subtract');

        function isString(input) {
            return typeof input === 'string' || input instanceof String;
        }

        // type MomentInput = Moment | Date | string | number | (number | string)[] | MomentInputObject | void; // null | undefined
        function isMomentInput(input) {
            return (
                isMoment(input) ||
                isDate(input) ||
                isString(input) ||
                isNumber(input) ||
                isNumberOrStringArray(input) ||
                isMomentInputObject(input) ||
                input === null ||
                input === undefined
            );
        }

        function isMomentInputObject(input) {
            var objectTest = isObject(input) && !isObjectEmpty(input),
                propertyTest = false,
                properties = [
                    'years',
                    'year',
                    'y',
                    'months',
                    'month',
                    'M',
                    'days',
                    'day',
                    'd',
                    'dates',
                    'date',
                    'D',
                    'hours',
                    'hour',
                    'h',
                    'minutes',
                    'minute',
                    'm',
                    'seconds',
                    'second',
                    's',
                    'milliseconds',
                    'millisecond',
                    'ms',
                ],
                i,
                property;

            for (i = 0; i < properties.length; i += 1) {
                property = properties[i];
                propertyTest = propertyTest || hasOwnProp(input, property);
            }

            return objectTest && propertyTest;
        }

        function isNumberOrStringArray(input) {
            var arrayTest = isArray(input),
                dataTypeTest = false;
            if (arrayTest) {
                dataTypeTest =
                    input.filter(function (item) {
                        return !isNumber(item) && isString(input);
                    }).length === 0;
            }
            return arrayTest && dataTypeTest;
        }

        function isCalendarSpec(input) {
            var objectTest = isObject(input) && !isObjectEmpty(input),
                propertyTest = false,
                properties = [
                    'sameDay',
                    'nextDay',
                    'lastDay',
                    'nextWeek',
                    'lastWeek',
                    'sameElse',
                ],
                i,
                property;

            for (i = 0; i < properties.length; i += 1) {
                property = properties[i];
                propertyTest = propertyTest || hasOwnProp(input, property);
            }

            return objectTest && propertyTest;
        }

        function getCalendarFormat(myMoment, now) {
            var diff = myMoment.diff(now, 'days', true);
            return diff < -6
                ? 'sameElse'
                : diff < -1
                ? 'lastWeek'
                : diff < 0
                ? 'lastDay'
                : diff < 1
                ? 'sameDay'
                : diff < 2
                ? 'nextDay'
                : diff < 7
                ? 'nextWeek'
                : 'sameElse';
        }

        function calendar$1(time, formats) {
            // Support for single parameter, formats only overload to the calendar function
            if (arguments.length === 1) {
                if (!arguments[0]) {
                    time = undefined;
                    formats = undefined;
                } else if (isMomentInput(arguments[0])) {
                    time = arguments[0];
                    formats = undefined;
                } else if (isCalendarSpec(arguments[0])) {
                    formats = arguments[0];
                    time = undefined;
                }
            }
            // We want to compare the start of today, vs this.
            // Getting start-of-today depends on whether we're local/utc/offset or not.
            var now = time || createLocal(),
                sod = cloneWithOffset(now, this).startOf('day'),
                format = hooks.calendarFormat(this, sod) || 'sameElse',
                output =
                    formats &&
                    (isFunction(formats[format])
                        ? formats[format].call(this, now)
                        : formats[format]);

            return this.format(
                output || this.localeData().calendar(format, this, createLocal(now))
            );
        }

        function clone() {
            return new Moment(this);
        }

        function isAfter(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() > localInput.valueOf();
            } else {
                return localInput.valueOf() < this.clone().startOf(units).valueOf();
            }
        }

        function isBefore(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() < localInput.valueOf();
            } else {
                return this.clone().endOf(units).valueOf() < localInput.valueOf();
            }
        }

        function isBetween(from, to, units, inclusivity) {
            var localFrom = isMoment(from) ? from : createLocal(from),
                localTo = isMoment(to) ? to : createLocal(to);
            if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
                return false;
            }
            inclusivity = inclusivity || '()';
            return (
                (inclusivity[0] === '('
                    ? this.isAfter(localFrom, units)
                    : !this.isBefore(localFrom, units)) &&
                (inclusivity[1] === ')'
                    ? this.isBefore(localTo, units)
                    : !this.isAfter(localTo, units))
            );
        }

        function isSame(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input),
                inputMs;
            if (!(this.isValid() && localInput.isValid())) {
                return false;
            }
            units = normalizeUnits(units) || 'millisecond';
            if (units === 'millisecond') {
                return this.valueOf() === localInput.valueOf();
            } else {
                inputMs = localInput.valueOf();
                return (
                    this.clone().startOf(units).valueOf() <= inputMs &&
                    inputMs <= this.clone().endOf(units).valueOf()
                );
            }
        }

        function isSameOrAfter(input, units) {
            return this.isSame(input, units) || this.isAfter(input, units);
        }

        function isSameOrBefore(input, units) {
            return this.isSame(input, units) || this.isBefore(input, units);
        }

        function diff(input, units, asFloat) {
            var that, zoneDelta, output;

            if (!this.isValid()) {
                return NaN;
            }

            that = cloneWithOffset(input, this);

            if (!that.isValid()) {
                return NaN;
            }

            zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

            units = normalizeUnits(units);

            switch (units) {
                case 'year':
                    output = monthDiff(this, that) / 12;
                    break;
                case 'month':
                    output = monthDiff(this, that);
                    break;
                case 'quarter':
                    output = monthDiff(this, that) / 3;
                    break;
                case 'second':
                    output = (this - that) / 1e3;
                    break; // 1000
                case 'minute':
                    output = (this - that) / 6e4;
                    break; // 1000 * 60
                case 'hour':
                    output = (this - that) / 36e5;
                    break; // 1000 * 60 * 60
                case 'day':
                    output = (this - that - zoneDelta) / 864e5;
                    break; // 1000 * 60 * 60 * 24, negate dst
                case 'week':
                    output = (this - that - zoneDelta) / 6048e5;
                    break; // 1000 * 60 * 60 * 24 * 7, negate dst
                default:
                    output = this - that;
            }

            return asFloat ? output : absFloor(output);
        }

        function monthDiff(a, b) {
            if (a.date() < b.date()) {
                // end-of-month calculations work correct when the start month has more
                // days than the end month.
                return -monthDiff(b, a);
            }
            // difference in months
            var wholeMonthDiff = (b.year() - a.year()) * 12 + (b.month() - a.month()),
                // b is in (anchor - 1 month, anchor + 1 month)
                anchor = a.clone().add(wholeMonthDiff, 'months'),
                anchor2,
                adjust;

            if (b - anchor < 0) {
                anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
                // linear across the month
                adjust = (b - anchor) / (anchor - anchor2);
            } else {
                anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
                // linear across the month
                adjust = (b - anchor) / (anchor2 - anchor);
            }

            //check for negative zero, return zero if negative zero
            return -(wholeMonthDiff + adjust) || 0;
        }

        hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
        hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

        function toString() {
            return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
        }

        function toISOString(keepOffset) {
            if (!this.isValid()) {
                return null;
            }
            var utc = keepOffset !== true,
                m = utc ? this.clone().utc() : this;
            if (m.year() < 0 || m.year() > 9999) {
                return formatMoment(
                    m,
                    utc
                        ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]'
                        : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ'
                );
            }
            if (isFunction(Date.prototype.toISOString)) {
                // native implementation is ~50x faster, use it when we can
                if (utc) {
                    return this.toDate().toISOString();
                } else {
                    return new Date(this.valueOf() + this.utcOffset() * 60 * 1000)
                        .toISOString()
                        .replace('Z', formatMoment(m, 'Z'));
                }
            }
            return formatMoment(
                m,
                utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ'
            );
        }

        /**
         * Return a human readable representation of a moment that can
         * also be evaluated to get a new moment which is the same
         *
         * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
         */
        function inspect() {
            if (!this.isValid()) {
                return 'moment.invalid(/* ' + this._i + ' */)';
            }
            var func = 'moment',
                zone = '',
                prefix,
                year,
                datetime,
                suffix;
            if (!this.isLocal()) {
                func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
                zone = 'Z';
            }
            prefix = '[' + func + '("]';
            year = 0 <= this.year() && this.year() <= 9999 ? 'YYYY' : 'YYYYYY';
            datetime = '-MM-DD[T]HH:mm:ss.SSS';
            suffix = zone + '[")]';

            return this.format(prefix + year + datetime + suffix);
        }

        function format(inputString) {
            if (!inputString) {
                inputString = this.isUtc()
                    ? hooks.defaultFormatUtc
                    : hooks.defaultFormat;
            }
            var output = formatMoment(this, inputString);
            return this.localeData().postformat(output);
        }

        function from(time, withoutSuffix) {
            if (
                this.isValid() &&
                ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
            ) {
                return createDuration({ to: this, from: time })
                    .locale(this.locale())
                    .humanize(!withoutSuffix);
            } else {
                return this.localeData().invalidDate();
            }
        }

        function fromNow(withoutSuffix) {
            return this.from(createLocal(), withoutSuffix);
        }

        function to(time, withoutSuffix) {
            if (
                this.isValid() &&
                ((isMoment(time) && time.isValid()) || createLocal(time).isValid())
            ) {
                return createDuration({ from: this, to: time })
                    .locale(this.locale())
                    .humanize(!withoutSuffix);
            } else {
                return this.localeData().invalidDate();
            }
        }

        function toNow(withoutSuffix) {
            return this.to(createLocal(), withoutSuffix);
        }

        // If passed a locale key, it will set the locale for this
        // instance.  Otherwise, it will return the locale configuration
        // variables for this instance.
        function locale(key) {
            var newLocaleData;

            if (key === undefined) {
                return this._locale._abbr;
            } else {
                newLocaleData = getLocale(key);
                if (newLocaleData != null) {
                    this._locale = newLocaleData;
                }
                return this;
            }
        }

        var lang = deprecate(
            'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
            function (key) {
                if (key === undefined) {
                    return this.localeData();
                } else {
                    return this.locale(key);
                }
            }
        );

        function localeData() {
            return this._locale;
        }

        var MS_PER_SECOND = 1000,
            MS_PER_MINUTE = 60 * MS_PER_SECOND,
            MS_PER_HOUR = 60 * MS_PER_MINUTE,
            MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

        // actual modulo - handles negative numbers (for dates before 1970):
        function mod$1(dividend, divisor) {
            return ((dividend % divisor) + divisor) % divisor;
        }

        function localStartOfDate(y, m, d) {
            // the date constructor remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                return new Date(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
                return new Date(y, m, d).valueOf();
            }
        }

        function utcStartOfDate(y, m, d) {
            // Date.UTC remaps years 0-99 to 1900-1999
            if (y < 100 && y >= 0) {
                // preserve leap years using a full 400 year cycle, then reset
                return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
            } else {
                return Date.UTC(y, m, d);
            }
        }

        function startOf(units) {
            var time, startOfDate;
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond' || !this.isValid()) {
                return this;
            }

            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
                case 'year':
                    time = startOfDate(this.year(), 0, 1);
                    break;
                case 'quarter':
                    time = startOfDate(
                        this.year(),
                        this.month() - (this.month() % 3),
                        1
                    );
                    break;
                case 'month':
                    time = startOfDate(this.year(), this.month(), 1);
                    break;
                case 'week':
                    time = startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - this.weekday()
                    );
                    break;
                case 'isoWeek':
                    time = startOfDate(
                        this.year(),
                        this.month(),
                        this.date() - (this.isoWeekday() - 1)
                    );
                    break;
                case 'day':
                case 'date':
                    time = startOfDate(this.year(), this.month(), this.date());
                    break;
                case 'hour':
                    time = this._d.valueOf();
                    time -= mod$1(
                        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                        MS_PER_HOUR
                    );
                    break;
                case 'minute':
                    time = this._d.valueOf();
                    time -= mod$1(time, MS_PER_MINUTE);
                    break;
                case 'second':
                    time = this._d.valueOf();
                    time -= mod$1(time, MS_PER_SECOND);
                    break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
        }

        function endOf(units) {
            var time, startOfDate;
            units = normalizeUnits(units);
            if (units === undefined || units === 'millisecond' || !this.isValid()) {
                return this;
            }

            startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

            switch (units) {
                case 'year':
                    time = startOfDate(this.year() + 1, 0, 1) - 1;
                    break;
                case 'quarter':
                    time =
                        startOfDate(
                            this.year(),
                            this.month() - (this.month() % 3) + 3,
                            1
                        ) - 1;
                    break;
                case 'month':
                    time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                    break;
                case 'week':
                    time =
                        startOfDate(
                            this.year(),
                            this.month(),
                            this.date() - this.weekday() + 7
                        ) - 1;
                    break;
                case 'isoWeek':
                    time =
                        startOfDate(
                            this.year(),
                            this.month(),
                            this.date() - (this.isoWeekday() - 1) + 7
                        ) - 1;
                    break;
                case 'day':
                case 'date':
                    time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                    break;
                case 'hour':
                    time = this._d.valueOf();
                    time +=
                        MS_PER_HOUR -
                        mod$1(
                            time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
                            MS_PER_HOUR
                        ) -
                        1;
                    break;
                case 'minute':
                    time = this._d.valueOf();
                    time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                    break;
                case 'second':
                    time = this._d.valueOf();
                    time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                    break;
            }

            this._d.setTime(time);
            hooks.updateOffset(this, true);
            return this;
        }

        function valueOf() {
            return this._d.valueOf() - (this._offset || 0) * 60000;
        }

        function unix() {
            return Math.floor(this.valueOf() / 1000);
        }

        function toDate() {
            return new Date(this.valueOf());
        }

        function toArray() {
            var m = this;
            return [
                m.year(),
                m.month(),
                m.date(),
                m.hour(),
                m.minute(),
                m.second(),
                m.millisecond(),
            ];
        }

        function toObject() {
            var m = this;
            return {
                years: m.year(),
                months: m.month(),
                date: m.date(),
                hours: m.hours(),
                minutes: m.minutes(),
                seconds: m.seconds(),
                milliseconds: m.milliseconds(),
            };
        }

        function toJSON() {
            // new Date(NaN).toJSON() === null
            return this.isValid() ? this.toISOString() : null;
        }

        function isValid$2() {
            return isValid(this);
        }

        function parsingFlags() {
            return extend({}, getParsingFlags(this));
        }

        function invalidAt() {
            return getParsingFlags(this).overflow;
        }

        function creationData() {
            return {
                input: this._i,
                format: this._f,
                locale: this._locale,
                isUTC: this._isUTC,
                strict: this._strict,
            };
        }

        addFormatToken('N', 0, 0, 'eraAbbr');
        addFormatToken('NN', 0, 0, 'eraAbbr');
        addFormatToken('NNN', 0, 0, 'eraAbbr');
        addFormatToken('NNNN', 0, 0, 'eraName');
        addFormatToken('NNNNN', 0, 0, 'eraNarrow');

        addFormatToken('y', ['y', 1], 'yo', 'eraYear');
        addFormatToken('y', ['yy', 2], 0, 'eraYear');
        addFormatToken('y', ['yyy', 3], 0, 'eraYear');
        addFormatToken('y', ['yyyy', 4], 0, 'eraYear');

        addRegexToken('N', matchEraAbbr);
        addRegexToken('NN', matchEraAbbr);
        addRegexToken('NNN', matchEraAbbr);
        addRegexToken('NNNN', matchEraName);
        addRegexToken('NNNNN', matchEraNarrow);

        addParseToken(['N', 'NN', 'NNN', 'NNNN', 'NNNNN'], function (
            input,
            array,
            config,
            token
        ) {
            var era = config._locale.erasParse(input, token, config._strict);
            if (era) {
                getParsingFlags(config).era = era;
            } else {
                getParsingFlags(config).invalidEra = input;
            }
        });

        addRegexToken('y', matchUnsigned);
        addRegexToken('yy', matchUnsigned);
        addRegexToken('yyy', matchUnsigned);
        addRegexToken('yyyy', matchUnsigned);
        addRegexToken('yo', matchEraYearOrdinal);

        addParseToken(['y', 'yy', 'yyy', 'yyyy'], YEAR);
        addParseToken(['yo'], function (input, array, config, token) {
            var match;
            if (config._locale._eraYearOrdinalRegex) {
                match = input.match(config._locale._eraYearOrdinalRegex);
            }

            if (config._locale.eraYearOrdinalParse) {
                array[YEAR] = config._locale.eraYearOrdinalParse(input, match);
            } else {
                array[YEAR] = parseInt(input, 10);
            }
        });

        function localeEras(m, format) {
            var i,
                l,
                date,
                eras = this._eras || getLocale('en')._eras;
            for (i = 0, l = eras.length; i < l; ++i) {
                switch (typeof eras[i].since) {
                    case 'string':
                        // truncate time
                        date = hooks(eras[i].since).startOf('day');
                        eras[i].since = date.valueOf();
                        break;
                }

                switch (typeof eras[i].until) {
                    case 'undefined':
                        eras[i].until = +Infinity;
                        break;
                    case 'string':
                        // truncate time
                        date = hooks(eras[i].until).startOf('day').valueOf();
                        eras[i].until = date.valueOf();
                        break;
                }
            }
            return eras;
        }

        function localeErasParse(eraName, format, strict) {
            var i,
                l,
                eras = this.eras(),
                name,
                abbr,
                narrow;
            eraName = eraName.toUpperCase();

            for (i = 0, l = eras.length; i < l; ++i) {
                name = eras[i].name.toUpperCase();
                abbr = eras[i].abbr.toUpperCase();
                narrow = eras[i].narrow.toUpperCase();

                if (strict) {
                    switch (format) {
                        case 'N':
                        case 'NN':
                        case 'NNN':
                            if (abbr === eraName) {
                                return eras[i];
                            }
                            break;

                        case 'NNNN':
                            if (name === eraName) {
                                return eras[i];
                            }
                            break;

                        case 'NNNNN':
                            if (narrow === eraName) {
                                return eras[i];
                            }
                            break;
                    }
                } else if ([name, abbr, narrow].indexOf(eraName) >= 0) {
                    return eras[i];
                }
            }
        }

        function localeErasConvertYear(era, year) {
            var dir = era.since <= era.until ? +1 : -1;
            if (year === undefined) {
                return hooks(era.since).year();
            } else {
                return hooks(era.since).year() + (year - era.offset) * dir;
            }
        }

        function getEraName() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].name;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].name;
                }
            }

            return '';
        }

        function getEraNarrow() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].narrow;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].narrow;
                }
            }

            return '';
        }

        function getEraAbbr() {
            var i,
                l,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (eras[i].since <= val && val <= eras[i].until) {
                    return eras[i].abbr;
                }
                if (eras[i].until <= val && val <= eras[i].since) {
                    return eras[i].abbr;
                }
            }

            return '';
        }

        function getEraYear() {
            var i,
                l,
                dir,
                val,
                eras = this.localeData().eras();
            for (i = 0, l = eras.length; i < l; ++i) {
                dir = eras[i].since <= eras[i].until ? +1 : -1;

                // truncate time
                val = this.clone().startOf('day').valueOf();

                if (
                    (eras[i].since <= val && val <= eras[i].until) ||
                    (eras[i].until <= val && val <= eras[i].since)
                ) {
                    return (
                        (this.year() - hooks(eras[i].since).year()) * dir +
                        eras[i].offset
                    );
                }
            }

            return this.year();
        }

        function erasNameRegex(isStrict) {
            if (!hasOwnProp(this, '_erasNameRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasNameRegex : this._erasRegex;
        }

        function erasAbbrRegex(isStrict) {
            if (!hasOwnProp(this, '_erasAbbrRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasAbbrRegex : this._erasRegex;
        }

        function erasNarrowRegex(isStrict) {
            if (!hasOwnProp(this, '_erasNarrowRegex')) {
                computeErasParse.call(this);
            }
            return isStrict ? this._erasNarrowRegex : this._erasRegex;
        }

        function matchEraAbbr(isStrict, locale) {
            return locale.erasAbbrRegex(isStrict);
        }

        function matchEraName(isStrict, locale) {
            return locale.erasNameRegex(isStrict);
        }

        function matchEraNarrow(isStrict, locale) {
            return locale.erasNarrowRegex(isStrict);
        }

        function matchEraYearOrdinal(isStrict, locale) {
            return locale._eraYearOrdinalRegex || matchUnsigned;
        }

        function computeErasParse() {
            var abbrPieces = [],
                namePieces = [],
                narrowPieces = [],
                mixedPieces = [],
                i,
                l,
                eras = this.eras();

            for (i = 0, l = eras.length; i < l; ++i) {
                namePieces.push(regexEscape(eras[i].name));
                abbrPieces.push(regexEscape(eras[i].abbr));
                narrowPieces.push(regexEscape(eras[i].narrow));

                mixedPieces.push(regexEscape(eras[i].name));
                mixedPieces.push(regexEscape(eras[i].abbr));
                mixedPieces.push(regexEscape(eras[i].narrow));
            }

            this._erasRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
            this._erasNameRegex = new RegExp('^(' + namePieces.join('|') + ')', 'i');
            this._erasAbbrRegex = new RegExp('^(' + abbrPieces.join('|') + ')', 'i');
            this._erasNarrowRegex = new RegExp(
                '^(' + narrowPieces.join('|') + ')',
                'i'
            );
        }

        // FORMATTING

        addFormatToken(0, ['gg', 2], 0, function () {
            return this.weekYear() % 100;
        });

        addFormatToken(0, ['GG', 2], 0, function () {
            return this.isoWeekYear() % 100;
        });

        function addWeekYearFormatToken(token, getter) {
            addFormatToken(0, [token, token.length], 0, getter);
        }

        addWeekYearFormatToken('gggg', 'weekYear');
        addWeekYearFormatToken('ggggg', 'weekYear');
        addWeekYearFormatToken('GGGG', 'isoWeekYear');
        addWeekYearFormatToken('GGGGG', 'isoWeekYear');

        // ALIASES

        addUnitAlias('weekYear', 'gg');
        addUnitAlias('isoWeekYear', 'GG');

        // PRIORITY

        addUnitPriority('weekYear', 1);
        addUnitPriority('isoWeekYear', 1);

        // PARSING

        addRegexToken('G', matchSigned);
        addRegexToken('g', matchSigned);
        addRegexToken('GG', match1to2, match2);
        addRegexToken('gg', match1to2, match2);
        addRegexToken('GGGG', match1to4, match4);
        addRegexToken('gggg', match1to4, match4);
        addRegexToken('GGGGG', match1to6, match6);
        addRegexToken('ggggg', match1to6, match6);

        addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (
            input,
            week,
            config,
            token
        ) {
            week[token.substr(0, 2)] = toInt(input);
        });

        addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
            week[token] = hooks.parseTwoDigitYear(input);
        });

        // MOMENTS

        function getSetWeekYear(input) {
            return getSetWeekYearHelper.call(
                this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy
            );
        }

        function getSetISOWeekYear(input) {
            return getSetWeekYearHelper.call(
                this,
                input,
                this.isoWeek(),
                this.isoWeekday(),
                1,
                4
            );
        }

        function getISOWeeksInYear() {
            return weeksInYear(this.year(), 1, 4);
        }

        function getISOWeeksInISOWeekYear() {
            return weeksInYear(this.isoWeekYear(), 1, 4);
        }

        function getWeeksInYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
        }

        function getWeeksInWeekYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
        }

        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
            var weeksTarget;
            if (input == null) {
                return weekOfYear(this, dow, doy).year;
            } else {
                weeksTarget = weeksInYear(input, dow, doy);
                if (week > weeksTarget) {
                    week = weeksTarget;
                }
                return setWeekAll.call(this, input, week, weekday, dow, doy);
            }
        }

        function setWeekAll(weekYear, week, weekday, dow, doy) {
            var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

            this.year(date.getUTCFullYear());
            this.month(date.getUTCMonth());
            this.date(date.getUTCDate());
            return this;
        }

        // FORMATTING

        addFormatToken('Q', 0, 'Qo', 'quarter');

        // ALIASES

        addUnitAlias('quarter', 'Q');

        // PRIORITY

        addUnitPriority('quarter', 7);

        // PARSING

        addRegexToken('Q', match1);
        addParseToken('Q', function (input, array) {
            array[MONTH] = (toInt(input) - 1) * 3;
        });

        // MOMENTS

        function getSetQuarter(input) {
            return input == null
                ? Math.ceil((this.month() + 1) / 3)
                : this.month((input - 1) * 3 + (this.month() % 3));
        }

        // FORMATTING

        addFormatToken('D', ['DD', 2], 'Do', 'date');

        // ALIASES

        addUnitAlias('date', 'D');

        // PRIORITY
        addUnitPriority('date', 9);

        // PARSING

        addRegexToken('D', match1to2);
        addRegexToken('DD', match1to2, match2);
        addRegexToken('Do', function (isStrict, locale) {
            // TODO: Remove "ordinalParse" fallback in next major release.
            return isStrict
                ? locale._dayOfMonthOrdinalParse || locale._ordinalParse
                : locale._dayOfMonthOrdinalParseLenient;
        });

        addParseToken(['D', 'DD'], DATE);
        addParseToken('Do', function (input, array) {
            array[DATE] = toInt(input.match(match1to2)[0]);
        });

        // MOMENTS

        var getSetDayOfMonth = makeGetSet('Date', true);

        // FORMATTING

        addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

        // ALIASES

        addUnitAlias('dayOfYear', 'DDD');

        // PRIORITY
        addUnitPriority('dayOfYear', 4);

        // PARSING

        addRegexToken('DDD', match1to3);
        addRegexToken('DDDD', match3);
        addParseToken(['DDD', 'DDDD'], function (input, array, config) {
            config._dayOfYear = toInt(input);
        });

        // HELPERS

        // MOMENTS

        function getSetDayOfYear(input) {
            var dayOfYear =
                Math.round(
                    (this.clone().startOf('day') - this.clone().startOf('year')) / 864e5
                ) + 1;
            return input == null ? dayOfYear : this.add(input - dayOfYear, 'd');
        }

        // FORMATTING

        addFormatToken('m', ['mm', 2], 0, 'minute');

        // ALIASES

        addUnitAlias('minute', 'm');

        // PRIORITY

        addUnitPriority('minute', 14);

        // PARSING

        addRegexToken('m', match1to2);
        addRegexToken('mm', match1to2, match2);
        addParseToken(['m', 'mm'], MINUTE);

        // MOMENTS

        var getSetMinute = makeGetSet('Minutes', false);

        // FORMATTING

        addFormatToken('s', ['ss', 2], 0, 'second');

        // ALIASES

        addUnitAlias('second', 's');

        // PRIORITY

        addUnitPriority('second', 15);

        // PARSING

        addRegexToken('s', match1to2);
        addRegexToken('ss', match1to2, match2);
        addParseToken(['s', 'ss'], SECOND);

        // MOMENTS

        var getSetSecond = makeGetSet('Seconds', false);

        // FORMATTING

        addFormatToken('S', 0, 0, function () {
            return ~~(this.millisecond() / 100);
        });

        addFormatToken(0, ['SS', 2], 0, function () {
            return ~~(this.millisecond() / 10);
        });

        addFormatToken(0, ['SSS', 3], 0, 'millisecond');
        addFormatToken(0, ['SSSS', 4], 0, function () {
            return this.millisecond() * 10;
        });
        addFormatToken(0, ['SSSSS', 5], 0, function () {
            return this.millisecond() * 100;
        });
        addFormatToken(0, ['SSSSSS', 6], 0, function () {
            return this.millisecond() * 1000;
        });
        addFormatToken(0, ['SSSSSSS', 7], 0, function () {
            return this.millisecond() * 10000;
        });
        addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
            return this.millisecond() * 100000;
        });
        addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
            return this.millisecond() * 1000000;
        });

        // ALIASES

        addUnitAlias('millisecond', 'ms');

        // PRIORITY

        addUnitPriority('millisecond', 16);

        // PARSING

        addRegexToken('S', match1to3, match1);
        addRegexToken('SS', match1to3, match2);
        addRegexToken('SSS', match1to3, match3);

        var token, getSetMillisecond;
        for (token = 'SSSS'; token.length <= 9; token += 'S') {
            addRegexToken(token, matchUnsigned);
        }

        function parseMs(input, array) {
            array[MILLISECOND] = toInt(('0.' + input) * 1000);
        }

        for (token = 'S'; token.length <= 9; token += 'S') {
            addParseToken(token, parseMs);
        }

        getSetMillisecond = makeGetSet('Milliseconds', false);

        // FORMATTING

        addFormatToken('z', 0, 0, 'zoneAbbr');
        addFormatToken('zz', 0, 0, 'zoneName');

        // MOMENTS

        function getZoneAbbr() {
            return this._isUTC ? 'UTC' : '';
        }

        function getZoneName() {
            return this._isUTC ? 'Coordinated Universal Time' : '';
        }

        var proto = Moment.prototype;

        proto.add = add;
        proto.calendar = calendar$1;
        proto.clone = clone;
        proto.diff = diff;
        proto.endOf = endOf;
        proto.format = format;
        proto.from = from;
        proto.fromNow = fromNow;
        proto.to = to;
        proto.toNow = toNow;
        proto.get = stringGet;
        proto.invalidAt = invalidAt;
        proto.isAfter = isAfter;
        proto.isBefore = isBefore;
        proto.isBetween = isBetween;
        proto.isSame = isSame;
        proto.isSameOrAfter = isSameOrAfter;
        proto.isSameOrBefore = isSameOrBefore;
        proto.isValid = isValid$2;
        proto.lang = lang;
        proto.locale = locale;
        proto.localeData = localeData;
        proto.max = prototypeMax;
        proto.min = prototypeMin;
        proto.parsingFlags = parsingFlags;
        proto.set = stringSet;
        proto.startOf = startOf;
        proto.subtract = subtract;
        proto.toArray = toArray;
        proto.toObject = toObject;
        proto.toDate = toDate;
        proto.toISOString = toISOString;
        proto.inspect = inspect;
        if (typeof Symbol !== 'undefined' && Symbol.for != null) {
            proto[Symbol.for('nodejs.util.inspect.custom')] = function () {
                return 'Moment<' + this.format() + '>';
            };
        }
        proto.toJSON = toJSON;
        proto.toString = toString;
        proto.unix = unix;
        proto.valueOf = valueOf;
        proto.creationData = creationData;
        proto.eraName = getEraName;
        proto.eraNarrow = getEraNarrow;
        proto.eraAbbr = getEraAbbr;
        proto.eraYear = getEraYear;
        proto.year = getSetYear;
        proto.isLeapYear = getIsLeapYear;
        proto.weekYear = getSetWeekYear;
        proto.isoWeekYear = getSetISOWeekYear;
        proto.quarter = proto.quarters = getSetQuarter;
        proto.month = getSetMonth;
        proto.daysInMonth = getDaysInMonth;
        proto.week = proto.weeks = getSetWeek;
        proto.isoWeek = proto.isoWeeks = getSetISOWeek;
        proto.weeksInYear = getWeeksInYear;
        proto.weeksInWeekYear = getWeeksInWeekYear;
        proto.isoWeeksInYear = getISOWeeksInYear;
        proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
        proto.date = getSetDayOfMonth;
        proto.day = proto.days = getSetDayOfWeek;
        proto.weekday = getSetLocaleDayOfWeek;
        proto.isoWeekday = getSetISODayOfWeek;
        proto.dayOfYear = getSetDayOfYear;
        proto.hour = proto.hours = getSetHour;
        proto.minute = proto.minutes = getSetMinute;
        proto.second = proto.seconds = getSetSecond;
        proto.millisecond = proto.milliseconds = getSetMillisecond;
        proto.utcOffset = getSetOffset;
        proto.utc = setOffsetToUTC;
        proto.local = setOffsetToLocal;
        proto.parseZone = setOffsetToParsedOffset;
        proto.hasAlignedHourOffset = hasAlignedHourOffset;
        proto.isDST = isDaylightSavingTime;
        proto.isLocal = isLocal;
        proto.isUtcOffset = isUtcOffset;
        proto.isUtc = isUtc;
        proto.isUTC = isUtc;
        proto.zoneAbbr = getZoneAbbr;
        proto.zoneName = getZoneName;
        proto.dates = deprecate(
            'dates accessor is deprecated. Use date instead.',
            getSetDayOfMonth
        );
        proto.months = deprecate(
            'months accessor is deprecated. Use month instead',
            getSetMonth
        );
        proto.years = deprecate(
            'years accessor is deprecated. Use year instead',
            getSetYear
        );
        proto.zone = deprecate(
            'moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/',
            getSetZone
        );
        proto.isDSTShifted = deprecate(
            'isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information',
            isDaylightSavingTimeShifted
        );

        function createUnix(input) {
            return createLocal(input * 1000);
        }

        function createInZone() {
            return createLocal.apply(null, arguments).parseZone();
        }

        function preParsePostFormat(string) {
            return string;
        }

        var proto$1 = Locale.prototype;

        proto$1.calendar = calendar;
        proto$1.longDateFormat = longDateFormat;
        proto$1.invalidDate = invalidDate;
        proto$1.ordinal = ordinal;
        proto$1.preparse = preParsePostFormat;
        proto$1.postformat = preParsePostFormat;
        proto$1.relativeTime = relativeTime;
        proto$1.pastFuture = pastFuture;
        proto$1.set = set;
        proto$1.eras = localeEras;
        proto$1.erasParse = localeErasParse;
        proto$1.erasConvertYear = localeErasConvertYear;
        proto$1.erasAbbrRegex = erasAbbrRegex;
        proto$1.erasNameRegex = erasNameRegex;
        proto$1.erasNarrowRegex = erasNarrowRegex;

        proto$1.months = localeMonths;
        proto$1.monthsShort = localeMonthsShort;
        proto$1.monthsParse = localeMonthsParse;
        proto$1.monthsRegex = monthsRegex;
        proto$1.monthsShortRegex = monthsShortRegex;
        proto$1.week = localeWeek;
        proto$1.firstDayOfYear = localeFirstDayOfYear;
        proto$1.firstDayOfWeek = localeFirstDayOfWeek;

        proto$1.weekdays = localeWeekdays;
        proto$1.weekdaysMin = localeWeekdaysMin;
        proto$1.weekdaysShort = localeWeekdaysShort;
        proto$1.weekdaysParse = localeWeekdaysParse;

        proto$1.weekdaysRegex = weekdaysRegex;
        proto$1.weekdaysShortRegex = weekdaysShortRegex;
        proto$1.weekdaysMinRegex = weekdaysMinRegex;

        proto$1.isPM = localeIsPM;
        proto$1.meridiem = localeMeridiem;

        function get$1(format, index, field, setter) {
            var locale = getLocale(),
                utc = createUTC().set(setter, index);
            return locale[field](utc, format);
        }

        function listMonthsImpl(format, index, field) {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';

            if (index != null) {
                return get$1(format, index, field, 'month');
            }

            var i,
                out = [];
            for (i = 0; i < 12; i++) {
                out[i] = get$1(format, i, field, 'month');
            }
            return out;
        }

        // ()
        // (5)
        // (fmt, 5)
        // (fmt)
        // (true)
        // (true, 5)
        // (true, fmt, 5)
        // (true, fmt)
        function listWeekdaysImpl(localeSorted, format, index, field) {
            if (typeof localeSorted === 'boolean') {
                if (isNumber(format)) {
                    index = format;
                    format = undefined;
                }

                format = format || '';
            } else {
                format = localeSorted;
                index = format;
                localeSorted = false;

                if (isNumber(format)) {
                    index = format;
                    format = undefined;
                }

                format = format || '';
            }

            var locale = getLocale(),
                shift = localeSorted ? locale._week.dow : 0,
                i,
                out = [];

            if (index != null) {
                return get$1(format, (index + shift) % 7, field, 'day');
            }

            for (i = 0; i < 7; i++) {
                out[i] = get$1(format, (i + shift) % 7, field, 'day');
            }
            return out;
        }

        function listMonths(format, index) {
            return listMonthsImpl(format, index, 'months');
        }

        function listMonthsShort(format, index) {
            return listMonthsImpl(format, index, 'monthsShort');
        }

        function listWeekdays(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
        }

        function listWeekdaysShort(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
        }

        function listWeekdaysMin(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
        }

        getSetGlobalLocale('en', {
            eras: [
                {
                    since: '0001-01-01',
                    until: +Infinity,
                    offset: 1,
                    name: 'Anno Domini',
                    narrow: 'AD',
                    abbr: 'AD',
                },
                {
                    since: '0000-12-31',
                    until: -Infinity,
                    offset: 1,
                    name: 'Before Christ',
                    narrow: 'BC',
                    abbr: 'BC',
                },
            ],
            dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal: function (number) {
                var b = number % 10,
                    output =
                        toInt((number % 100) / 10) === 1
                            ? 'th'
                            : b === 1
                            ? 'st'
                            : b === 2
                            ? 'nd'
                            : b === 3
                            ? 'rd'
                            : 'th';
                return number + output;
            },
        });

        // Side effect imports

        hooks.lang = deprecate(
            'moment.lang is deprecated. Use moment.locale instead.',
            getSetGlobalLocale
        );
        hooks.langData = deprecate(
            'moment.langData is deprecated. Use moment.localeData instead.',
            getLocale
        );

        var mathAbs = Math.abs;

        function abs() {
            var data = this._data;

            this._milliseconds = mathAbs(this._milliseconds);
            this._days = mathAbs(this._days);
            this._months = mathAbs(this._months);

            data.milliseconds = mathAbs(data.milliseconds);
            data.seconds = mathAbs(data.seconds);
            data.minutes = mathAbs(data.minutes);
            data.hours = mathAbs(data.hours);
            data.months = mathAbs(data.months);
            data.years = mathAbs(data.years);

            return this;
        }

        function addSubtract$1(duration, input, value, direction) {
            var other = createDuration(input, value);

            duration._milliseconds += direction * other._milliseconds;
            duration._days += direction * other._days;
            duration._months += direction * other._months;

            return duration._bubble();
        }

        // supports only 2.0-style add(1, 's') or add(duration)
        function add$1(input, value) {
            return addSubtract$1(this, input, value, 1);
        }

        // supports only 2.0-style subtract(1, 's') or subtract(duration)
        function subtract$1(input, value) {
            return addSubtract$1(this, input, value, -1);
        }

        function absCeil(number) {
            if (number < 0) {
                return Math.floor(number);
            } else {
                return Math.ceil(number);
            }
        }

        function bubble() {
            var milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data,
                seconds,
                minutes,
                hours,
                years,
                monthsFromDays;

            // if we have a mix of positive and negative values, bubble down first
            // check: https://github.com/moment/moment/issues/2166
            if (
                !(
                    (milliseconds >= 0 && days >= 0 && months >= 0) ||
                    (milliseconds <= 0 && days <= 0 && months <= 0)
                )
            ) {
                milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
                days = 0;
                months = 0;
            }

            // The following code bubbles up values, see the tests for
            // examples of what that means.
            data.milliseconds = milliseconds % 1000;

            seconds = absFloor(milliseconds / 1000);
            data.seconds = seconds % 60;

            minutes = absFloor(seconds / 60);
            data.minutes = minutes % 60;

            hours = absFloor(minutes / 60);
            data.hours = hours % 24;

            days += absFloor(hours / 24);

            // convert days to months
            monthsFromDays = absFloor(daysToMonths(days));
            months += monthsFromDays;
            days -= absCeil(monthsToDays(monthsFromDays));

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            data.days = days;
            data.months = months;
            data.years = years;

            return this;
        }

        function daysToMonths(days) {
            // 400 years have 146097 days (taking into account leap year rules)
            // 400 years have 12 months === 4800
            return (days * 4800) / 146097;
        }

        function monthsToDays(months) {
            // the reverse of daysToMonths
            return (months * 146097) / 4800;
        }

        function as(units) {
            if (!this.isValid()) {
                return NaN;
            }
            var days,
                months,
                milliseconds = this._milliseconds;

            units = normalizeUnits(units);

            if (units === 'month' || units === 'quarter' || units === 'year') {
                days = this._days + milliseconds / 864e5;
                months = this._months + daysToMonths(days);
                switch (units) {
                    case 'month':
                        return months;
                    case 'quarter':
                        return months / 3;
                    case 'year':
                        return months / 12;
                }
            } else {
                // handle milliseconds separately because of floating point math errors (issue #1867)
                days = this._days + Math.round(monthsToDays(this._months));
                switch (units) {
                    case 'week':
                        return days / 7 + milliseconds / 6048e5;
                    case 'day':
                        return days + milliseconds / 864e5;
                    case 'hour':
                        return days * 24 + milliseconds / 36e5;
                    case 'minute':
                        return days * 1440 + milliseconds / 6e4;
                    case 'second':
                        return days * 86400 + milliseconds / 1000;
                    // Math.floor prevents floating point math errors here
                    case 'millisecond':
                        return Math.floor(days * 864e5) + milliseconds;
                    default:
                        throw new Error('Unknown unit ' + units);
                }
            }
        }

        // TODO: Use this.as('ms')?
        function valueOf$1() {
            if (!this.isValid()) {
                return NaN;
            }
            return (
                this._milliseconds +
                this._days * 864e5 +
                (this._months % 12) * 2592e6 +
                toInt(this._months / 12) * 31536e6
            );
        }

        function makeAs(alias) {
            return function () {
                return this.as(alias);
            };
        }

        var asMilliseconds = makeAs('ms'),
            asSeconds = makeAs('s'),
            asMinutes = makeAs('m'),
            asHours = makeAs('h'),
            asDays = makeAs('d'),
            asWeeks = makeAs('w'),
            asMonths = makeAs('M'),
            asQuarters = makeAs('Q'),
            asYears = makeAs('y');

        function clone$1() {
            return createDuration(this);
        }

        function get$2(units) {
            units = normalizeUnits(units);
            return this.isValid() ? this[units + 's']() : NaN;
        }

        function makeGetter(name) {
            return function () {
                return this.isValid() ? this._data[name] : NaN;
            };
        }

        var milliseconds = makeGetter('milliseconds'),
            seconds = makeGetter('seconds'),
            minutes = makeGetter('minutes'),
            hours = makeGetter('hours'),
            days = makeGetter('days'),
            months = makeGetter('months'),
            years = makeGetter('years');

        function weeks() {
            return absFloor(this.days() / 7);
        }

        var round = Math.round,
            thresholds = {
                ss: 44, // a few seconds to seconds
                s: 45, // seconds to minute
                m: 45, // minutes to hour
                h: 22, // hours to day
                d: 26, // days to month/week
                w: null, // weeks to month
                M: 11, // months to year
            };

        // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
            return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
        }

        function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
            var duration = createDuration(posNegDuration).abs(),
                seconds = round(duration.as('s')),
                minutes = round(duration.as('m')),
                hours = round(duration.as('h')),
                days = round(duration.as('d')),
                months = round(duration.as('M')),
                weeks = round(duration.as('w')),
                years = round(duration.as('y')),
                a =
                    (seconds <= thresholds.ss && ['s', seconds]) ||
                    (seconds < thresholds.s && ['ss', seconds]) ||
                    (minutes <= 1 && ['m']) ||
                    (minutes < thresholds.m && ['mm', minutes]) ||
                    (hours <= 1 && ['h']) ||
                    (hours < thresholds.h && ['hh', hours]) ||
                    (days <= 1 && ['d']) ||
                    (days < thresholds.d && ['dd', days]);

            if (thresholds.w != null) {
                a =
                    a ||
                    (weeks <= 1 && ['w']) ||
                    (weeks < thresholds.w && ['ww', weeks]);
            }
            a = a ||
                (months <= 1 && ['M']) ||
                (months < thresholds.M && ['MM', months]) ||
                (years <= 1 && ['y']) || ['yy', years];

            a[2] = withoutSuffix;
            a[3] = +posNegDuration > 0;
            a[4] = locale;
            return substituteTimeAgo.apply(null, a);
        }

        // This function allows you to set the rounding function for relative time strings
        function getSetRelativeTimeRounding(roundingFunction) {
            if (roundingFunction === undefined) {
                return round;
            }
            if (typeof roundingFunction === 'function') {
                round = roundingFunction;
                return true;
            }
            return false;
        }

        // This function allows you to set a threshold for relative time strings
        function getSetRelativeTimeThreshold(threshold, limit) {
            if (thresholds[threshold] === undefined) {
                return false;
            }
            if (limit === undefined) {
                return thresholds[threshold];
            }
            thresholds[threshold] = limit;
            if (threshold === 's') {
                thresholds.ss = limit - 1;
            }
            return true;
        }

        function humanize(argWithSuffix, argThresholds) {
            if (!this.isValid()) {
                return this.localeData().invalidDate();
            }

            var withSuffix = false,
                th = thresholds,
                locale,
                output;

            if (typeof argWithSuffix === 'object') {
                argThresholds = argWithSuffix;
                argWithSuffix = false;
            }
            if (typeof argWithSuffix === 'boolean') {
                withSuffix = argWithSuffix;
            }
            if (typeof argThresholds === 'object') {
                th = Object.assign({}, thresholds, argThresholds);
                if (argThresholds.s != null && argThresholds.ss == null) {
                    th.ss = argThresholds.s - 1;
                }
            }

            locale = this.localeData();
            output = relativeTime$1(this, !withSuffix, th, locale);

            if (withSuffix) {
                output = locale.pastFuture(+this, output);
            }

            return locale.postformat(output);
        }

        var abs$1 = Math.abs;

        function sign(x) {
            return (x > 0) - (x < 0) || +x;
        }

        function toISOString$1() {
            // for ISO strings we do not use the normal bubbling rules:
            //  * milliseconds bubble up until they become hours
            //  * days do not bubble at all
            //  * months bubble up until they become years
            // This is because there is no context-free conversion between hours and days
            // (think of clock changes)
            // and also not between days and months (28-31 days per month)
            if (!this.isValid()) {
                return this.localeData().invalidDate();
            }

            var seconds = abs$1(this._milliseconds) / 1000,
                days = abs$1(this._days),
                months = abs$1(this._months),
                minutes,
                hours,
                years,
                s,
                total = this.asSeconds(),
                totalSign,
                ymSign,
                daysSign,
                hmsSign;

            if (!total) {
                // this is the same as C#'s (Noda) and python (isodate)...
                // but not other JS (goog.date)
                return 'P0D';
            }

            // 3600 seconds -> 60 minutes -> 1 hour
            minutes = absFloor(seconds / 60);
            hours = absFloor(minutes / 60);
            seconds %= 60;
            minutes %= 60;

            // 12 months -> 1 year
            years = absFloor(months / 12);
            months %= 12;

            // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
            s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';

            totalSign = total < 0 ? '-' : '';
            ymSign = sign(this._months) !== sign(total) ? '-' : '';
            daysSign = sign(this._days) !== sign(total) ? '-' : '';
            hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

            return (
                totalSign +
                'P' +
                (years ? ymSign + years + 'Y' : '') +
                (months ? ymSign + months + 'M' : '') +
                (days ? daysSign + days + 'D' : '') +
                (hours || minutes || seconds ? 'T' : '') +
                (hours ? hmsSign + hours + 'H' : '') +
                (minutes ? hmsSign + minutes + 'M' : '') +
                (seconds ? hmsSign + s + 'S' : '')
            );
        }

        var proto$2 = Duration.prototype;

        proto$2.isValid = isValid$1;
        proto$2.abs = abs;
        proto$2.add = add$1;
        proto$2.subtract = subtract$1;
        proto$2.as = as;
        proto$2.asMilliseconds = asMilliseconds;
        proto$2.asSeconds = asSeconds;
        proto$2.asMinutes = asMinutes;
        proto$2.asHours = asHours;
        proto$2.asDays = asDays;
        proto$2.asWeeks = asWeeks;
        proto$2.asMonths = asMonths;
        proto$2.asQuarters = asQuarters;
        proto$2.asYears = asYears;
        proto$2.valueOf = valueOf$1;
        proto$2._bubble = bubble;
        proto$2.clone = clone$1;
        proto$2.get = get$2;
        proto$2.milliseconds = milliseconds;
        proto$2.seconds = seconds;
        proto$2.minutes = minutes;
        proto$2.hours = hours;
        proto$2.days = days;
        proto$2.weeks = weeks;
        proto$2.months = months;
        proto$2.years = years;
        proto$2.humanize = humanize;
        proto$2.toISOString = toISOString$1;
        proto$2.toString = toISOString$1;
        proto$2.toJSON = toISOString$1;
        proto$2.locale = locale;
        proto$2.localeData = localeData;

        proto$2.toIsoString = deprecate(
            'toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)',
            toISOString$1
        );
        proto$2.lang = lang;

        // FORMATTING

        addFormatToken('X', 0, 0, 'unix');
        addFormatToken('x', 0, 0, 'valueOf');

        // PARSING

        addRegexToken('x', matchSigned);
        addRegexToken('X', matchTimestamp);
        addParseToken('X', function (input, array, config) {
            config._d = new Date(parseFloat(input) * 1000);
        });
        addParseToken('x', function (input, array, config) {
            config._d = new Date(toInt(input));
        });

        //! moment.js

        hooks.version = '2.29.1';

        setHookCallback(createLocal);

        hooks.fn = proto;
        hooks.min = min;
        hooks.max = max;
        hooks.now = now;
        hooks.utc = createUTC;
        hooks.unix = createUnix;
        hooks.months = listMonths;
        hooks.isDate = isDate;
        hooks.locale = getSetGlobalLocale;
        hooks.invalid = createInvalid;
        hooks.duration = createDuration;
        hooks.isMoment = isMoment;
        hooks.weekdays = listWeekdays;
        hooks.parseZone = createInZone;
        hooks.localeData = getLocale;
        hooks.isDuration = isDuration;
        hooks.monthsShort = listMonthsShort;
        hooks.weekdaysMin = listWeekdaysMin;
        hooks.defineLocale = defineLocale;
        hooks.updateLocale = updateLocale;
        hooks.locales = listLocales;
        hooks.weekdaysShort = listWeekdaysShort;
        hooks.normalizeUnits = normalizeUnits;
        hooks.relativeTimeRounding = getSetRelativeTimeRounding;
        hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
        hooks.calendarFormat = getCalendarFormat;
        hooks.prototype = proto;

        // currently HTML5 input type only supports 24-hour formats
        hooks.HTML5_FMT = {
            DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm', // <input type="datetime-local" />
            DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss', // <input type="datetime-local" step="1" />
            DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS', // <input type="datetime-local" step="0.001" />
            DATE: 'YYYY-MM-DD', // <input type="date" />
            TIME: 'HH:mm', // <input type="time" />
            TIME_SECONDS: 'HH:mm:ss', // <input type="time" step="1" />
            TIME_MS: 'HH:mm:ss.SSS', // <input type="time" step="0.001" />
            WEEK: 'GGGG-[W]WW', // <input type="week" />
            MONTH: 'YYYY-MM', // <input type="month" />
        };

        return hooks;

    })));
    });

    const DEFAULT_OPTIONS = {
      timeZone: 'Europe/Moscow',
    };

    const DATE_NUMERIC_OPTIONS = {
      ...DEFAULT_OPTIONS,
      year: '2-digit',
      month: 'numeric',
      day: 'numeric',
    };

    const DATE_NUMERIC_LONG_OPTIONS = {
      ...DEFAULT_OPTIONS,
      year: 'numeric',
      month: 'numeric',
      day: 'numeric',
    };

    const DATE_SHORT_OPTIONS = {
      ...DEFAULT_OPTIONS,
      month: 'short',
      day: 'numeric',
    };

    const MONTH_SHORT_OPTIONS = {
      ...DEFAULT_OPTIONS,
      month: 'short',
    };

    const MONTH_LONG_OPTIONS = {
      ...DEFAULT_OPTIONS,
      month: 'long',
    };

    const MONTH_YEAR_OPTIONS = {
      ...DEFAULT_OPTIONS,
      year: 'numeric',
      month: 'long',
    };

    const MONTH_YEAR_SHORT_OPTIONS = {
      ...DEFAULT_OPTIONS,
      year: '2-digit',
      month: 'short',
    };

    const DAY = 86400000;
    const WEEK = DAY * 7;

    function calculateDatePoP(timestamp, dynamics) {
      const date = new Date(timestamp);  
      if (dynamics === 'graphDetailDay') {
        date.setDate(date.getDate() - 30);
      } else if (dynamics === 'graphDetailWeek') {
        date.setDate(date.getDate() - (10 * 7));
      } else if (dynamics === 'graphDetailMonth') {
        date.setDate(1);
        date.setMonth(date.getMonth() - 12);
      } else if (dynamics === 'graphDetailQuarter') {
        date.setDate(1); 
        date.setMonth(date.getMonth() - 12);
      } else {
        date.setDate(1);
        date.setMonth(date.getMonth() - 24);  
      }
      return Math.floor(date);
    }

    function generateAvailableDays(start, end, precision, name) {
      const dates = name === 'date' ? CONFIG.dates[0] : name === 'datePoP' ? CONFIG.dates[1] : [];
      const foundDates = dates.reduce((acc, item) => {
        if (!item.dateDataExist && (precision === 0))
          return acc;
        if (!item.weekDataExist && (precision === 1))
          return acc;
        const date = new Date(item.year, item.month - 1, item.day);
        if (date.getTime() >= start.getTime() && date.getTime() <= end.getTime())
          acc.push({ number: item.number, date: date });
        return acc;
      }, []);
      return foundDates;
    }

    function calculateDatesForValue(value, precision, name) {  
      const date = moment([value.getFullYear(), value.getMonth(), value.getDate()]);
      if (precision === 1) {
        const weekNumber = calculateWeekNumber(value.getDate(), value.getMonth(), value.getFullYear());
        const year = weekNumber === 53 && value.getMonth() === 0 
          ? value.getFullYear() - 1 : value.getFullYear();
        const start = moment(new Date(year, 1, 1)).isoWeek(weekNumber).startOf('isoWeek');
        const end = moment(new Date(year, 1, 1)).isoWeek(weekNumber).endOf('isoWeek');
        return generateAvailableDays(start.toDate(), end.toDate(), precision, name)
      } else if (precision === 2) { // меcяц
        const start = date.clone().startOf('month');
        const end = date.clone().endOf('month');
        return generateAvailableDays(start.toDate(), end.toDate(), precision, name);
      } else if (precision === 3) {
        const start = date.clone().startOf('quarter');
        const end = date.clone().endOf('quarter');
        return generateAvailableDays(start.toDate(), end.toDate(), precision, name);
      } else if (precision === 4) {
        const start = date.clone().startOf('year');
        const end = date.clone().endOf('year');
        return generateAvailableDays(start.toDate(), end.toDate(), precision, name);
      }
      return generateAvailableDays(date.toDate(), date.toDate(), precision, name);
    }

    function calculateDateForPrecision(date, precision, weekNumber, name) {
      if (precision === 1) { // неделя
        const year = weekNumber === 53 && date.getMonth() === 0 
          ? date.getFullYear() - 1 : date.getFullYear();
        return moment(new Date(year, 1, 1)).isoWeek(weekNumber).endOf('isoWeek').toDate();
      } else if (precision === 2) { // месяц
        return moment([date.getFullYear(), date.getMonth()]).endOf('month').toDate();
      } else if (precision === 3) { // квартал
        return moment([date.getFullYear(), date.getMonth()]).endOf('quarter').toDate();
      } else if (precision === 4) { // год
        return moment([date.getFullYear()]).endOf('year').toDate();
      }
      return date;
    }

    function generateCurrentMonthDayOption(count, month, year, dates, dayOptions) {
      const currentDates = dates.filter(item => item.year === year && item.month === month + 1);
      for (let index = 1; index <= count; index += 1) {
        const d = currentDates.filter(item => item.day === index);
        const option = {
          day: index,
          month,
          year,
          disabled: d.length > 0 ? !d[0].dateDataExist : true
        };
        dayOptions.push(option);
      }
    }

    function generateBeginningPadding(month, year, dates, dayOptions) {
      let firstDay = (new Date(year, month, 1)).getDay();
      if (firstDay === 0)
        firstDay = 7;
      if (firstDay > 1) {
        const prevMonth = month - 1 < 0 ? 11 : month - 1;
        const prevYear = prevMonth === 11 ? year - 1 : year;
        const prevMonthLastDate = (new Date(year, month, 0)).getDate();
        const currentDates = dates.filter(item => item.year === prevYear && item.month === prevMonth + 1);
        for (let index = 0; index < (firstDay - 1); index += 1) {
          const d = currentDates.filter(item => item.day === prevMonthLastDate - index);
          const option = {
            day: prevMonthLastDate - index,
            month: prevMonth,
            year: prevYear,
            disabled: d.length > 0 ? !d[0].dateDataExist : true
          };
          dayOptions.unshift(option);
        }
      }
    }

    function generateEndPadding(month, year, maxYear, dates, dayOptions) {  
      const lastDay = (new Date(year, month, dayOptions[dayOptions.length - 1].day)).getDay();
      if (lastDay > 0) {
        const paddingCount = 7 - lastDay;
        const nextMonth = month + 1 > 11 ? 0 : month + 1;
        const nextYear = nextMonth === 0 ? year + 1 : year;
        const currentDates = dates.filter(item => item.year === nextYear && item.month === nextMonth + 1);
        if (nextYear <= maxYear) {
          for (let index = 1; index <= paddingCount; index += 1) {
            const d = currentDates.filter(item => item.day === index);
            const option = {
              day: index,
              month: nextMonth,
              year: nextYear,
              disabled: d.length > 0 ? !d[0].dateDataExist : true
            };
            dayOptions.push(option);
          }
        }
      }
    }

    function generateDayOptions(month, year, maxYear, name) {
      const dayOptions = [];
      const dates = name === 'date' ? CONFIG.dates[0] : name === 'datePoP' ? CONFIG.dates[1] : [];
      const count = (new Date(year, (month + 1), 0)).getDate();
      generateCurrentMonthDayOption(count, month, year, dates, dayOptions);
      generateBeginningPadding(month, year, dates, dayOptions);
      generateEndPadding(month, year, maxYear, dates, dayOptions);
      return dayOptions;
    }

    function subtractDays(timestamp, count = 1) {
      return timestamp - (DAY * (count - 1));
    }

    function addWeeks(timestamp, count = 1) {
      return timestamp + (WEEK * count);
    }

    function subtractWeeks(timestamp, count = 1) {
      return timestamp - (WEEK * (count - 1));
    }

    function addMonths(timestamp, count = 1) {
      const date = new Date(timestamp);
      return date.setMonth(date.getMonth() + count);
    }

    function subtractYear(timestamp) {
      const date = new Date(timestamp);
      return date.setFullYear(date.getFullYear() - 1);
    }

    function calculateYearWeekCount(year) {
      return calculateWeekNumber(31, 11, year);
    }

    function calculateWeekNumber(day, month, year, iso = true) {
      const date = new Date(Date.UTC(year, month, day));
      const mnt = new moment(date);
      return iso ? mnt.isoWeek() : mnt.week();
    }

    function generateWeekNumbers(day, month, year, name) {
      const weekNumbers = [];
      const monthFirstWeek = calculateWeekNumber(1, month, year);
      const lastDay = (new Date(year, (month + 1), 0)).getDate();
      const monthLasttWeek = calculateWeekNumber(lastDay, month, year);
      const monthLength = monthLasttWeek - (monthFirstWeek % 53);
      for (let index = 0; index <= monthLength; index += 1) {
        let weekNumber = (monthFirstWeek + index) % 53;
        weekNumber = !weekNumber ? 53 : weekNumber;
        const yearValue = weekNumber === 53 && month === 0 ? year - 1 : year;
        const startOfWeek = moment(new Date(yearValue, 1, 1))
          .isoWeek(weekNumber).startOf('isoWeek');
        const endOfWeek = moment(new Date(yearValue, 1, 1))
          .isoWeek(weekNumber).endOf('isoWeek');
        const weekDates = generateAvailableDays(startOfWeek.toDate(), endOfWeek.toDate(), 1, name);
        weekNumbers.push({
          disabled: !weekDates.length,
          number: weekNumber
        });
      }
      return weekNumbers;
    }

    function renderMonthLong(timestamp, locale) {
      const date = new Date(timestamp);
      const formatter = new Intl.DateTimeFormat(locale === 'ru' ? 'ru-RU' : 'en-US', MONTH_LONG_OPTIONS);
      return formatter.format(date);
    }

    function renderMonthShort(timestamp, locale) {
      const date = new Date(timestamp);
      const formatter = new Intl.DateTimeFormat(locale === 'ru' ? 'ru-RU' : 'en-US', MONTH_SHORT_OPTIONS);
      return formatter.format(date);
    }

    function renderMonthYear(timestamp, locale) {  
      const date = new Date(timestamp);
      const formatter = new Intl.DateTimeFormat(locale === 'ru' ? 'ru-RU' : 'en-US', MONTH_YEAR_OPTIONS);
      return formatter.format(date);
    }

    function renderMonthYearShort(timestamp, locale) {
      const date = new Date(timestamp);
      const formatter = new Intl.DateTimeFormat(locale === 'ru' ? 'ru-RU' : 'en-US', MONTH_YEAR_SHORT_OPTIONS);
      return formatter.format(date);
    }

    function renderDateNumeric(timestamp, locale) {
      const date = new Date(timestamp);
      const formatter = new Intl.DateTimeFormat(locale === 'ru' ? 'ru-RU' : 'en-US', DATE_NUMERIC_OPTIONS);
      return formatter.format(date);
    }

    function renderDateNumericLong(timestamp, locale) {
      const date = new Date(timestamp);
      const formatter = new Intl.DateTimeFormat(locale === 'ru' ? 'ru-RU' : 'en-US', DATE_NUMERIC_LONG_OPTIONS);
      return formatter.format(date);
    }

    function renderWeekYearShort(timestamp, locale) {
      const date = new Date(timestamp);
      const day = date.getDate();
      const month = date.getMonth();
      const year = date.getFullYear();
      const week = calculateWeekNumber(day, month, year);
      return locale === 'ru' ? `${week} н ${year % 100}` : `${week} n ${year % 100}`;
    }

    function renderQuarterYearShort(timestamp, locale) {
      const date = new Date(timestamp);
      const month = date.getMonth() + 1;
      const quarter = Math.ceil(month / 3);
      const year = date.getFullYear();
      return locale === 'ru' ? `${quarter} кв. ${year % 100}` : `${quarter} qu. ${year % 100}`;
    }

    function renderDateShort(timestamp, locale) {
      const date = new Date(timestamp);
      const formatter = new Intl.DateTimeFormat(locale === 'ru' ? 'ru-RU' : 'en-US', DATE_SHORT_OPTIONS);
      return formatter.format(date);
    }

    function renderWeekShort(timestamp, locale) {
      const date = new Date(timestamp);
      const day = date.getDate();
      const month = date.getMonth();
      const year = date.getFullYear();
      const week = calculateWeekNumber(day, month, year);
      return locale === 'ru' ? `${week}-я нед` : `${week} week`;
    }

    function renderQuarterShort(timestamp, locale) {
      const date = new Date(timestamp);
      const month = date.getMonth() + 1;
      const quarter = Math.ceil(month / 3);
      return locale === 'ru' ? `${quarter} кв.` : `${quarter} qu.`;
    }

    function renderWeekYear(timestamp, locale) {
      const date = new Date(timestamp);
      const day = date.getDate();
      const month = date.getMonth();
      const year = date.getFullYear();
      const week = calculateWeekNumber(day, month, year);
      return locale === 'ru' ? `${week}-я неделя ${year}` : `${week} week ${year}`;
    }

    function renderQuarterYear(timestamp, locale) {
      const date = new Date(timestamp);
      const month = date.getMonth() + 1;
      const year = date.getFullYear();
      const quarter = Math.ceil(month / 3);
      return locale === 'ru' ? `${quarter} квартал ${year}` : `${quarter} quarter ${year}`;
    }

    function renderYear(timestamp) {
      const date = new Date(timestamp);
      const year = date.getFullYear();
      return `${year}`;
    }

    function renderPreciseCellDate(timestamp, precision, locale) {
      if (precision === 0) return renderDateNumeric(timestamp, locale);
      if (precision === 1) return renderWeekYearShort(timestamp, locale);
      if (precision === 2) return renderMonthYearShort(timestamp, locale);
      if (precision === 3) return renderQuarterYearShort(timestamp, locale);
      return renderYear(timestamp);
    }

    function renderPreciseCellMonth(timestamp, precision, maxTimestamp, locale) {
      if (precision >= 0 && precision <= 2) return renderMonthYearShort(timestamp, locale);
      const dateMax = new Date(maxTimestamp);
      const yearMax = dateMax.getFullYear();
      const monthMax = dateMax.getMonth();
      const date = new Date(timestamp);
      const year = date.getFullYear();
      if (precision === 3) {
        const quarter = calculateQuarter(timestamp);
        const month = (quarter * 3) - 1;
        const monthFinal = year === yearMax && month > monthMax ? monthMax : month;
        const monthTimestamp = Date.UTC(year, monthFinal, 1);
        return renderMonthYearShort(monthTimestamp, locale);
      }
      const month = year === yearMax && monthMax < 11 ? monthMax : 11;
      const yearTimestamp = Date.UTC(year, month, 1);
      return renderMonthYearShort(yearTimestamp, locale);
    }

    function renderPreciseTableDate(timestamp, precision, locale) {
      if (precision === 0) return renderDateShort(timestamp, locale);
      if (precision === 1) return renderWeekShort(timestamp, locale);
      if (precision === 2) return renderMonthShort(timestamp, locale);
      if (precision === 3) return renderQuarterShort(timestamp, locale);
      return renderYear(timestamp);
    }

    function renderPreciseTableMonth(timestamp, precision, maxTimestamp, locale) {
      if (precision >= 0 && precision <= 2) return renderMonthShort(timestamp, locale);
      const dateMax = new Date(maxTimestamp);
      const yearMax = dateMax.getFullYear();
      const monthMax = dateMax.getMonth();
      const date = new Date(timestamp);
      const year = date.getFullYear();
      if (precision === 3) {
        const quarter = calculateQuarter(timestamp);
        const month = (quarter * 3) - 1;
        const monthFinal = year === yearMax && month > monthMax ? monthMax : month;
        const monthTimestamp = Date.UTC(year, monthFinal, 1);
        return renderMonthShort(monthTimestamp, locale);
      }
      const month = year === yearMax && monthMax < 11 ? monthMax : 11;
      const yearTimestamp = Date.UTC(year, month, 1);
      return renderMonthShort(yearTimestamp, locale);
    }

    function renderPreciseDate(timestamp, precision, locale) {
      if (precision === 0) return renderDateNumericLong(timestamp, locale);
      if (precision === 1) return renderWeekYear(timestamp, locale);
      if (precision === 2) return renderMonthYear(timestamp, locale);
      if (precision === 3) return renderQuarterYear(timestamp, locale);
      return renderYear(timestamp);
    }

    function calcuateMonthDayCount(timestamp) {
      return new Date(timestamp).getDate();
    }

    function calculateDatesMonthsCount(firstTimestamp, lastTimestamp) {
      const yearCount = calculateDatesYearsCount(firstTimestamp, lastTimestamp);
      const firstDate = new Date(firstTimestamp);
      const firstMonth = firstDate.getMonth() + 1;
      const lastDate = new Date(lastTimestamp);
      const lastMonth = lastDate.getMonth() + 1;
      if (yearCount > 1) {
        const firstYearMonths = (12 - firstMonth) + 1;
        const lastYearMonths = lastMonth;
        const fullYearsMonths = yearCount > 2 ? (yearCount - 2) * 12 : 0;
        const count = firstYearMonths + lastYearMonths + fullYearsMonths;
        return count;
      }
      return (lastMonth - firstMonth) + 1;
    }

    function calculateDatesQuartersCount(firstTimestamp, lastTimestamp) {
      const yearCount = calculateDatesYearsCount(firstTimestamp, lastTimestamp) - 1;
      const firstDate = new Date(firstTimestamp);
      const firstYearMonth = firstDate.getMonth() + 1;
      const lastDate = new Date(lastTimestamp);
      const lastYearMonths = lastDate.getMonth() + 1;
      const firstYearQuarters = (4 - Math.ceil(firstYearMonth / 3)) + 1;
      const lastYearQuarters = Math.ceil(lastYearMonths / 3);
      const fullYearsQuarters = yearCount > 2 ? (yearCount - 2) * 4 : 0;
      const count = firstYearQuarters + lastYearQuarters + fullYearsQuarters;
      return count;
    }

    function calculateQuartersRestCount(timestamp) {
      const date = new Date(timestamp);
      const month = date.getMonth() + 1;
      const count = (4 - Math.ceil(month / 3)) + 1;
      return count;
    }

    function calculateQuarter(timestamp) {
      const date = new Date(timestamp);
      const months = date.getMonth() + 1;
      const quarter = Math.ceil(months / 3);
      return quarter;
    }

    function calculateDatesYearsCount(firstDate, lastDate) {
      const firstYear = (new Date(firstDate)).getFullYear();
      const lastYear = (new Date(lastDate)).getFullYear();
      return (lastYear - firstYear) + 1;
    }

    function generateYearsWeekCache(dateMin, dateMax) {
      const yearMin = new Date(dateMin).getFullYear();
      const yearCount = calculateDatesYearsCount(dateMin, dateMax);
      const weeks = [];
      for (let yearShift = 0; yearShift < yearCount; yearShift += 1) {
        const year = yearMin + yearShift;
        const yearEnd = Date.UTC(year, 11, 31);
        const dateEnd = new Date(dateMax < yearEnd ? dateMax : yearEnd);
        const dateEndMonth = dateEnd.getMonth();
        const dateEndDate = dateEnd.getDate();
        const weekCount = calculateWeekNumber(dateEndDate, dateEndMonth, year);
        weeks.push(weekCount);
      }
      return weeks;
    }

    function generateYearsWeekRangeCache(dateMin, dateMax, weeksCache) {
      const yearMin = (new Date(dateMin)).getFullYear();
      const yearCount = calculateDatesYearsCount(dateMin, dateMax);
      const ranges = {};
      for (let yearShift = 0; yearShift < yearCount; yearShift += 1) {
        const year = yearMin + yearShift;
        const min = yearShift === 0 ? 1 : weeksCache.slice(0, yearShift).reduce((result, weekCache) => result + weekCache, 0) + 1;
        const max = yearShift === 0 ? weeksCache[0] : (min - 1) + weeksCache[yearShift];
        ranges[year] = { min, max };
      }
      return ranges;
    }

    /* src/js/components/datepicker/DatepickerToggle.svelte generated by Svelte v3.24.0 */

    const file$1 = "src/js/components/datepicker/DatepickerToggle.svelte";

    function create_fragment$3(ctx) {
    	let button;
    	let t0;
    	let t1;
    	let t2_value = /*renderToggleNote*/ ctx[4](/*note*/ ctx[2]) + "";
    	let t2;
    	let t3;
    	let svg;
    	let use;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t0 = text(/*label*/ ctx[1]);
    			t1 = space();
    			t2 = text(t2_value);
    			t3 = space();
    			svg = svg_element("svg");
    			use = svg_element("use");
    			xlink_attr(use, "xlink:href", "#txspt-icons-fatArrow");
    			add_location(use, file$1, 29, 8, 558);
    			attr_dev(svg, "class", "txcm-datepickerToggleIcon");
    			add_location(svg, file$1, 27, 4, 504);
    			attr_dev(button, "class", "txcm-datepickerToggle");
    			button.disabled = /*disabled*/ ctx[3];
    			toggle_class(button, "txcm-datepickerToggle-is-active", /*isActive*/ ctx[0]);
    			add_location(button, file$1, 20, 0, 327);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t0);
    			append_dev(button, t1);
    			append_dev(button, t2);
    			append_dev(button, t3);
    			append_dev(button, svg);
    			append_dev(svg, use);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onToggleClick*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*label*/ 2) set_data_dev(t0, /*label*/ ctx[1]);
    			if (dirty & /*note*/ 4 && t2_value !== (t2_value = /*renderToggleNote*/ ctx[4](/*note*/ ctx[2]) + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*disabled*/ 8) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[3]);
    			}

    			if (dirty & /*isActive*/ 1) {
    				toggle_class(button, "txcm-datepickerToggle-is-active", /*isActive*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	let { note = null } = $$props;
    	let { disabled = false } = $$props;
    	let { isActive } = $$props;

    	function renderToggleNote() {
    		if (note) return ` (${note})`;
    		return "";
    	}

    	function show() {
    		$$invalidate(0, isActive = true);
    	}

    	function onToggleClick() {
    		if (!isActive) setTimeout(show, 5);
    	}

    	const writable_props = ["label", "note", "disabled", "isActive"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DatepickerToggle> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DatepickerToggle", $$slots, []);

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("note" in $$props) $$invalidate(2, note = $$props.note);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    	};

    	$$self.$capture_state = () => ({
    		label,
    		note,
    		disabled,
    		isActive,
    		renderToggleNote,
    		show,
    		onToggleClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("note" in $$props) $$invalidate(2, note = $$props.note);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [isActive, label, note, disabled, renderToggleNote, onToggleClick];
    }

    class DatepickerToggle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$3, create_fragment$3, safe_not_equal, {
    			label: 1,
    			note: 2,
    			disabled: 3,
    			isActive: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatepickerToggle",
    			options,
    			id: create_fragment$3.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[1] === undefined && !("label" in props)) {
    			console.warn("<DatepickerToggle> was created without expected prop 'label'");
    		}

    		if (/*isActive*/ ctx[0] === undefined && !("isActive" in props)) {
    			console.warn("<DatepickerToggle> was created without expected prop 'isActive'");
    		}
    	}

    	get label() {
    		throw new Error("<DatepickerToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<DatepickerToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get note() {
    		throw new Error("<DatepickerToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set note(value) {
    		throw new Error("<DatepickerToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<DatepickerToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<DatepickerToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isActive() {
    		throw new Error("<DatepickerToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isActive(value) {
    		throw new Error("<DatepickerToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/datepicker/DatepickerSwitcher.svelte generated by Svelte v3.24.0 */
    const file$2 = "src/js/components/datepicker/DatepickerSwitcher.svelte";

    function create_fragment$4(ctx) {
    	let div;
    	let button0;
    	let int0;
    	let t0;
    	let button1;
    	let int1;
    	let t1;
    	let svg0;
    	let use0;
    	let t2;
    	let button2;
    	let int2;
    	let t3;
    	let svg1;
    	let use1;
    	let current;
    	let mounted;
    	let dispose;

    	int0 = new Int({
    			props: { key: /*options*/ ctx[1][/*pick*/ ctx[0]] },
    			$$inline: true
    		});

    	int1 = new Int({
    			props: { key: "Предыдущая опция" },
    			$$inline: true
    		});

    	int2 = new Int({
    			props: { key: "Следующая опция" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			create_component(int0.$$.fragment);
    			t0 = space();
    			button1 = element("button");
    			create_component(int1.$$.fragment);
    			t1 = space();
    			svg0 = svg_element("svg");
    			use0 = svg_element("use");
    			t2 = space();
    			button2 = element("button");
    			create_component(int2.$$.fragment);
    			t3 = space();
    			svg1 = svg_element("svg");
    			use1 = svg_element("use");
    			attr_dev(button0, "class", "txcm-datepickerPrecisionOption");
    			add_location(button0, file$2, 25, 4, 472);
    			xlink_attr(use0, "xlink:href", "#txspt-icons-angleArrow");
    			add_location(use0, file$2, 39, 12, 894);
    			attr_dev(svg0, "class", "txcm-datepickerSwitcherPrevIcon");
    			add_location(svg0, file$2, 37, 8, 826);
    			attr_dev(button1, "class", "txcm-datepickerSwitcherPrev");
    			toggle_class(button1, "txcm-datepickerSwitcherPrev-is-inactive", /*pick*/ ctx[0] === 0);
    			add_location(button1, file$2, 31, 4, 624);
    			xlink_attr(use1, "xlink:href", "#txspt-icons-angleArrow");
    			add_location(use1, file$2, 51, 12, 1257);
    			attr_dev(svg1, "class", "txcm-datepickerSwitcherNextIcon");
    			add_location(svg1, file$2, 49, 8, 1189);
    			attr_dev(button2, "class", "txcm-datepickerSwitcherNext");
    			toggle_class(button2, "txcm-datepickerSwitcherNext-is-inactive", /*pick*/ ctx[0] === /*max*/ ctx[2]);
    			add_location(button2, file$2, 43, 4, 986);
    			attr_dev(div, "class", "txcm-datepickerSwitcher");
    			add_location(div, file$2, 23, 0, 428);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			mount_component(int0, button0, null);
    			append_dev(div, t0);
    			append_dev(div, button1);
    			mount_component(int1, button1, null);
    			append_dev(button1, t1);
    			append_dev(button1, svg0);
    			append_dev(svg0, use0);
    			append_dev(div, t2);
    			append_dev(div, button2);
    			mount_component(int2, button2, null);
    			append_dev(button2, t3);
    			append_dev(button2, svg1);
    			append_dev(svg1, use1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*onPrecisionClick*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*onPrevClick*/ ctx[3], false, false, false),
    					listen_dev(button2, "click", /*onNextClick*/ ctx[4], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const int0_changes = {};
    			if (dirty & /*options, pick*/ 3) int0_changes.key = /*options*/ ctx[1][/*pick*/ ctx[0]];
    			int0.$set(int0_changes);

    			if (dirty & /*pick*/ 1) {
    				toggle_class(button1, "txcm-datepickerSwitcherPrev-is-inactive", /*pick*/ ctx[0] === 0);
    			}

    			if (dirty & /*pick, max*/ 5) {
    				toggle_class(button2, "txcm-datepickerSwitcherNext-is-inactive", /*pick*/ ctx[0] === /*max*/ ctx[2]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			transition_in(int2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			transition_out(int2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int0);
    			destroy_component(int1);
    			destroy_component(int2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { precision } = $$props;
    	let { options } = $$props;
    	let { pick = 0 } = $$props;
    	let { precisionOption } = $$props;
    	const max = options.length - 1;

    	function onPrevClick() {
    		$$invalidate(0, pick = Math.max(0, pick - 1));
    	}

    	function onNextClick() {
    		$$invalidate(0, pick = Math.min(max, pick + 1));
    	}

    	function onPrecisionClick() {
    		$$invalidate(6, precision = precisionOption);
    	}

    	const writable_props = ["precision", "options", "pick", "precisionOption"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DatepickerSwitcher> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DatepickerSwitcher", $$slots, []);

    	$$self.$set = $$props => {
    		if ("precision" in $$props) $$invalidate(6, precision = $$props.precision);
    		if ("options" in $$props) $$invalidate(1, options = $$props.options);
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("precisionOption" in $$props) $$invalidate(7, precisionOption = $$props.precisionOption);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		precision,
    		options,
    		pick,
    		precisionOption,
    		max,
    		onPrevClick,
    		onNextClick,
    		onPrecisionClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("precision" in $$props) $$invalidate(6, precision = $$props.precision);
    		if ("options" in $$props) $$invalidate(1, options = $$props.options);
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("precisionOption" in $$props) $$invalidate(7, precisionOption = $$props.precisionOption);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		pick,
    		options,
    		max,
    		onPrevClick,
    		onNextClick,
    		onPrecisionClick,
    		precision,
    		precisionOption
    	];
    }

    class DatepickerSwitcher extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
    			precision: 6,
    			options: 1,
    			pick: 0,
    			precisionOption: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatepickerSwitcher",
    			options,
    			id: create_fragment$4.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*precision*/ ctx[6] === undefined && !("precision" in props)) {
    			console.warn("<DatepickerSwitcher> was created without expected prop 'precision'");
    		}

    		if (/*options*/ ctx[1] === undefined && !("options" in props)) {
    			console.warn("<DatepickerSwitcher> was created without expected prop 'options'");
    		}

    		if (/*precisionOption*/ ctx[7] === undefined && !("precisionOption" in props)) {
    			console.warn("<DatepickerSwitcher> was created without expected prop 'precisionOption'");
    		}
    	}

    	get precision() {
    		throw new Error("<DatepickerSwitcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precision(value) {
    		throw new Error("<DatepickerSwitcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<DatepickerSwitcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<DatepickerSwitcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pick() {
    		throw new Error("<DatepickerSwitcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pick(value) {
    		throw new Error("<DatepickerSwitcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get precisionOption() {
    		throw new Error("<DatepickerSwitcher>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precisionOption(value) {
    		throw new Error("<DatepickerSwitcher>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/datepicker/DatepickerOptionsWeeks.svelte generated by Svelte v3.24.0 */
    const file$3 = "src/js/components/datepicker/DatepickerOptionsWeeks.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (31:2) {#each weekNumbers as weekNumber}
    function create_each_block(ctx) {
    	let li;
    	let button;
    	let int;
    	let button_data_option_value;
    	let button_disabled_value;
    	let t;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*weekNumber*/ ctx[9].number },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			create_component(int.$$.fragment);
    			t = space();
    			attr_dev(button, "class", "txcm-datepickerWeekNumberButton");
    			attr_dev(button, "data-option", button_data_option_value = /*weekNumber*/ ctx[9].number);
    			button.disabled = button_disabled_value = /*weekNumber*/ ctx[9].disabled;
    			toggle_class(button, "txcm-datepickerWeekNumberButton-is-active", isActive(/*weekNumber*/ ctx[9].number, /*week*/ ctx[1], /*precision*/ ctx[0]));
    			add_location(button, file$3, 33, 8, 798);
    			attr_dev(li, "class", "txcm-datepickerWeekNumber");
    			add_location(li, file$3, 31, 4, 745);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			mount_component(int, button, null);
    			append_dev(li, t);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onButtonClick*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*weekNumbers*/ 4) int_changes.key = /*weekNumber*/ ctx[9].number;
    			int.$set(int_changes);

    			if (!current || dirty & /*weekNumbers*/ 4 && button_data_option_value !== (button_data_option_value = /*weekNumber*/ ctx[9].number)) {
    				attr_dev(button, "data-option", button_data_option_value);
    			}

    			if (!current || dirty & /*weekNumbers*/ 4 && button_disabled_value !== (button_disabled_value = /*weekNumber*/ ctx[9].disabled)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}

    			if (dirty & /*isActive, weekNumbers, week, precision*/ 7) {
    				toggle_class(button, "txcm-datepickerWeekNumberButton-is-active", isActive(/*weekNumber*/ ctx[9].number, /*week*/ ctx[1], /*precision*/ ctx[0]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(31:2) {#each weekNumbers as weekNumber}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div;
    	let t1;
    	let ol;
    	let current;
    	let each_value = /*weekNumbers*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "W";
    			t1 = space();
    			ol = element("ol");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-datepickerWeekLabel");
    			add_location(div, file$3, 26, 0, 615);
    			attr_dev(ol, "class", "txcm-datepickerWeekNumbers");
    			add_location(ol, file$3, 29, 0, 665);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, ol, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ol, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*weekNumbers, isActive, week, precision, onButtonClick*/ 15) {
    				each_value = /*weekNumbers*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ol, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(ol);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function isActive(weekNumber, week, precision) {
    	return precision === 1 && weekNumber === week;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { precision } = $$props;
    	let { day } = $$props;
    	let { week } = $$props;
    	let { month } = $$props;
    	let { year } = $$props;
    	let { name } = $$props;
    	let { yearOptions } = $$props;

    	function onButtonClick({ target }) {
    		const option = parseInt(target.dataset.option, 10);
    		$$invalidate(0, precision = 1);
    		$$invalidate(1, week = option);
    	}

    	const writable_props = ["precision", "day", "week", "month", "year", "name", "yearOptions"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DatepickerOptionsWeeks> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DatepickerOptionsWeeks", $$slots, []);

    	$$self.$set = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("day" in $$props) $$invalidate(4, day = $$props.day);
    		if ("week" in $$props) $$invalidate(1, week = $$props.week);
    		if ("month" in $$props) $$invalidate(5, month = $$props.month);
    		if ("year" in $$props) $$invalidate(6, year = $$props.year);
    		if ("name" in $$props) $$invalidate(7, name = $$props.name);
    		if ("yearOptions" in $$props) $$invalidate(8, yearOptions = $$props.yearOptions);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		generateWeekNumbers,
    		precision,
    		day,
    		week,
    		month,
    		year,
    		name,
    		yearOptions,
    		isActive,
    		onButtonClick,
    		weekNumbers
    	});

    	$$self.$inject_state = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("day" in $$props) $$invalidate(4, day = $$props.day);
    		if ("week" in $$props) $$invalidate(1, week = $$props.week);
    		if ("month" in $$props) $$invalidate(5, month = $$props.month);
    		if ("year" in $$props) $$invalidate(6, year = $$props.year);
    		if ("name" in $$props) $$invalidate(7, name = $$props.name);
    		if ("yearOptions" in $$props) $$invalidate(8, yearOptions = $$props.yearOptions);
    		if ("weekNumbers" in $$props) $$invalidate(2, weekNumbers = $$props.weekNumbers);
    	};

    	let weekNumbers;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*day, month, yearOptions, year, name*/ 496) {
    			 $$invalidate(2, weekNumbers = generateWeekNumbers(day, month, yearOptions[year], name));
    		}
    	};

    	return [
    		precision,
    		week,
    		weekNumbers,
    		onButtonClick,
    		day,
    		month,
    		year,
    		name,
    		yearOptions
    	];
    }

    class DatepickerOptionsWeeks extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
    			precision: 0,
    			day: 4,
    			week: 1,
    			month: 5,
    			year: 6,
    			name: 7,
    			yearOptions: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatepickerOptionsWeeks",
    			options,
    			id: create_fragment$5.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*precision*/ ctx[0] === undefined && !("precision" in props)) {
    			console.warn("<DatepickerOptionsWeeks> was created without expected prop 'precision'");
    		}

    		if (/*day*/ ctx[4] === undefined && !("day" in props)) {
    			console.warn("<DatepickerOptionsWeeks> was created without expected prop 'day'");
    		}

    		if (/*week*/ ctx[1] === undefined && !("week" in props)) {
    			console.warn("<DatepickerOptionsWeeks> was created without expected prop 'week'");
    		}

    		if (/*month*/ ctx[5] === undefined && !("month" in props)) {
    			console.warn("<DatepickerOptionsWeeks> was created without expected prop 'month'");
    		}

    		if (/*year*/ ctx[6] === undefined && !("year" in props)) {
    			console.warn("<DatepickerOptionsWeeks> was created without expected prop 'year'");
    		}

    		if (/*name*/ ctx[7] === undefined && !("name" in props)) {
    			console.warn("<DatepickerOptionsWeeks> was created without expected prop 'name'");
    		}

    		if (/*yearOptions*/ ctx[8] === undefined && !("yearOptions" in props)) {
    			console.warn("<DatepickerOptionsWeeks> was created without expected prop 'yearOptions'");
    		}
    	}

    	get precision() {
    		throw new Error("<DatepickerOptionsWeeks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precision(value) {
    		throw new Error("<DatepickerOptionsWeeks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get day() {
    		throw new Error("<DatepickerOptionsWeeks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set day(value) {
    		throw new Error("<DatepickerOptionsWeeks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get week() {
    		throw new Error("<DatepickerOptionsWeeks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set week(value) {
    		throw new Error("<DatepickerOptionsWeeks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get month() {
    		throw new Error("<DatepickerOptionsWeeks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set month(value) {
    		throw new Error("<DatepickerOptionsWeeks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get year() {
    		throw new Error("<DatepickerOptionsWeeks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set year(value) {
    		throw new Error("<DatepickerOptionsWeeks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<DatepickerOptionsWeeks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<DatepickerOptionsWeeks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yearOptions() {
    		throw new Error("<DatepickerOptionsWeeks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yearOptions(value) {
    		throw new Error("<DatepickerOptionsWeeks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/datepicker/DatepickerOptionsDays.svelte generated by Svelte v3.24.0 */
    const file$4 = "src/js/components/datepicker/DatepickerOptionsDays.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	child_ctx[16] = i;
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	return child_ctx;
    }

    // (46:4) {#each dayNames as dayName}
    function create_each_block_1(ctx) {
    	let li;
    	let int;
    	let t;
    	let current;

    	int = new Int({
    			props: { key: /*dayName*/ ctx[17] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(int.$$.fragment);
    			t = space();
    			attr_dev(li, "class", "txcm-datepickerDayName");
    			add_location(li, file$4, 46, 6, 1367);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(int, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(46:4) {#each dayNames as dayName}",
    		ctx
    	});

    	return block;
    }

    // (56:4) {#each dayOptions as dayOption, index}
    function create_each_block$1(ctx) {
    	let li;
    	let button;
    	let int;
    	let button_data_option_value;
    	let button_disabled_value;
    	let t;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*dayOption*/ ctx[14].day },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			create_component(int.$$.fragment);
    			t = space();
    			attr_dev(button, "class", "txcm-datepickerDayButton");
    			attr_dev(button, "data-option", button_data_option_value = /*index*/ ctx[16]);
    			button.disabled = button_disabled_value = /*dayOption*/ ctx[14].disabled;
    			toggle_class(button, "txcm-datepickerDayButton-is-active", /*isActive*/ ctx[6](/*dayOption*/ ctx[14], /*day*/ ctx[1], /*precision*/ ctx[0]));
    			toggle_class(button, "txcm-datepickerDayButton-is-padding", /*isPadding*/ ctx[7](/*dayOption*/ ctx[14], /*month*/ ctx[2], /*year*/ ctx[3]));
    			add_location(button, file$4, 58, 10, 1619);
    			attr_dev(li, "class", "txcm-datepickerDay");
    			add_location(li, file$4, 56, 6, 1569);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			mount_component(int, button, null);
    			append_dev(li, t);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onOptionClick*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*dayOptions*/ 16) int_changes.key = /*dayOption*/ ctx[14].day;
    			int.$set(int_changes);

    			if (!current || dirty & /*dayOptions*/ 16 && button_disabled_value !== (button_disabled_value = /*dayOption*/ ctx[14].disabled)) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}

    			if (dirty & /*isActive, dayOptions, day, precision*/ 83) {
    				toggle_class(button, "txcm-datepickerDayButton-is-active", /*isActive*/ ctx[6](/*dayOption*/ ctx[14], /*day*/ ctx[1], /*precision*/ ctx[0]));
    			}

    			if (dirty & /*isPadding, dayOptions, month, year*/ 156) {
    				toggle_class(button, "txcm-datepickerDayButton-is-padding", /*isPadding*/ ctx[7](/*dayOption*/ ctx[14], /*month*/ ctx[2], /*year*/ ctx[3]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(56:4) {#each dayOptions as dayOption, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let ol0;
    	let t;
    	let ol1;
    	let current;
    	let each_value_1 = /*dayNames*/ ctx[5];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	let each_value = /*dayOptions*/ ctx[4];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ol0 = element("ol");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t = space();
    			ol1 = element("ol");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ol0, "class", "txcm-datepickerDayNames");
    			add_location(ol0, file$4, 43, 0, 1290);
    			attr_dev(ol1, "class", "txcm-datepickerDays");
    			add_location(ol1, file$4, 53, 0, 1485);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ol0, anchor);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(ol0, null);
    			}

    			insert_dev(target, t, anchor);
    			insert_dev(target, ol1, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ol1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*dayNames*/ 32) {
    				each_value_1 = /*dayNames*/ ctx[5];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(ol0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*dayOptions, isActive, day, precision, isPadding, month, year, onOptionClick*/ 479) {
    				each_value = /*dayOptions*/ ctx[4];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ol1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ol0);
    			destroy_each(each_blocks_1, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(ol1);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { precision } = $$props;
    	let { day } = $$props;
    	let { week } = $$props;
    	let { month } = $$props;
    	let { year } = $$props;
    	let { name } = $$props;
    	let { yearOptions } = $$props;
    	const dayNames = ["Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Вс"];
    	const maxYear = yearOptions[yearOptions.length - 1];

    	function findYearOption(value) {
    		return yearOptions.indexOf(value);
    	}

    	function isActive(dayOption, day, precision) {
    		const yearOption = findYearOption(dayOption.year);
    		return precision === 0 && dayOption.day === day && dayOption.month === month && yearOption === year;
    	}

    	function isPadding(dayOption) {
    		const yearOption = findYearOption(dayOption.year);
    		return dayOption.month !== month || yearOption !== year;
    	}

    	function onOptionClick({ target }) {
    		const index = parseInt(target.dataset.option, 10);
    		const dayOption = dayOptions[index];
    		const yearOption = findYearOption(dayOption.year);
    		$$invalidate(0, precision = 0);
    		$$invalidate(1, { day, month } = dayOption, day, $$invalidate(2, month));
    		$$invalidate(3, year = yearOption);
    		$$invalidate(9, week = calculateWeekNumber(day, month, dayOption.year));
    	}

    	const writable_props = ["precision", "day", "week", "month", "year", "name", "yearOptions"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DatepickerOptionsDays> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DatepickerOptionsDays", $$slots, []);

    	$$self.$set = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("day" in $$props) $$invalidate(1, day = $$props.day);
    		if ("week" in $$props) $$invalidate(9, week = $$props.week);
    		if ("month" in $$props) $$invalidate(2, month = $$props.month);
    		if ("year" in $$props) $$invalidate(3, year = $$props.year);
    		if ("name" in $$props) $$invalidate(10, name = $$props.name);
    		if ("yearOptions" in $$props) $$invalidate(11, yearOptions = $$props.yearOptions);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		generateDayOptions,
    		calculateWeekNumber,
    		precision,
    		day,
    		week,
    		month,
    		year,
    		name,
    		yearOptions,
    		dayNames,
    		maxYear,
    		findYearOption,
    		isActive,
    		isPadding,
    		onOptionClick,
    		dayOptions
    	});

    	$$self.$inject_state = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("day" in $$props) $$invalidate(1, day = $$props.day);
    		if ("week" in $$props) $$invalidate(9, week = $$props.week);
    		if ("month" in $$props) $$invalidate(2, month = $$props.month);
    		if ("year" in $$props) $$invalidate(3, year = $$props.year);
    		if ("name" in $$props) $$invalidate(10, name = $$props.name);
    		if ("yearOptions" in $$props) $$invalidate(11, yearOptions = $$props.yearOptions);
    		if ("dayOptions" in $$props) $$invalidate(4, dayOptions = $$props.dayOptions);
    	};

    	let dayOptions;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*month, yearOptions, year, name*/ 3084) {
    			 $$invalidate(4, dayOptions = generateDayOptions(month, yearOptions[year], maxYear, name));
    		}
    	};

    	return [
    		precision,
    		day,
    		month,
    		year,
    		dayOptions,
    		dayNames,
    		isActive,
    		isPadding,
    		onOptionClick,
    		week,
    		name,
    		yearOptions
    	];
    }

    class DatepickerOptionsDays extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
    			precision: 0,
    			day: 1,
    			week: 9,
    			month: 2,
    			year: 3,
    			name: 10,
    			yearOptions: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatepickerOptionsDays",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*precision*/ ctx[0] === undefined && !("precision" in props)) {
    			console.warn("<DatepickerOptionsDays> was created without expected prop 'precision'");
    		}

    		if (/*day*/ ctx[1] === undefined && !("day" in props)) {
    			console.warn("<DatepickerOptionsDays> was created without expected prop 'day'");
    		}

    		if (/*week*/ ctx[9] === undefined && !("week" in props)) {
    			console.warn("<DatepickerOptionsDays> was created without expected prop 'week'");
    		}

    		if (/*month*/ ctx[2] === undefined && !("month" in props)) {
    			console.warn("<DatepickerOptionsDays> was created without expected prop 'month'");
    		}

    		if (/*year*/ ctx[3] === undefined && !("year" in props)) {
    			console.warn("<DatepickerOptionsDays> was created without expected prop 'year'");
    		}

    		if (/*name*/ ctx[10] === undefined && !("name" in props)) {
    			console.warn("<DatepickerOptionsDays> was created without expected prop 'name'");
    		}

    		if (/*yearOptions*/ ctx[11] === undefined && !("yearOptions" in props)) {
    			console.warn("<DatepickerOptionsDays> was created without expected prop 'yearOptions'");
    		}
    	}

    	get precision() {
    		throw new Error("<DatepickerOptionsDays>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precision(value) {
    		throw new Error("<DatepickerOptionsDays>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get day() {
    		throw new Error("<DatepickerOptionsDays>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set day(value) {
    		throw new Error("<DatepickerOptionsDays>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get week() {
    		throw new Error("<DatepickerOptionsDays>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set week(value) {
    		throw new Error("<DatepickerOptionsDays>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get month() {
    		throw new Error("<DatepickerOptionsDays>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set month(value) {
    		throw new Error("<DatepickerOptionsDays>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get year() {
    		throw new Error("<DatepickerOptionsDays>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set year(value) {
    		throw new Error("<DatepickerOptionsDays>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<DatepickerOptionsDays>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<DatepickerOptionsDays>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yearOptions() {
    		throw new Error("<DatepickerOptionsDays>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yearOptions(value) {
    		throw new Error("<DatepickerOptionsDays>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/datepicker/DatepickerSectionMonth.svelte generated by Svelte v3.24.0 */
    const file$5 = "src/js/components/datepicker/DatepickerSectionMonth.svelte";

    function create_fragment$7(ctx) {
    	let div;
    	let datepickerswitcher;
    	let updating_precision;
    	let updating_pick;
    	let t0;
    	let datepickeroptionweeks;
    	let updating_precision_1;
    	let updating_day;
    	let updating_week;
    	let updating_month;
    	let updating_year;
    	let t1;
    	let datepickeroptiondays;
    	let updating_precision_2;
    	let updating_day_1;
    	let updating_week_1;
    	let updating_month_1;
    	let updating_year_1;
    	let div_class_value;
    	let current;

    	function datepickerswitcher_precision_binding(value) {
    		/*datepickerswitcher_precision_binding*/ ctx[12].call(null, value);
    	}

    	function datepickerswitcher_pick_binding(value) {
    		/*datepickerswitcher_pick_binding*/ ctx[13].call(null, value);
    	}

    	let datepickerswitcher_props = {
    		options: /*pickOptions*/ ctx[9],
    		precisionOption: 2
    	};

    	if (/*precision*/ ctx[0] !== void 0) {
    		datepickerswitcher_props.precision = /*precision*/ ctx[0];
    	}

    	if (/*month*/ ctx[3] !== void 0) {
    		datepickerswitcher_props.pick = /*month*/ ctx[3];
    	}

    	datepickerswitcher = new DatepickerSwitcher({
    			props: datepickerswitcher_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(datepickerswitcher, "precision", datepickerswitcher_precision_binding));
    	binding_callbacks.push(() => bind(datepickerswitcher, "pick", datepickerswitcher_pick_binding));

    	function datepickeroptionweeks_precision_binding(value) {
    		/*datepickeroptionweeks_precision_binding*/ ctx[14].call(null, value);
    	}

    	function datepickeroptionweeks_day_binding(value) {
    		/*datepickeroptionweeks_day_binding*/ ctx[15].call(null, value);
    	}

    	function datepickeroptionweeks_week_binding(value) {
    		/*datepickeroptionweeks_week_binding*/ ctx[16].call(null, value);
    	}

    	function datepickeroptionweeks_month_binding(value) {
    		/*datepickeroptionweeks_month_binding*/ ctx[17].call(null, value);
    	}

    	function datepickeroptionweeks_year_binding(value) {
    		/*datepickeroptionweeks_year_binding*/ ctx[18].call(null, value);
    	}

    	let datepickeroptionweeks_props = {
    		name: /*name*/ ctx[5],
    		lowerLimit: /*lowerLimit*/ ctx[6],
    		upperLimit: /*upperLimit*/ ctx[7],
    		yearOptions: /*yearOptions*/ ctx[8]
    	};

    	if (/*precision*/ ctx[0] !== void 0) {
    		datepickeroptionweeks_props.precision = /*precision*/ ctx[0];
    	}

    	if (/*day*/ ctx[1] !== void 0) {
    		datepickeroptionweeks_props.day = /*day*/ ctx[1];
    	}

    	if (/*week*/ ctx[2] !== void 0) {
    		datepickeroptionweeks_props.week = /*week*/ ctx[2];
    	}

    	if (/*month*/ ctx[3] !== void 0) {
    		datepickeroptionweeks_props.month = /*month*/ ctx[3];
    	}

    	if (/*year*/ ctx[4] !== void 0) {
    		datepickeroptionweeks_props.year = /*year*/ ctx[4];
    	}

    	datepickeroptionweeks = new DatepickerOptionsWeeks({
    			props: datepickeroptionweeks_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(datepickeroptionweeks, "precision", datepickeroptionweeks_precision_binding));
    	binding_callbacks.push(() => bind(datepickeroptionweeks, "day", datepickeroptionweeks_day_binding));
    	binding_callbacks.push(() => bind(datepickeroptionweeks, "week", datepickeroptionweeks_week_binding));
    	binding_callbacks.push(() => bind(datepickeroptionweeks, "month", datepickeroptionweeks_month_binding));
    	binding_callbacks.push(() => bind(datepickeroptionweeks, "year", datepickeroptionweeks_year_binding));

    	function datepickeroptiondays_precision_binding(value) {
    		/*datepickeroptiondays_precision_binding*/ ctx[19].call(null, value);
    	}

    	function datepickeroptiondays_day_binding(value) {
    		/*datepickeroptiondays_day_binding*/ ctx[20].call(null, value);
    	}

    	function datepickeroptiondays_week_binding(value) {
    		/*datepickeroptiondays_week_binding*/ ctx[21].call(null, value);
    	}

    	function datepickeroptiondays_month_binding(value) {
    		/*datepickeroptiondays_month_binding*/ ctx[22].call(null, value);
    	}

    	function datepickeroptiondays_year_binding(value) {
    		/*datepickeroptiondays_year_binding*/ ctx[23].call(null, value);
    	}

    	let datepickeroptiondays_props = {
    		name: /*name*/ ctx[5],
    		lowerLimit: /*lowerLimit*/ ctx[6],
    		upperLimit: /*upperLimit*/ ctx[7],
    		yearOptions: /*yearOptions*/ ctx[8]
    	};

    	if (/*precision*/ ctx[0] !== void 0) {
    		datepickeroptiondays_props.precision = /*precision*/ ctx[0];
    	}

    	if (/*day*/ ctx[1] !== void 0) {
    		datepickeroptiondays_props.day = /*day*/ ctx[1];
    	}

    	if (/*week*/ ctx[2] !== void 0) {
    		datepickeroptiondays_props.week = /*week*/ ctx[2];
    	}

    	if (/*month*/ ctx[3] !== void 0) {
    		datepickeroptiondays_props.month = /*month*/ ctx[3];
    	}

    	if (/*year*/ ctx[4] !== void 0) {
    		datepickeroptiondays_props.year = /*year*/ ctx[4];
    	}

    	datepickeroptiondays = new DatepickerOptionsDays({
    			props: datepickeroptiondays_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(datepickeroptiondays, "precision", datepickeroptiondays_precision_binding));
    	binding_callbacks.push(() => bind(datepickeroptiondays, "day", datepickeroptiondays_day_binding));
    	binding_callbacks.push(() => bind(datepickeroptiondays, "week", datepickeroptiondays_week_binding));
    	binding_callbacks.push(() => bind(datepickeroptiondays, "month", datepickeroptiondays_month_binding));
    	binding_callbacks.push(() => bind(datepickeroptiondays, "year", datepickeroptiondays_year_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(datepickerswitcher.$$.fragment);
    			t0 = space();
    			create_component(datepickeroptionweeks.$$.fragment);
    			t1 = space();
    			create_component(datepickeroptiondays.$$.fragment);
    			attr_dev(div, "class", div_class_value = `txcm-datepickerSection ${/*renderStatus*/ ctx[10](/*precision*/ ctx[0])}`);
    			add_location(div, file$5, 29, 0, 740);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(datepickerswitcher, div, null);
    			append_dev(div, t0);
    			mount_component(datepickeroptionweeks, div, null);
    			append_dev(div, t1);
    			mount_component(datepickeroptiondays, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const datepickerswitcher_changes = {};
    			if (dirty & /*pickOptions*/ 512) datepickerswitcher_changes.options = /*pickOptions*/ ctx[9];

    			if (!updating_precision && dirty & /*precision*/ 1) {
    				updating_precision = true;
    				datepickerswitcher_changes.precision = /*precision*/ ctx[0];
    				add_flush_callback(() => updating_precision = false);
    			}

    			if (!updating_pick && dirty & /*month*/ 8) {
    				updating_pick = true;
    				datepickerswitcher_changes.pick = /*month*/ ctx[3];
    				add_flush_callback(() => updating_pick = false);
    			}

    			datepickerswitcher.$set(datepickerswitcher_changes);
    			const datepickeroptionweeks_changes = {};
    			if (dirty & /*name*/ 32) datepickeroptionweeks_changes.name = /*name*/ ctx[5];
    			if (dirty & /*lowerLimit*/ 64) datepickeroptionweeks_changes.lowerLimit = /*lowerLimit*/ ctx[6];
    			if (dirty & /*upperLimit*/ 128) datepickeroptionweeks_changes.upperLimit = /*upperLimit*/ ctx[7];
    			if (dirty & /*yearOptions*/ 256) datepickeroptionweeks_changes.yearOptions = /*yearOptions*/ ctx[8];

    			if (!updating_precision_1 && dirty & /*precision*/ 1) {
    				updating_precision_1 = true;
    				datepickeroptionweeks_changes.precision = /*precision*/ ctx[0];
    				add_flush_callback(() => updating_precision_1 = false);
    			}

    			if (!updating_day && dirty & /*day*/ 2) {
    				updating_day = true;
    				datepickeroptionweeks_changes.day = /*day*/ ctx[1];
    				add_flush_callback(() => updating_day = false);
    			}

    			if (!updating_week && dirty & /*week*/ 4) {
    				updating_week = true;
    				datepickeroptionweeks_changes.week = /*week*/ ctx[2];
    				add_flush_callback(() => updating_week = false);
    			}

    			if (!updating_month && dirty & /*month*/ 8) {
    				updating_month = true;
    				datepickeroptionweeks_changes.month = /*month*/ ctx[3];
    				add_flush_callback(() => updating_month = false);
    			}

    			if (!updating_year && dirty & /*year*/ 16) {
    				updating_year = true;
    				datepickeroptionweeks_changes.year = /*year*/ ctx[4];
    				add_flush_callback(() => updating_year = false);
    			}

    			datepickeroptionweeks.$set(datepickeroptionweeks_changes);
    			const datepickeroptiondays_changes = {};
    			if (dirty & /*name*/ 32) datepickeroptiondays_changes.name = /*name*/ ctx[5];
    			if (dirty & /*lowerLimit*/ 64) datepickeroptiondays_changes.lowerLimit = /*lowerLimit*/ ctx[6];
    			if (dirty & /*upperLimit*/ 128) datepickeroptiondays_changes.upperLimit = /*upperLimit*/ ctx[7];
    			if (dirty & /*yearOptions*/ 256) datepickeroptiondays_changes.yearOptions = /*yearOptions*/ ctx[8];

    			if (!updating_precision_2 && dirty & /*precision*/ 1) {
    				updating_precision_2 = true;
    				datepickeroptiondays_changes.precision = /*precision*/ ctx[0];
    				add_flush_callback(() => updating_precision_2 = false);
    			}

    			if (!updating_day_1 && dirty & /*day*/ 2) {
    				updating_day_1 = true;
    				datepickeroptiondays_changes.day = /*day*/ ctx[1];
    				add_flush_callback(() => updating_day_1 = false);
    			}

    			if (!updating_week_1 && dirty & /*week*/ 4) {
    				updating_week_1 = true;
    				datepickeroptiondays_changes.week = /*week*/ ctx[2];
    				add_flush_callback(() => updating_week_1 = false);
    			}

    			if (!updating_month_1 && dirty & /*month*/ 8) {
    				updating_month_1 = true;
    				datepickeroptiondays_changes.month = /*month*/ ctx[3];
    				add_flush_callback(() => updating_month_1 = false);
    			}

    			if (!updating_year_1 && dirty & /*year*/ 16) {
    				updating_year_1 = true;
    				datepickeroptiondays_changes.year = /*year*/ ctx[4];
    				add_flush_callback(() => updating_year_1 = false);
    			}

    			datepickeroptiondays.$set(datepickeroptiondays_changes);

    			if (!current || dirty & /*precision*/ 1 && div_class_value !== (div_class_value = `txcm-datepickerSection ${/*renderStatus*/ ctx[10](/*precision*/ ctx[0])}`)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(datepickerswitcher.$$.fragment, local);
    			transition_in(datepickeroptionweeks.$$.fragment, local);
    			transition_in(datepickeroptiondays.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(datepickerswitcher.$$.fragment, local);
    			transition_out(datepickeroptionweeks.$$.fragment, local);
    			transition_out(datepickeroptiondays.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(datepickerswitcher);
    			destroy_component(datepickeroptionweeks);
    			destroy_component(datepickeroptiondays);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let { precision } = $$props;
    	let { day } = $$props;
    	let { week } = $$props;
    	let { month } = $$props;
    	let { year } = $$props;
    	let { name } = $$props;
    	let { lowerLimit } = $$props;
    	let { upperLimit } = $$props;
    	let { monthOptions } = $$props;
    	let { yearOptions } = $$props;

    	function updateOptions() {
    		return monthOptions.map(item => item.month);
    	}

    	function renderStatus() {
    		if (precision <= 1) return "txcm-datepickerSection-month-is-active";
    		return "txcm-datepickerSection-month-is-inactive";
    	}

    	const writable_props = [
    		"precision",
    		"day",
    		"week",
    		"month",
    		"year",
    		"name",
    		"lowerLimit",
    		"upperLimit",
    		"monthOptions",
    		"yearOptions"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DatepickerSectionMonth> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DatepickerSectionMonth", $$slots, []);

    	function datepickerswitcher_precision_binding(value) {
    		precision = value;
    		$$invalidate(0, precision);
    	}

    	function datepickerswitcher_pick_binding(value) {
    		month = value;
    		$$invalidate(3, month);
    	}

    	function datepickeroptionweeks_precision_binding(value) {
    		precision = value;
    		$$invalidate(0, precision);
    	}

    	function datepickeroptionweeks_day_binding(value) {
    		day = value;
    		$$invalidate(1, day);
    	}

    	function datepickeroptionweeks_week_binding(value) {
    		week = value;
    		$$invalidate(2, week);
    	}

    	function datepickeroptionweeks_month_binding(value) {
    		month = value;
    		$$invalidate(3, month);
    	}

    	function datepickeroptionweeks_year_binding(value) {
    		year = value;
    		$$invalidate(4, year);
    	}

    	function datepickeroptiondays_precision_binding(value) {
    		precision = value;
    		$$invalidate(0, precision);
    	}

    	function datepickeroptiondays_day_binding(value) {
    		day = value;
    		$$invalidate(1, day);
    	}

    	function datepickeroptiondays_week_binding(value) {
    		week = value;
    		$$invalidate(2, week);
    	}

    	function datepickeroptiondays_month_binding(value) {
    		month = value;
    		$$invalidate(3, month);
    	}

    	function datepickeroptiondays_year_binding(value) {
    		year = value;
    		$$invalidate(4, year);
    	}

    	$$self.$set = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("day" in $$props) $$invalidate(1, day = $$props.day);
    		if ("week" in $$props) $$invalidate(2, week = $$props.week);
    		if ("month" in $$props) $$invalidate(3, month = $$props.month);
    		if ("year" in $$props) $$invalidate(4, year = $$props.year);
    		if ("name" in $$props) $$invalidate(5, name = $$props.name);
    		if ("lowerLimit" in $$props) $$invalidate(6, lowerLimit = $$props.lowerLimit);
    		if ("upperLimit" in $$props) $$invalidate(7, upperLimit = $$props.upperLimit);
    		if ("monthOptions" in $$props) $$invalidate(11, monthOptions = $$props.monthOptions);
    		if ("yearOptions" in $$props) $$invalidate(8, yearOptions = $$props.yearOptions);
    	};

    	$$self.$capture_state = () => ({
    		DatepickerSwitcher,
    		DatepickerOptionWeeks: DatepickerOptionsWeeks,
    		DatepickerOptionDays: DatepickerOptionsDays,
    		precision,
    		day,
    		week,
    		month,
    		year,
    		name,
    		lowerLimit,
    		upperLimit,
    		monthOptions,
    		yearOptions,
    		updateOptions,
    		renderStatus,
    		pickOptions
    	});

    	$$self.$inject_state = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("day" in $$props) $$invalidate(1, day = $$props.day);
    		if ("week" in $$props) $$invalidate(2, week = $$props.week);
    		if ("month" in $$props) $$invalidate(3, month = $$props.month);
    		if ("year" in $$props) $$invalidate(4, year = $$props.year);
    		if ("name" in $$props) $$invalidate(5, name = $$props.name);
    		if ("lowerLimit" in $$props) $$invalidate(6, lowerLimit = $$props.lowerLimit);
    		if ("upperLimit" in $$props) $$invalidate(7, upperLimit = $$props.upperLimit);
    		if ("monthOptions" in $$props) $$invalidate(11, monthOptions = $$props.monthOptions);
    		if ("yearOptions" in $$props) $$invalidate(8, yearOptions = $$props.yearOptions);
    		if ("pickOptions" in $$props) $$invalidate(9, pickOptions = $$props.pickOptions);
    	};

    	let pickOptions;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*monthOptions*/ 2048) {
    			 $$invalidate(9, pickOptions = updateOptions());
    		}
    	};

    	return [
    		precision,
    		day,
    		week,
    		month,
    		year,
    		name,
    		lowerLimit,
    		upperLimit,
    		yearOptions,
    		pickOptions,
    		renderStatus,
    		monthOptions,
    		datepickerswitcher_precision_binding,
    		datepickerswitcher_pick_binding,
    		datepickeroptionweeks_precision_binding,
    		datepickeroptionweeks_day_binding,
    		datepickeroptionweeks_week_binding,
    		datepickeroptionweeks_month_binding,
    		datepickeroptionweeks_year_binding,
    		datepickeroptiondays_precision_binding,
    		datepickeroptiondays_day_binding,
    		datepickeroptiondays_week_binding,
    		datepickeroptiondays_month_binding,
    		datepickeroptiondays_year_binding
    	];
    }

    class DatepickerSectionMonth extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {
    			precision: 0,
    			day: 1,
    			week: 2,
    			month: 3,
    			year: 4,
    			name: 5,
    			lowerLimit: 6,
    			upperLimit: 7,
    			monthOptions: 11,
    			yearOptions: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatepickerSectionMonth",
    			options,
    			id: create_fragment$7.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*precision*/ ctx[0] === undefined && !("precision" in props)) {
    			console.warn("<DatepickerSectionMonth> was created without expected prop 'precision'");
    		}

    		if (/*day*/ ctx[1] === undefined && !("day" in props)) {
    			console.warn("<DatepickerSectionMonth> was created without expected prop 'day'");
    		}

    		if (/*week*/ ctx[2] === undefined && !("week" in props)) {
    			console.warn("<DatepickerSectionMonth> was created without expected prop 'week'");
    		}

    		if (/*month*/ ctx[3] === undefined && !("month" in props)) {
    			console.warn("<DatepickerSectionMonth> was created without expected prop 'month'");
    		}

    		if (/*year*/ ctx[4] === undefined && !("year" in props)) {
    			console.warn("<DatepickerSectionMonth> was created without expected prop 'year'");
    		}

    		if (/*name*/ ctx[5] === undefined && !("name" in props)) {
    			console.warn("<DatepickerSectionMonth> was created without expected prop 'name'");
    		}

    		if (/*lowerLimit*/ ctx[6] === undefined && !("lowerLimit" in props)) {
    			console.warn("<DatepickerSectionMonth> was created without expected prop 'lowerLimit'");
    		}

    		if (/*upperLimit*/ ctx[7] === undefined && !("upperLimit" in props)) {
    			console.warn("<DatepickerSectionMonth> was created without expected prop 'upperLimit'");
    		}

    		if (/*monthOptions*/ ctx[11] === undefined && !("monthOptions" in props)) {
    			console.warn("<DatepickerSectionMonth> was created without expected prop 'monthOptions'");
    		}

    		if (/*yearOptions*/ ctx[8] === undefined && !("yearOptions" in props)) {
    			console.warn("<DatepickerSectionMonth> was created without expected prop 'yearOptions'");
    		}
    	}

    	get precision() {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precision(value) {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get day() {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set day(value) {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get week() {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set week(value) {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get month() {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set month(value) {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get year() {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set year(value) {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lowerLimit() {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lowerLimit(value) {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get upperLimit() {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set upperLimit(value) {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get monthOptions() {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set monthOptions(value) {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yearOptions() {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yearOptions(value) {
    		throw new Error("<DatepickerSectionMonth>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/datepicker/DatepickerOptionsQuarters.svelte generated by Svelte v3.24.0 */
    const file$6 = "src/js/components/datepicker/DatepickerOptionsQuarters.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[22] = i;
    	return child_ctx;
    }

    // (83:4) {#each newQuarterOptions as quarterOption, index}
    function create_each_block$2(ctx) {
    	let li;
    	let button;
    	let int;
    	let button_data_option_value;
    	let button_disabled_value;
    	let t;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*quarterOption*/ ctx[20].name },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			create_component(int.$$.fragment);
    			t = space();
    			attr_dev(button, "class", "txcm-datepickerQuarterButton");
    			attr_dev(button, "data-option", button_data_option_value = /*index*/ ctx[22]);
    			button.disabled = button_disabled_value = /*checkDisabled*/ ctx[8](/*index*/ ctx[22], /*year*/ ctx[2]);
    			toggle_class(button, "txcm-datepickerQuarterButton-is-active", /*isActive*/ ctx[4](/*index*/ ctx[22], /*quarter*/ ctx[1], /*precision*/ ctx[0]));
    			add_location(button, file$6, 85, 10, 2731);
    			attr_dev(li, "class", "txcm-datepickerQuarter");
    			add_location(li, file$6, 83, 6, 2677);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			mount_component(int, button, null);
    			append_dev(li, t);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*onOptionClick*/ ctx[5], false, false, false),
    					listen_dev(button, "mouseover", /*onOptionMouseOver*/ ctx[6], false, false, false),
    					listen_dev(button, "mouseout", /*onOptionMouseOut*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*newQuarterOptions*/ 8) int_changes.key = /*quarterOption*/ ctx[20].name;
    			int.$set(int_changes);

    			if (!current || dirty & /*year*/ 4 && button_disabled_value !== (button_disabled_value = /*checkDisabled*/ ctx[8](/*index*/ ctx[22], /*year*/ ctx[2]))) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}

    			if (dirty & /*isActive, quarter, precision*/ 19) {
    				toggle_class(button, "txcm-datepickerQuarterButton-is-active", /*isActive*/ ctx[4](/*index*/ ctx[22], /*quarter*/ ctx[1], /*precision*/ ctx[0]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(int);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(83:4) {#each newQuarterOptions as quarterOption, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let ol;
    	let current;
    	let each_value = /*newQuarterOptions*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ol = element("ol");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ol, "class", "txcm-datepickerQuarters");
    			add_location(ol, file$6, 80, 0, 2578);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ol, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ol, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*checkDisabled, year, isActive, quarter, precision, onOptionClick, onOptionMouseOver, onOptionMouseOut, newQuarterOptions*/ 511) {
    				each_value = /*newQuarterOptions*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ol, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ol);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let { precision } = $$props;
    	let { month } = $$props;
    	let { quarter } = $$props;
    	let { year } = $$props;
    	let { lowerLimit } = $$props;
    	let { upperLimit } = $$props;
    	let { highlitedQuarter = null } = $$props;
    	let { yearOptions } = $$props;
    	let { quarterOptions } = $$props;
    	let { name } = $$props;
    	const appConfig = getContext("app").getAppConfig();

    	function updateQuarter() {
    		const opts = [];
    		const { dateMin } = appConfig;
    		const yearMin = new Date(dateMin).getFullYear() + year;

    		for (let index = 0; index < 4; ++index) {
    			const startOfQuarter = moment([yearMin, index * 3]).startOf("quarter");
    			const endOfQuarter = moment([yearMin, index * 3]).endOf("quarter");
    			const availDays = generateAvailableDays(startOfQuarter.toDate(), endOfQuarter.toDate(), precision, name);

    			opts.push({
    				disabled: !availDays.length,
    				name: quarterOptions[index]
    			});
    		}

    		return opts;
    	}

    	function updateLimits() {
    		return {
    			year: yearOptions[year],
    			lowerLimitYear: lowerLimit ? new Date(lowerLimit).getFullYear() : -10000,
    			lowerLimitQuarter: lowerLimit ? calculateQuarter(lowerLimit) : -10000,
    			upperLimitYear: upperLimit ? new Date(upperLimit).getFullYear() : 10000,
    			upperLimitQuarter: upperLimit ? calculateQuarter(upperLimit) : 10000
    		};
    	}

    	function isActive(index) {
    		return precision === 3 && index === quarter;
    	}

    	function onOptionClick({ target }) {
    		$$invalidate(0, precision = 3);
    		$$invalidate(1, quarter = parseInt(target.dataset.option, 10));
    		$$invalidate(9, month = quarter * 3);
    	}

    	function onOptionMouseOver({ target }) {
    		$$invalidate(10, highlitedQuarter = parseInt(target.dataset.option, 10));
    	}

    	function onOptionMouseOut() {
    		$$invalidate(10, highlitedQuarter = null);
    	}

    	function checkDisabled(option) {
    		const optionQuarter = option + 1;
    		const isLowerYear = limits.year > limits.upperLimitYear;
    		const isUpperYear = limits.year < limits.lowerLimitYear;
    		const isLowerQuarter = limits.year === limits.upperLimitYear && optionQuarter > limits.upperLimitQuarter;
    		const isUpperQuarter = limits.year === limits.lowerLimitYear && optionQuarter < limits.lowerLimitQuarter;
    		return isLowerYear || isUpperYear || isLowerQuarter || isUpperQuarter;
    	}

    	const writable_props = [
    		"precision",
    		"month",
    		"quarter",
    		"year",
    		"lowerLimit",
    		"upperLimit",
    		"highlitedQuarter",
    		"yearOptions",
    		"quarterOptions",
    		"name"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DatepickerOptionsQuarters> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DatepickerOptionsQuarters", $$slots, []);

    	$$self.$set = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("month" in $$props) $$invalidate(9, month = $$props.month);
    		if ("quarter" in $$props) $$invalidate(1, quarter = $$props.quarter);
    		if ("year" in $$props) $$invalidate(2, year = $$props.year);
    		if ("lowerLimit" in $$props) $$invalidate(11, lowerLimit = $$props.lowerLimit);
    		if ("upperLimit" in $$props) $$invalidate(12, upperLimit = $$props.upperLimit);
    		if ("highlitedQuarter" in $$props) $$invalidate(10, highlitedQuarter = $$props.highlitedQuarter);
    		if ("yearOptions" in $$props) $$invalidate(13, yearOptions = $$props.yearOptions);
    		if ("quarterOptions" in $$props) $$invalidate(14, quarterOptions = $$props.quarterOptions);
    		if ("name" in $$props) $$invalidate(15, name = $$props.name);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		Int,
    		calculateQuarter,
    		moment,
    		generateAvailableDays,
    		precision,
    		month,
    		quarter,
    		year,
    		lowerLimit,
    		upperLimit,
    		highlitedQuarter,
    		yearOptions,
    		quarterOptions,
    		name,
    		appConfig,
    		updateQuarter,
    		updateLimits,
    		isActive,
    		onOptionClick,
    		onOptionMouseOver,
    		onOptionMouseOut,
    		checkDisabled,
    		limits,
    		newQuarterOptions
    	});

    	$$self.$inject_state = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("month" in $$props) $$invalidate(9, month = $$props.month);
    		if ("quarter" in $$props) $$invalidate(1, quarter = $$props.quarter);
    		if ("year" in $$props) $$invalidate(2, year = $$props.year);
    		if ("lowerLimit" in $$props) $$invalidate(11, lowerLimit = $$props.lowerLimit);
    		if ("upperLimit" in $$props) $$invalidate(12, upperLimit = $$props.upperLimit);
    		if ("highlitedQuarter" in $$props) $$invalidate(10, highlitedQuarter = $$props.highlitedQuarter);
    		if ("yearOptions" in $$props) $$invalidate(13, yearOptions = $$props.yearOptions);
    		if ("quarterOptions" in $$props) $$invalidate(14, quarterOptions = $$props.quarterOptions);
    		if ("name" in $$props) $$invalidate(15, name = $$props.name);
    		if ("limits" in $$props) limits = $$props.limits;
    		if ("newQuarterOptions" in $$props) $$invalidate(3, newQuarterOptions = $$props.newQuarterOptions);
    	};

    	let limits;
    	let newQuarterOptions;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*year, lowerLimit, upperLimit*/ 6148) {
    			 limits = updateLimits();
    		}

    		if ($$self.$$.dirty & /*year, quarterOptions, name*/ 49156) {
    			 $$invalidate(3, newQuarterOptions = updateQuarter());
    		}
    	};

    	return [
    		precision,
    		quarter,
    		year,
    		newQuarterOptions,
    		isActive,
    		onOptionClick,
    		onOptionMouseOver,
    		onOptionMouseOut,
    		checkDisabled,
    		month,
    		highlitedQuarter,
    		lowerLimit,
    		upperLimit,
    		yearOptions,
    		quarterOptions,
    		name
    	];
    }

    class DatepickerOptionsQuarters extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
    			precision: 0,
    			month: 9,
    			quarter: 1,
    			year: 2,
    			lowerLimit: 11,
    			upperLimit: 12,
    			highlitedQuarter: 10,
    			yearOptions: 13,
    			quarterOptions: 14,
    			name: 15
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatepickerOptionsQuarters",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*precision*/ ctx[0] === undefined && !("precision" in props)) {
    			console.warn("<DatepickerOptionsQuarters> was created without expected prop 'precision'");
    		}

    		if (/*month*/ ctx[9] === undefined && !("month" in props)) {
    			console.warn("<DatepickerOptionsQuarters> was created without expected prop 'month'");
    		}

    		if (/*quarter*/ ctx[1] === undefined && !("quarter" in props)) {
    			console.warn("<DatepickerOptionsQuarters> was created without expected prop 'quarter'");
    		}

    		if (/*year*/ ctx[2] === undefined && !("year" in props)) {
    			console.warn("<DatepickerOptionsQuarters> was created without expected prop 'year'");
    		}

    		if (/*lowerLimit*/ ctx[11] === undefined && !("lowerLimit" in props)) {
    			console.warn("<DatepickerOptionsQuarters> was created without expected prop 'lowerLimit'");
    		}

    		if (/*upperLimit*/ ctx[12] === undefined && !("upperLimit" in props)) {
    			console.warn("<DatepickerOptionsQuarters> was created without expected prop 'upperLimit'");
    		}

    		if (/*yearOptions*/ ctx[13] === undefined && !("yearOptions" in props)) {
    			console.warn("<DatepickerOptionsQuarters> was created without expected prop 'yearOptions'");
    		}

    		if (/*quarterOptions*/ ctx[14] === undefined && !("quarterOptions" in props)) {
    			console.warn("<DatepickerOptionsQuarters> was created without expected prop 'quarterOptions'");
    		}

    		if (/*name*/ ctx[15] === undefined && !("name" in props)) {
    			console.warn("<DatepickerOptionsQuarters> was created without expected prop 'name'");
    		}
    	}

    	get precision() {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precision(value) {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get month() {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set month(value) {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get quarter() {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set quarter(value) {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get year() {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set year(value) {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lowerLimit() {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lowerLimit(value) {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get upperLimit() {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set upperLimit(value) {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get highlitedQuarter() {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set highlitedQuarter(value) {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yearOptions() {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yearOptions(value) {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get quarterOptions() {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set quarterOptions(value) {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<DatepickerOptionsQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/datepicker/DatepickerOptionsMonths.svelte generated by Svelte v3.24.0 */

    const { console: console_1$1 } = globals;
    const file$7 = "src/js/components/datepicker/DatepickerOptionsMonths.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[15] = list[i];
    	child_ctx[17] = i;
    	return child_ctx;
    }

    // (57:4) {#each monthOptions as monthOption, index}
    function create_each_block$3(ctx) {
    	let li;
    	let button;
    	let int;
    	let button_data_option_value;
    	let button_disabled_value;
    	let t;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*monthOption*/ ctx[15].month },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			create_component(int.$$.fragment);
    			t = space();
    			attr_dev(button, "class", "txcm-datepickerMonthButton");
    			attr_dev(button, "data-option", button_data_option_value = /*index*/ ctx[17]);
    			button.disabled = button_disabled_value = /*checkDisabled*/ ctx[9](/*index*/ ctx[17], /*year*/ ctx[3]);
    			toggle_class(button, "txcm-datepickerMonthButton-is-active", /*isActive*/ ctx[6](/*index*/ ctx[17], /*month*/ ctx[1], /*precision*/ ctx[0]));
    			toggle_class(button, "txcm-datepickerMonthButton-is-highlighted", /*isHighlighted*/ ctx[7](/*index*/ ctx[17], /*quarter*/ ctx[2], /*precision*/ ctx[0], /*highlitedQuarter*/ ctx[4]));
    			add_location(button, file$7, 59, 10, 1940);
    			attr_dev(li, "class", "txcm-datepickerMonth");
    			add_location(li, file$7, 57, 6, 1888);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			mount_component(int, button, null);
    			append_dev(li, t);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onOptionClick*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*monthOptions*/ 32) int_changes.key = /*monthOption*/ ctx[15].month;
    			int.$set(int_changes);

    			if (!current || dirty & /*year*/ 8 && button_disabled_value !== (button_disabled_value = /*checkDisabled*/ ctx[9](/*index*/ ctx[17], /*year*/ ctx[3]))) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}

    			if (dirty & /*isActive, month, precision*/ 67) {
    				toggle_class(button, "txcm-datepickerMonthButton-is-active", /*isActive*/ ctx[6](/*index*/ ctx[17], /*month*/ ctx[1], /*precision*/ ctx[0]));
    			}

    			if (dirty & /*isHighlighted, quarter, precision, highlitedQuarter*/ 149) {
    				toggle_class(button, "txcm-datepickerMonthButton-is-highlighted", /*isHighlighted*/ ctx[7](/*index*/ ctx[17], /*quarter*/ ctx[2], /*precision*/ ctx[0], /*highlitedQuarter*/ ctx[4]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(57:4) {#each monthOptions as monthOption, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let ol;
    	let current;
    	let each_value = /*monthOptions*/ ctx[5];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ol = element("ol");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ol, "class", "txcm-datepickerMonths");
    			add_location(ol, file$7, 54, 0, 1798);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ol, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ol, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*checkDisabled, year, isActive, month, precision, isHighlighted, quarter, highlitedQuarter, onOptionClick, monthOptions*/ 1023) {
    				each_value = /*monthOptions*/ ctx[5];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ol, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ol);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let { precision } = $$props;
    	let { month } = $$props;
    	let { quarter } = $$props;
    	let { year } = $$props;
    	let { lowerLimit } = $$props;
    	let { upperLimit } = $$props;
    	let { highlitedQuarter = null } = $$props;
    	let { monthOptions } = $$props;
    	let { yearOptions } = $$props;

    	function updateLimits() {
    		const lowerLimitDate = new Date(lowerLimit);
    		const upperLimitDate = new Date(upperLimit);
    		console.log("UPPER", lowerLimitDate, upperLimitDate);

    		return {
    			year: yearOptions[year],
    			lowerLimitYear: lowerLimit ? lowerLimitDate.getFullYear() : -10000,
    			lowerLimitMonth: lowerLimit ? lowerLimitDate.getMonth() : -10000,
    			upperLimitYear: upperLimit ? upperLimitDate.getFullYear() : 10000,
    			upperLimitMonth: upperLimit ? upperLimitDate.getMonth() : 10000
    		};
    	}

    	function isActive(index) {
    		return precision === 2 && index === month;
    	}

    	function isHighlighted(index) {
    		const monthQuarter = Math.floor(index / 3);
    		return precision === 3 && monthQuarter === quarter || highlitedQuarter === monthQuarter;
    	}

    	function onOptionClick({ target }) {
    		$$invalidate(0, precision = 2);
    		$$invalidate(1, month = parseInt(target.dataset.option, 10));
    		$$invalidate(2, quarter = Math.floor(month / 3));
    	}

    	function checkDisabled(option) {
    		const optionMonth = option;
    		const isLowerYear = limits.year > limits.upperLimitYear;
    		const isUpperYear = limits.year < limits.lowerLimitYear;
    		const isLowerMonth = limits.year === limits.upperLimitYear && optionMonth > limits.upperLimitMonth;
    		const isUpperMonth = limits.year === limits.lowerLimitYear && optionMonth < limits.lowerLimitMonth;
    		return isLowerYear || isUpperYear || isLowerMonth || isUpperMonth;
    	}

    	const writable_props = [
    		"precision",
    		"month",
    		"quarter",
    		"year",
    		"lowerLimit",
    		"upperLimit",
    		"highlitedQuarter",
    		"monthOptions",
    		"yearOptions"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<DatepickerOptionsMonths> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DatepickerOptionsMonths", $$slots, []);

    	$$self.$set = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("month" in $$props) $$invalidate(1, month = $$props.month);
    		if ("quarter" in $$props) $$invalidate(2, quarter = $$props.quarter);
    		if ("year" in $$props) $$invalidate(3, year = $$props.year);
    		if ("lowerLimit" in $$props) $$invalidate(10, lowerLimit = $$props.lowerLimit);
    		if ("upperLimit" in $$props) $$invalidate(11, upperLimit = $$props.upperLimit);
    		if ("highlitedQuarter" in $$props) $$invalidate(4, highlitedQuarter = $$props.highlitedQuarter);
    		if ("monthOptions" in $$props) $$invalidate(5, monthOptions = $$props.monthOptions);
    		if ("yearOptions" in $$props) $$invalidate(12, yearOptions = $$props.yearOptions);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		precision,
    		month,
    		quarter,
    		year,
    		lowerLimit,
    		upperLimit,
    		highlitedQuarter,
    		monthOptions,
    		yearOptions,
    		updateLimits,
    		isActive,
    		isHighlighted,
    		onOptionClick,
    		checkDisabled,
    		limits
    	});

    	$$self.$inject_state = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("month" in $$props) $$invalidate(1, month = $$props.month);
    		if ("quarter" in $$props) $$invalidate(2, quarter = $$props.quarter);
    		if ("year" in $$props) $$invalidate(3, year = $$props.year);
    		if ("lowerLimit" in $$props) $$invalidate(10, lowerLimit = $$props.lowerLimit);
    		if ("upperLimit" in $$props) $$invalidate(11, upperLimit = $$props.upperLimit);
    		if ("highlitedQuarter" in $$props) $$invalidate(4, highlitedQuarter = $$props.highlitedQuarter);
    		if ("monthOptions" in $$props) $$invalidate(5, monthOptions = $$props.monthOptions);
    		if ("yearOptions" in $$props) $$invalidate(12, yearOptions = $$props.yearOptions);
    		if ("limits" in $$props) limits = $$props.limits;
    	};

    	let limits;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*year, lowerLimit, upperLimit*/ 3080) {
    			 limits = updateLimits();
    		}
    	};

    	return [
    		precision,
    		month,
    		quarter,
    		year,
    		highlitedQuarter,
    		monthOptions,
    		isActive,
    		isHighlighted,
    		onOptionClick,
    		checkDisabled,
    		lowerLimit,
    		upperLimit,
    		yearOptions
    	];
    }

    class DatepickerOptionsMonths extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$9, create_fragment$9, safe_not_equal, {
    			precision: 0,
    			month: 1,
    			quarter: 2,
    			year: 3,
    			lowerLimit: 10,
    			upperLimit: 11,
    			highlitedQuarter: 4,
    			monthOptions: 5,
    			yearOptions: 12
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatepickerOptionsMonths",
    			options,
    			id: create_fragment$9.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*precision*/ ctx[0] === undefined && !("precision" in props)) {
    			console_1$1.warn("<DatepickerOptionsMonths> was created without expected prop 'precision'");
    		}

    		if (/*month*/ ctx[1] === undefined && !("month" in props)) {
    			console_1$1.warn("<DatepickerOptionsMonths> was created without expected prop 'month'");
    		}

    		if (/*quarter*/ ctx[2] === undefined && !("quarter" in props)) {
    			console_1$1.warn("<DatepickerOptionsMonths> was created without expected prop 'quarter'");
    		}

    		if (/*year*/ ctx[3] === undefined && !("year" in props)) {
    			console_1$1.warn("<DatepickerOptionsMonths> was created without expected prop 'year'");
    		}

    		if (/*lowerLimit*/ ctx[10] === undefined && !("lowerLimit" in props)) {
    			console_1$1.warn("<DatepickerOptionsMonths> was created without expected prop 'lowerLimit'");
    		}

    		if (/*upperLimit*/ ctx[11] === undefined && !("upperLimit" in props)) {
    			console_1$1.warn("<DatepickerOptionsMonths> was created without expected prop 'upperLimit'");
    		}

    		if (/*monthOptions*/ ctx[5] === undefined && !("monthOptions" in props)) {
    			console_1$1.warn("<DatepickerOptionsMonths> was created without expected prop 'monthOptions'");
    		}

    		if (/*yearOptions*/ ctx[12] === undefined && !("yearOptions" in props)) {
    			console_1$1.warn("<DatepickerOptionsMonths> was created without expected prop 'yearOptions'");
    		}
    	}

    	get precision() {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precision(value) {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get month() {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set month(value) {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get quarter() {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set quarter(value) {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get year() {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set year(value) {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lowerLimit() {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lowerLimit(value) {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get upperLimit() {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set upperLimit(value) {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get highlitedQuarter() {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set highlitedQuarter(value) {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get monthOptions() {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set monthOptions(value) {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yearOptions() {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yearOptions(value) {
    		throw new Error("<DatepickerOptionsMonths>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/datepicker/DatepickerSectionQuarters.svelte generated by Svelte v3.24.0 */
    const file$8 = "src/js/components/datepicker/DatepickerSectionQuarters.svelte";

    function create_fragment$a(ctx) {
    	let div;
    	let datepickerswitcher;
    	let updating_precision;
    	let updating_pick;
    	let t0;
    	let datepickeroptionsquarters;
    	let updating_precision_1;
    	let updating_month;
    	let updating_quarter;
    	let updating_highlitedQuarter;
    	let t1;
    	let datepickeroptionsmonths;
    	let updating_precision_2;
    	let updating_month_1;
    	let updating_quarter_1;
    	let div_class_value;
    	let current;

    	function datepickerswitcher_precision_binding(value) {
    		/*datepickerswitcher_precision_binding*/ ctx[12].call(null, value);
    	}

    	function datepickerswitcher_pick_binding(value) {
    		/*datepickerswitcher_pick_binding*/ ctx[13].call(null, value);
    	}

    	let datepickerswitcher_props = {
    		options: /*yearOptions*/ ctx[9],
    		precisionOption: 4
    	};

    	if (/*precision*/ ctx[0] !== void 0) {
    		datepickerswitcher_props.precision = /*precision*/ ctx[0];
    	}

    	if (/*year*/ ctx[3] !== void 0) {
    		datepickerswitcher_props.pick = /*year*/ ctx[3];
    	}

    	datepickerswitcher = new DatepickerSwitcher({
    			props: datepickerswitcher_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(datepickerswitcher, "precision", datepickerswitcher_precision_binding));
    	binding_callbacks.push(() => bind(datepickerswitcher, "pick", datepickerswitcher_pick_binding));

    	function datepickeroptionsquarters_precision_binding(value) {
    		/*datepickeroptionsquarters_precision_binding*/ ctx[14].call(null, value);
    	}

    	function datepickeroptionsquarters_month_binding(value) {
    		/*datepickeroptionsquarters_month_binding*/ ctx[15].call(null, value);
    	}

    	function datepickeroptionsquarters_quarter_binding(value) {
    		/*datepickeroptionsquarters_quarter_binding*/ ctx[16].call(null, value);
    	}

    	function datepickeroptionsquarters_highlitedQuarter_binding(value) {
    		/*datepickeroptionsquarters_highlitedQuarter_binding*/ ctx[17].call(null, value);
    	}

    	let datepickeroptionsquarters_props = {
    		name: /*name*/ ctx[4],
    		year: /*year*/ ctx[3],
    		lowerLimit: /*lowerLimit*/ ctx[5],
    		upperLimit: /*upperLimit*/ ctx[6],
    		yearOptions: /*yearOptions*/ ctx[9],
    		quarterOptions: /*quarterOptions*/ ctx[8]
    	};

    	if (/*precision*/ ctx[0] !== void 0) {
    		datepickeroptionsquarters_props.precision = /*precision*/ ctx[0];
    	}

    	if (/*month*/ ctx[1] !== void 0) {
    		datepickeroptionsquarters_props.month = /*month*/ ctx[1];
    	}

    	if (/*quarter*/ ctx[2] !== void 0) {
    		datepickeroptionsquarters_props.quarter = /*quarter*/ ctx[2];
    	}

    	if (/*highlitedQuarter*/ ctx[10] !== void 0) {
    		datepickeroptionsquarters_props.highlitedQuarter = /*highlitedQuarter*/ ctx[10];
    	}

    	datepickeroptionsquarters = new DatepickerOptionsQuarters({
    			props: datepickeroptionsquarters_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(datepickeroptionsquarters, "precision", datepickeroptionsquarters_precision_binding));
    	binding_callbacks.push(() => bind(datepickeroptionsquarters, "month", datepickeroptionsquarters_month_binding));
    	binding_callbacks.push(() => bind(datepickeroptionsquarters, "quarter", datepickeroptionsquarters_quarter_binding));
    	binding_callbacks.push(() => bind(datepickeroptionsquarters, "highlitedQuarter", datepickeroptionsquarters_highlitedQuarter_binding));

    	function datepickeroptionsmonths_precision_binding(value) {
    		/*datepickeroptionsmonths_precision_binding*/ ctx[18].call(null, value);
    	}

    	function datepickeroptionsmonths_month_binding(value) {
    		/*datepickeroptionsmonths_month_binding*/ ctx[19].call(null, value);
    	}

    	function datepickeroptionsmonths_quarter_binding(value) {
    		/*datepickeroptionsmonths_quarter_binding*/ ctx[20].call(null, value);
    	}

    	let datepickeroptionsmonths_props = {
    		name: /*name*/ ctx[4],
    		year: /*year*/ ctx[3],
    		lowerLimit: /*lowerLimit*/ ctx[5],
    		upperLimit: /*upperLimit*/ ctx[6],
    		highlitedQuarter: /*highlitedQuarter*/ ctx[10],
    		yearOptions: /*yearOptions*/ ctx[9],
    		monthOptions: /*monthOptions*/ ctx[7]
    	};

    	if (/*precision*/ ctx[0] !== void 0) {
    		datepickeroptionsmonths_props.precision = /*precision*/ ctx[0];
    	}

    	if (/*month*/ ctx[1] !== void 0) {
    		datepickeroptionsmonths_props.month = /*month*/ ctx[1];
    	}

    	if (/*quarter*/ ctx[2] !== void 0) {
    		datepickeroptionsmonths_props.quarter = /*quarter*/ ctx[2];
    	}

    	datepickeroptionsmonths = new DatepickerOptionsMonths({
    			props: datepickeroptionsmonths_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(datepickeroptionsmonths, "precision", datepickeroptionsmonths_precision_binding));
    	binding_callbacks.push(() => bind(datepickeroptionsmonths, "month", datepickeroptionsmonths_month_binding));
    	binding_callbacks.push(() => bind(datepickeroptionsmonths, "quarter", datepickeroptionsmonths_quarter_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(datepickerswitcher.$$.fragment);
    			t0 = space();
    			create_component(datepickeroptionsquarters.$$.fragment);
    			t1 = space();
    			create_component(datepickeroptionsmonths.$$.fragment);
    			attr_dev(div, "class", div_class_value = `txcm-datepickerSection ${/*renderStatus*/ ctx[11](/*precision*/ ctx[0])}`);
    			add_location(div, file$8, 41, 0, 1326);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(datepickerswitcher, div, null);
    			append_dev(div, t0);
    			mount_component(datepickeroptionsquarters, div, null);
    			append_dev(div, t1);
    			mount_component(datepickeroptionsmonths, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const datepickerswitcher_changes = {};
    			if (dirty & /*yearOptions*/ 512) datepickerswitcher_changes.options = /*yearOptions*/ ctx[9];

    			if (!updating_precision && dirty & /*precision*/ 1) {
    				updating_precision = true;
    				datepickerswitcher_changes.precision = /*precision*/ ctx[0];
    				add_flush_callback(() => updating_precision = false);
    			}

    			if (!updating_pick && dirty & /*year*/ 8) {
    				updating_pick = true;
    				datepickerswitcher_changes.pick = /*year*/ ctx[3];
    				add_flush_callback(() => updating_pick = false);
    			}

    			datepickerswitcher.$set(datepickerswitcher_changes);
    			const datepickeroptionsquarters_changes = {};
    			if (dirty & /*name*/ 16) datepickeroptionsquarters_changes.name = /*name*/ ctx[4];
    			if (dirty & /*year*/ 8) datepickeroptionsquarters_changes.year = /*year*/ ctx[3];
    			if (dirty & /*lowerLimit*/ 32) datepickeroptionsquarters_changes.lowerLimit = /*lowerLimit*/ ctx[5];
    			if (dirty & /*upperLimit*/ 64) datepickeroptionsquarters_changes.upperLimit = /*upperLimit*/ ctx[6];
    			if (dirty & /*yearOptions*/ 512) datepickeroptionsquarters_changes.yearOptions = /*yearOptions*/ ctx[9];
    			if (dirty & /*quarterOptions*/ 256) datepickeroptionsquarters_changes.quarterOptions = /*quarterOptions*/ ctx[8];

    			if (!updating_precision_1 && dirty & /*precision*/ 1) {
    				updating_precision_1 = true;
    				datepickeroptionsquarters_changes.precision = /*precision*/ ctx[0];
    				add_flush_callback(() => updating_precision_1 = false);
    			}

    			if (!updating_month && dirty & /*month*/ 2) {
    				updating_month = true;
    				datepickeroptionsquarters_changes.month = /*month*/ ctx[1];
    				add_flush_callback(() => updating_month = false);
    			}

    			if (!updating_quarter && dirty & /*quarter*/ 4) {
    				updating_quarter = true;
    				datepickeroptionsquarters_changes.quarter = /*quarter*/ ctx[2];
    				add_flush_callback(() => updating_quarter = false);
    			}

    			if (!updating_highlitedQuarter && dirty & /*highlitedQuarter*/ 1024) {
    				updating_highlitedQuarter = true;
    				datepickeroptionsquarters_changes.highlitedQuarter = /*highlitedQuarter*/ ctx[10];
    				add_flush_callback(() => updating_highlitedQuarter = false);
    			}

    			datepickeroptionsquarters.$set(datepickeroptionsquarters_changes);
    			const datepickeroptionsmonths_changes = {};
    			if (dirty & /*name*/ 16) datepickeroptionsmonths_changes.name = /*name*/ ctx[4];
    			if (dirty & /*year*/ 8) datepickeroptionsmonths_changes.year = /*year*/ ctx[3];
    			if (dirty & /*lowerLimit*/ 32) datepickeroptionsmonths_changes.lowerLimit = /*lowerLimit*/ ctx[5];
    			if (dirty & /*upperLimit*/ 64) datepickeroptionsmonths_changes.upperLimit = /*upperLimit*/ ctx[6];
    			if (dirty & /*highlitedQuarter*/ 1024) datepickeroptionsmonths_changes.highlitedQuarter = /*highlitedQuarter*/ ctx[10];
    			if (dirty & /*yearOptions*/ 512) datepickeroptionsmonths_changes.yearOptions = /*yearOptions*/ ctx[9];
    			if (dirty & /*monthOptions*/ 128) datepickeroptionsmonths_changes.monthOptions = /*monthOptions*/ ctx[7];

    			if (!updating_precision_2 && dirty & /*precision*/ 1) {
    				updating_precision_2 = true;
    				datepickeroptionsmonths_changes.precision = /*precision*/ ctx[0];
    				add_flush_callback(() => updating_precision_2 = false);
    			}

    			if (!updating_month_1 && dirty & /*month*/ 2) {
    				updating_month_1 = true;
    				datepickeroptionsmonths_changes.month = /*month*/ ctx[1];
    				add_flush_callback(() => updating_month_1 = false);
    			}

    			if (!updating_quarter_1 && dirty & /*quarter*/ 4) {
    				updating_quarter_1 = true;
    				datepickeroptionsmonths_changes.quarter = /*quarter*/ ctx[2];
    				add_flush_callback(() => updating_quarter_1 = false);
    			}

    			datepickeroptionsmonths.$set(datepickeroptionsmonths_changes);

    			if (!current || dirty & /*precision*/ 1 && div_class_value !== (div_class_value = `txcm-datepickerSection ${/*renderStatus*/ ctx[11](/*precision*/ ctx[0])}`)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(datepickerswitcher.$$.fragment, local);
    			transition_in(datepickeroptionsquarters.$$.fragment, local);
    			transition_in(datepickeroptionsmonths.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(datepickerswitcher.$$.fragment, local);
    			transition_out(datepickeroptionsquarters.$$.fragment, local);
    			transition_out(datepickeroptionsmonths.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(datepickerswitcher);
    			destroy_component(datepickeroptionsquarters);
    			destroy_component(datepickeroptionsmonths);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { precision } = $$props;
    	let { month } = $$props;
    	let { quarter } = $$props;
    	let { year } = $$props;
    	let { name } = $$props;
    	let { lowerLimit } = $$props;
    	let { upperLimit } = $$props;
    	let { monthOptions } = $$props;
    	let { quarterOptions } = $$props;
    	let { yearOptions } = $$props;
    	let highlitedQuarter;
    	let prevPrecision = precision;

    	function renderStatus() {
    		if (precision > 1 && precision <= 3) {
    			if (prevPrecision === 4) {
    				prevPrecision = precision;
    				return "txcm-datepickerSection-quarters-is-activeFromLeft";
    			} else if (prevPrecision <= 1) {
    				prevPrecision = precision;
    				return "txcm-datepickerSection-quarters-is-activeFromRight";
    			}

    			prevPrecision = precision;
    			return "txcm-datepickerSection-quarters-is-active";
    		} else if (prevPrecision > 1 && prevPrecision <= 3) {
    			prevPrecision = precision;
    			if (precision === 4) return "txcm-datepickerSection-quarters-is-inactiveToLeft";
    			return "txcm-datepickerSection-quarters-is-inactiveToRight";
    		}

    		prevPrecision = precision;
    		return "txcm-datepickerSection-quarters-is-inactive";
    	}

    	const writable_props = [
    		"precision",
    		"month",
    		"quarter",
    		"year",
    		"name",
    		"lowerLimit",
    		"upperLimit",
    		"monthOptions",
    		"quarterOptions",
    		"yearOptions"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DatepickerSectionQuarters> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DatepickerSectionQuarters", $$slots, []);

    	function datepickerswitcher_precision_binding(value) {
    		precision = value;
    		$$invalidate(0, precision);
    	}

    	function datepickerswitcher_pick_binding(value) {
    		year = value;
    		$$invalidate(3, year);
    	}

    	function datepickeroptionsquarters_precision_binding(value) {
    		precision = value;
    		$$invalidate(0, precision);
    	}

    	function datepickeroptionsquarters_month_binding(value) {
    		month = value;
    		$$invalidate(1, month);
    	}

    	function datepickeroptionsquarters_quarter_binding(value) {
    		quarter = value;
    		$$invalidate(2, quarter);
    	}

    	function datepickeroptionsquarters_highlitedQuarter_binding(value) {
    		highlitedQuarter = value;
    		$$invalidate(10, highlitedQuarter);
    	}

    	function datepickeroptionsmonths_precision_binding(value) {
    		precision = value;
    		$$invalidate(0, precision);
    	}

    	function datepickeroptionsmonths_month_binding(value) {
    		month = value;
    		$$invalidate(1, month);
    	}

    	function datepickeroptionsmonths_quarter_binding(value) {
    		quarter = value;
    		$$invalidate(2, quarter);
    	}

    	$$self.$set = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("month" in $$props) $$invalidate(1, month = $$props.month);
    		if ("quarter" in $$props) $$invalidate(2, quarter = $$props.quarter);
    		if ("year" in $$props) $$invalidate(3, year = $$props.year);
    		if ("name" in $$props) $$invalidate(4, name = $$props.name);
    		if ("lowerLimit" in $$props) $$invalidate(5, lowerLimit = $$props.lowerLimit);
    		if ("upperLimit" in $$props) $$invalidate(6, upperLimit = $$props.upperLimit);
    		if ("monthOptions" in $$props) $$invalidate(7, monthOptions = $$props.monthOptions);
    		if ("quarterOptions" in $$props) $$invalidate(8, quarterOptions = $$props.quarterOptions);
    		if ("yearOptions" in $$props) $$invalidate(9, yearOptions = $$props.yearOptions);
    	};

    	$$self.$capture_state = () => ({
    		DatepickerSwitcher,
    		DatepickerOptionsQuarters,
    		DatepickerOptionsMonths,
    		precision,
    		month,
    		quarter,
    		year,
    		name,
    		lowerLimit,
    		upperLimit,
    		monthOptions,
    		quarterOptions,
    		yearOptions,
    		highlitedQuarter,
    		prevPrecision,
    		renderStatus
    	});

    	$$self.$inject_state = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("month" in $$props) $$invalidate(1, month = $$props.month);
    		if ("quarter" in $$props) $$invalidate(2, quarter = $$props.quarter);
    		if ("year" in $$props) $$invalidate(3, year = $$props.year);
    		if ("name" in $$props) $$invalidate(4, name = $$props.name);
    		if ("lowerLimit" in $$props) $$invalidate(5, lowerLimit = $$props.lowerLimit);
    		if ("upperLimit" in $$props) $$invalidate(6, upperLimit = $$props.upperLimit);
    		if ("monthOptions" in $$props) $$invalidate(7, monthOptions = $$props.monthOptions);
    		if ("quarterOptions" in $$props) $$invalidate(8, quarterOptions = $$props.quarterOptions);
    		if ("yearOptions" in $$props) $$invalidate(9, yearOptions = $$props.yearOptions);
    		if ("highlitedQuarter" in $$props) $$invalidate(10, highlitedQuarter = $$props.highlitedQuarter);
    		if ("prevPrecision" in $$props) prevPrecision = $$props.prevPrecision;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		precision,
    		month,
    		quarter,
    		year,
    		name,
    		lowerLimit,
    		upperLimit,
    		monthOptions,
    		quarterOptions,
    		yearOptions,
    		highlitedQuarter,
    		renderStatus,
    		datepickerswitcher_precision_binding,
    		datepickerswitcher_pick_binding,
    		datepickeroptionsquarters_precision_binding,
    		datepickeroptionsquarters_month_binding,
    		datepickeroptionsquarters_quarter_binding,
    		datepickeroptionsquarters_highlitedQuarter_binding,
    		datepickeroptionsmonths_precision_binding,
    		datepickeroptionsmonths_month_binding,
    		datepickeroptionsmonths_quarter_binding
    	];
    }

    class DatepickerSectionQuarters extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {
    			precision: 0,
    			month: 1,
    			quarter: 2,
    			year: 3,
    			name: 4,
    			lowerLimit: 5,
    			upperLimit: 6,
    			monthOptions: 7,
    			quarterOptions: 8,
    			yearOptions: 9
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatepickerSectionQuarters",
    			options,
    			id: create_fragment$a.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*precision*/ ctx[0] === undefined && !("precision" in props)) {
    			console.warn("<DatepickerSectionQuarters> was created without expected prop 'precision'");
    		}

    		if (/*month*/ ctx[1] === undefined && !("month" in props)) {
    			console.warn("<DatepickerSectionQuarters> was created without expected prop 'month'");
    		}

    		if (/*quarter*/ ctx[2] === undefined && !("quarter" in props)) {
    			console.warn("<DatepickerSectionQuarters> was created without expected prop 'quarter'");
    		}

    		if (/*year*/ ctx[3] === undefined && !("year" in props)) {
    			console.warn("<DatepickerSectionQuarters> was created without expected prop 'year'");
    		}

    		if (/*name*/ ctx[4] === undefined && !("name" in props)) {
    			console.warn("<DatepickerSectionQuarters> was created without expected prop 'name'");
    		}

    		if (/*lowerLimit*/ ctx[5] === undefined && !("lowerLimit" in props)) {
    			console.warn("<DatepickerSectionQuarters> was created without expected prop 'lowerLimit'");
    		}

    		if (/*upperLimit*/ ctx[6] === undefined && !("upperLimit" in props)) {
    			console.warn("<DatepickerSectionQuarters> was created without expected prop 'upperLimit'");
    		}

    		if (/*monthOptions*/ ctx[7] === undefined && !("monthOptions" in props)) {
    			console.warn("<DatepickerSectionQuarters> was created without expected prop 'monthOptions'");
    		}

    		if (/*quarterOptions*/ ctx[8] === undefined && !("quarterOptions" in props)) {
    			console.warn("<DatepickerSectionQuarters> was created without expected prop 'quarterOptions'");
    		}

    		if (/*yearOptions*/ ctx[9] === undefined && !("yearOptions" in props)) {
    			console.warn("<DatepickerSectionQuarters> was created without expected prop 'yearOptions'");
    		}
    	}

    	get precision() {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precision(value) {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get month() {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set month(value) {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get quarter() {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set quarter(value) {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get year() {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set year(value) {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lowerLimit() {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lowerLimit(value) {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get upperLimit() {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set upperLimit(value) {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get monthOptions() {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set monthOptions(value) {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get quarterOptions() {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set quarterOptions(value) {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yearOptions() {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yearOptions(value) {
    		throw new Error("<DatepickerSectionQuarters>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/datepicker/DatepickerOptionsYears.svelte generated by Svelte v3.24.0 */
    const file$9 = "src/js/components/datepicker/DatepickerOptionsYears.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[7] = i;
    	return child_ctx;
    }

    // (21:4) {#each yearOptions as yearOption, index}
    function create_each_block$4(ctx) {
    	let li;
    	let button;
    	let int;
    	let button_data_option_value;
    	let t;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*yearOption*/ ctx[5] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			button = element("button");
    			create_component(int.$$.fragment);
    			t = space();
    			attr_dev(button, "class", "txcm-datepickerYearButton");
    			attr_dev(button, "data-option", button_data_option_value = /*index*/ ctx[7]);
    			toggle_class(button, "txcm-datepickerYearButton-is-active", /*isActive*/ ctx[3](/*index*/ ctx[7], /*year*/ ctx[1], /*precision*/ ctx[0]));
    			add_location(button, file$9, 23, 10, 489);
    			attr_dev(li, "class", "txcm-datepickerYear");
    			add_location(li, file$9, 21, 6, 438);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button);
    			mount_component(int, button, null);
    			append_dev(li, t);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onOptionClick*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*yearOptions*/ 4) int_changes.key = /*yearOption*/ ctx[5];
    			int.$set(int_changes);

    			if (dirty & /*isActive, year, precision*/ 11) {
    				toggle_class(button, "txcm-datepickerYearButton-is-active", /*isActive*/ ctx[3](/*index*/ ctx[7], /*year*/ ctx[1], /*precision*/ ctx[0]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(21:4) {#each yearOptions as yearOption, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let ol;
    	let current;
    	let each_value = /*yearOptions*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ol = element("ol");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ol, "class", "txcm-datepickerYears");
    			add_location(ol, file$9, 18, 0, 351);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ol, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ol, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*isActive, year, precision, onOptionClick, yearOptions*/ 31) {
    				each_value = /*yearOptions*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ol, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ol);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let { precision } = $$props;
    	let { year } = $$props;
    	let { yearOptions } = $$props;

    	function isActive(index) {
    		return precision === 4 && index === year;
    	}

    	function onOptionClick({ target }) {
    		$$invalidate(0, precision = 4);
    		$$invalidate(1, year = parseInt(target.dataset.option, 10));
    	}

    	const writable_props = ["precision", "year", "yearOptions"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DatepickerOptionsYears> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DatepickerOptionsYears", $$slots, []);

    	$$self.$set = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("year" in $$props) $$invalidate(1, year = $$props.year);
    		if ("yearOptions" in $$props) $$invalidate(2, yearOptions = $$props.yearOptions);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		precision,
    		year,
    		yearOptions,
    		isActive,
    		onOptionClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("year" in $$props) $$invalidate(1, year = $$props.year);
    		if ("yearOptions" in $$props) $$invalidate(2, yearOptions = $$props.yearOptions);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [precision, year, yearOptions, isActive, onOptionClick];
    }

    class DatepickerOptionsYears extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { precision: 0, year: 1, yearOptions: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatepickerOptionsYears",
    			options,
    			id: create_fragment$b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*precision*/ ctx[0] === undefined && !("precision" in props)) {
    			console.warn("<DatepickerOptionsYears> was created without expected prop 'precision'");
    		}

    		if (/*year*/ ctx[1] === undefined && !("year" in props)) {
    			console.warn("<DatepickerOptionsYears> was created without expected prop 'year'");
    		}

    		if (/*yearOptions*/ ctx[2] === undefined && !("yearOptions" in props)) {
    			console.warn("<DatepickerOptionsYears> was created without expected prop 'yearOptions'");
    		}
    	}

    	get precision() {
    		throw new Error("<DatepickerOptionsYears>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precision(value) {
    		throw new Error("<DatepickerOptionsYears>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get year() {
    		throw new Error("<DatepickerOptionsYears>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set year(value) {
    		throw new Error("<DatepickerOptionsYears>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yearOptions() {
    		throw new Error("<DatepickerOptionsYears>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yearOptions(value) {
    		throw new Error("<DatepickerOptionsYears>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/datepicker/DatepickerSectionYears.svelte generated by Svelte v3.24.0 */
    const file$a = "src/js/components/datepicker/DatepickerSectionYears.svelte";

    function create_fragment$c(ctx) {
    	let div;
    	let datepickeroptionsyears;
    	let updating_precision;
    	let updating_year;
    	let div_class_value;
    	let current;

    	function datepickeroptionsyears_precision_binding(value) {
    		/*datepickeroptionsyears_precision_binding*/ ctx[4].call(null, value);
    	}

    	function datepickeroptionsyears_year_binding(value) {
    		/*datepickeroptionsyears_year_binding*/ ctx[5].call(null, value);
    	}

    	let datepickeroptionsyears_props = { yearOptions: /*yearOptions*/ ctx[2] };

    	if (/*precision*/ ctx[0] !== void 0) {
    		datepickeroptionsyears_props.precision = /*precision*/ ctx[0];
    	}

    	if (/*year*/ ctx[1] !== void 0) {
    		datepickeroptionsyears_props.year = /*year*/ ctx[1];
    	}

    	datepickeroptionsyears = new DatepickerOptionsYears({
    			props: datepickeroptionsyears_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(datepickeroptionsyears, "precision", datepickeroptionsyears_precision_binding));
    	binding_callbacks.push(() => bind(datepickeroptionsyears, "year", datepickeroptionsyears_year_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(datepickeroptionsyears.$$.fragment);
    			attr_dev(div, "class", div_class_value = `txcm-datepickerSection ${/*renderStatus*/ ctx[3](/*precision*/ ctx[0])}`);
    			add_location(div, file$a, 14, 0, 325);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(datepickeroptionsyears, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const datepickeroptionsyears_changes = {};
    			if (dirty & /*yearOptions*/ 4) datepickeroptionsyears_changes.yearOptions = /*yearOptions*/ ctx[2];

    			if (!updating_precision && dirty & /*precision*/ 1) {
    				updating_precision = true;
    				datepickeroptionsyears_changes.precision = /*precision*/ ctx[0];
    				add_flush_callback(() => updating_precision = false);
    			}

    			if (!updating_year && dirty & /*year*/ 2) {
    				updating_year = true;
    				datepickeroptionsyears_changes.year = /*year*/ ctx[1];
    				add_flush_callback(() => updating_year = false);
    			}

    			datepickeroptionsyears.$set(datepickeroptionsyears_changes);

    			if (!current || dirty & /*precision*/ 1 && div_class_value !== (div_class_value = `txcm-datepickerSection ${/*renderStatus*/ ctx[3](/*precision*/ ctx[0])}`)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(datepickeroptionsyears.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(datepickeroptionsyears.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(datepickeroptionsyears);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { precision } = $$props;
    	let { year } = $$props;
    	let { yearOptions } = $$props;

    	function renderStatus() {
    		if (precision === 4) return "txcm-datepickerSection-years-is-active";
    		return "txcm-datepickerSection-years-is-inactive";
    	}

    	const writable_props = ["precision", "year", "yearOptions"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DatepickerSectionYears> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DatepickerSectionYears", $$slots, []);

    	function datepickeroptionsyears_precision_binding(value) {
    		precision = value;
    		$$invalidate(0, precision);
    	}

    	function datepickeroptionsyears_year_binding(value) {
    		year = value;
    		$$invalidate(1, year);
    	}

    	$$self.$set = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("year" in $$props) $$invalidate(1, year = $$props.year);
    		if ("yearOptions" in $$props) $$invalidate(2, yearOptions = $$props.yearOptions);
    	};

    	$$self.$capture_state = () => ({
    		DatepickerOptionsYears,
    		precision,
    		year,
    		yearOptions,
    		renderStatus
    	});

    	$$self.$inject_state = $$props => {
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("year" in $$props) $$invalidate(1, year = $$props.year);
    		if ("yearOptions" in $$props) $$invalidate(2, yearOptions = $$props.yearOptions);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		precision,
    		year,
    		yearOptions,
    		renderStatus,
    		datepickeroptionsyears_precision_binding,
    		datepickeroptionsyears_year_binding
    	];
    }

    class DatepickerSectionYears extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { precision: 0, year: 1, yearOptions: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatepickerSectionYears",
    			options,
    			id: create_fragment$c.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*precision*/ ctx[0] === undefined && !("precision" in props)) {
    			console.warn("<DatepickerSectionYears> was created without expected prop 'precision'");
    		}

    		if (/*year*/ ctx[1] === undefined && !("year" in props)) {
    			console.warn("<DatepickerSectionYears> was created without expected prop 'year'");
    		}

    		if (/*yearOptions*/ ctx[2] === undefined && !("yearOptions" in props)) {
    			console.warn("<DatepickerSectionYears> was created without expected prop 'yearOptions'");
    		}
    	}

    	get precision() {
    		throw new Error("<DatepickerSectionYears>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precision(value) {
    		throw new Error("<DatepickerSectionYears>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get year() {
    		throw new Error("<DatepickerSectionYears>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set year(value) {
    		throw new Error("<DatepickerSectionYears>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yearOptions() {
    		throw new Error("<DatepickerSectionYears>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yearOptions(value) {
    		throw new Error("<DatepickerSectionYears>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/datepicker/DatepickerContainer.svelte generated by Svelte v3.24.0 */
    const file$b = "src/js/components/datepicker/DatepickerContainer.svelte";

    // (48:8) {#if mode === 0}
    function create_if_block_2(ctx) {
    	let datepickersectionmonth;
    	let updating_precision;
    	let updating_day;
    	let updating_week;
    	let updating_month;
    	let updating_year;
    	let current;

    	function datepickersectionmonth_precision_binding(value) {
    		/*datepickersectionmonth_precision_binding*/ ctx[21].call(null, value);
    	}

    	function datepickersectionmonth_day_binding(value) {
    		/*datepickersectionmonth_day_binding*/ ctx[22].call(null, value);
    	}

    	function datepickersectionmonth_week_binding(value) {
    		/*datepickersectionmonth_week_binding*/ ctx[23].call(null, value);
    	}

    	function datepickersectionmonth_month_binding(value) {
    		/*datepickersectionmonth_month_binding*/ ctx[24].call(null, value);
    	}

    	function datepickersectionmonth_year_binding(value) {
    		/*datepickersectionmonth_year_binding*/ ctx[25].call(null, value);
    	}

    	let datepickersectionmonth_props = {
    		name: /*name*/ ctx[7],
    		lowerLimit: /*lowerLimit*/ ctx[9],
    		upperLimit: /*upperLimit*/ ctx[10],
    		monthOptions: /*monthOptions*/ ctx[11],
    		yearOptions: /*yearOptions*/ ctx[13]
    	};

    	if (/*precision*/ ctx[0] !== void 0) {
    		datepickersectionmonth_props.precision = /*precision*/ ctx[0];
    	}

    	if (/*day*/ ctx[1] !== void 0) {
    		datepickersectionmonth_props.day = /*day*/ ctx[1];
    	}

    	if (/*week*/ ctx[2] !== void 0) {
    		datepickersectionmonth_props.week = /*week*/ ctx[2];
    	}

    	if (/*month*/ ctx[3] !== void 0) {
    		datepickersectionmonth_props.month = /*month*/ ctx[3];
    	}

    	if (/*year*/ ctx[5] !== void 0) {
    		datepickersectionmonth_props.year = /*year*/ ctx[5];
    	}

    	datepickersectionmonth = new DatepickerSectionMonth({
    			props: datepickersectionmonth_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(datepickersectionmonth, "precision", datepickersectionmonth_precision_binding));
    	binding_callbacks.push(() => bind(datepickersectionmonth, "day", datepickersectionmonth_day_binding));
    	binding_callbacks.push(() => bind(datepickersectionmonth, "week", datepickersectionmonth_week_binding));
    	binding_callbacks.push(() => bind(datepickersectionmonth, "month", datepickersectionmonth_month_binding));
    	binding_callbacks.push(() => bind(datepickersectionmonth, "year", datepickersectionmonth_year_binding));

    	const block = {
    		c: function create() {
    			create_component(datepickersectionmonth.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(datepickersectionmonth, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const datepickersectionmonth_changes = {};
    			if (dirty[0] & /*name*/ 128) datepickersectionmonth_changes.name = /*name*/ ctx[7];
    			if (dirty[0] & /*lowerLimit*/ 512) datepickersectionmonth_changes.lowerLimit = /*lowerLimit*/ ctx[9];
    			if (dirty[0] & /*upperLimit*/ 1024) datepickersectionmonth_changes.upperLimit = /*upperLimit*/ ctx[10];
    			if (dirty[0] & /*monthOptions*/ 2048) datepickersectionmonth_changes.monthOptions = /*monthOptions*/ ctx[11];
    			if (dirty[0] & /*yearOptions*/ 8192) datepickersectionmonth_changes.yearOptions = /*yearOptions*/ ctx[13];

    			if (!updating_precision && dirty[0] & /*precision*/ 1) {
    				updating_precision = true;
    				datepickersectionmonth_changes.precision = /*precision*/ ctx[0];
    				add_flush_callback(() => updating_precision = false);
    			}

    			if (!updating_day && dirty[0] & /*day*/ 2) {
    				updating_day = true;
    				datepickersectionmonth_changes.day = /*day*/ ctx[1];
    				add_flush_callback(() => updating_day = false);
    			}

    			if (!updating_week && dirty[0] & /*week*/ 4) {
    				updating_week = true;
    				datepickersectionmonth_changes.week = /*week*/ ctx[2];
    				add_flush_callback(() => updating_week = false);
    			}

    			if (!updating_month && dirty[0] & /*month*/ 8) {
    				updating_month = true;
    				datepickersectionmonth_changes.month = /*month*/ ctx[3];
    				add_flush_callback(() => updating_month = false);
    			}

    			if (!updating_year && dirty[0] & /*year*/ 32) {
    				updating_year = true;
    				datepickersectionmonth_changes.year = /*year*/ ctx[5];
    				add_flush_callback(() => updating_year = false);
    			}

    			datepickersectionmonth.$set(datepickersectionmonth_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(datepickersectionmonth.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(datepickersectionmonth.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(datepickersectionmonth, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(48:8) {#if mode === 0}",
    		ctx
    	});

    	return block;
    }

    // (61:8) {#if mode <= 1}
    function create_if_block_1(ctx) {
    	let datepickersectionquarters;
    	let updating_precision;
    	let updating_month;
    	let updating_quarter;
    	let updating_year;
    	let current;

    	function datepickersectionquarters_precision_binding(value) {
    		/*datepickersectionquarters_precision_binding*/ ctx[26].call(null, value);
    	}

    	function datepickersectionquarters_month_binding(value) {
    		/*datepickersectionquarters_month_binding*/ ctx[27].call(null, value);
    	}

    	function datepickersectionquarters_quarter_binding(value) {
    		/*datepickersectionquarters_quarter_binding*/ ctx[28].call(null, value);
    	}

    	function datepickersectionquarters_year_binding(value) {
    		/*datepickersectionquarters_year_binding*/ ctx[29].call(null, value);
    	}

    	let datepickersectionquarters_props = {
    		name: /*name*/ ctx[7],
    		lowerLimit: /*lowerLimit*/ ctx[9],
    		upperLimit: /*upperLimit*/ ctx[10],
    		monthOptions: /*monthOptions*/ ctx[11],
    		quarterOptions: /*quarterOptions*/ ctx[12],
    		yearOptions: /*yearOptions*/ ctx[13]
    	};

    	if (/*precision*/ ctx[0] !== void 0) {
    		datepickersectionquarters_props.precision = /*precision*/ ctx[0];
    	}

    	if (/*month*/ ctx[3] !== void 0) {
    		datepickersectionquarters_props.month = /*month*/ ctx[3];
    	}

    	if (/*quarter*/ ctx[4] !== void 0) {
    		datepickersectionquarters_props.quarter = /*quarter*/ ctx[4];
    	}

    	if (/*year*/ ctx[5] !== void 0) {
    		datepickersectionquarters_props.year = /*year*/ ctx[5];
    	}

    	datepickersectionquarters = new DatepickerSectionQuarters({
    			props: datepickersectionquarters_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(datepickersectionquarters, "precision", datepickersectionquarters_precision_binding));
    	binding_callbacks.push(() => bind(datepickersectionquarters, "month", datepickersectionquarters_month_binding));
    	binding_callbacks.push(() => bind(datepickersectionquarters, "quarter", datepickersectionquarters_quarter_binding));
    	binding_callbacks.push(() => bind(datepickersectionquarters, "year", datepickersectionquarters_year_binding));

    	const block = {
    		c: function create() {
    			create_component(datepickersectionquarters.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(datepickersectionquarters, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const datepickersectionquarters_changes = {};
    			if (dirty[0] & /*name*/ 128) datepickersectionquarters_changes.name = /*name*/ ctx[7];
    			if (dirty[0] & /*lowerLimit*/ 512) datepickersectionquarters_changes.lowerLimit = /*lowerLimit*/ ctx[9];
    			if (dirty[0] & /*upperLimit*/ 1024) datepickersectionquarters_changes.upperLimit = /*upperLimit*/ ctx[10];
    			if (dirty[0] & /*monthOptions*/ 2048) datepickersectionquarters_changes.monthOptions = /*monthOptions*/ ctx[11];
    			if (dirty[0] & /*quarterOptions*/ 4096) datepickersectionquarters_changes.quarterOptions = /*quarterOptions*/ ctx[12];
    			if (dirty[0] & /*yearOptions*/ 8192) datepickersectionquarters_changes.yearOptions = /*yearOptions*/ ctx[13];

    			if (!updating_precision && dirty[0] & /*precision*/ 1) {
    				updating_precision = true;
    				datepickersectionquarters_changes.precision = /*precision*/ ctx[0];
    				add_flush_callback(() => updating_precision = false);
    			}

    			if (!updating_month && dirty[0] & /*month*/ 8) {
    				updating_month = true;
    				datepickersectionquarters_changes.month = /*month*/ ctx[3];
    				add_flush_callback(() => updating_month = false);
    			}

    			if (!updating_quarter && dirty[0] & /*quarter*/ 16) {
    				updating_quarter = true;
    				datepickersectionquarters_changes.quarter = /*quarter*/ ctx[4];
    				add_flush_callback(() => updating_quarter = false);
    			}

    			if (!updating_year && dirty[0] & /*year*/ 32) {
    				updating_year = true;
    				datepickersectionquarters_changes.year = /*year*/ ctx[5];
    				add_flush_callback(() => updating_year = false);
    			}

    			datepickersectionquarters.$set(datepickersectionquarters_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(datepickersectionquarters.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(datepickersectionquarters.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(datepickersectionquarters, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(61:8) {#if mode <= 1}",
    		ctx
    	});

    	return block;
    }

    // (74:8) {#if mode === 0}
    function create_if_block$1(ctx) {
    	let datepickersectionyears;
    	let updating_precision;
    	let updating_year;
    	let current;

    	function datepickersectionyears_precision_binding(value) {
    		/*datepickersectionyears_precision_binding*/ ctx[30].call(null, value);
    	}

    	function datepickersectionyears_year_binding(value) {
    		/*datepickersectionyears_year_binding*/ ctx[31].call(null, value);
    	}

    	let datepickersectionyears_props = { yearOptions: /*yearOptions*/ ctx[13] };

    	if (/*precision*/ ctx[0] !== void 0) {
    		datepickersectionyears_props.precision = /*precision*/ ctx[0];
    	}

    	if (/*year*/ ctx[5] !== void 0) {
    		datepickersectionyears_props.year = /*year*/ ctx[5];
    	}

    	datepickersectionyears = new DatepickerSectionYears({
    			props: datepickersectionyears_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(datepickersectionyears, "precision", datepickersectionyears_precision_binding));
    	binding_callbacks.push(() => bind(datepickersectionyears, "year", datepickersectionyears_year_binding));

    	const block = {
    		c: function create() {
    			create_component(datepickersectionyears.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(datepickersectionyears, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const datepickersectionyears_changes = {};
    			if (dirty[0] & /*yearOptions*/ 8192) datepickersectionyears_changes.yearOptions = /*yearOptions*/ ctx[13];

    			if (!updating_precision && dirty[0] & /*precision*/ 1) {
    				updating_precision = true;
    				datepickersectionyears_changes.precision = /*precision*/ ctx[0];
    				add_flush_callback(() => updating_precision = false);
    			}

    			if (!updating_year && dirty[0] & /*year*/ 32) {
    				updating_year = true;
    				datepickersectionyears_changes.year = /*year*/ ctx[5];
    				add_flush_callback(() => updating_year = false);
    			}

    			datepickersectionyears.$set(datepickersectionyears_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(datepickersectionyears.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(datepickersectionyears.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(datepickersectionyears, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(74:8) {#if mode === 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let t2;
    	let current;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[20]);
    	let if_block0 = /*mode*/ ctx[8] === 0 && create_if_block_2(ctx);
    	let if_block1 = /*mode*/ ctx[8] <= 1 && create_if_block_1(ctx);
    	let if_block2 = /*mode*/ ctx[8] === 0 && create_if_block$1(ctx);
    	const default_slot_template = /*$$slots*/ ctx[18].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[17], null);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (default_slot) default_slot.c();
    			attr_dev(div0, "class", "txcm-datepickerSections");
    			add_location(div0, file$b, 45, 4, 1055);
    			attr_dev(div1, "class", "txcm-datepickerContainer");
    			set_style(div1, "--shift", /*shift*/ ctx[15]);
    			toggle_class(div1, "txcm-datepickerContainer-is-active", /*isActive*/ ctx[6]);
    			add_location(div1, file$b, 39, 0, 883);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t0);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div0, t1);
    			if (if_block2) if_block2.m(div0, null);
    			append_dev(div1, t2);

    			if (default_slot) {
    				default_slot.m(div1, null);
    			}

    			/*div1_binding*/ ctx[32](div1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "resize", /*onwindowresize*/ ctx[20]),
    					listen_dev(div1, "click", stop_propagation(/*click_handler*/ ctx[19]), false, false, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*mode*/ ctx[8] === 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*mode*/ 256) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*mode*/ ctx[8] <= 1) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*mode*/ 256) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div0, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*mode*/ ctx[8] === 0) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*mode*/ 256) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div0, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty[0] & /*$$scope*/ 131072) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[17], dirty, null, null);
    				}
    			}

    			if (!current || dirty[0] & /*shift*/ 32768) {
    				set_style(div1, "--shift", /*shift*/ ctx[15]);
    			}

    			if (dirty[0] & /*isActive*/ 64) {
    				toggle_class(div1, "txcm-datepickerContainer-is-active", /*isActive*/ ctx[6]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (default_slot) default_slot.d(detaching);
    			/*div1_binding*/ ctx[32](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const LEFT_MARGIN = 16;

    function instance$d($$self, $$props, $$invalidate) {
    	let { isActive } = $$props;
    	let { precision } = $$props;
    	let { day } = $$props;
    	let { week } = $$props;
    	let { month } = $$props;
    	let { quarter } = $$props;
    	let { year } = $$props;
    	let { name } = $$props;
    	let { mode } = $$props;
    	let { lowerLimit } = $$props;
    	let { upperLimit } = $$props;
    	let { monthOptions } = $$props;
    	let { quarterOptions } = $$props;
    	let { yearOptions } = $$props;
    	let node;
    	let shift = 0;
    	let screenWidth;

    	function updateShift() {
    		if (isActive && node) {
    			const rect = node.getBoundingClientRect();
    			const { x } = rect;

    			$$invalidate(15, shift = x < 0
    			? `translateX(${-x + LEFT_MARGIN}px)`
    			: "translateX(0)");
    		}
    	}

    	const writable_props = [
    		"isActive",
    		"precision",
    		"day",
    		"week",
    		"month",
    		"quarter",
    		"year",
    		"name",
    		"mode",
    		"lowerLimit",
    		"upperLimit",
    		"monthOptions",
    		"quarterOptions",
    		"yearOptions"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DatepickerContainer> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DatepickerContainer", $$slots, ['default']);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function onwindowresize() {
    		$$invalidate(16, screenWidth = window.innerWidth);
    	}

    	function datepickersectionmonth_precision_binding(value) {
    		precision = value;
    		$$invalidate(0, precision);
    	}

    	function datepickersectionmonth_day_binding(value) {
    		day = value;
    		$$invalidate(1, day);
    	}

    	function datepickersectionmonth_week_binding(value) {
    		week = value;
    		$$invalidate(2, week);
    	}

    	function datepickersectionmonth_month_binding(value) {
    		month = value;
    		$$invalidate(3, month);
    	}

    	function datepickersectionmonth_year_binding(value) {
    		year = value;
    		$$invalidate(5, year);
    	}

    	function datepickersectionquarters_precision_binding(value) {
    		precision = value;
    		$$invalidate(0, precision);
    	}

    	function datepickersectionquarters_month_binding(value) {
    		month = value;
    		$$invalidate(3, month);
    	}

    	function datepickersectionquarters_quarter_binding(value) {
    		quarter = value;
    		$$invalidate(4, quarter);
    	}

    	function datepickersectionquarters_year_binding(value) {
    		year = value;
    		$$invalidate(5, year);
    	}

    	function datepickersectionyears_precision_binding(value) {
    		precision = value;
    		$$invalidate(0, precision);
    	}

    	function datepickersectionyears_year_binding(value) {
    		year = value;
    		$$invalidate(5, year);
    	}

    	function div1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			node = $$value;
    			$$invalidate(14, node);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("isActive" in $$props) $$invalidate(6, isActive = $$props.isActive);
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("day" in $$props) $$invalidate(1, day = $$props.day);
    		if ("week" in $$props) $$invalidate(2, week = $$props.week);
    		if ("month" in $$props) $$invalidate(3, month = $$props.month);
    		if ("quarter" in $$props) $$invalidate(4, quarter = $$props.quarter);
    		if ("year" in $$props) $$invalidate(5, year = $$props.year);
    		if ("name" in $$props) $$invalidate(7, name = $$props.name);
    		if ("mode" in $$props) $$invalidate(8, mode = $$props.mode);
    		if ("lowerLimit" in $$props) $$invalidate(9, lowerLimit = $$props.lowerLimit);
    		if ("upperLimit" in $$props) $$invalidate(10, upperLimit = $$props.upperLimit);
    		if ("monthOptions" in $$props) $$invalidate(11, monthOptions = $$props.monthOptions);
    		if ("quarterOptions" in $$props) $$invalidate(12, quarterOptions = $$props.quarterOptions);
    		if ("yearOptions" in $$props) $$invalidate(13, yearOptions = $$props.yearOptions);
    		if ("$$scope" in $$props) $$invalidate(17, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		DatepickerSectionMonth,
    		DatepickerSectionQuarters,
    		DatepickerSectionYears,
    		LEFT_MARGIN,
    		isActive,
    		precision,
    		day,
    		week,
    		month,
    		quarter,
    		year,
    		name,
    		mode,
    		lowerLimit,
    		upperLimit,
    		monthOptions,
    		quarterOptions,
    		yearOptions,
    		node,
    		shift,
    		screenWidth,
    		updateShift
    	});

    	$$self.$inject_state = $$props => {
    		if ("isActive" in $$props) $$invalidate(6, isActive = $$props.isActive);
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("day" in $$props) $$invalidate(1, day = $$props.day);
    		if ("week" in $$props) $$invalidate(2, week = $$props.week);
    		if ("month" in $$props) $$invalidate(3, month = $$props.month);
    		if ("quarter" in $$props) $$invalidate(4, quarter = $$props.quarter);
    		if ("year" in $$props) $$invalidate(5, year = $$props.year);
    		if ("name" in $$props) $$invalidate(7, name = $$props.name);
    		if ("mode" in $$props) $$invalidate(8, mode = $$props.mode);
    		if ("lowerLimit" in $$props) $$invalidate(9, lowerLimit = $$props.lowerLimit);
    		if ("upperLimit" in $$props) $$invalidate(10, upperLimit = $$props.upperLimit);
    		if ("monthOptions" in $$props) $$invalidate(11, monthOptions = $$props.monthOptions);
    		if ("quarterOptions" in $$props) $$invalidate(12, quarterOptions = $$props.quarterOptions);
    		if ("yearOptions" in $$props) $$invalidate(13, yearOptions = $$props.yearOptions);
    		if ("node" in $$props) $$invalidate(14, node = $$props.node);
    		if ("shift" in $$props) $$invalidate(15, shift = $$props.shift);
    		if ("screenWidth" in $$props) $$invalidate(16, screenWidth = $$props.screenWidth);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*isActive*/ 64) {
    			 updateShift();
    		}
    	};

    	return [
    		precision,
    		day,
    		week,
    		month,
    		quarter,
    		year,
    		isActive,
    		name,
    		mode,
    		lowerLimit,
    		upperLimit,
    		monthOptions,
    		quarterOptions,
    		yearOptions,
    		node,
    		shift,
    		screenWidth,
    		$$scope,
    		$$slots,
    		click_handler,
    		onwindowresize,
    		datepickersectionmonth_precision_binding,
    		datepickersectionmonth_day_binding,
    		datepickersectionmonth_week_binding,
    		datepickersectionmonth_month_binding,
    		datepickersectionmonth_year_binding,
    		datepickersectionquarters_precision_binding,
    		datepickersectionquarters_month_binding,
    		datepickersectionquarters_quarter_binding,
    		datepickersectionquarters_year_binding,
    		datepickersectionyears_precision_binding,
    		datepickersectionyears_year_binding,
    		div1_binding
    	];
    }

    class DatepickerContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$d,
    			create_fragment$d,
    			safe_not_equal,
    			{
    				isActive: 6,
    				precision: 0,
    				day: 1,
    				week: 2,
    				month: 3,
    				quarter: 4,
    				year: 5,
    				name: 7,
    				mode: 8,
    				lowerLimit: 9,
    				upperLimit: 10,
    				monthOptions: 11,
    				quarterOptions: 12,
    				yearOptions: 13
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatepickerContainer",
    			options,
    			id: create_fragment$d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*isActive*/ ctx[6] === undefined && !("isActive" in props)) {
    			console.warn("<DatepickerContainer> was created without expected prop 'isActive'");
    		}

    		if (/*precision*/ ctx[0] === undefined && !("precision" in props)) {
    			console.warn("<DatepickerContainer> was created without expected prop 'precision'");
    		}

    		if (/*day*/ ctx[1] === undefined && !("day" in props)) {
    			console.warn("<DatepickerContainer> was created without expected prop 'day'");
    		}

    		if (/*week*/ ctx[2] === undefined && !("week" in props)) {
    			console.warn("<DatepickerContainer> was created without expected prop 'week'");
    		}

    		if (/*month*/ ctx[3] === undefined && !("month" in props)) {
    			console.warn("<DatepickerContainer> was created without expected prop 'month'");
    		}

    		if (/*quarter*/ ctx[4] === undefined && !("quarter" in props)) {
    			console.warn("<DatepickerContainer> was created without expected prop 'quarter'");
    		}

    		if (/*year*/ ctx[5] === undefined && !("year" in props)) {
    			console.warn("<DatepickerContainer> was created without expected prop 'year'");
    		}

    		if (/*name*/ ctx[7] === undefined && !("name" in props)) {
    			console.warn("<DatepickerContainer> was created without expected prop 'name'");
    		}

    		if (/*mode*/ ctx[8] === undefined && !("mode" in props)) {
    			console.warn("<DatepickerContainer> was created without expected prop 'mode'");
    		}

    		if (/*lowerLimit*/ ctx[9] === undefined && !("lowerLimit" in props)) {
    			console.warn("<DatepickerContainer> was created without expected prop 'lowerLimit'");
    		}

    		if (/*upperLimit*/ ctx[10] === undefined && !("upperLimit" in props)) {
    			console.warn("<DatepickerContainer> was created without expected prop 'upperLimit'");
    		}

    		if (/*monthOptions*/ ctx[11] === undefined && !("monthOptions" in props)) {
    			console.warn("<DatepickerContainer> was created without expected prop 'monthOptions'");
    		}

    		if (/*quarterOptions*/ ctx[12] === undefined && !("quarterOptions" in props)) {
    			console.warn("<DatepickerContainer> was created without expected prop 'quarterOptions'");
    		}

    		if (/*yearOptions*/ ctx[13] === undefined && !("yearOptions" in props)) {
    			console.warn("<DatepickerContainer> was created without expected prop 'yearOptions'");
    		}
    	}

    	get isActive() {
    		throw new Error("<DatepickerContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isActive(value) {
    		throw new Error("<DatepickerContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get precision() {
    		throw new Error("<DatepickerContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precision(value) {
    		throw new Error("<DatepickerContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get day() {
    		throw new Error("<DatepickerContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set day(value) {
    		throw new Error("<DatepickerContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get week() {
    		throw new Error("<DatepickerContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set week(value) {
    		throw new Error("<DatepickerContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get month() {
    		throw new Error("<DatepickerContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set month(value) {
    		throw new Error("<DatepickerContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get quarter() {
    		throw new Error("<DatepickerContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set quarter(value) {
    		throw new Error("<DatepickerContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get year() {
    		throw new Error("<DatepickerContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set year(value) {
    		throw new Error("<DatepickerContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<DatepickerContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<DatepickerContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mode() {
    		throw new Error("<DatepickerContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mode(value) {
    		throw new Error("<DatepickerContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lowerLimit() {
    		throw new Error("<DatepickerContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lowerLimit(value) {
    		throw new Error("<DatepickerContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get upperLimit() {
    		throw new Error("<DatepickerContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set upperLimit(value) {
    		throw new Error("<DatepickerContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get monthOptions() {
    		throw new Error("<DatepickerContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set monthOptions(value) {
    		throw new Error("<DatepickerContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get quarterOptions() {
    		throw new Error("<DatepickerContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set quarterOptions(value) {
    		throw new Error("<DatepickerContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get yearOptions() {
    		throw new Error("<DatepickerContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set yearOptions(value) {
    		throw new Error("<DatepickerContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/datepicker/DatepickerControls.svelte generated by Svelte v3.24.0 */
    const file$c = "src/js/components/datepicker/DatepickerControls.svelte";

    // (27:4) {#if mode === 0}
    function create_if_block$2(ctx) {
    	let button;
    	let svg;
    	let use;
    	let t;
    	let int;
    	let button_data_option_value;
    	let current;
    	let mounted;
    	let dispose;
    	int = new Int({ props: { key: "месяц" }, $$inline: true });

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t = space();
    			create_component(int.$$.fragment);
    			xlink_attr(use, "xlink:href", "#txspt-icons-arrow");
    			add_location(use, file$c, 34, 14, 828);
    			attr_dev(svg, "class", "txcm-datepickerPrecisionControlIcon");
    			add_location(svg, file$c, 32, 10, 752);
    			attr_dev(button, "class", "txcm-datepickerPrecisionControl");
    			attr_dev(button, "data-option", button_data_option_value = 0);
    			toggle_class(button, "txcm-datepickerPrecisionControl-is-active", /*isMonthsQuarters*/ ctx[2](/*precision*/ ctx[0]));
    			add_location(button, file$c, 27, 6, 539);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, use);
    			append_dev(button, t);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onPrecisionClick*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*isMonthsQuarters, precision*/ 5) {
    				toggle_class(button, "txcm-datepickerPrecisionControl-is-active", /*isMonthsQuarters*/ ctx[2](/*precision*/ ctx[0]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(27:4) {#if mode === 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div;
    	let t0;
    	let button;
    	let svg;
    	let use;
    	let t1;
    	let int;
    	let button_data_option_value;
    	let t2;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*mode*/ ctx[1] === 0 && create_if_block$2(ctx);
    	int = new Int({ props: { key: "год" }, $$inline: true });
    	const default_slot_template = /*$$slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t0 = space();
    			button = element("button");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t1 = space();
    			create_component(int.$$.fragment);
    			t2 = space();
    			if (default_slot) default_slot.c();
    			xlink_attr(use, "xlink:href", "#txspt-icons-arrow");
    			add_location(use, file$c, 48, 12, 1239);
    			attr_dev(svg, "class", "txcm-datepickerPrecisionControlIcon");
    			add_location(svg, file$c, 46, 8, 1167);
    			attr_dev(button, "class", "txcm-datepickerPrecisionControl");
    			attr_dev(button, "data-option", button_data_option_value = 2);
    			toggle_class(button, "txcm-datepickerPrecisionControl-is-active", /*isYears*/ ctx[3](/*precision*/ ctx[0]));
    			add_location(button, file$c, 41, 4, 973);
    			attr_dev(div, "class", "txcm-datepickerControls");
    			add_location(div, file$c, 24, 0, 472);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t0);
    			append_dev(div, button);
    			append_dev(button, svg);
    			append_dev(svg, use);
    			append_dev(button, t1);
    			mount_component(int, button, null);
    			append_dev(div, t2);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onPrecisionClick*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*mode*/ ctx[1] === 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*mode*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*isYears, precision*/ 9) {
    				toggle_class(button, "txcm-datepickerPrecisionControl-is-active", /*isYears*/ ctx[3](/*precision*/ ctx[0]));
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(int.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(int.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			destroy_component(int);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { mode } = $$props;
    	let { precision } = $$props;

    	function isMonthsQuarters() {
    		return precision === 2 || precision === 3;
    	}

    	function isYears() {
    		return precision === 4;
    	}

    	function changePrecision(option) {
    		$$invalidate(0, precision = option);
    	}

    	function onPrecisionClick(event) {
    		const option = parseInt(event.target.dataset.option, 10);
    		changePrecision(option);
    	}

    	const writable_props = ["mode", "precision"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DatepickerControls> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DatepickerControls", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("mode" in $$props) $$invalidate(1, mode = $$props.mode);
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		mode,
    		precision,
    		isMonthsQuarters,
    		isYears,
    		changePrecision,
    		onPrecisionClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("mode" in $$props) $$invalidate(1, mode = $$props.mode);
    		if ("precision" in $$props) $$invalidate(0, precision = $$props.precision);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [precision, mode, isMonthsQuarters, isYears, onPrecisionClick, $$scope, $$slots];
    }

    class DatepickerControls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { mode: 1, precision: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DatepickerControls",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*mode*/ ctx[1] === undefined && !("mode" in props)) {
    			console.warn("<DatepickerControls> was created without expected prop 'mode'");
    		}

    		if (/*precision*/ ctx[0] === undefined && !("precision" in props)) {
    			console.warn("<DatepickerControls> was created without expected prop 'precision'");
    		}
    	}

    	get mode() {
    		throw new Error("<DatepickerControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mode(value) {
    		throw new Error("<DatepickerControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get precision() {
    		throw new Error("<DatepickerControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precision(value) {
    		throw new Error("<DatepickerControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/datepicker/Datepicker.svelte generated by Svelte v3.24.0 */
    const file$d = "src/js/components/datepicker/Datepicker.svelte";

    // (172:8) <DatepickerControls           {mode}           bind:precision>
    function create_default_slot_1(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[22].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[31], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty[1] & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[31], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(172:8) <DatepickerControls           {mode}           bind:precision>",
    		ctx
    	});

    	return block;
    }

    // (157:4) <DatepickerContainer       {isActive}       {upperLimit}       {lowerLimit}       {mode}       {monthOptions}       {quarterOptions}       {yearOptions}       {name}       bind:precision       bind:day       bind:week       bind:month       bind:quarter       bind:year>
    function create_default_slot(ctx) {
    	let datepickercontrols;
    	let updating_precision;
    	let current;

    	function datepickercontrols_precision_binding(value) {
    		/*datepickercontrols_precision_binding*/ ctx[24].call(null, value);
    	}

    	let datepickercontrols_props = {
    		mode: /*mode*/ ctx[3],
    		$$slots: { default: [create_default_slot_1] },
    		$$scope: { ctx }
    	};

    	if (/*precision*/ ctx[12] !== void 0) {
    		datepickercontrols_props.precision = /*precision*/ ctx[12];
    	}

    	datepickercontrols = new DatepickerControls({
    			props: datepickercontrols_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(datepickercontrols, "precision", datepickercontrols_precision_binding));

    	const block = {
    		c: function create() {
    			create_component(datepickercontrols.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(datepickercontrols, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const datepickercontrols_changes = {};
    			if (dirty[0] & /*mode*/ 8) datepickercontrols_changes.mode = /*mode*/ ctx[3];

    			if (dirty[1] & /*$$scope*/ 1) {
    				datepickercontrols_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_precision && dirty[0] & /*precision*/ 4096) {
    				updating_precision = true;
    				datepickercontrols_changes.precision = /*precision*/ ctx[12];
    				add_flush_callback(() => updating_precision = false);
    			}

    			datepickercontrols.$set(datepickercontrols_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(datepickercontrols.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(datepickercontrols.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(datepickercontrols, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(157:4) <DatepickerContainer       {isActive}       {upperLimit}       {lowerLimit}       {mode}       {monthOptions}       {quarterOptions}       {yearOptions}       {name}       bind:precision       bind:day       bind:week       bind:month       bind:quarter       bind:year>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let div;
    	let datepickertoggle;
    	let updating_isActive;
    	let t;
    	let datepickercontainer;
    	let updating_precision;
    	let updating_day;
    	let updating_week;
    	let updating_month;
    	let updating_quarter;
    	let updating_year;
    	let current;

    	function datepickertoggle_isActive_binding(value) {
    		/*datepickertoggle_isActive_binding*/ ctx[23].call(null, value);
    	}

    	let datepickertoggle_props = {
    		label: /*label*/ ctx[13],
    		note: /*note*/ ctx[4],
    		disabled: /*disabledAll*/ ctx[5]
    	};

    	if (/*isActive*/ ctx[0] !== void 0) {
    		datepickertoggle_props.isActive = /*isActive*/ ctx[0];
    	}

    	datepickertoggle = new DatepickerToggle({
    			props: datepickertoggle_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(datepickertoggle, "isActive", datepickertoggle_isActive_binding));

    	function datepickercontainer_precision_binding(value) {
    		/*datepickercontainer_precision_binding*/ ctx[25].call(null, value);
    	}

    	function datepickercontainer_day_binding(value) {
    		/*datepickercontainer_day_binding*/ ctx[26].call(null, value);
    	}

    	function datepickercontainer_week_binding(value) {
    		/*datepickercontainer_week_binding*/ ctx[27].call(null, value);
    	}

    	function datepickercontainer_month_binding(value) {
    		/*datepickercontainer_month_binding*/ ctx[28].call(null, value);
    	}

    	function datepickercontainer_quarter_binding(value) {
    		/*datepickercontainer_quarter_binding*/ ctx[29].call(null, value);
    	}

    	function datepickercontainer_year_binding(value) {
    		/*datepickercontainer_year_binding*/ ctx[30].call(null, value);
    	}

    	let datepickercontainer_props = {
    		isActive: /*isActive*/ ctx[0],
    		upperLimit: /*upperLimit*/ ctx[2],
    		lowerLimit: /*lowerLimit*/ ctx[1],
    		mode: /*mode*/ ctx[3],
    		monthOptions: /*monthOptions*/ ctx[14],
    		quarterOptions: /*quarterOptions*/ ctx[16],
    		yearOptions: /*yearOptions*/ ctx[17],
    		name: /*name*/ ctx[6],
    		$$slots: { default: [create_default_slot] },
    		$$scope: { ctx }
    	};

    	if (/*precision*/ ctx[12] !== void 0) {
    		datepickercontainer_props.precision = /*precision*/ ctx[12];
    	}

    	if (/*day*/ ctx[7] !== void 0) {
    		datepickercontainer_props.day = /*day*/ ctx[7];
    	}

    	if (/*week*/ ctx[10] !== void 0) {
    		datepickercontainer_props.week = /*week*/ ctx[10];
    	}

    	if (/*month*/ ctx[8] !== void 0) {
    		datepickercontainer_props.month = /*month*/ ctx[8];
    	}

    	if (/*quarter*/ ctx[11] !== void 0) {
    		datepickercontainer_props.quarter = /*quarter*/ ctx[11];
    	}

    	if (/*year*/ ctx[9] !== void 0) {
    		datepickercontainer_props.year = /*year*/ ctx[9];
    	}

    	datepickercontainer = new DatepickerContainer({
    			props: datepickercontainer_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(datepickercontainer, "precision", datepickercontainer_precision_binding));
    	binding_callbacks.push(() => bind(datepickercontainer, "day", datepickercontainer_day_binding));
    	binding_callbacks.push(() => bind(datepickercontainer, "week", datepickercontainer_week_binding));
    	binding_callbacks.push(() => bind(datepickercontainer, "month", datepickercontainer_month_binding));
    	binding_callbacks.push(() => bind(datepickercontainer, "quarter", datepickercontainer_quarter_binding));
    	binding_callbacks.push(() => bind(datepickercontainer, "year", datepickercontainer_year_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(datepickertoggle.$$.fragment);
    			t = space();
    			create_component(datepickercontainer.$$.fragment);
    			attr_dev(div, "class", "txcm-datepickerHolder");
    			add_location(div, file$d, 149, 0, 4218);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(datepickertoggle, div, null);
    			append_dev(div, t);
    			mount_component(datepickercontainer, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const datepickertoggle_changes = {};
    			if (dirty[0] & /*label*/ 8192) datepickertoggle_changes.label = /*label*/ ctx[13];
    			if (dirty[0] & /*note*/ 16) datepickertoggle_changes.note = /*note*/ ctx[4];
    			if (dirty[0] & /*disabledAll*/ 32) datepickertoggle_changes.disabled = /*disabledAll*/ ctx[5];

    			if (!updating_isActive && dirty[0] & /*isActive*/ 1) {
    				updating_isActive = true;
    				datepickertoggle_changes.isActive = /*isActive*/ ctx[0];
    				add_flush_callback(() => updating_isActive = false);
    			}

    			datepickertoggle.$set(datepickertoggle_changes);
    			const datepickercontainer_changes = {};
    			if (dirty[0] & /*isActive*/ 1) datepickercontainer_changes.isActive = /*isActive*/ ctx[0];
    			if (dirty[0] & /*upperLimit*/ 4) datepickercontainer_changes.upperLimit = /*upperLimit*/ ctx[2];
    			if (dirty[0] & /*lowerLimit*/ 2) datepickercontainer_changes.lowerLimit = /*lowerLimit*/ ctx[1];
    			if (dirty[0] & /*mode*/ 8) datepickercontainer_changes.mode = /*mode*/ ctx[3];
    			if (dirty[0] & /*monthOptions*/ 16384) datepickercontainer_changes.monthOptions = /*monthOptions*/ ctx[14];
    			if (dirty[0] & /*name*/ 64) datepickercontainer_changes.name = /*name*/ ctx[6];

    			if (dirty[0] & /*mode, precision*/ 4104 | dirty[1] & /*$$scope*/ 1) {
    				datepickercontainer_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_precision && dirty[0] & /*precision*/ 4096) {
    				updating_precision = true;
    				datepickercontainer_changes.precision = /*precision*/ ctx[12];
    				add_flush_callback(() => updating_precision = false);
    			}

    			if (!updating_day && dirty[0] & /*day*/ 128) {
    				updating_day = true;
    				datepickercontainer_changes.day = /*day*/ ctx[7];
    				add_flush_callback(() => updating_day = false);
    			}

    			if (!updating_week && dirty[0] & /*week*/ 1024) {
    				updating_week = true;
    				datepickercontainer_changes.week = /*week*/ ctx[10];
    				add_flush_callback(() => updating_week = false);
    			}

    			if (!updating_month && dirty[0] & /*month*/ 256) {
    				updating_month = true;
    				datepickercontainer_changes.month = /*month*/ ctx[8];
    				add_flush_callback(() => updating_month = false);
    			}

    			if (!updating_quarter && dirty[0] & /*quarter*/ 2048) {
    				updating_quarter = true;
    				datepickercontainer_changes.quarter = /*quarter*/ ctx[11];
    				add_flush_callback(() => updating_quarter = false);
    			}

    			if (!updating_year && dirty[0] & /*year*/ 512) {
    				updating_year = true;
    				datepickercontainer_changes.year = /*year*/ ctx[9];
    				add_flush_callback(() => updating_year = false);
    			}

    			datepickercontainer.$set(datepickercontainer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(datepickertoggle.$$.fragment, local);
    			transition_in(datepickercontainer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(datepickertoggle.$$.fragment, local);
    			transition_out(datepickercontainer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(datepickertoggle);
    			destroy_component(datepickercontainer);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function isCloseKey(keyCode) {
    	return keyCode === 27;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let $locale;
    	let { pick } = $$props;
    	let { precisionPick } = $$props;
    	let { value } = $$props;
    	let { precisionValue } = $$props;
    	let { lowerLimit = null } = $$props;
    	let { upperLimit = null } = $$props;
    	let { mode = 0 } = $$props;
    	let { note = null } = $$props;
    	let { disabledAll } = $$props;
    	let { isActive = false } = $$props;
    	let { name } = $$props;
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(32, $locale = value));
    	const appConfig = getContext("app").getAppConfig();
    	const quarterOptions = ["Q1", "Q2", "Q3", "Q4"];
    	const yearOptions = generateYearOptions();
    	let day;
    	let month;
    	let year;
    	let week;
    	let quarter;
    	let precision;
    	let label;

    	function renderLabel() {
    		return renderPreciseDate(pick, precisionPick, $locale);
    	}

    	function generateMonthOptions() {
    		const { dateMin } = appConfig;
    		const yearMin = new Date(dateMin).getFullYear() + year;
    		const result = [];

    		for (let monthShift = 0; monthShift < 12; monthShift += 1) {
    			const startOfMonth = moment([yearMin, monthShift]).startOf("month");
    			const endOfMonth = moment([yearMin, monthShift]).endOf("month");
    			const availDays = generateAvailableDays(startOfMonth.toDate(), endOfMonth.toDate(), precision, name);
    			const monthOption = renderMonthLong(Date.UTC(year, monthShift, 1), $locale);

    			result.push({
    				disabled: !availDays.length,
    				month: monthOption
    			});
    		}

    		return result;
    	}

    	function generateYearOptions() {
    		const { dateMin, dateMax } = appConfig;
    		const yearMin = new Date(dateMin).getFullYear();
    		const yearMax = new Date(dateMax).getFullYear();
    		const diff = yearMax - yearMin;
    		const result = [];

    		for (let yearShift = 0; yearShift <= diff; yearShift += 1) {
    			const yearOption = yearMin + yearShift;
    			result.push(yearOption);
    		}

    		return result;
    	}

    	function updateDisabled() {
    		if (disabledAll) $$invalidate(0, isActive = false);
    	}

    	function updatePrecisionValue() {
    		$$invalidate(19, precisionValue = precision);
    	}

    	function updateValue() {
    		const timestamp = Date.UTC(yearOptions[year], month, precision == 0 ? day : 1);
    		const date = new Date(timestamp);
    		$$invalidate(18, value = calculateDateForPrecision(date, precision, week));
    	}

    	function resetValues() {
    		const now = new Date(pick);
    		const dayValue = now.getDate();
    		const monthValue = now.getMonth();
    		const yearValue = now.getFullYear();
    		$$invalidate(7, day = dayValue);
    		$$invalidate(8, month = monthValue);
    		$$invalidate(9, year = yearOptions.indexOf(yearValue));
    		$$invalidate(10, week = calculateWeekNumber(day, month, yearValue));
    		$$invalidate(11, quarter = Math.floor(month / 3));
    		$$invalidate(12, precision = precisionPick);
    		$$invalidate(18, value = pick);
    		$$invalidate(19, precisionValue = precisionPick);
    	}

    	function updateLabel() {
    		$$invalidate(12, precision = precisionPick);
    		$$invalidate(19, precisionValue = precisionPick);
    		$$invalidate(13, label = renderLabel());
    	}

    	function updateDatepicker() {
    		if (isActive) {
    			subscribeWindow();
    			resetValues();
    		} else unsubscribeWindow();
    	}

    	function hide() {
    		$$invalidate(0, isActive = false);
    	}

    	function onKeyUp({ keyCode }) {
    		if (isCloseKey(keyCode) && isActive) hide();
    	}

    	function onWindowClick() {
    		hide();
    	}

    	function subscribeWindow() {
    		window.addEventListener("click", onWindowClick);
    		window.addEventListener("keyup", onKeyUp);
    	}

    	function unsubscribeWindow() {
    		window.removeEventListener("click", onWindowClick);
    		window.removeEventListener("keyup", onKeyUp);
    	}

    	resetValues();

    	const writable_props = [
    		"pick",
    		"precisionPick",
    		"value",
    		"precisionValue",
    		"lowerLimit",
    		"upperLimit",
    		"mode",
    		"note",
    		"disabledAll",
    		"isActive",
    		"name"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Datepicker> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Datepicker", $$slots, ['default']);

    	function datepickertoggle_isActive_binding(value) {
    		isActive = value;
    		$$invalidate(0, isActive);
    	}

    	function datepickercontrols_precision_binding(value) {
    		precision = value;
    		$$invalidate(12, precision);
    	}

    	function datepickercontainer_precision_binding(value) {
    		precision = value;
    		$$invalidate(12, precision);
    	}

    	function datepickercontainer_day_binding(value) {
    		day = value;
    		$$invalidate(7, day);
    	}

    	function datepickercontainer_week_binding(value) {
    		week = value;
    		$$invalidate(10, week);
    	}

    	function datepickercontainer_month_binding(value) {
    		month = value;
    		$$invalidate(8, month);
    	}

    	function datepickercontainer_quarter_binding(value) {
    		quarter = value;
    		$$invalidate(11, quarter);
    	}

    	function datepickercontainer_year_binding(value) {
    		year = value;
    		$$invalidate(9, year);
    	}

    	$$self.$set = $$props => {
    		if ("pick" in $$props) $$invalidate(20, pick = $$props.pick);
    		if ("precisionPick" in $$props) $$invalidate(21, precisionPick = $$props.precisionPick);
    		if ("value" in $$props) $$invalidate(18, value = $$props.value);
    		if ("precisionValue" in $$props) $$invalidate(19, precisionValue = $$props.precisionValue);
    		if ("lowerLimit" in $$props) $$invalidate(1, lowerLimit = $$props.lowerLimit);
    		if ("upperLimit" in $$props) $$invalidate(2, upperLimit = $$props.upperLimit);
    		if ("mode" in $$props) $$invalidate(3, mode = $$props.mode);
    		if ("note" in $$props) $$invalidate(4, note = $$props.note);
    		if ("disabledAll" in $$props) $$invalidate(5, disabledAll = $$props.disabledAll);
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    		if ("name" in $$props) $$invalidate(6, name = $$props.name);
    		if ("$$scope" in $$props) $$invalidate(31, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		renderPreciseDate,
    		renderMonthLong,
    		calculateWeekNumber,
    		DatepickerToggle,
    		DatepickerContainer,
    		DatepickerControls,
    		getUIState,
    		generateAvailableDays,
    		calculateDateForPrecision,
    		moment,
    		getDashboardState,
    		pick,
    		precisionPick,
    		value,
    		precisionValue,
    		lowerLimit,
    		upperLimit,
    		mode,
    		note,
    		disabledAll,
    		isActive,
    		name,
    		locale,
    		appConfig,
    		quarterOptions,
    		yearOptions,
    		day,
    		month,
    		year,
    		week,
    		quarter,
    		precision,
    		label,
    		renderLabel,
    		generateMonthOptions,
    		generateYearOptions,
    		updateDisabled,
    		updatePrecisionValue,
    		updateValue,
    		resetValues,
    		updateLabel,
    		updateDatepicker,
    		hide,
    		isCloseKey,
    		onKeyUp,
    		onWindowClick,
    		subscribeWindow,
    		unsubscribeWindow,
    		monthOptions,
    		$locale
    	});

    	$$self.$inject_state = $$props => {
    		if ("pick" in $$props) $$invalidate(20, pick = $$props.pick);
    		if ("precisionPick" in $$props) $$invalidate(21, precisionPick = $$props.precisionPick);
    		if ("value" in $$props) $$invalidate(18, value = $$props.value);
    		if ("precisionValue" in $$props) $$invalidate(19, precisionValue = $$props.precisionValue);
    		if ("lowerLimit" in $$props) $$invalidate(1, lowerLimit = $$props.lowerLimit);
    		if ("upperLimit" in $$props) $$invalidate(2, upperLimit = $$props.upperLimit);
    		if ("mode" in $$props) $$invalidate(3, mode = $$props.mode);
    		if ("note" in $$props) $$invalidate(4, note = $$props.note);
    		if ("disabledAll" in $$props) $$invalidate(5, disabledAll = $$props.disabledAll);
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    		if ("name" in $$props) $$invalidate(6, name = $$props.name);
    		if ("day" in $$props) $$invalidate(7, day = $$props.day);
    		if ("month" in $$props) $$invalidate(8, month = $$props.month);
    		if ("year" in $$props) $$invalidate(9, year = $$props.year);
    		if ("week" in $$props) $$invalidate(10, week = $$props.week);
    		if ("quarter" in $$props) $$invalidate(11, quarter = $$props.quarter);
    		if ("precision" in $$props) $$invalidate(12, precision = $$props.precision);
    		if ("label" in $$props) $$invalidate(13, label = $$props.label);
    		if ("monthOptions" in $$props) $$invalidate(14, monthOptions = $$props.monthOptions);
    	};

    	let monthOptions;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*year*/ 512 | $$self.$$.dirty[1] & /*$locale*/ 2) {
    			 $$invalidate(14, monthOptions = generateMonthOptions());
    		}

    		if ($$self.$$.dirty[0] & /*year, quarter, month, week, day, precision*/ 8064) {
    			 updateValue();
    		}

    		if ($$self.$$.dirty[0] & /*precision*/ 4096 | $$self.$$.dirty[1] & /*$locale*/ 2) {
    			 updatePrecisionValue();
    		}

    		if ($$self.$$.dirty[0] & /*pick, precisionPick*/ 3145728 | $$self.$$.dirty[1] & /*$locale*/ 2) {
    			 updateLabel();
    		}

    		if ($$self.$$.dirty[0] & /*isActive*/ 1) {
    			 updateDatepicker();
    		}

    		if ($$self.$$.dirty[0] & /*disabledAll*/ 32) {
    			 updateDisabled();
    		}
    	};

    	return [
    		isActive,
    		lowerLimit,
    		upperLimit,
    		mode,
    		note,
    		disabledAll,
    		name,
    		day,
    		month,
    		year,
    		week,
    		quarter,
    		precision,
    		label,
    		monthOptions,
    		locale,
    		quarterOptions,
    		yearOptions,
    		value,
    		precisionValue,
    		pick,
    		precisionPick,
    		$$slots,
    		datepickertoggle_isActive_binding,
    		datepickercontrols_precision_binding,
    		datepickercontainer_precision_binding,
    		datepickercontainer_day_binding,
    		datepickercontainer_week_binding,
    		datepickercontainer_month_binding,
    		datepickercontainer_quarter_binding,
    		datepickercontainer_year_binding,
    		$$scope
    	];
    }

    class Datepicker extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$f,
    			create_fragment$f,
    			safe_not_equal,
    			{
    				pick: 20,
    				precisionPick: 21,
    				value: 18,
    				precisionValue: 19,
    				lowerLimit: 1,
    				upperLimit: 2,
    				mode: 3,
    				note: 4,
    				disabledAll: 5,
    				isActive: 0,
    				name: 6
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Datepicker",
    			options,
    			id: create_fragment$f.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*pick*/ ctx[20] === undefined && !("pick" in props)) {
    			console.warn("<Datepicker> was created without expected prop 'pick'");
    		}

    		if (/*precisionPick*/ ctx[21] === undefined && !("precisionPick" in props)) {
    			console.warn("<Datepicker> was created without expected prop 'precisionPick'");
    		}

    		if (/*value*/ ctx[18] === undefined && !("value" in props)) {
    			console.warn("<Datepicker> was created without expected prop 'value'");
    		}

    		if (/*precisionValue*/ ctx[19] === undefined && !("precisionValue" in props)) {
    			console.warn("<Datepicker> was created without expected prop 'precisionValue'");
    		}

    		if (/*disabledAll*/ ctx[5] === undefined && !("disabledAll" in props)) {
    			console.warn("<Datepicker> was created without expected prop 'disabledAll'");
    		}

    		if (/*name*/ ctx[6] === undefined && !("name" in props)) {
    			console.warn("<Datepicker> was created without expected prop 'name'");
    		}
    	}

    	get pick() {
    		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pick(value) {
    		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get precisionPick() {
    		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precisionPick(value) {
    		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get precisionValue() {
    		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set precisionValue(value) {
    		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get lowerLimit() {
    		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set lowerLimit(value) {
    		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get upperLimit() {
    		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set upperLimit(value) {
    		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get mode() {
    		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mode(value) {
    		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get note() {
    		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set note(value) {
    		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabledAll() {
    		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabledAll(value) {
    		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isActive() {
    		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isActive(value) {
    		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Datepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Datepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/header/HeaderDatepicker.svelte generated by Svelte v3.24.0 */
    const file$e = "src/js/components/header/HeaderDatepicker.svelte";

    // (45:0) <Datepicker   bind:pick   bind:precisionPick   bind:value   bind:precisionValue   bind:isActive   lowerLimit={dateMin}   upperLimit={dateMax}   disabledAll={disabled}   name="date"   {mode}>
    function create_default_slot$1(ctx) {
    	let button;
    	let int;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: "Выбрать" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(int.$$.fragment);
    			attr_dev(button, "class", "txcm-datepickerSubmit");
    			add_location(button, file$e, 55, 4, 1321);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", prevent_default(/*onSubmitClick*/ ctx[11]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(45:0) <Datepicker   bind:pick   bind:precisionPick   bind:value   bind:precisionValue   bind:isActive   lowerLimit={dateMin}   upperLimit={dateMax}   disabledAll={disabled}   name=\\\"date\\\"   {mode}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let datepicker;
    	let updating_pick;
    	let updating_precisionPick;
    	let updating_value;
    	let updating_precisionValue;
    	let updating_isActive;
    	let current;

    	function datepicker_pick_binding(value) {
    		/*datepicker_pick_binding*/ ctx[13].call(null, value);
    	}

    	function datepicker_precisionPick_binding(value) {
    		/*datepicker_precisionPick_binding*/ ctx[14].call(null, value);
    	}

    	function datepicker_value_binding(value) {
    		/*datepicker_value_binding*/ ctx[15].call(null, value);
    	}

    	function datepicker_precisionValue_binding(value) {
    		/*datepicker_precisionValue_binding*/ ctx[16].call(null, value);
    	}

    	function datepicker_isActive_binding(value) {
    		/*datepicker_isActive_binding*/ ctx[17].call(null, value);
    	}

    	let datepicker_props = {
    		lowerLimit: /*dateMin*/ ctx[7],
    		upperLimit: /*dateMax*/ ctx[8],
    		disabledAll: /*disabled*/ ctx[0],
    		name: "date",
    		mode: /*mode*/ ctx[6],
    		$$slots: { default: [create_default_slot$1] },
    		$$scope: { ctx }
    	};

    	if (/*pick*/ ctx[4] !== void 0) {
    		datepicker_props.pick = /*pick*/ ctx[4];
    	}

    	if (/*precisionPick*/ ctx[5] !== void 0) {
    		datepicker_props.precisionPick = /*precisionPick*/ ctx[5];
    	}

    	if (/*value*/ ctx[1] !== void 0) {
    		datepicker_props.value = /*value*/ ctx[1];
    	}

    	if (/*precisionValue*/ ctx[2] !== void 0) {
    		datepicker_props.precisionValue = /*precisionValue*/ ctx[2];
    	}

    	if (/*isActive*/ ctx[3] !== void 0) {
    		datepicker_props.isActive = /*isActive*/ ctx[3];
    	}

    	datepicker = new Datepicker({ props: datepicker_props, $$inline: true });
    	binding_callbacks.push(() => bind(datepicker, "pick", datepicker_pick_binding));
    	binding_callbacks.push(() => bind(datepicker, "precisionPick", datepicker_precisionPick_binding));
    	binding_callbacks.push(() => bind(datepicker, "value", datepicker_value_binding));
    	binding_callbacks.push(() => bind(datepicker, "precisionValue", datepicker_precisionValue_binding));
    	binding_callbacks.push(() => bind(datepicker, "isActive", datepicker_isActive_binding));

    	const block = {
    		c: function create() {
    			create_component(datepicker.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(datepicker, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const datepicker_changes = {};
    			if (dirty & /*disabled*/ 1) datepicker_changes.disabledAll = /*disabled*/ ctx[0];
    			if (dirty & /*mode*/ 64) datepicker_changes.mode = /*mode*/ ctx[6];

    			if (dirty & /*$$scope*/ 16777216) {
    				datepicker_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_pick && dirty & /*pick*/ 16) {
    				updating_pick = true;
    				datepicker_changes.pick = /*pick*/ ctx[4];
    				add_flush_callback(() => updating_pick = false);
    			}

    			if (!updating_precisionPick && dirty & /*precisionPick*/ 32) {
    				updating_precisionPick = true;
    				datepicker_changes.precisionPick = /*precisionPick*/ ctx[5];
    				add_flush_callback(() => updating_precisionPick = false);
    			}

    			if (!updating_value && dirty & /*value*/ 2) {
    				updating_value = true;
    				datepicker_changes.value = /*value*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			if (!updating_precisionValue && dirty & /*precisionValue*/ 4) {
    				updating_precisionValue = true;
    				datepicker_changes.precisionValue = /*precisionValue*/ ctx[2];
    				add_flush_callback(() => updating_precisionValue = false);
    			}

    			if (!updating_isActive && dirty & /*isActive*/ 8) {
    				updating_isActive = true;
    				datepicker_changes.isActive = /*isActive*/ ctx[3];
    				add_flush_callback(() => updating_isActive = false);
    			}

    			datepicker.$set(datepicker_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(datepicker.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(datepicker.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(datepicker, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $date;
    	let $datePrecision;
    	let { dashboard } = $$props;
    	let { disabled } = $$props;
    	const { dateMin } = getContext("app").getAppConfig();
    	const { dateMax } = getContext("app").getAppConfig();
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(18, $date = value));
    	const datePoP = getDashboardState("datePoP");
    	const datePrecision = getDashboardState("datePrecision");
    	validate_store(datePrecision, "datePrecision");
    	component_subscribe($$self, datePrecision, value => $$invalidate(19, $datePrecision = value));
    	let value;
    	let precisionValue;
    	let isActive;

    	function updatePick() {
    		if (pick !== $date) $$invalidate(4, pick = $date);
    	}

    	function updatePrecisionPick() {
    		if (precisionPick !== $datePrecision) $$invalidate(5, precisionPick = $datePrecision);
    	}

    	function pickValue() {
    		set_store_value(date, $date = value);
    		set_store_value(datePrecision, $datePrecision = precisionValue);
    		$$invalidate(3, isActive = false);
    	}

    	function onSubmitClick() {
    		pickValue();
    	}

    	const writable_props = ["dashboard", "disabled"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HeaderDatepicker> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("HeaderDatepicker", $$slots, []);

    	function datepicker_pick_binding(value) {
    		pick = value;
    		($$invalidate(4, pick), $$invalidate(18, $date));
    	}

    	function datepicker_precisionPick_binding(value) {
    		precisionPick = value;
    		($$invalidate(5, precisionPick), $$invalidate(19, $datePrecision));
    	}

    	function datepicker_value_binding(value$1) {
    		value = value$1;
    		$$invalidate(1, value);
    	}

    	function datepicker_precisionValue_binding(value) {
    		precisionValue = value;
    		$$invalidate(2, precisionValue);
    	}

    	function datepicker_isActive_binding(value) {
    		isActive = value;
    		$$invalidate(3, isActive);
    	}

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(12, dashboard = $$props.dashboard);
    		if ("disabled" in $$props) $$invalidate(0, disabled = $$props.disabled);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		getDashboardState,
    		Int,
    		Datepicker,
    		dashboard,
    		disabled,
    		dateMin,
    		dateMax,
    		date,
    		datePoP,
    		datePrecision,
    		value,
    		precisionValue,
    		isActive,
    		updatePick,
    		updatePrecisionPick,
    		pickValue,
    		onSubmitClick,
    		pick,
    		$date,
    		precisionPick,
    		$datePrecision,
    		mode
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(12, dashboard = $$props.dashboard);
    		if ("disabled" in $$props) $$invalidate(0, disabled = $$props.disabled);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("precisionValue" in $$props) $$invalidate(2, precisionValue = $$props.precisionValue);
    		if ("isActive" in $$props) $$invalidate(3, isActive = $$props.isActive);
    		if ("pick" in $$props) $$invalidate(4, pick = $$props.pick);
    		if ("precisionPick" in $$props) $$invalidate(5, precisionPick = $$props.precisionPick);
    		if ("mode" in $$props) $$invalidate(6, mode = $$props.mode);
    	};

    	let pick;
    	let precisionPick;
    	let mode;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$date*/ 262144) {
    			 $$invalidate(4, pick = $date);
    		}

    		if ($$self.$$.dirty & /*$datePrecision*/ 524288) {
    			 $$invalidate(5, precisionPick = $datePrecision);
    		}

    		if ($$self.$$.dirty & /*$date*/ 262144) {
    			 updatePick();
    		}

    		if ($$self.$$.dirty & /*$datePrecision*/ 524288) {
    			 updatePrecisionPick();
    		}

    		if ($$self.$$.dirty & /*dashboard*/ 4096) {
    			 $$invalidate(6, mode = dashboard === "financial" ? 1 : 0);
    		}
    	};

    	return [
    		disabled,
    		value,
    		precisionValue,
    		isActive,
    		pick,
    		precisionPick,
    		mode,
    		dateMin,
    		dateMax,
    		date,
    		datePrecision,
    		onSubmitClick,
    		dashboard,
    		datepicker_pick_binding,
    		datepicker_precisionPick_binding,
    		datepicker_value_binding,
    		datepicker_precisionValue_binding,
    		datepicker_isActive_binding
    	];
    }

    class HeaderDatepicker extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { dashboard: 12, disabled: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HeaderDatepicker",
    			options,
    			id: create_fragment$g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[12] === undefined && !("dashboard" in props)) {
    			console.warn("<HeaderDatepicker> was created without expected prop 'dashboard'");
    		}

    		if (/*disabled*/ ctx[0] === undefined && !("disabled" in props)) {
    			console.warn("<HeaderDatepicker> was created without expected prop 'disabled'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<HeaderDatepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<HeaderDatepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<HeaderDatepicker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<HeaderDatepicker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/header/HeaderDatepickerPoP.svelte generated by Svelte v3.24.0 */
    const file$f = "src/js/components/header/HeaderDatepickerPoP.svelte";

    // (56:0) <Datepicker   bind:pick   bind:precisionPick   bind:value   bind:precisionValue   bind:isActive   lowerLimit={dateMin}   upperLimit={dateMax}   disabledAll={disabled}   name="datePoP"   {mode}   {note}>
    function create_default_slot$2(ctx) {
    	let button;
    	let int;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: "Выбрать PoP" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(int.$$.fragment);
    			attr_dev(button, "class", "txcm-datepickerSubmit");
    			add_location(button, file$f, 67, 4, 1615);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", prevent_default(/*onSubmitPOPClick*/ ctx[14]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(56:0) <Datepicker   bind:pick   bind:precisionPick   bind:value   bind:precisionValue   bind:isActive   lowerLimit={dateMin}   upperLimit={dateMax}   disabledAll={disabled}   name=\\\"datePoP\\\"   {mode}   {note}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let datepicker;
    	let updating_pick;
    	let updating_precisionPick;
    	let updating_value;
    	let updating_precisionValue;
    	let updating_isActive;
    	let current;

    	function datepicker_pick_binding(value) {
    		/*datepicker_pick_binding*/ ctx[16].call(null, value);
    	}

    	function datepicker_precisionPick_binding(value) {
    		/*datepicker_precisionPick_binding*/ ctx[17].call(null, value);
    	}

    	function datepicker_value_binding(value) {
    		/*datepicker_value_binding*/ ctx[18].call(null, value);
    	}

    	function datepicker_precisionValue_binding(value) {
    		/*datepicker_precisionValue_binding*/ ctx[19].call(null, value);
    	}

    	function datepicker_isActive_binding(value) {
    		/*datepicker_isActive_binding*/ ctx[20].call(null, value);
    	}

    	let datepicker_props = {
    		lowerLimit: /*dateMin*/ ctx[8],
    		upperLimit: /*dateMax*/ ctx[9],
    		disabledAll: /*disabled*/ ctx[0],
    		name: "datePoP",
    		mode: /*mode*/ ctx[6],
    		note: /*note*/ ctx[7],
    		$$slots: { default: [create_default_slot$2] },
    		$$scope: { ctx }
    	};

    	if (/*pick*/ ctx[4] !== void 0) {
    		datepicker_props.pick = /*pick*/ ctx[4];
    	}

    	if (/*precisionPick*/ ctx[5] !== void 0) {
    		datepicker_props.precisionPick = /*precisionPick*/ ctx[5];
    	}

    	if (/*value*/ ctx[1] !== void 0) {
    		datepicker_props.value = /*value*/ ctx[1];
    	}

    	if (/*precisionValue*/ ctx[2] !== void 0) {
    		datepicker_props.precisionValue = /*precisionValue*/ ctx[2];
    	}

    	if (/*isActive*/ ctx[3] !== void 0) {
    		datepicker_props.isActive = /*isActive*/ ctx[3];
    	}

    	datepicker = new Datepicker({ props: datepicker_props, $$inline: true });
    	binding_callbacks.push(() => bind(datepicker, "pick", datepicker_pick_binding));
    	binding_callbacks.push(() => bind(datepicker, "precisionPick", datepicker_precisionPick_binding));
    	binding_callbacks.push(() => bind(datepicker, "value", datepicker_value_binding));
    	binding_callbacks.push(() => bind(datepicker, "precisionValue", datepicker_precisionValue_binding));
    	binding_callbacks.push(() => bind(datepicker, "isActive", datepicker_isActive_binding));

    	const block = {
    		c: function create() {
    			create_component(datepicker.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(datepicker, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const datepicker_changes = {};
    			if (dirty & /*disabled*/ 1) datepicker_changes.disabledAll = /*disabled*/ ctx[0];
    			if (dirty & /*mode*/ 64) datepicker_changes.mode = /*mode*/ ctx[6];
    			if (dirty & /*note*/ 128) datepicker_changes.note = /*note*/ ctx[7];

    			if (dirty & /*$$scope*/ 536870912) {
    				datepicker_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_pick && dirty & /*pick*/ 16) {
    				updating_pick = true;
    				datepicker_changes.pick = /*pick*/ ctx[4];
    				add_flush_callback(() => updating_pick = false);
    			}

    			if (!updating_precisionPick && dirty & /*precisionPick*/ 32) {
    				updating_precisionPick = true;
    				datepicker_changes.precisionPick = /*precisionPick*/ ctx[5];
    				add_flush_callback(() => updating_precisionPick = false);
    			}

    			if (!updating_value && dirty & /*value*/ 2) {
    				updating_value = true;
    				datepicker_changes.value = /*value*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			if (!updating_precisionValue && dirty & /*precisionValue*/ 4) {
    				updating_precisionValue = true;
    				datepicker_changes.precisionValue = /*precisionValue*/ ctx[2];
    				add_flush_callback(() => updating_precisionValue = false);
    			}

    			if (!updating_isActive && dirty & /*isActive*/ 8) {
    				updating_isActive = true;
    				datepicker_changes.isActive = /*isActive*/ ctx[3];
    				add_flush_callback(() => updating_isActive = false);
    			}

    			datepicker.$set(datepicker_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(datepicker.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(datepicker.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(datepicker, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let $datePoP;
    	let $datePrecision;
    	let $date;
    	let $yoyMode;
    	let { dashboard } = $$props;
    	let { disabled } = $$props;
    	const { dateMin } = getContext("app").getAppConfig();
    	const { dateMax } = getContext("app").getAppConfig();
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(23, $date = value));
    	const datePoP = getDashboardState("datePoP");
    	validate_store(datePoP, "datePoP");
    	component_subscribe($$self, datePoP, value => $$invalidate(21, $datePoP = value));
    	const datePrecision = getDashboardState("datePrecision");
    	validate_store(datePrecision, "datePrecision");
    	component_subscribe($$self, datePrecision, value => $$invalidate(22, $datePrecision = value));
    	const yoyMode = getDashboardState("yoyMode");
    	validate_store(yoyMode, "yoyMode");
    	component_subscribe($$self, yoyMode, value => $$invalidate(24, $yoyMode = value));
    	let value;
    	let precisionValue;
    	let isActive;

    	function updatePrecisionPick() {
    		if (precisionPick !== $datePrecision) $$invalidate(5, precisionPick = $datePrecision);
    	}

    	function changeYoY() {
    		if ($yoyMode) {
    			$$invalidate(1, value = subtractYear($date));
    			set_store_value(datePoP, $datePoP = value);
    		}
    	}

    	function updateNote() {
    		if ($yoyMode) return "YoY";
    		return "PoP";
    	}

    	function pickValue() {
    		set_store_value(datePoP, $datePoP = value);
    		set_store_value(datePrecision, $datePrecision = precisionValue);
    		$$invalidate(3, isActive = false);
    	}

    	function onSubmitPOPClick() {
    		pickValue();
    	}

    	const writable_props = ["dashboard", "disabled"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HeaderDatepickerPoP> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("HeaderDatepickerPoP", $$slots, []);

    	function datepicker_pick_binding(value) {
    		pick = value;
    		($$invalidate(4, pick), $$invalidate(21, $datePoP));
    	}

    	function datepicker_precisionPick_binding(value) {
    		precisionPick = value;
    		($$invalidate(5, precisionPick), $$invalidate(22, $datePrecision));
    	}

    	function datepicker_value_binding(value$1) {
    		value = value$1;
    		$$invalidate(1, value);
    	}

    	function datepicker_precisionValue_binding(value) {
    		precisionValue = value;
    		$$invalidate(2, precisionValue);
    	}

    	function datepicker_isActive_binding(value) {
    		isActive = value;
    		$$invalidate(3, isActive);
    	}

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(15, dashboard = $$props.dashboard);
    		if ("disabled" in $$props) $$invalidate(0, disabled = $$props.disabled);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		subtractYear,
    		getDashboardState,
    		Int,
    		Datepicker,
    		dashboard,
    		disabled,
    		dateMin,
    		dateMax,
    		date,
    		datePoP,
    		datePrecision,
    		yoyMode,
    		value,
    		precisionValue,
    		isActive,
    		updatePrecisionPick,
    		changeYoY,
    		updateNote,
    		pickValue,
    		onSubmitPOPClick,
    		pick,
    		$datePoP,
    		precisionPick,
    		$datePrecision,
    		$date,
    		$yoyMode,
    		mode,
    		note
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(15, dashboard = $$props.dashboard);
    		if ("disabled" in $$props) $$invalidate(0, disabled = $$props.disabled);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("precisionValue" in $$props) $$invalidate(2, precisionValue = $$props.precisionValue);
    		if ("isActive" in $$props) $$invalidate(3, isActive = $$props.isActive);
    		if ("pick" in $$props) $$invalidate(4, pick = $$props.pick);
    		if ("precisionPick" in $$props) $$invalidate(5, precisionPick = $$props.precisionPick);
    		if ("mode" in $$props) $$invalidate(6, mode = $$props.mode);
    		if ("note" in $$props) $$invalidate(7, note = $$props.note);
    	};

    	let pick;
    	let precisionPick;
    	let mode;
    	let note;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$datePoP*/ 2097152) {
    			 $$invalidate(4, pick = $datePoP);
    		}

    		if ($$self.$$.dirty & /*$datePrecision*/ 4194304) {
    			 $$invalidate(5, precisionPick = $datePrecision);
    		}

    		if ($$self.$$.dirty & /*$datePrecision*/ 4194304) {
    			 updatePrecisionPick();
    		}

    		if ($$self.$$.dirty & /*$date, pick, $yoyMode*/ 25165840) {
    			 changeYoY();
    		}

    		if ($$self.$$.dirty & /*dashboard*/ 32768) {
    			 $$invalidate(6, mode = dashboard === "financial" ? 1 : 0);
    		}

    		if ($$self.$$.dirty & /*$yoyMode*/ 16777216) {
    			 $$invalidate(7, note = updateNote());
    		}
    	};

    	return [
    		disabled,
    		value,
    		precisionValue,
    		isActive,
    		pick,
    		precisionPick,
    		mode,
    		note,
    		dateMin,
    		dateMax,
    		date,
    		datePoP,
    		datePrecision,
    		yoyMode,
    		onSubmitPOPClick,
    		dashboard,
    		datepicker_pick_binding,
    		datepicker_precisionPick_binding,
    		datepicker_value_binding,
    		datepicker_precisionValue_binding,
    		datepicker_isActive_binding
    	];
    }

    class HeaderDatepickerPoP extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, { dashboard: 15, disabled: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HeaderDatepickerPoP",
    			options,
    			id: create_fragment$h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[15] === undefined && !("dashboard" in props)) {
    			console.warn("<HeaderDatepickerPoP> was created without expected prop 'dashboard'");
    		}

    		if (/*disabled*/ ctx[0] === undefined && !("disabled" in props)) {
    			console.warn("<HeaderDatepickerPoP> was created without expected prop 'disabled'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<HeaderDatepickerPoP>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<HeaderDatepickerPoP>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<HeaderDatepickerPoP>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<HeaderDatepickerPoP>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/core/stepper/StepperOption.svelte generated by Svelte v3.24.0 */
    const file$g = "src/js/components/core/stepper/StepperOption.svelte";

    function create_fragment$i(ctx) {
    	let li;
    	let input;
    	let t;
    	let label_1;
    	let int;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*label*/ ctx[3] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			input = element("input");
    			t = space();
    			label_1 = element("label");
    			create_component(int.$$.fragment);
    			attr_dev(input, "class", "txcm-stepperInput");
    			attr_dev(input, "type", "radio");
    			attr_dev(input, "name", /*name*/ ctx[2]);
    			attr_dev(input, "id", /*id*/ ctx[5]);
    			input.__value = /*value*/ ctx[1];
    			input.value = input.__value;
    			input.disabled = /*disabled*/ ctx[4];
    			/*$$binding_groups*/ ctx[10][0].push(input);
    			add_location(input, file$g, 23, 4, 441);
    			attr_dev(label_1, "class", "txcm-stepperLabel");
    			attr_dev(label_1, "for", /*id*/ ctx[5]);
    			add_location(label_1, file$g, 31, 4, 583);
    			attr_dev(li, "class", "txcm-stepperOption");
    			add_location(li, file$g, 21, 0, 403);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, input);
    			input.checked = input.__value === /*pick*/ ctx[0];
    			append_dev(li, t);
    			append_dev(li, label_1);
    			mount_component(int, label_1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*input_change_handler*/ ctx[9]),
    					listen_dev(label_1, "click", /*onLabelClick*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*name*/ 4) {
    				attr_dev(input, "name", /*name*/ ctx[2]);
    			}

    			if (!current || dirty & /*value*/ 2) {
    				prop_dev(input, "__value", /*value*/ ctx[1]);
    				input.value = input.__value;
    			}

    			if (!current || dirty & /*disabled*/ 16) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[4]);
    			}

    			if (dirty & /*pick*/ 1) {
    				input.checked = input.__value === /*pick*/ ctx[0];
    			}

    			const int_changes = {};
    			if (dirty & /*label*/ 8) int_changes.key = /*label*/ ctx[3];
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			/*$$binding_groups*/ ctx[10][0].splice(/*$$binding_groups*/ ctx[10][0].indexOf(input), 1);
    			destroy_component(int);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let { pick } = $$props;
    	let { value } = $$props;
    	let { name } = $$props;
    	let { index } = $$props;
    	let { label } = $$props;
    	let { disabled = false } = $$props;
    	let { cancel } = $$props;
    	const id = `${name}-${index}`;

    	function onLabelClick(event) {
    		if (cancel && pick === value) {
    			event.preventDefault();
    			$$invalidate(0, pick = null);
    		}
    	}

    	const writable_props = ["pick", "value", "name", "index", "label", "disabled", "cancel"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<StepperOption> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("StepperOption", $$slots, []);
    	const $$binding_groups = [[]];

    	function input_change_handler() {
    		pick = this.__value;
    		$$invalidate(0, pick);
    	}

    	$$self.$set = $$props => {
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("name" in $$props) $$invalidate(2, name = $$props.name);
    		if ("index" in $$props) $$invalidate(7, index = $$props.index);
    		if ("label" in $$props) $$invalidate(3, label = $$props.label);
    		if ("disabled" in $$props) $$invalidate(4, disabled = $$props.disabled);
    		if ("cancel" in $$props) $$invalidate(8, cancel = $$props.cancel);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		pick,
    		value,
    		name,
    		index,
    		label,
    		disabled,
    		cancel,
    		id,
    		onLabelClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("name" in $$props) $$invalidate(2, name = $$props.name);
    		if ("index" in $$props) $$invalidate(7, index = $$props.index);
    		if ("label" in $$props) $$invalidate(3, label = $$props.label);
    		if ("disabled" in $$props) $$invalidate(4, disabled = $$props.disabled);
    		if ("cancel" in $$props) $$invalidate(8, cancel = $$props.cancel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		pick,
    		value,
    		name,
    		label,
    		disabled,
    		id,
    		onLabelClick,
    		index,
    		cancel,
    		input_change_handler,
    		$$binding_groups
    	];
    }

    class StepperOption extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$i, create_fragment$i, safe_not_equal, {
    			pick: 0,
    			value: 1,
    			name: 2,
    			index: 7,
    			label: 3,
    			disabled: 4,
    			cancel: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "StepperOption",
    			options,
    			id: create_fragment$i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*pick*/ ctx[0] === undefined && !("pick" in props)) {
    			console.warn("<StepperOption> was created without expected prop 'pick'");
    		}

    		if (/*value*/ ctx[1] === undefined && !("value" in props)) {
    			console.warn("<StepperOption> was created without expected prop 'value'");
    		}

    		if (/*name*/ ctx[2] === undefined && !("name" in props)) {
    			console.warn("<StepperOption> was created without expected prop 'name'");
    		}

    		if (/*index*/ ctx[7] === undefined && !("index" in props)) {
    			console.warn("<StepperOption> was created without expected prop 'index'");
    		}

    		if (/*label*/ ctx[3] === undefined && !("label" in props)) {
    			console.warn("<StepperOption> was created without expected prop 'label'");
    		}

    		if (/*cancel*/ ctx[8] === undefined && !("cancel" in props)) {
    			console.warn("<StepperOption> was created without expected prop 'cancel'");
    		}
    	}

    	get pick() {
    		throw new Error("<StepperOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pick(value) {
    		throw new Error("<StepperOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<StepperOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<StepperOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<StepperOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<StepperOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<StepperOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<StepperOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<StepperOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<StepperOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<StepperOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<StepperOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cancel() {
    		throw new Error("<StepperOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cancel(value) {
    		throw new Error("<StepperOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/core/stepper/Stepper.svelte generated by Svelte v3.24.0 */
    const file$h = "src/js/components/core/stepper/Stepper.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (14:4) {#each options as option, index}
    function create_each_block$5(ctx) {
    	let stepperoption;
    	let updating_pick;
    	let current;

    	const stepperoption_spread_levels = [
    		/*option*/ ctx[7],
    		{ name: /*name*/ ctx[1] },
    		{ cancel: /*cancel*/ ctx[3] },
    		{ disabled: /*disabled*/ ctx[4] },
    		{ index: /*index*/ ctx[9] }
    	];

    	function stepperoption_pick_binding(value) {
    		/*stepperoption_pick_binding*/ ctx[6].call(null, value);
    	}

    	let stepperoption_props = {};

    	for (let i = 0; i < stepperoption_spread_levels.length; i += 1) {
    		stepperoption_props = assign(stepperoption_props, stepperoption_spread_levels[i]);
    	}

    	if (/*pick*/ ctx[0] !== void 0) {
    		stepperoption_props.pick = /*pick*/ ctx[0];
    	}

    	stepperoption = new StepperOption({
    			props: stepperoption_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(stepperoption, "pick", stepperoption_pick_binding));

    	const block = {
    		c: function create() {
    			create_component(stepperoption.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(stepperoption, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const stepperoption_changes = (dirty & /*options, name, cancel, disabled*/ 30)
    			? get_spread_update(stepperoption_spread_levels, [
    					dirty & /*options*/ 4 && get_spread_object(/*option*/ ctx[7]),
    					dirty & /*name*/ 2 && { name: /*name*/ ctx[1] },
    					dirty & /*cancel*/ 8 && { cancel: /*cancel*/ ctx[3] },
    					dirty & /*disabled*/ 16 && { disabled: /*disabled*/ ctx[4] },
    					stepperoption_spread_levels[4]
    				])
    			: {};

    			if (!updating_pick && dirty & /*pick*/ 1) {
    				updating_pick = true;
    				stepperoption_changes.pick = /*pick*/ ctx[0];
    				add_flush_callback(() => updating_pick = false);
    			}

    			stepperoption.$set(stepperoption_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(stepperoption.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(stepperoption.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(stepperoption, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(14:4) {#each options as option, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let ul;
    	let ul_class_value;
    	let current;
    	let each_value = /*options*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", ul_class_value = `txcm-stepper ${/*theme*/ ctx[5]}`);
    			add_location(ul, file$h, 11, 0, 225);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*options, name, cancel, disabled, pick*/ 31) {
    				each_value = /*options*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*theme*/ 32 && ul_class_value !== (ul_class_value = `txcm-stepper ${/*theme*/ ctx[5]}`)) {
    				attr_dev(ul, "class", ul_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let { pick } = $$props;
    	let { name } = $$props;
    	let { options = [] } = $$props;
    	let { cancel = false } = $$props;
    	let { disabled = false } = $$props;
    	let { theme = "" } = $$props;
    	const writable_props = ["pick", "name", "options", "cancel", "disabled", "theme"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Stepper> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Stepper", $$slots, []);

    	function stepperoption_pick_binding(value) {
    		pick = value;
    		$$invalidate(0, pick);
    	}

    	$$self.$set = $$props => {
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    		if ("options" in $$props) $$invalidate(2, options = $$props.options);
    		if ("cancel" in $$props) $$invalidate(3, cancel = $$props.cancel);
    		if ("disabled" in $$props) $$invalidate(4, disabled = $$props.disabled);
    		if ("theme" in $$props) $$invalidate(5, theme = $$props.theme);
    	};

    	$$self.$capture_state = () => ({
    		StepperOption,
    		pick,
    		name,
    		options,
    		cancel,
    		disabled,
    		theme
    	});

    	$$self.$inject_state = $$props => {
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    		if ("options" in $$props) $$invalidate(2, options = $$props.options);
    		if ("cancel" in $$props) $$invalidate(3, cancel = $$props.cancel);
    		if ("disabled" in $$props) $$invalidate(4, disabled = $$props.disabled);
    		if ("theme" in $$props) $$invalidate(5, theme = $$props.theme);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [pick, name, options, cancel, disabled, theme, stepperoption_pick_binding];
    }

    class Stepper extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
    			pick: 0,
    			name: 1,
    			options: 2,
    			cancel: 3,
    			disabled: 4,
    			theme: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Stepper",
    			options,
    			id: create_fragment$j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*pick*/ ctx[0] === undefined && !("pick" in props)) {
    			console.warn("<Stepper> was created without expected prop 'pick'");
    		}

    		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
    			console.warn("<Stepper> was created without expected prop 'name'");
    		}
    	}

    	get pick() {
    		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pick(value) {
    		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get cancel() {
    		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cancel(value) {
    		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get theme() {
    		throw new Error("<Stepper>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set theme(value) {
    		throw new Error("<Stepper>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/header/HeaderUnits.svelte generated by Svelte v3.24.0 */

    function create_fragment$k(ctx) {
    	let stepper;
    	let updating_pick;
    	let current;

    	function stepper_pick_binding(value) {
    		/*stepper_pick_binding*/ ctx[5].call(null, value);
    	}

    	let stepper_props = {
    		name: `uintOptions-${/*variant*/ ctx[0]}`,
    		options: /*UNIT_OPTIONS*/ ctx[3],
    		disabled: /*disabled*/ ctx[1],
    		theme: "txcm-unitStepper"
    	};

    	if (/*$units*/ ctx[2] !== void 0) {
    		stepper_props.pick = /*$units*/ ctx[2];
    	}

    	stepper = new Stepper({ props: stepper_props, $$inline: true });
    	binding_callbacks.push(() => bind(stepper, "pick", stepper_pick_binding));

    	const block = {
    		c: function create() {
    			create_component(stepper.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(stepper, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const stepper_changes = {};
    			if (dirty & /*variant*/ 1) stepper_changes.name = `uintOptions-${/*variant*/ ctx[0]}`;
    			if (dirty & /*disabled*/ 2) stepper_changes.disabled = /*disabled*/ ctx[1];

    			if (!updating_pick && dirty & /*$units*/ 4) {
    				updating_pick = true;
    				stepper_changes.pick = /*$units*/ ctx[2];
    				add_flush_callback(() => updating_pick = false);
    			}

    			stepper.$set(stepper_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(stepper.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(stepper.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(stepper, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $units;
    	const UNIT_OPTIONS = [{ label: "% от выр.", value: 0 }, { label: "млн. руб", value: 1 }];
    	let { variant } = $$props;
    	let { disabled = false } = $$props;
    	const units = getDashboardState("units");
    	validate_store(units, "units");
    	component_subscribe($$self, units, value => $$invalidate(2, $units = value));
    	const writable_props = ["variant", "disabled"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HeaderUnits> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("HeaderUnits", $$slots, []);

    	function stepper_pick_binding(value) {
    		$units = value;
    		units.set($units);
    	}

    	$$self.$set = $$props => {
    		if ("variant" in $$props) $$invalidate(0, variant = $$props.variant);
    		if ("disabled" in $$props) $$invalidate(1, disabled = $$props.disabled);
    	};

    	$$self.$capture_state = () => ({
    		Stepper,
    		getDashboardState,
    		UNIT_OPTIONS,
    		variant,
    		disabled,
    		units,
    		$units
    	});

    	$$self.$inject_state = $$props => {
    		if ("variant" in $$props) $$invalidate(0, variant = $$props.variant);
    		if ("disabled" in $$props) $$invalidate(1, disabled = $$props.disabled);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [variant, disabled, $units, UNIT_OPTIONS, units, stepper_pick_binding];
    }

    class HeaderUnits extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, { variant: 0, disabled: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HeaderUnits",
    			options,
    			id: create_fragment$k.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*variant*/ ctx[0] === undefined && !("variant" in props)) {
    			console.warn("<HeaderUnits> was created without expected prop 'variant'");
    		}
    	}

    	get variant() {
    		throw new Error("<HeaderUnits>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error("<HeaderUnits>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<HeaderUnits>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<HeaderUnits>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/header/HeaderFilter.svelte generated by Svelte v3.24.0 */

    // (24:0) {#if isUnitsActive}
    function create_if_block$3(ctx) {
    	let headerunits;
    	let current;

    	headerunits = new HeaderUnits({
    			props: {
    				variant: /*variant*/ ctx[1],
    				disabled: /*isDisabled*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(headerunits.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(headerunits, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const headerunits_changes = {};
    			if (dirty & /*variant*/ 2) headerunits_changes.variant = /*variant*/ ctx[1];
    			if (dirty & /*isDisabled*/ 8) headerunits_changes.disabled = /*isDisabled*/ ctx[3];
    			headerunits.$set(headerunits_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(headerunits.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(headerunits.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(headerunits, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(24:0) {#if isUnitsActive}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let headerdatepicker;
    	let t0;
    	let headerdatepickerpop;
    	let t1;
    	let if_block_anchor;
    	let current;

    	headerdatepicker = new HeaderDatepicker({
    			props: {
    				dashboard: /*dashboard*/ ctx[0],
    				disabled: /*isDisabled*/ ctx[3]
    			},
    			$$inline: true
    		});

    	headerdatepickerpop = new HeaderDatepickerPoP({
    			props: {
    				dashboard: /*dashboard*/ ctx[0],
    				disabled: /*isDisabled*/ ctx[3]
    			},
    			$$inline: true
    		});

    	let if_block = /*isUnitsActive*/ ctx[2] && create_if_block$3(ctx);

    	const block = {
    		c: function create() {
    			create_component(headerdatepicker.$$.fragment);
    			t0 = space();
    			create_component(headerdatepickerpop.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(headerdatepicker, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(headerdatepickerpop, target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const headerdatepicker_changes = {};
    			if (dirty & /*dashboard*/ 1) headerdatepicker_changes.dashboard = /*dashboard*/ ctx[0];
    			if (dirty & /*isDisabled*/ 8) headerdatepicker_changes.disabled = /*isDisabled*/ ctx[3];
    			headerdatepicker.$set(headerdatepicker_changes);
    			const headerdatepickerpop_changes = {};
    			if (dirty & /*dashboard*/ 1) headerdatepickerpop_changes.dashboard = /*dashboard*/ ctx[0];
    			if (dirty & /*isDisabled*/ 8) headerdatepickerpop_changes.disabled = /*isDisabled*/ ctx[3];
    			headerdatepickerpop.$set(headerdatepickerpop_changes);

    			if (/*isUnitsActive*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isUnitsActive*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(headerdatepicker.$$.fragment, local);
    			transition_in(headerdatepickerpop.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(headerdatepicker.$$.fragment, local);
    			transition_out(headerdatepickerpop.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(headerdatepicker, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(headerdatepickerpop, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let $updating;
    	let $downloading;
    	let { dashboard } = $$props;
    	let { variant } = $$props;
    	const updating = getUIState("updating");
    	validate_store(updating, "updating");
    	component_subscribe($$self, updating, value => $$invalidate(6, $updating = value));
    	const downloading = getExportState("downloading");
    	validate_store(downloading, "downloading");
    	component_subscribe($$self, downloading, value => $$invalidate(7, $downloading = value));
    	const writable_props = ["dashboard", "variant"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HeaderFilter> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("HeaderFilter", $$slots, []);

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("variant" in $$props) $$invalidate(1, variant = $$props.variant);
    	};

    	$$self.$capture_state = () => ({
    		getUIState,
    		getExportState,
    		HeaderDatepicker,
    		HeaderDatepickerPoP,
    		HeaderUnits,
    		dashboard,
    		variant,
    		updating,
    		downloading,
    		isUnitsActive,
    		isDisabled,
    		$updating,
    		$downloading
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("variant" in $$props) $$invalidate(1, variant = $$props.variant);
    		if ("isUnitsActive" in $$props) $$invalidate(2, isUnitsActive = $$props.isUnitsActive);
    		if ("isDisabled" in $$props) $$invalidate(3, isDisabled = $$props.isDisabled);
    	};

    	let isUnitsActive;
    	let isDisabled;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*dashboard*/ 1) {
    			 $$invalidate(2, isUnitsActive = dashboard === "financial");
    		}

    		if ($$self.$$.dirty & /*$updating, $downloading*/ 192) {
    			 $$invalidate(3, isDisabled = $updating > 0 || $downloading > 0);
    		}
    	};

    	return [dashboard, variant, isUnitsActive, isDisabled, updating, downloading];
    }

    class HeaderFilter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, { dashboard: 0, variant: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HeaderFilter",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[0] === undefined && !("dashboard" in props)) {
    			console.warn("<HeaderFilter> was created without expected prop 'dashboard'");
    		}

    		if (/*variant*/ ctx[1] === undefined && !("variant" in props)) {
    			console.warn("<HeaderFilter> was created without expected prop 'variant'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<HeaderFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<HeaderFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get variant() {
    		throw new Error("<HeaderFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set variant(value) {
    		throw new Error("<HeaderFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/core/pick/Pick.svelte generated by Svelte v3.24.0 */
    const file$i = "src/js/components/core/pick/Pick.svelte";

    function create_fragment$m(ctx) {
    	let input;
    	let t;
    	let label_1;
    	let int;
    	let label_1_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*label*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			input = element("input");
    			t = space();
    			label_1 = element("label");
    			create_component(int.$$.fragment);
    			attr_dev(input, "class", "txcm-pickInput");
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "id", /*name*/ ctx[1]);
    			input.checked = /*pick*/ ctx[0];
    			input.disabled = /*disabled*/ ctx[3];
    			add_location(input, file$i, 16, 0, 308);
    			attr_dev(label_1, "class", label_1_class_value = `txcm-pick ${/*theme*/ ctx[4]}`);
    			attr_dev(label_1, "for", /*name*/ ctx[1]);
    			add_location(label_1, file$i, 23, 0, 428);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, label_1, anchor);
    			mount_component(int, label_1, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*onPickChange*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*name*/ 2) {
    				attr_dev(input, "id", /*name*/ ctx[1]);
    			}

    			if (!current || dirty & /*pick*/ 1) {
    				prop_dev(input, "checked", /*pick*/ ctx[0]);
    			}

    			if (!current || dirty & /*disabled*/ 8) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[3]);
    			}

    			const int_changes = {};
    			if (dirty & /*label*/ 4) int_changes.key = /*label*/ ctx[2];
    			int.$set(int_changes);

    			if (!current || dirty & /*theme*/ 16 && label_1_class_value !== (label_1_class_value = `txcm-pick ${/*theme*/ ctx[4]}`)) {
    				attr_dev(label_1, "class", label_1_class_value);
    			}

    			if (!current || dirty & /*name*/ 2) {
    				attr_dev(label_1, "for", /*name*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(label_1);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let { pick } = $$props;
    	let { name } = $$props;
    	let { value } = $$props;
    	let { label } = $$props;
    	let { disabled = false } = $$props;
    	let { theme = "" } = $$props;

    	function onPickChange() {
    		if (!pick) $$invalidate(0, pick = value); else $$invalidate(0, pick = null);
    	}

    	const writable_props = ["pick", "name", "value", "label", "disabled", "theme"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Pick> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Pick", $$slots, []);

    	$$self.$set = $$props => {
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    		if ("value" in $$props) $$invalidate(6, value = $$props.value);
    		if ("label" in $$props) $$invalidate(2, label = $$props.label);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    		if ("theme" in $$props) $$invalidate(4, theme = $$props.theme);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		pick,
    		name,
    		value,
    		label,
    		disabled,
    		theme,
    		onPickChange
    	});

    	$$self.$inject_state = $$props => {
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    		if ("value" in $$props) $$invalidate(6, value = $$props.value);
    		if ("label" in $$props) $$invalidate(2, label = $$props.label);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    		if ("theme" in $$props) $$invalidate(4, theme = $$props.theme);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [pick, name, label, disabled, theme, onPickChange, value];
    }

    class Pick extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {
    			pick: 0,
    			name: 1,
    			value: 6,
    			label: 2,
    			disabled: 3,
    			theme: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Pick",
    			options,
    			id: create_fragment$m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*pick*/ ctx[0] === undefined && !("pick" in props)) {
    			console.warn("<Pick> was created without expected prop 'pick'");
    		}

    		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
    			console.warn("<Pick> was created without expected prop 'name'");
    		}

    		if (/*value*/ ctx[6] === undefined && !("value" in props)) {
    			console.warn("<Pick> was created without expected prop 'value'");
    		}

    		if (/*label*/ ctx[2] === undefined && !("label" in props)) {
    			console.warn("<Pick> was created without expected prop 'label'");
    		}
    	}

    	get pick() {
    		throw new Error("<Pick>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pick(value) {
    		throw new Error("<Pick>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Pick>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Pick>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<Pick>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<Pick>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<Pick>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Pick>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Pick>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Pick>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get theme() {
    		throw new Error("<Pick>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set theme(value) {
    		throw new Error("<Pick>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function findIndex(array, value) {
      const index = array.findIndex(item => item.value === value);
      return index !== -1 ? index : null;
    }

    function findIndexes(array, values) {
      return values.map(value => findIndex(array, value));
    }

    function findGroupedIndex(array, value) {
      const groupIndex = array.findIndex(group => group.options.some(option => option.value === value));
      if (groupIndex === -1) return null;
      const optionIndex = array[groupIndex].options.findIndex(option => option.value === value);
      if (optionIndex === -1) return null;
      return `${groupIndex}-${optionIndex}`;
    }

    function findGroupedIndexes(array, values) {
      return values.map(value => findGroupedIndex(array, value));
    }

    function findValue(array, index) {
      if (index !== null) return array[index].value;
      return null;
    }

    function findValues(array, indexes) {
      return indexes.map(index => findValue(array, index));
    }

    function findGroupedValue(array, index) {
      const indexElements = index.split('-');
      const groupIndex = parseInt(indexElements[0], 10);
      const optionIndex = parseInt(indexElements[1], 10);
      if (index !== null) return array[groupIndex].options[optionIndex].value;
      return null;
    }

    function findGroupedValues(array, indexes) {
      return indexes.map(index => findGroupedValue(array, index));
    }

    /* src/js/components/core/dropdown/Dropdown.svelte generated by Svelte v3.24.0 */

    function create_fragment$n(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function isCloseKey$1(keyCode) {
    	return keyCode === 27;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let { isActive } = $$props;
    	const dispatch = createEventDispatcher();

    	function hide() {
    		if (isActive) dispatch("dropdownclose");
    	}

    	function onWindowClick() {
    		hide();
    	}

    	function onKeyUp({ keyCode }) {
    		if (isCloseKey$1(keyCode) && isActive) hide();
    	}

    	function onWheel() {
    		hide();
    	}

    	function subscribeWindow() {
    		window.addEventListener("click", onWindowClick);
    		window.addEventListener("keyup", onKeyUp);
    		window.addEventListener("wheel", onWheel);
    	}

    	function unsubscribeWindow() {
    		window.removeEventListener("click", onWindowClick);
    		window.removeEventListener("keyup", onKeyUp);
    		window.removeEventListener("wheel", onWheel);
    	}

    	function updateEvents() {
    		if (isActive) subscribeWindow(); else unsubscribeWindow();
    	}

    	const writable_props = ["isActive"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Dropdown> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Dropdown", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		isActive,
    		dispatch,
    		isCloseKey: isCloseKey$1,
    		hide,
    		onWindowClick,
    		onKeyUp,
    		onWheel,
    		subscribeWindow,
    		unsubscribeWindow,
    		updateEvents
    	});

    	$$self.$inject_state = $$props => {
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*isActive*/ 1) {
    			 updateEvents();
    		}
    	};

    	return [isActive, $$scope, $$slots];
    }

    class Dropdown extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, { isActive: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dropdown",
    			options,
    			id: create_fragment$n.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*isActive*/ ctx[0] === undefined && !("isActive" in props)) {
    			console.warn("<Dropdown> was created without expected prop 'isActive'");
    		}
    	}

    	get isActive() {
    		throw new Error("<Dropdown>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isActive(value) {
    		throw new Error("<Dropdown>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function renderID(name, index) {
      return `${name}-${index}`;
    }

    function renderURL(dashboard, indicator) {
      return `/dashboard/${dashboard}/${indicator}`;
    }

    /* src/js/components/core/select/SelectOption.svelte generated by Svelte v3.24.0 */
    const file$j = "src/js/components/core/select/SelectOption.svelte";

    function create_fragment$o(ctx) {
    	let li;
    	let input;
    	let t;
    	let label_1;
    	let int;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*label*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			input = element("input");
    			t = space();
    			label_1 = element("label");
    			create_component(int.$$.fragment);
    			attr_dev(input, "class", "txcm-selectInput");
    			attr_dev(input, "type", "radio");
    			attr_dev(input, "name", /*name*/ ctx[3]);
    			attr_dev(input, "id", /*id*/ ctx[7]);
    			input.disabled = /*disabled*/ ctx[5];
    			input.__value = /*index*/ ctx[4];
    			input.value = input.__value;
    			/*$$binding_groups*/ ctx[12][0].push(input);
    			add_location(input, file$j, 71, 4, 1657);
    			attr_dev(label_1, "class", "txcm-selectLabel");
    			attr_dev(label_1, "for", /*id*/ ctx[7]);
    			attr_dev(label_1, "data-option", /*index*/ ctx[4]);
    			toggle_class(label_1, "txcm-selectLabel-is-highlighted", /*isHighlighted*/ ctx[8](/*highlighted*/ ctx[1]));
    			add_location(label_1, file$j, 79, 4, 1808);
    			attr_dev(li, "class", "txcm-selectOption");
    			add_location(li, file$j, 69, 0, 1620);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, input);
    			input.checked = input.__value === /*selected*/ ctx[0];
    			append_dev(li, t);
    			append_dev(li, label_1);
    			mount_component(int, label_1, null);
    			/*label_1_binding*/ ctx[13](label_1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[11]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*name*/ 8) {
    				attr_dev(input, "name", /*name*/ ctx[3]);
    			}

    			if (!current || dirty & /*disabled*/ 32) {
    				prop_dev(input, "disabled", /*disabled*/ ctx[5]);
    			}

    			if (!current || dirty & /*index*/ 16) {
    				prop_dev(input, "__value", /*index*/ ctx[4]);
    				input.value = input.__value;
    			}

    			if (dirty & /*selected*/ 1) {
    				input.checked = input.__value === /*selected*/ ctx[0];
    			}

    			const int_changes = {};
    			if (dirty & /*label*/ 4) int_changes.key = /*label*/ ctx[2];
    			int.$set(int_changes);

    			if (!current || dirty & /*index*/ 16) {
    				attr_dev(label_1, "data-option", /*index*/ ctx[4]);
    			}

    			if (dirty & /*isHighlighted, highlighted*/ 258) {
    				toggle_class(label_1, "txcm-selectLabel-is-highlighted", /*isHighlighted*/ ctx[8](/*highlighted*/ ctx[1]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			/*$$binding_groups*/ ctx[12][0].splice(/*$$binding_groups*/ ctx[12][0].indexOf(input), 1);
    			destroy_component(int);
    			/*label_1_binding*/ ctx[13](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	let { selected } = $$props;
    	let { highlighted } = $$props;
    	let { name } = $$props;
    	let { index } = $$props;
    	let { value } = $$props;
    	let { disabled = false } = $$props;
    	let { isActive } = $$props;
    	const id = renderID(name, index);
    	let node;

    	function scrollPickIntoView() {
    		if (node && selected === value) node.scrollIntoView({ block: "nearest" });
    	}

    	function scrollHighlightIntoView() {
    		if (node && highlighted === index) node.scrollIntoView({ block: "nearest" });
    	}

    	function scrollActiveIntoView() {
    		if (node && isActive && selected === value) node.scrollIntoView({ block: "center" });
    	}

    	function isHighlighted() {
    		return highlighted === index;
    	}

    	function onOptionClick(event) {
    		if (selected === value) {
    			event.preventDefault();
    			$$invalidate(0, selected = null);
    		}
    	}

    	function onMouseOver({ target }) {
    		$$invalidate(1, highlighted = parseInt(target.dataset.option, 10));
    	}

    	function subscribeClick() {
    		if (node) {
    			node.addEventListener("click", onOptionClick);
    			node.addEventListener("mouseover", onMouseOver);
    		}
    	}

    	function unsubscribeClick() {
    		if (node) {
    			node.removeEventListener("click", onOptionClick);
    			node.removeEventListener("mouseover", onOptionClick);
    		}
    	}

    	function updateEvents() {
    		if (isActive) subscribeClick(); else unsubscribeClick();
    	}

    	const writable_props = [
    		"label",
    		"selected",
    		"highlighted",
    		"name",
    		"index",
    		"value",
    		"disabled",
    		"isActive"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SelectOption> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SelectOption", $$slots, []);
    	const $$binding_groups = [[]];

    	function input_change_handler() {
    		selected = this.__value;
    		$$invalidate(0, selected);
    	}

    	function label_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			node = $$value;
    			$$invalidate(6, node);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(2, label = $$props.label);
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    		if ("highlighted" in $$props) $$invalidate(1, highlighted = $$props.highlighted);
    		if ("name" in $$props) $$invalidate(3, name = $$props.name);
    		if ("index" in $$props) $$invalidate(4, index = $$props.index);
    		if ("value" in $$props) $$invalidate(9, value = $$props.value);
    		if ("disabled" in $$props) $$invalidate(5, disabled = $$props.disabled);
    		if ("isActive" in $$props) $$invalidate(10, isActive = $$props.isActive);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		renderID,
    		label,
    		selected,
    		highlighted,
    		name,
    		index,
    		value,
    		disabled,
    		isActive,
    		id,
    		node,
    		scrollPickIntoView,
    		scrollHighlightIntoView,
    		scrollActiveIntoView,
    		isHighlighted,
    		onOptionClick,
    		onMouseOver,
    		subscribeClick,
    		unsubscribeClick,
    		updateEvents
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(2, label = $$props.label);
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    		if ("highlighted" in $$props) $$invalidate(1, highlighted = $$props.highlighted);
    		if ("name" in $$props) $$invalidate(3, name = $$props.name);
    		if ("index" in $$props) $$invalidate(4, index = $$props.index);
    		if ("value" in $$props) $$invalidate(9, value = $$props.value);
    		if ("disabled" in $$props) $$invalidate(5, disabled = $$props.disabled);
    		if ("isActive" in $$props) $$invalidate(10, isActive = $$props.isActive);
    		if ("node" in $$props) $$invalidate(6, node = $$props.node);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*isActive*/ 1024) {
    			 updateEvents();
    		}

    		if ($$self.$$.dirty & /*selected*/ 1) {
    			 scrollPickIntoView();
    		}

    		if ($$self.$$.dirty & /*isActive*/ 1024) {
    			 scrollActiveIntoView();
    		}

    		if ($$self.$$.dirty & /*highlighted*/ 2) {
    			 scrollHighlightIntoView();
    		}
    	};

    	return [
    		selected,
    		highlighted,
    		label,
    		name,
    		index,
    		disabled,
    		node,
    		id,
    		isHighlighted,
    		value,
    		isActive,
    		input_change_handler,
    		$$binding_groups,
    		label_1_binding
    	];
    }

    class SelectOption extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {
    			label: 2,
    			selected: 0,
    			highlighted: 1,
    			name: 3,
    			index: 4,
    			value: 9,
    			disabled: 5,
    			isActive: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SelectOption",
    			options,
    			id: create_fragment$o.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[2] === undefined && !("label" in props)) {
    			console.warn("<SelectOption> was created without expected prop 'label'");
    		}

    		if (/*selected*/ ctx[0] === undefined && !("selected" in props)) {
    			console.warn("<SelectOption> was created without expected prop 'selected'");
    		}

    		if (/*highlighted*/ ctx[1] === undefined && !("highlighted" in props)) {
    			console.warn("<SelectOption> was created without expected prop 'highlighted'");
    		}

    		if (/*name*/ ctx[3] === undefined && !("name" in props)) {
    			console.warn("<SelectOption> was created without expected prop 'name'");
    		}

    		if (/*index*/ ctx[4] === undefined && !("index" in props)) {
    			console.warn("<SelectOption> was created without expected prop 'index'");
    		}

    		if (/*value*/ ctx[9] === undefined && !("value" in props)) {
    			console.warn("<SelectOption> was created without expected prop 'value'");
    		}

    		if (/*isActive*/ ctx[10] === undefined && !("isActive" in props)) {
    			console.warn("<SelectOption> was created without expected prop 'isActive'");
    		}
    	}

    	get label() {
    		throw new Error("<SelectOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<SelectOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<SelectOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<SelectOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get highlighted() {
    		throw new Error("<SelectOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set highlighted(value) {
    		throw new Error("<SelectOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<SelectOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<SelectOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<SelectOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<SelectOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<SelectOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<SelectOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<SelectOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<SelectOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isActive() {
    		throw new Error("<SelectOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isActive(value) {
    		throw new Error("<SelectOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/core/select/Select.svelte generated by Svelte v3.24.0 */
    const file$k = "src/js/components/core/select/Select.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[32] = list[i];
    	child_ctx[34] = i;
    	return child_ctx;
    }

    // (165:12) {#each options as option, index}
    function create_each_block$6(ctx) {
    	let selectoption;
    	let updating_selected;
    	let updating_highlighted;
    	let current;

    	const selectoption_spread_levels = [
    		/*option*/ ctx[32],
    		{ name: /*name*/ ctx[1] },
    		{ index: /*index*/ ctx[34] },
    		{ isActive: /*isActive*/ ctx[8] }
    	];

    	function selectoption_selected_binding(value) {
    		/*selectoption_selected_binding*/ ctx[15].call(null, value);
    	}

    	function selectoption_highlighted_binding(value) {
    		/*selectoption_highlighted_binding*/ ctx[16].call(null, value);
    	}

    	let selectoption_props = {};

    	for (let i = 0; i < selectoption_spread_levels.length; i += 1) {
    		selectoption_props = assign(selectoption_props, selectoption_spread_levels[i]);
    	}

    	if (/*selected*/ ctx[6] !== void 0) {
    		selectoption_props.selected = /*selected*/ ctx[6];
    	}

    	if (/*highlighted*/ ctx[7] !== void 0) {
    		selectoption_props.highlighted = /*highlighted*/ ctx[7];
    	}

    	selectoption = new SelectOption({
    			props: selectoption_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(selectoption, "selected", selectoption_selected_binding));
    	binding_callbacks.push(() => bind(selectoption, "highlighted", selectoption_highlighted_binding));

    	const block = {
    		c: function create() {
    			create_component(selectoption.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(selectoption, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const selectoption_changes = (dirty[0] & /*options, name, isActive*/ 262)
    			? get_spread_update(selectoption_spread_levels, [
    					dirty[0] & /*options*/ 4 && get_spread_object(/*option*/ ctx[32]),
    					dirty[0] & /*name*/ 2 && { name: /*name*/ ctx[1] },
    					selectoption_spread_levels[2],
    					dirty[0] & /*isActive*/ 256 && { isActive: /*isActive*/ ctx[8] }
    				])
    			: {};

    			if (!updating_selected && dirty[0] & /*selected*/ 64) {
    				updating_selected = true;
    				selectoption_changes.selected = /*selected*/ ctx[6];
    				add_flush_callback(() => updating_selected = false);
    			}

    			if (!updating_highlighted && dirty[0] & /*highlighted*/ 128) {
    				updating_highlighted = true;
    				selectoption_changes.highlighted = /*highlighted*/ ctx[7];
    				add_flush_callback(() => updating_highlighted = false);
    			}

    			selectoption.$set(selectoption_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(selectoption.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(selectoption.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(selectoption, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(165:12) {#each options as option, index}",
    		ctx
    	});

    	return block;
    }

    // (158:4) <Dropdown       {isActive}       on:dropdownclose={onDropdownClose}>
    function create_default_slot$3(ctx) {
    	let ul;
    	let current;
    	let each_value = /*options*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "txcm-selectOptions");
    			toggle_class(ul, "txcm-selectOptions-is-opened", /*isActive*/ ctx[8]);
    			add_location(ul, file$k, 160, 8, 3630);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			/*ul_binding*/ ctx[17](ul);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*options, name, isActive, selected, highlighted*/ 454) {
    				each_value = /*options*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty[0] & /*isActive*/ 256) {
    				toggle_class(ul, "txcm-selectOptions-is-opened", /*isActive*/ ctx[8]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    			/*ul_binding*/ ctx[17](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(158:4) <Dropdown       {isActive}       on:dropdownclose={onDropdownClose}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$p(ctx) {
    	let div;
    	let button0;
    	let t0_value = /*renderToggleLabel*/ ctx[10](/*pick*/ ctx[0]) + "";
    	let t0;
    	let t1;
    	let svg;
    	let use;
    	let t2;
    	let button1;
    	let int;
    	let t3;
    	let dropdown;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: "Сбросить" },
    			$$inline: true
    		});

    	dropdown = new Dropdown({
    			props: {
    				isActive: /*isActive*/ ctx[8],
    				$$slots: { default: [create_default_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown.$on("dropdownclose", /*onDropdownClose*/ ctx[12]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			t0 = text(t0_value);
    			t1 = space();
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t2 = space();
    			button1 = element("button");
    			create_component(int.$$.fragment);
    			t3 = space();
    			create_component(dropdown.$$.fragment);
    			xlink_attr(use, "xlink:href", "#txspt-icons-fatArrow");
    			add_location(use, file$k, 146, 12, 3317);
    			attr_dev(svg, "class", "txcm-selectToggleIcon");
    			add_location(svg, file$k, 144, 8, 3259);
    			attr_dev(button0, "class", "txcm-selectToggle");
    			button0.disabled = /*disabled*/ ctx[3];
    			toggle_class(button0, "txcm-selectToggle-has-selected", /*hasSelected*/ ctx[9](/*pick*/ ctx[0]));
    			toggle_class(button0, "txcm-selectToggle-is-opened", /*isActive*/ ctx[8]);
    			add_location(button0, file$k, 137, 4, 3014);
    			attr_dev(button1, "class", "txcm-selectReset");
    			button1.disabled = /*disabled*/ ctx[3];
    			add_location(button1, file$k, 150, 4, 3407);
    			attr_dev(div, "class", div_class_value = `txcm-select ${/*theme*/ ctx[4]}`);
    			add_location(div, file$k, 135, 0, 2971);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(button0, t0);
    			append_dev(button0, t1);
    			append_dev(button0, svg);
    			append_dev(svg, use);
    			append_dev(div, t2);
    			append_dev(div, button1);
    			mount_component(int, button1, null);
    			append_dev(div, t3);
    			mount_component(dropdown, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*onToggleClick*/ ctx[11], false, false, false),
    					listen_dev(button1, "click", /*onResetClick*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*pick*/ 1) && t0_value !== (t0_value = /*renderToggleLabel*/ ctx[10](/*pick*/ ctx[0]) + "")) set_data_dev(t0, t0_value);

    			if (!current || dirty[0] & /*disabled*/ 8) {
    				prop_dev(button0, "disabled", /*disabled*/ ctx[3]);
    			}

    			if (dirty[0] & /*hasSelected, pick*/ 513) {
    				toggle_class(button0, "txcm-selectToggle-has-selected", /*hasSelected*/ ctx[9](/*pick*/ ctx[0]));
    			}

    			if (dirty[0] & /*isActive*/ 256) {
    				toggle_class(button0, "txcm-selectToggle-is-opened", /*isActive*/ ctx[8]);
    			}

    			if (!current || dirty[0] & /*disabled*/ 8) {
    				prop_dev(button1, "disabled", /*disabled*/ ctx[3]);
    			}

    			const dropdown_changes = {};
    			if (dirty[0] & /*isActive*/ 256) dropdown_changes.isActive = /*isActive*/ ctx[8];

    			if (dirty[0] & /*node, isActive, options, name, selected, highlighted*/ 486 | dirty[1] & /*$$scope*/ 16) {
    				dropdown_changes.$$scope = { dirty, ctx };
    			}

    			dropdown.$set(dropdown_changes);

    			if (!current || dirty[0] & /*theme*/ 16 && div_class_value !== (div_class_value = `txcm-select ${/*theme*/ ctx[4]}`)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			transition_in(dropdown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			transition_out(dropdown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    			destroy_component(dropdown);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function isPrevKey(keyCode) {
    	return keyCode === 38;
    }

    function isNextKey(keyCode) {
    	return keyCode === 40;
    }

    function isEnterKey(keyCode) {
    	return keyCode === 13;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	let { pick } = $$props;
    	let { name } = $$props;
    	let { options = [] } = $$props;
    	let { disabled = false } = $$props;
    	let { theme = "" } = $$props;
    	let node;
    	let selected = findIndex(options, pick);
    	let highlighted = null;
    	let isActive = false;

    	function hasSelected() {
    		return pick !== null;
    	}

    	function resetSelected() {
    		$$invalidate(6, selected = null);
    	}

    	function findHighlighted() {
    		if (hasSelected()) return findIndex(options, pick);
    		return 0;
    	}

    	function renderToggleLabel() {
    		if (hasSelected()) {
    			return options[highlighted].label;
    		}

    		return label;
    	}

    	function updatePick() {
    		$$invalidate(0, pick = findValue(options, selected));
    	}

    	function show() {
    		$$invalidate(8, isActive = true);
    	}

    	function hide() {
    		if (isActive) $$invalidate(8, isActive = false);
    	}

    	function highlightPrev() {
    		if (highlighted === null) $$invalidate(7, highlighted = findHighlighted());
    		if (highlighted === 0) $$invalidate(7, highlighted = options.length - 1); else $$invalidate(7, highlighted -= 1);
    	}

    	function highlightNext() {
    		if (highlighted === null) $$invalidate(7, highlighted = findHighlighted());
    		if (highlighted === options.length - 1) $$invalidate(7, highlighted = 0); else $$invalidate(7, highlighted += 1);
    	}

    	function pickHighlighted() {
    		if (isActive && highlighted !== null) {
    			if (pick !== options[highlighted].value) $$invalidate(0, pick = options[highlighted].value); else $$invalidate(0, pick = null);
    		}
    	}

    	function scrollOptions(delta) {
    		if (delta !== 0) {
    			const step = delta < 0 ? -32 : 32;

    			requestAnimationFrame(() => {
    				$$invalidate(5, node.scrollTop += step, node);
    			});
    		}
    	}

    	function onToggleClick() {
    		if (!isActive) setTimeout(show, 5);
    	}

    	function onKeyUp({ keyCode }) {
    		if (isPrevKey(keyCode)) highlightPrev(); else if (isNextKey(keyCode)) highlightNext(); else if (isEnterKey(keyCode)) pickHighlighted();
    	}

    	function onWheel() {
    		event.preventDefault();
    		event.stopPropagation();
    		const { deltaY } = event;
    		scrollOptions(deltaY);
    	}

    	function onDropdownClose() {
    		hide();
    	}

    	function subscribeEvents() {
    		window.addEventListener("keyup", onKeyUp);
    		if (node) node.addEventListener("wheel", onWheel);
    	}

    	function unsubscribeEvents() {
    		window.removeEventListener("keyup", onKeyUp);
    		if (node) node.addEventListener("wheel", onWheel);
    	}

    	function updateEvents() {
    		if (isActive) subscribeEvents(); else unsubscribeEvents();
    	}

    	function onResetClick() {
    		resetSelected();
    	}

    	const writable_props = ["label", "pick", "name", "options", "disabled", "theme"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Select> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Select", $$slots, []);

    	function selectoption_selected_binding(value) {
    		selected = value;
    		$$invalidate(6, selected);
    	}

    	function selectoption_highlighted_binding(value) {
    		highlighted = value;
    		$$invalidate(7, highlighted);
    	}

    	function ul_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			node = $$value;
    			$$invalidate(5, node);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(14, label = $$props.label);
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    		if ("options" in $$props) $$invalidate(2, options = $$props.options);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    		if ("theme" in $$props) $$invalidate(4, theme = $$props.theme);
    	};

    	$$self.$capture_state = () => ({
    		isPrevKey,
    		isNextKey,
    		isEnterKey,
    		findIndex,
    		findValue,
    		Int,
    		Dropdown,
    		SelectOption,
    		label,
    		pick,
    		name,
    		options,
    		disabled,
    		theme,
    		node,
    		selected,
    		highlighted,
    		isActive,
    		hasSelected,
    		resetSelected,
    		findHighlighted,
    		renderToggleLabel,
    		updatePick,
    		show,
    		hide,
    		highlightPrev,
    		highlightNext,
    		pickHighlighted,
    		scrollOptions,
    		onToggleClick,
    		onKeyUp,
    		onWheel,
    		onDropdownClose,
    		subscribeEvents,
    		unsubscribeEvents,
    		updateEvents,
    		onResetClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(14, label = $$props.label);
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    		if ("options" in $$props) $$invalidate(2, options = $$props.options);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    		if ("theme" in $$props) $$invalidate(4, theme = $$props.theme);
    		if ("node" in $$props) $$invalidate(5, node = $$props.node);
    		if ("selected" in $$props) $$invalidate(6, selected = $$props.selected);
    		if ("highlighted" in $$props) $$invalidate(7, highlighted = $$props.highlighted);
    		if ("isActive" in $$props) $$invalidate(8, isActive = $$props.isActive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*isActive*/ 256) {
    			 updateEvents();
    		}

    		if ($$self.$$.dirty[0] & /*selected*/ 64) {
    			 hide();
    		}

    		if ($$self.$$.dirty[0] & /*selected*/ 64) {
    			 updatePick();
    		}
    	};

    	return [
    		pick,
    		name,
    		options,
    		disabled,
    		theme,
    		node,
    		selected,
    		highlighted,
    		isActive,
    		hasSelected,
    		renderToggleLabel,
    		onToggleClick,
    		onDropdownClose,
    		onResetClick,
    		label,
    		selectoption_selected_binding,
    		selectoption_highlighted_binding,
    		ul_binding
    	];
    }

    class Select extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$p,
    			create_fragment$p,
    			safe_not_equal,
    			{
    				label: 14,
    				pick: 0,
    				name: 1,
    				options: 2,
    				disabled: 3,
    				theme: 4
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Select",
    			options,
    			id: create_fragment$p.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[14] === undefined && !("label" in props)) {
    			console.warn("<Select> was created without expected prop 'label'");
    		}

    		if (/*pick*/ ctx[0] === undefined && !("pick" in props)) {
    			console.warn("<Select> was created without expected prop 'pick'");
    		}

    		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
    			console.warn("<Select> was created without expected prop 'name'");
    		}
    	}

    	get label() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pick() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pick(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get theme() {
    		throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set theme(value) {
    		throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/picks/Picks.svelte generated by Svelte v3.24.0 */
    const file$l = "src/js/components/picks/Picks.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    // (11:0) {#each options as option, index}
    function create_each_block$7(ctx) {
    	let input;
    	let input_id_value;
    	let input_disabled_value;
    	let input_value_value;
    	let t0;
    	let label;
    	let int;
    	let t1;
    	let label_for_value;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*option*/ ctx[6].label },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			input = element("input");
    			t0 = space();
    			label = element("label");
    			create_component(int.$$.fragment);
    			t1 = space();
    			attr_dev(input, "class", "txcm-pickInput");
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "id", input_id_value = renderID(/*name*/ ctx[1], /*index*/ ctx[8]));
    			input.disabled = input_disabled_value = /*disabled*/ ctx[3] || /*option*/ ctx[6].disabled;
    			input.__value = input_value_value = /*option*/ ctx[6].value;
    			input.value = input.__value;
    			/*$$binding_groups*/ ctx[5][0].push(input);
    			add_location(input, file$l, 11, 2, 273);
    			attr_dev(label, "class", "txcm-pick");
    			attr_dev(label, "for", label_for_value = renderID(/*name*/ ctx[1], /*index*/ ctx[8]));
    			add_location(label, file$l, 18, 2, 451);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = ~/*pick*/ ctx[0].indexOf(input.__value);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, label, anchor);
    			mount_component(int, label, null);
    			append_dev(label, t1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[4]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*name*/ 2 && input_id_value !== (input_id_value = renderID(/*name*/ ctx[1], /*index*/ ctx[8]))) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (!current || dirty & /*disabled, options*/ 12 && input_disabled_value !== (input_disabled_value = /*disabled*/ ctx[3] || /*option*/ ctx[6].disabled)) {
    				prop_dev(input, "disabled", input_disabled_value);
    			}

    			if (!current || dirty & /*options*/ 4 && input_value_value !== (input_value_value = /*option*/ ctx[6].value)) {
    				prop_dev(input, "__value", input_value_value);
    				input.value = input.__value;
    			}

    			if (dirty & /*pick*/ 1) {
    				input.checked = ~/*pick*/ ctx[0].indexOf(input.__value);
    			}

    			const int_changes = {};
    			if (dirty & /*options*/ 4) int_changes.key = /*option*/ ctx[6].label;
    			int.$set(int_changes);

    			if (!current || dirty & /*name*/ 2 && label_for_value !== (label_for_value = renderID(/*name*/ ctx[1], /*index*/ ctx[8]))) {
    				attr_dev(label, "for", label_for_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*$$binding_groups*/ ctx[5][0].splice(/*$$binding_groups*/ ctx[5][0].indexOf(input), 1);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(label);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(11:0) {#each options as option, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$q(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*options*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*renderID, name, options, disabled, pick*/ 15) {
    				each_value = /*options*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let { pick = [] } = $$props;
    	let { name } = $$props;
    	let { options = [] } = $$props;
    	let { disabled = false } = $$props;
    	const writable_props = ["pick", "name", "options", "disabled"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Picks> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Picks", $$slots, []);
    	const $$binding_groups = [[]];

    	function input_change_handler() {
    		pick = get_binding_group_value($$binding_groups[0], this.__value, this.checked);
    		$$invalidate(0, pick);
    	}

    	$$self.$set = $$props => {
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    		if ("options" in $$props) $$invalidate(2, options = $$props.options);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    	};

    	$$self.$capture_state = () => ({
    		renderID,
    		Int,
    		pick,
    		name,
    		options,
    		disabled
    	});

    	$$self.$inject_state = $$props => {
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("name" in $$props) $$invalidate(1, name = $$props.name);
    		if ("options" in $$props) $$invalidate(2, options = $$props.options);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [pick, name, options, disabled, input_change_handler, $$binding_groups];
    }

    class Picks extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {
    			pick: 0,
    			name: 1,
    			options: 2,
    			disabled: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Picks",
    			options,
    			id: create_fragment$q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*name*/ ctx[1] === undefined && !("name" in props)) {
    			console.warn("<Picks> was created without expected prop 'name'");
    		}
    	}

    	get pick() {
    		throw new Error("<Picks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pick(value) {
    		throw new Error("<Picks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<Picks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<Picks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<Picks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<Picks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Picks>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Picks>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var lodash = createCommonjsModule(function (module, exports) {
    (function() {

      /** Used as a safe reference for `undefined` in pre-ES5 environments. */
      var undefined$1;

      /** Used as the semantic version number. */
      var VERSION = '4.17.20';

      /** Used as the size to enable large array optimizations. */
      var LARGE_ARRAY_SIZE = 200;

      /** Error message constants. */
      var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
          FUNC_ERROR_TEXT = 'Expected a function';

      /** Used to stand-in for `undefined` hash values. */
      var HASH_UNDEFINED = '__lodash_hash_undefined__';

      /** Used as the maximum memoize cache size. */
      var MAX_MEMOIZE_SIZE = 500;

      /** Used as the internal argument placeholder. */
      var PLACEHOLDER = '__lodash_placeholder__';

      /** Used to compose bitmasks for cloning. */
      var CLONE_DEEP_FLAG = 1,
          CLONE_FLAT_FLAG = 2,
          CLONE_SYMBOLS_FLAG = 4;

      /** Used to compose bitmasks for value comparisons. */
      var COMPARE_PARTIAL_FLAG = 1,
          COMPARE_UNORDERED_FLAG = 2;

      /** Used to compose bitmasks for function metadata. */
      var WRAP_BIND_FLAG = 1,
          WRAP_BIND_KEY_FLAG = 2,
          WRAP_CURRY_BOUND_FLAG = 4,
          WRAP_CURRY_FLAG = 8,
          WRAP_CURRY_RIGHT_FLAG = 16,
          WRAP_PARTIAL_FLAG = 32,
          WRAP_PARTIAL_RIGHT_FLAG = 64,
          WRAP_ARY_FLAG = 128,
          WRAP_REARG_FLAG = 256,
          WRAP_FLIP_FLAG = 512;

      /** Used as default options for `_.truncate`. */
      var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';

      /** Used to detect hot functions by number of calls within a span of milliseconds. */
      var HOT_COUNT = 800,
          HOT_SPAN = 16;

      /** Used to indicate the type of lazy iteratees. */
      var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2,
          LAZY_WHILE_FLAG = 3;

      /** Used as references for various `Number` constants. */
      var INFINITY = 1 / 0,
          MAX_SAFE_INTEGER = 9007199254740991,
          MAX_INTEGER = 1.7976931348623157e+308,
          NAN = 0 / 0;

      /** Used as references for the maximum length and index of an array. */
      var MAX_ARRAY_LENGTH = 4294967295,
          MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
          HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

      /** Used to associate wrap methods with their bit flags. */
      var wrapFlags = [
        ['ary', WRAP_ARY_FLAG],
        ['bind', WRAP_BIND_FLAG],
        ['bindKey', WRAP_BIND_KEY_FLAG],
        ['curry', WRAP_CURRY_FLAG],
        ['curryRight', WRAP_CURRY_RIGHT_FLAG],
        ['flip', WRAP_FLIP_FLAG],
        ['partial', WRAP_PARTIAL_FLAG],
        ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
        ['rearg', WRAP_REARG_FLAG]
      ];

      /** `Object#toString` result references. */
      var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          asyncTag = '[object AsyncFunction]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          domExcTag = '[object DOMException]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          genTag = '[object GeneratorFunction]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          nullTag = '[object Null]',
          objectTag = '[object Object]',
          promiseTag = '[object Promise]',
          proxyTag = '[object Proxy]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          symbolTag = '[object Symbol]',
          undefinedTag = '[object Undefined]',
          weakMapTag = '[object WeakMap]',
          weakSetTag = '[object WeakSet]';

      var arrayBufferTag = '[object ArrayBuffer]',
          dataViewTag = '[object DataView]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';

      /** Used to match empty string literals in compiled template source. */
      var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

      /** Used to match HTML entities and HTML characters. */
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
          reUnescapedHtml = /[&<>"']/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

      /** Used to match template delimiters. */
      var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;

      /** Used to match property names within property paths. */
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

      /**
       * Used to match `RegExp`
       * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
       */
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
          reHasRegExpChar = RegExp(reRegExpChar.source);

      /** Used to match leading and trailing whitespace. */
      var reTrim = /^\s+|\s+$/g,
          reTrimStart = /^\s+/,
          reTrimEnd = /\s+$/;

      /** Used to match wrap detail comments. */
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
          reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
          reSplitDetails = /,? & /;

      /** Used to match words composed of alphanumeric characters. */
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

      /** Used to match backslashes in property paths. */
      var reEscapeChar = /\\(\\)?/g;

      /**
       * Used to match
       * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
       */
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

      /** Used to match `RegExp` flags from their coerced string values. */
      var reFlags = /\w*$/;

      /** Used to detect bad signed hexadecimal string values. */
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

      /** Used to detect binary string values. */
      var reIsBinary = /^0b[01]+$/i;

      /** Used to detect host constructors (Safari). */
      var reIsHostCtor = /^\[object .+?Constructor\]$/;

      /** Used to detect octal string values. */
      var reIsOctal = /^0o[0-7]+$/i;

      /** Used to detect unsigned integer values. */
      var reIsUint = /^(?:0|[1-9]\d*)$/;

      /** Used to match Latin Unicode letters (excluding mathematical operators). */
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

      /** Used to ensure capturing order of template delimiters. */
      var reNoMatch = /($^)/;

      /** Used to match unescaped characters in compiled string literals. */
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

      /** Used to compose unicode character classes. */
      var rsAstralRange = '\\ud800-\\udfff',
          rsComboMarksRange = '\\u0300-\\u036f',
          reComboHalfMarksRange = '\\ufe20-\\ufe2f',
          rsComboSymbolsRange = '\\u20d0-\\u20ff',
          rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
          rsDingbatRange = '\\u2700-\\u27bf',
          rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
          rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
          rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
          rsPunctuationRange = '\\u2000-\\u206f',
          rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
          rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
          rsVarRange = '\\ufe0e\\ufe0f',
          rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

      /** Used to compose unicode capture groups. */
      var rsApos = "['\u2019]",
          rsAstral = '[' + rsAstralRange + ']',
          rsBreak = '[' + rsBreakRange + ']',
          rsCombo = '[' + rsComboRange + ']',
          rsDigits = '\\d+',
          rsDingbat = '[' + rsDingbatRange + ']',
          rsLower = '[' + rsLowerRange + ']',
          rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
          rsFitz = '\\ud83c[\\udffb-\\udfff]',
          rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
          rsNonAstral = '[^' + rsAstralRange + ']',
          rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
          rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
          rsUpper = '[' + rsUpperRange + ']',
          rsZWJ = '\\u200d';

      /** Used to compose unicode regexes. */
      var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
          rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
          rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
          rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
          reOptMod = rsModifier + '?',
          rsOptVar = '[' + rsVarRange + ']?',
          rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
          rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
          rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
          rsSeq = rsOptVar + reOptMod + rsOptJoin,
          rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
          rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

      /** Used to match apostrophes. */
      var reApos = RegExp(rsApos, 'g');

      /**
       * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
       * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
       */
      var reComboMark = RegExp(rsCombo, 'g');

      /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
      var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

      /** Used to match complex or compound words. */
      var reUnicodeWord = RegExp([
        rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
        rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
        rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
        rsUpper + '+' + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join('|'), 'g');

      /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
      var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

      /** Used to detect strings that need a more robust regexp to match words. */
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

      /** Used to assign default `context` object properties. */
      var contextProps = [
        'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
        'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
        'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
        'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
        '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
      ];

      /** Used to make template sourceURLs easier to identify. */
      var templateCounter = -1;

      /** Used to identify `toStringTag` values of typed arrays. */
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
      typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
      typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
      typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
      typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
      typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
      typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
      typedArrayTags[errorTag] = typedArrayTags[funcTag] =
      typedArrayTags[mapTag] = typedArrayTags[numberTag] =
      typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
      typedArrayTags[setTag] = typedArrayTags[stringTag] =
      typedArrayTags[weakMapTag] = false;

      /** Used to identify `toStringTag` values supported by `_.clone`. */
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] =
      cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
      cloneableTags[boolTag] = cloneableTags[dateTag] =
      cloneableTags[float32Tag] = cloneableTags[float64Tag] =
      cloneableTags[int8Tag] = cloneableTags[int16Tag] =
      cloneableTags[int32Tag] = cloneableTags[mapTag] =
      cloneableTags[numberTag] = cloneableTags[objectTag] =
      cloneableTags[regexpTag] = cloneableTags[setTag] =
      cloneableTags[stringTag] = cloneableTags[symbolTag] =
      cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
      cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] =
      cloneableTags[weakMapTag] = false;

      /** Used to map Latin Unicode letters to basic Latin letters. */
      var deburredLetters = {
        // Latin-1 Supplement block.
        '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
        '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
        '\xc7': 'C',  '\xe7': 'c',
        '\xd0': 'D',  '\xf0': 'd',
        '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
        '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
        '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
        '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
        '\xd1': 'N',  '\xf1': 'n',
        '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
        '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
        '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
        '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
        '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
        '\xc6': 'Ae', '\xe6': 'ae',
        '\xde': 'Th', '\xfe': 'th',
        '\xdf': 'ss',
        // Latin Extended-A block.
        '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
        '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
        '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
        '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
        '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
        '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
        '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
        '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
        '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
        '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
        '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
        '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
        '\u0134': 'J',  '\u0135': 'j',
        '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
        '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
        '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
        '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
        '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
        '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
        '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
        '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
        '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
        '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
        '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
        '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
        '\u0163': 't',  '\u0165': 't', '\u0167': 't',
        '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
        '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
        '\u0174': 'W',  '\u0175': 'w',
        '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
        '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
        '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
        '\u0132': 'IJ', '\u0133': 'ij',
        '\u0152': 'Oe', '\u0153': 'oe',
        '\u0149': "'n", '\u017f': 's'
      };

      /** Used to map characters to HTML entities. */
      var htmlEscapes = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      };

      /** Used to map HTML entities to characters. */
      var htmlUnescapes = {
        '&amp;': '&',
        '&lt;': '<',
        '&gt;': '>',
        '&quot;': '"',
        '&#39;': "'"
      };

      /** Used to escape characters for inclusion in compiled string literals. */
      var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
      };

      /** Built-in method references without a dependency on `root`. */
      var freeParseFloat = parseFloat,
          freeParseInt = parseInt;

      /** Detect free variable `global` from Node.js. */
      var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

      /** Detect free variable `self`. */
      var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

      /** Used as a reference to the global object. */
      var root = freeGlobal || freeSelf || Function('return this')();

      /** Detect free variable `exports`. */
      var freeExports =  exports && !exports.nodeType && exports;

      /** Detect free variable `module`. */
      var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

      /** Detect the popular CommonJS extension `module.exports`. */
      var moduleExports = freeModule && freeModule.exports === freeExports;

      /** Detect free variable `process` from Node.js. */
      var freeProcess = moduleExports && freeGlobal.process;

      /** Used to access faster Node.js helpers. */
      var nodeUtil = (function() {
        try {
          // Use `util.types` for Node.js 10+.
          var types = freeModule && freeModule.require && freeModule.require('util').types;

          if (types) {
            return types;
          }

          // Legacy `process.binding('util')` for Node.js < 10.
          return freeProcess && freeProcess.binding && freeProcess.binding('util');
        } catch (e) {}
      }());

      /* Node.js helper references. */
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
          nodeIsDate = nodeUtil && nodeUtil.isDate,
          nodeIsMap = nodeUtil && nodeUtil.isMap,
          nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
          nodeIsSet = nodeUtil && nodeUtil.isSet,
          nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

      /*--------------------------------------------------------------------------*/

      /**
       * A faster alternative to `Function#apply`, this function invokes `func`
       * with the `this` binding of `thisArg` and the arguments of `args`.
       *
       * @private
       * @param {Function} func The function to invoke.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} args The arguments to invoke `func` with.
       * @returns {*} Returns the result of `func`.
       */
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0: return func.call(thisArg);
          case 1: return func.call(thisArg, args[0]);
          case 2: return func.call(thisArg, args[0], args[1]);
          case 3: return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }

      /**
       * A specialized version of `baseAggregator` for arrays.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform keys.
       * @param {Object} accumulator The initial aggregated object.
       * @returns {Function} Returns `accumulator`.
       */
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.forEach` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEach(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }

      /**
       * A specialized version of `_.forEachRight` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns `array`.
       */
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;

        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }

      /**
       * A specialized version of `_.every` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       */
      function arrayEvery(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }

      /**
       * A specialized version of `_.filter` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */
      function arrayFilter(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }

      /**
       * A specialized version of `_.includes` for arrays without support for
       * specifying an index to search from.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }

      /**
       * This function is like `arrayIncludes` except that it accepts a comparator.
       *
       * @private
       * @param {Array} [array] The array to inspect.
       * @param {*} target The value to search for.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {boolean} Returns `true` if `target` is found, else `false`.
       */
      function arrayIncludesWith(array, value, comparator) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }

      /**
       * A specialized version of `_.map` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */
      function arrayMap(array, iteratee) {
        var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);

        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }

      /**
       * Appends the elements of `values` to `array`.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to append.
       * @returns {Array} Returns `array`.
       */
      function arrayPush(array, values) {
        var index = -1,
            length = values.length,
            offset = array.length;

        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }

      /**
       * A specialized version of `_.reduce` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the first element of `array` as
       *  the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1,
            length = array == null ? 0 : array.length;

        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.reduceRight` for arrays without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @param {boolean} [initAccum] Specify using the last element of `array` as
       *  the initial value.
       * @returns {*} Returns the accumulated value.
       */
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }

      /**
       * A specialized version of `_.some` for arrays without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} [array] The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       */
      function arraySome(array, predicate) {
        var index = -1,
            length = array == null ? 0 : array.length;

        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }

      /**
       * Gets the size of an ASCII `string`.
       *
       * @private
       * @param {string} string The string inspect.
       * @returns {number} Returns the string size.
       */
      var asciiSize = baseProperty('length');

      /**
       * Converts an ASCII `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function asciiToArray(string) {
        return string.split('');
      }

      /**
       * Splits an ASCII `string` into an array of its words.
       *
       * @private
       * @param {string} The string to inspect.
       * @returns {Array} Returns the words of `string`.
       */
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }

      /**
       * The base implementation of methods like `_.findKey` and `_.findLastKey`,
       * without support for iteratee shorthands, which iterates over `collection`
       * using `eachFunc`.
       *
       * @private
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} predicate The function invoked per iteration.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @returns {*} Returns the found element or its key, else `undefined`.
       */
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection) {
          if (predicate(value, key, collection)) {
            result = key;
            return false;
          }
        });
        return result;
      }

      /**
       * The base implementation of `_.findIndex` and `_.findLastIndex` without
       * support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} predicate The function invoked per iteration.
       * @param {number} fromIndex The index to search from.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length,
            index = fromIndex + (fromRight ? 1 : -1);

        while ((fromRight ? index-- : ++index < length)) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOf(array, value, fromIndex) {
        return value === value
          ? strictIndexOf(array, value, fromIndex)
          : baseFindIndex(array, baseIsNaN, fromIndex);
      }

      /**
       * This function is like `baseIndexOf` except that it accepts a comparator.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @param {Function} comparator The comparator invoked per element.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1,
            length = array.length;

        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }

      /**
       * The base implementation of `_.isNaN` without support for number objects.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
       */
      function baseIsNaN(value) {
        return value !== value;
      }

      /**
       * The base implementation of `_.mean` and `_.meanBy` without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {number} Returns the mean.
       */
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? (baseSum(array, iteratee) / length) : NAN;
      }

      /**
       * The base implementation of `_.property` without support for deep paths.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @returns {Function} Returns the new accessor function.
       */
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined$1 : object[key];
        };
      }

      /**
       * The base implementation of `_.propertyOf` without support for deep paths.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       */
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined$1 : object[key];
        };
      }

      /**
       * The base implementation of `_.reduce` and `_.reduceRight`, without support
       * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} accumulator The initial value.
       * @param {boolean} initAccum Specify using the first or last element of
       *  `collection` as the initial value.
       * @param {Function} eachFunc The function to iterate over `collection`.
       * @returns {*} Returns the accumulated value.
       */
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection) {
          accumulator = initAccum
            ? (initAccum = false, value)
            : iteratee(accumulator, value, index, collection);
        });
        return accumulator;
      }

      /**
       * The base implementation of `_.sortBy` which uses `comparer` to define the
       * sort order of `array` and replaces criteria objects with their corresponding
       * values.
       *
       * @private
       * @param {Array} array The array to sort.
       * @param {Function} comparer The function to define sort order.
       * @returns {Array} Returns `array`.
       */
      function baseSortBy(array, comparer) {
        var length = array.length;

        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }

      /**
       * The base implementation of `_.sum` and `_.sumBy` without support for
       * iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {number} Returns the sum.
       */
      function baseSum(array, iteratee) {
        var result,
            index = -1,
            length = array.length;

        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : (result + current);
          }
        }
        return result;
      }

      /**
       * The base implementation of `_.times` without support for iteratee shorthands
       * or max array length checks.
       *
       * @private
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       */
      function baseTimes(n, iteratee) {
        var index = -1,
            result = Array(n);

        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }

      /**
       * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
       * of key-value pairs for `object` corresponding to the property names of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the key-value pairs.
       */
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }

      /**
       * The base implementation of `_.unary` without support for storing metadata.
       *
       * @private
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       */
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }

      /**
       * The base implementation of `_.values` and `_.valuesIn` which creates an
       * array of `object` property values corresponding to the property names
       * of `props`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} props The property names to get values for.
       * @returns {Object} Returns the array of property values.
       */
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }

      /**
       * Checks if a `cache` value for `key` exists.
       *
       * @private
       * @param {Object} cache The cache to query.
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */
      function cacheHas(cache, key) {
        return cache.has(key);
      }

      /**
       * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
       * that is not found in the character symbols.
       *
       * @private
       * @param {Array} strSymbols The string symbols to inspect.
       * @param {Array} chrSymbols The character symbols to find.
       * @returns {number} Returns the index of the first unmatched string symbol.
       */
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1,
            length = strSymbols.length;

        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }

      /**
       * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
       * that is not found in the character symbols.
       *
       * @private
       * @param {Array} strSymbols The string symbols to inspect.
       * @param {Array} chrSymbols The character symbols to find.
       * @returns {number} Returns the index of the last unmatched string symbol.
       */
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;

        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
        return index;
      }

      /**
       * Gets the number of `placeholder` occurrences in `array`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} placeholder The placeholder to search for.
       * @returns {number} Returns the placeholder count.
       */
      function countHolders(array, placeholder) {
        var length = array.length,
            result = 0;

        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }

      /**
       * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
       * letters to basic Latin letters.
       *
       * @private
       * @param {string} letter The matched letter to deburr.
       * @returns {string} Returns the deburred letter.
       */
      var deburrLetter = basePropertyOf(deburredLetters);

      /**
       * Used by `_.escape` to convert characters to HTML entities.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      var escapeHtmlChar = basePropertyOf(htmlEscapes);

      /**
       * Used by `_.template` to escape characters for inclusion in compiled string literals.
       *
       * @private
       * @param {string} chr The matched character to escape.
       * @returns {string} Returns the escaped character.
       */
      function escapeStringChar(chr) {
        return '\\' + stringEscapes[chr];
      }

      /**
       * Gets the value at `key` of `object`.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */
      function getValue(object, key) {
        return object == null ? undefined$1 : object[key];
      }

      /**
       * Checks if `string` contains Unicode symbols.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {boolean} Returns `true` if a symbol is found, else `false`.
       */
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }

      /**
       * Checks if `string` contains a word composed of Unicode symbols.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {boolean} Returns `true` if a word is found, else `false`.
       */
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }

      /**
       * Converts `iterator` to an array.
       *
       * @private
       * @param {Object} iterator The iterator to convert.
       * @returns {Array} Returns the converted array.
       */
      function iteratorToArray(iterator) {
        var data,
            result = [];

        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }

      /**
       * Converts `map` to its key-value pairs.
       *
       * @private
       * @param {Object} map The map to convert.
       * @returns {Array} Returns the key-value pairs.
       */
      function mapToArray(map) {
        var index = -1,
            result = Array(map.size);

        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }

      /**
       * Creates a unary function that invokes `func` with its argument transformed.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {Function} transform The argument transform.
       * @returns {Function} Returns the new function.
       */
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }

      /**
       * Replaces all `placeholder` elements in `array` with an internal placeholder
       * and returns an array of their indexes.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {*} placeholder The placeholder to replace.
       * @returns {Array} Returns the new array of placeholder indexes.
       */
      function replaceHolders(array, placeholder) {
        var index = -1,
            length = array.length,
            resIndex = 0,
            result = [];

        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }

      /**
       * Converts `set` to an array of its values.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the values.
       */
      function setToArray(set) {
        var index = -1,
            result = Array(set.size);

        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }

      /**
       * Converts `set` to its value-value pairs.
       *
       * @private
       * @param {Object} set The set to convert.
       * @returns {Array} Returns the value-value pairs.
       */
      function setToPairs(set) {
        var index = -1,
            result = Array(set.size);

        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }

      /**
       * A specialized version of `_.indexOf` which performs strict equality
       * comparisons of values, i.e. `===`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1,
            length = array.length;

        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }

      /**
       * A specialized version of `_.lastIndexOf` which performs strict equality
       * comparisons of values, i.e. `===`.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} fromIndex The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }

      /**
       * Gets the number of symbols in `string`.
       *
       * @private
       * @param {string} string The string to inspect.
       * @returns {number} Returns the string size.
       */
      function stringSize(string) {
        return hasUnicode(string)
          ? unicodeSize(string)
          : asciiSize(string);
      }

      /**
       * Converts `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function stringToArray(string) {
        return hasUnicode(string)
          ? unicodeToArray(string)
          : asciiToArray(string);
      }

      /**
       * Used by `_.unescape` to convert HTML entities to characters.
       *
       * @private
       * @param {string} chr The matched character to unescape.
       * @returns {string} Returns the unescaped character.
       */
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

      /**
       * Gets the size of a Unicode `string`.
       *
       * @private
       * @param {string} string The string inspect.
       * @returns {number} Returns the string size.
       */
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }

      /**
       * Converts a Unicode `string` to an array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the converted array.
       */
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }

      /**
       * Splits a Unicode `string` into an array of its words.
       *
       * @private
       * @param {string} The string to inspect.
       * @returns {Array} Returns the words of `string`.
       */
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }

      /*--------------------------------------------------------------------------*/

      /**
       * Create a new pristine `lodash` function using the `context` object.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Util
       * @param {Object} [context=root] The context object.
       * @returns {Function} Returns a new `lodash` function.
       * @example
       *
       * _.mixin({ 'foo': _.constant('foo') });
       *
       * var lodash = _.runInContext();
       * lodash.mixin({ 'bar': lodash.constant('bar') });
       *
       * _.isFunction(_.foo);
       * // => true
       * _.isFunction(_.bar);
       * // => false
       *
       * lodash.isFunction(lodash.foo);
       * // => false
       * lodash.isFunction(lodash.bar);
       * // => true
       *
       * // Create a suped-up `defer` in Node.js.
       * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
       */
      var runInContext = (function runInContext(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

        /** Built-in constructor references. */
        var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;

        /** Used for built-in method references. */
        var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype;

        /** Used to detect overreaching core-js shims. */
        var coreJsData = context['__core-js_shared__'];

        /** Used to resolve the decompiled source of functions. */
        var funcToString = funcProto.toString;

        /** Used to check objects for own properties. */
        var hasOwnProperty = objectProto.hasOwnProperty;

        /** Used to generate unique IDs. */
        var idCounter = 0;

        /** Used to detect methods masquerading as native. */
        var maskSrcKey = (function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
          return uid ? ('Symbol(src)_1.' + uid) : '';
        }());

        /**
         * Used to resolve the
         * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
         * of values.
         */
        var nativeObjectToString = objectProto.toString;

        /** Used to infer the `Object` constructor. */
        var objectCtorString = funcToString.call(Object);

        /** Used to restore the original `_` reference in `_.noConflict`. */
        var oldDash = root._;

        /** Used to detect if a method is native. */
        var reIsNative = RegExp('^' +
          funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
          .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
        );

        /** Built-in value references. */
        var Buffer = moduleExports ? context.Buffer : undefined$1,
            Symbol = context.Symbol,
            Uint8Array = context.Uint8Array,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
            getPrototype = overArg(Object.getPrototypeOf, Object),
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice,
            spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
            symIterator = Symbol ? Symbol.iterator : undefined$1,
            symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

        var defineProperty = (function() {
          try {
            var func = getNative(Object, 'defineProperty');
            func({}, '', {});
            return func;
          } catch (e) {}
        }());

        /** Mocked built-ins. */
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
            ctxNow = Date && Date.now !== root.Date.now && Date.now,
            ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

        /* Built-in method references for those with the same name as other `lodash` methods. */
        var nativeCeil = Math.ceil,
            nativeFloor = Math.floor,
            nativeGetSymbols = Object.getOwnPropertySymbols,
            nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
            nativeIsFinite = context.isFinite,
            nativeJoin = arrayProto.join,
            nativeKeys = overArg(Object.keys, Object),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = Date.now,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random,
            nativeReverse = arrayProto.reverse;

        /* Built-in method references that are verified to be native. */
        var DataView = getNative(context, 'DataView'),
            Map = getNative(context, 'Map'),
            Promise = getNative(context, 'Promise'),
            Set = getNative(context, 'Set'),
            WeakMap = getNative(context, 'WeakMap'),
            nativeCreate = getNative(Object, 'create');

        /** Used to store function metadata. */
        var metaMap = WeakMap && new WeakMap;

        /** Used to lookup unminified function names. */
        var realNames = {};

        /** Used to detect maps, sets, and weakmaps. */
        var dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map),
            promiseCtorString = toSource(Promise),
            setCtorString = toSource(Set),
            weakMapCtorString = toSource(WeakMap);

        /** Used to convert symbols to primitives and strings. */
        var symbolProto = Symbol ? Symbol.prototype : undefined$1,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
            symbolToString = symbolProto ? symbolProto.toString : undefined$1;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a `lodash` object which wraps `value` to enable implicit method
         * chain sequences. Methods that operate on and return arrays, collections,
         * and functions can be chained together. Methods that retrieve a single value
         * or may return a primitive value will automatically end the chain sequence
         * and return the unwrapped value. Otherwise, the value must be unwrapped
         * with `_#value`.
         *
         * Explicit chain sequences, which must be unwrapped with `_#value`, may be
         * enabled using `_.chain`.
         *
         * The execution of chained methods is lazy, that is, it's deferred until
         * `_#value` is implicitly or explicitly called.
         *
         * Lazy evaluation allows several methods to support shortcut fusion.
         * Shortcut fusion is an optimization to merge iteratee calls; this avoids
         * the creation of intermediate arrays and can greatly reduce the number of
         * iteratee executions. Sections of a chain sequence qualify for shortcut
         * fusion if the section is applied to an array and iteratees accept only
         * one argument. The heuristic for whether a section qualifies for shortcut
         * fusion is subject to change.
         *
         * Chaining is supported in custom builds as long as the `_#value` method is
         * directly or indirectly included in the build.
         *
         * In addition to lodash methods, wrappers have `Array` and `String` methods.
         *
         * The wrapper `Array` methods are:
         * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
         *
         * The wrapper `String` methods are:
         * `replace` and `split`
         *
         * The wrapper methods that support shortcut fusion are:
         * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
         * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
         * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
         *
         * The chainable wrapper methods are:
         * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
         * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
         * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
         * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
         * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
         * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
         * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
         * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
         * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
         * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
         * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
         * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
         * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
         * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
         * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
         * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
         * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
         * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
         * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
         * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
         * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
         * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
         * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
         * `zipObject`, `zipObjectDeep`, and `zipWith`
         *
         * The wrapper methods that are **not** chainable by default are:
         * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
         * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
         * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
         * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
         * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
         * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
         * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
         * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
         * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
         * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
         * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
         * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
         * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
         * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
         * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
         * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
         * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
         * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
         * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
         * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
         * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
         * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
         * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
         * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
         * `upperFirst`, `value`, and `words`
         *
         * @name _
         * @constructor
         * @category Seq
         * @param {*} value The value to wrap in a `lodash` instance.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var wrapped = _([1, 2, 3]);
         *
         * // Returns an unwrapped value.
         * wrapped.reduce(_.add);
         * // => 6
         *
         * // Returns a wrapped value.
         * var squares = wrapped.map(square);
         *
         * _.isArray(squares);
         * // => false
         *
         * _.isArray(squares.value());
         * // => true
         */
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, '__wrapped__')) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }

        /**
         * The base implementation of `_.create` without support for assigning
         * properties to the created object.
         *
         * @private
         * @param {Object} proto The object to inherit from.
         * @returns {Object} Returns the new object.
         */
        var baseCreate = (function() {
          function object() {}
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result = new object;
            object.prototype = undefined$1;
            return result;
          };
        }());

        /**
         * The function whose prototype chain sequence wrappers inherit from.
         *
         * @private
         */
        function baseLodash() {
          // No operation performed.
        }

        /**
         * The base constructor for creating `lodash` wrapper objects.
         *
         * @private
         * @param {*} value The value to wrap.
         * @param {boolean} [chainAll] Enable explicit method chain sequences.
         */
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }

        /**
         * By default, the template delimiters used by lodash are like those in
         * embedded Ruby (ERB) as well as ES2015 template strings. Change the
         * following template settings to use alternative delimiters.
         *
         * @static
         * @memberOf _
         * @type {Object}
         */
        lodash.templateSettings = {

          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'escape': reEscape,

          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'evaluate': reEvaluate,

          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          'interpolate': reInterpolate,

          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          'variable': '',

          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          'imports': {

            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            '_': lodash
          }
        };

        // Ensure wrappers are instances of `baseLodash`.
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;

        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
         *
         * @private
         * @constructor
         * @param {*} value The value to wrap.
         */
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }

        /**
         * Creates a clone of the lazy wrapper object.
         *
         * @private
         * @name clone
         * @memberOf LazyWrapper
         * @returns {Object} Returns the cloned `LazyWrapper` object.
         */
        function lazyClone() {
          var result = new LazyWrapper(this.__wrapped__);
          result.__actions__ = copyArray(this.__actions__);
          result.__dir__ = this.__dir__;
          result.__filtered__ = this.__filtered__;
          result.__iteratees__ = copyArray(this.__iteratees__);
          result.__takeCount__ = this.__takeCount__;
          result.__views__ = copyArray(this.__views__);
          return result;
        }

        /**
         * Reverses the direction of lazy iteration.
         *
         * @private
         * @name reverse
         * @memberOf LazyWrapper
         * @returns {Object} Returns the new reversed `LazyWrapper` object.
         */
        function lazyReverse() {
          if (this.__filtered__) {
            var result = new LazyWrapper(this);
            result.__dir__ = -1;
            result.__filtered__ = true;
          } else {
            result = this.clone();
            result.__dir__ *= -1;
          }
          return result;
        }

        /**
         * Extracts the unwrapped value from its lazy wrapper.
         *
         * @private
         * @name value
         * @memberOf LazyWrapper
         * @returns {*} Returns the unwrapped value.
         */
        function lazyValue() {
          var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : (start - 1),
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);

          if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result = [];

          outer:
          while (length-- && resIndex < takeCount) {
            index += dir;

            var iterIndex = -1,
                value = array[index];

            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);

              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result[resIndex++] = value;
          }
          return result;
        }

        // Ensure `LazyWrapper` is an instance of `baseLodash`.
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a hash object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Hash(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the hash.
         *
         * @private
         * @name clear
         * @memberOf Hash
         */
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the hash.
         *
         * @private
         * @name delete
         * @memberOf Hash
         * @param {Object} hash The hash to modify.
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function hashDelete(key) {
          var result = this.has(key) && delete this.__data__[key];
          this.size -= result ? 1 : 0;
          return result;
        }

        /**
         * Gets the hash value for `key`.
         *
         * @private
         * @name get
         * @memberOf Hash
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result = data[key];
            return result === HASH_UNDEFINED ? undefined$1 : result;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
        }

        /**
         * Checks if a hash value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Hash
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
        }

        /**
         * Sets the hash `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Hash
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the hash instance.
         */
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
          return this;
        }

        // Add methods to `Hash`.
        Hash.prototype.clear = hashClear;
        Hash.prototype['delete'] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates an list cache object.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function ListCache(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the list cache.
         *
         * @private
         * @name clear
         * @memberOf ListCache
         */
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the list cache.
         *
         * @private
         * @name delete
         * @memberOf ListCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function listCacheDelete(key) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }

        /**
         * Gets the list cache value for `key`.
         *
         * @private
         * @name get
         * @memberOf ListCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function listCacheGet(key) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          return index < 0 ? undefined$1 : data[index][1];
        }

        /**
         * Checks if a list cache value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf ListCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }

        /**
         * Sets the list cache `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf ListCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the list cache instance.
         */
        function listCacheSet(key, value) {
          var data = this.__data__,
              index = assocIndexOf(data, key);

          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }

        // Add methods to `ListCache`.
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype['delete'] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a map cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function MapCache(entries) {
          var index = -1,
              length = entries == null ? 0 : entries.length;

          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }

        /**
         * Removes all key-value entries from the map.
         *
         * @private
         * @name clear
         * @memberOf MapCache
         */
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            'hash': new Hash,
            'map': new (Map || ListCache),
            'string': new Hash
          };
        }

        /**
         * Removes `key` and its value from the map.
         *
         * @private
         * @name delete
         * @memberOf MapCache
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function mapCacheDelete(key) {
          var result = getMapData(this, key)['delete'](key);
          this.size -= result ? 1 : 0;
          return result;
        }

        /**
         * Gets the map value for `key`.
         *
         * @private
         * @name get
         * @memberOf MapCache
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }

        /**
         * Checks if a map value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf MapCache
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }

        /**
         * Sets the map `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf MapCache
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the map cache instance.
         */
        function mapCacheSet(key, value) {
          var data = getMapData(this, key),
              size = data.size;

          data.set(key, value);
          this.size += data.size == size ? 0 : 1;
          return this;
        }

        // Add methods to `MapCache`.
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype['delete'] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;

        /*------------------------------------------------------------------------*/

        /**
         *
         * Creates an array cache object to store unique values.
         *
         * @private
         * @constructor
         * @param {Array} [values] The values to cache.
         */
        function SetCache(values) {
          var index = -1,
              length = values == null ? 0 : values.length;

          this.__data__ = new MapCache;
          while (++index < length) {
            this.add(values[index]);
          }
        }

        /**
         * Adds `value` to the array cache.
         *
         * @private
         * @name add
         * @memberOf SetCache
         * @alias push
         * @param {*} value The value to cache.
         * @returns {Object} Returns the cache instance.
         */
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }

        /**
         * Checks if `value` is in the array cache.
         *
         * @private
         * @name has
         * @memberOf SetCache
         * @param {*} value The value to search for.
         * @returns {number} Returns `true` if `value` is found, else `false`.
         */
        function setCacheHas(value) {
          return this.__data__.has(value);
        }

        // Add methods to `SetCache`.
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;

        /*------------------------------------------------------------------------*/

        /**
         * Creates a stack cache object to store key-value pairs.
         *
         * @private
         * @constructor
         * @param {Array} [entries] The key-value pairs to cache.
         */
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }

        /**
         * Removes all key-value entries from the stack.
         *
         * @private
         * @name clear
         * @memberOf Stack
         */
        function stackClear() {
          this.__data__ = new ListCache;
          this.size = 0;
        }

        /**
         * Removes `key` and its value from the stack.
         *
         * @private
         * @name delete
         * @memberOf Stack
         * @param {string} key The key of the value to remove.
         * @returns {boolean} Returns `true` if the entry was removed, else `false`.
         */
        function stackDelete(key) {
          var data = this.__data__,
              result = data['delete'](key);

          this.size = data.size;
          return result;
        }

        /**
         * Gets the stack value for `key`.
         *
         * @private
         * @name get
         * @memberOf Stack
         * @param {string} key The key of the value to get.
         * @returns {*} Returns the entry value.
         */
        function stackGet(key) {
          return this.__data__.get(key);
        }

        /**
         * Checks if a stack value for `key` exists.
         *
         * @private
         * @name has
         * @memberOf Stack
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function stackHas(key) {
          return this.__data__.has(key);
        }

        /**
         * Sets the stack `key` to `value`.
         *
         * @private
         * @name set
         * @memberOf Stack
         * @param {string} key The key of the value to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns the stack cache instance.
         */
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }

        // Add methods to `Stack`.
        Stack.prototype.clear = stackClear;
        Stack.prototype['delete'] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;

        /*------------------------------------------------------------------------*/

        /**
         * Creates an array of the enumerable property names of the array-like `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @param {boolean} inherited Specify returning inherited property names.
         * @returns {Array} Returns the array of property names.
         */
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value),
              isArg = !isArr && isArguments(value),
              isBuff = !isArr && !isArg && isBuffer(value),
              isType = !isArr && !isArg && !isBuff && isTypedArray(value),
              skipIndexes = isArr || isArg || isBuff || isType,
              result = skipIndexes ? baseTimes(value.length, String) : [],
              length = result.length;

          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) &&
                !(skipIndexes && (
                   // Safari 9 has enumerable `arguments.length` in strict mode.
                   key == 'length' ||
                   // Node.js 0.10 has enumerable non-index properties on buffers.
                   (isBuff && (key == 'offset' || key == 'parent')) ||
                   // PhantomJS 2 has enumerable non-index properties on typed arrays.
                   (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
                   // Skip index properties.
                   isIndex(key, length)
                ))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * A specialized version of `_.sample` for arrays.
         *
         * @private
         * @param {Array} array The array to sample.
         * @returns {*} Returns the random element.
         */
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined$1;
        }

        /**
         * A specialized version of `_.sampleSize` for arrays.
         *
         * @private
         * @param {Array} array The array to sample.
         * @param {number} n The number of elements to sample.
         * @returns {Array} Returns the random elements.
         */
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }

        /**
         * A specialized version of `_.shuffle` for arrays.
         *
         * @private
         * @param {Array} array The array to shuffle.
         * @returns {Array} Returns the new shuffled array.
         */
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }

        /**
         * This function is like `assignValue` except that it doesn't assign
         * `undefined` values.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignMergeValue(object, key, value) {
          if ((value !== undefined$1 && !eq(object[key], value)) ||
              (value === undefined$1 && !(key in object))) {
            baseAssignValue(object, key, value);
          }
        }

        /**
         * Assigns `value` to `key` of `object` if the existing value is not equivalent
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
              (value === undefined$1 && !(key in object))) {
            baseAssignValue(object, key, value);
          }
        }

        /**
         * Gets the index at which the `key` is found in `array` of key-value pairs.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} key The key to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }

        /**
         * Aggregates elements of `collection` on `accumulator` with keys transformed
         * by `iteratee` and values set by `setter`.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform keys.
         * @param {Object} accumulator The initial aggregated object.
         * @returns {Function} Returns `accumulator`.
         */
        function baseAggregator(collection, setter, iteratee, accumulator) {
          baseEach(collection, function(value, key, collection) {
            setter(accumulator, value, iteratee(value), collection);
          });
          return accumulator;
        }

        /**
         * The base implementation of `_.assign` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }

        /**
         * The base implementation of `_.assignIn` without support for multiple sources
         * or `customizer` functions.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @returns {Object} Returns `object`.
         */
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }

        /**
         * The base implementation of `assignValue` and `assignMergeValue` without
         * value checks.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {string} key The key of the property to assign.
         * @param {*} value The value to assign.
         */
        function baseAssignValue(object, key, value) {
          if (key == '__proto__' && defineProperty) {
            defineProperty(object, key, {
              'configurable': true,
              'enumerable': true,
              'value': value,
              'writable': true
            });
          } else {
            object[key] = value;
          }
        }

        /**
         * The base implementation of `_.at` without support for individual paths.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {string[]} paths The property paths to pick.
         * @returns {Array} Returns the picked elements.
         */
        function baseAt(object, paths) {
          var index = -1,
              length = paths.length,
              result = Array(length),
              skip = object == null;

          while (++index < length) {
            result[index] = skip ? undefined$1 : get(object, paths[index]);
          }
          return result;
        }

        /**
         * The base implementation of `_.clamp` which doesn't coerce arguments.
         *
         * @private
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         */
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined$1) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined$1) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }

        /**
         * The base implementation of `_.clone` and `_.cloneDeep` which tracks
         * traversed objects.
         *
         * @private
         * @param {*} value The value to clone.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Deep clone
         *  2 - Flatten inherited properties
         *  4 - Clone symbols
         * @param {Function} [customizer] The function to customize cloning.
         * @param {string} [key] The key of `value`.
         * @param {Object} [object] The parent object of `value`.
         * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
         * @returns {*} Returns the cloned value.
         */
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result,
              isDeep = bitmask & CLONE_DEEP_FLAG,
              isFlat = bitmask & CLONE_FLAT_FLAG,
              isFull = bitmask & CLONE_SYMBOLS_FLAG;

          if (customizer) {
            result = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result !== undefined$1) {
            return result;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result);
            }
          } else {
            var tag = getTag(value),
                isFunc = tag == funcTag || tag == genTag;

            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
              result = (isFlat || isFunc) ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat
                  ? copySymbolsIn(value, baseAssignIn(result, value))
                  : copySymbols(value, baseAssign(result, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result = initCloneByTag(value, tag, isDeep);
            }
          }
          // Check for circular references and return its corresponding clone.
          stack || (stack = new Stack);
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result);

          if (isSet(value)) {
            value.forEach(function(subValue) {
              result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key) {
              result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
            });
          }

          var keysFunc = isFull
            ? (isFlat ? getAllKeysIn : getAllKeys)
            : (isFlat ? keysIn : keys);

          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function(subValue, key) {
            if (props) {
              key = subValue;
              subValue = value[key];
            }
            // Recursively populate clone (susceptible to call stack limits).
            assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
          });
          return result;
        }

        /**
         * The base implementation of `_.conforms` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property predicates to conform to.
         * @returns {Function} Returns the new spec function.
         */
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }

        /**
         * The base implementation of `_.conformsTo` which accepts `props` to check.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property predicates to conform to.
         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
         */
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (length--) {
            var key = props[length],
                predicate = source[key],
                value = object[key];

            if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }

        /**
         * The base implementation of `_.delay` and `_.defer` which accepts `args`
         * to provide to `func`.
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {Array} args The arguments to provide to `func`.
         * @returns {number|Object} Returns the timer id or timeout object.
         */
        function baseDelay(func, wait, args) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return setTimeout(function() { func.apply(undefined$1, args); }, wait);
        }

        /**
         * The base implementation of methods like `_.difference` without support
         * for excluding multiple arrays or iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Array} values The values to exclude.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         */
        function baseDifference(array, values, iteratee, comparator) {
          var index = -1,
              includes = arrayIncludes,
              isCommon = true,
              length = array.length,
              result = [],
              valuesLength = values.length;

          if (!length) {
            return result;
          }
          if (iteratee) {
            values = arrayMap(values, baseUnary(iteratee));
          }
          if (comparator) {
            includes = arrayIncludesWith;
            isCommon = false;
          }
          else if (values.length >= LARGE_ARRAY_SIZE) {
            includes = cacheHas;
            isCommon = false;
            values = new SetCache(values);
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee == null ? value : iteratee(value);

            value = (comparator || value !== 0) ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result.push(value);
            }
            else if (!includes(values, computed, comparator)) {
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.forEach` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEach = createBaseEach(baseForOwn);

        /**
         * The base implementation of `_.forEachRight` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         */
        var baseEachRight = createBaseEach(baseForOwnRight, true);

        /**
         * The base implementation of `_.every` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`
         */
        function baseEvery(collection, predicate) {
          var result = true;
          baseEach(collection, function(value, index, collection) {
            result = !!predicate(value, index, collection);
            return result;
          });
          return result;
        }

        /**
         * The base implementation of methods like `_.max` and `_.min` which accepts a
         * `comparator` to determine the extremum value.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The iteratee invoked per iteration.
         * @param {Function} comparator The comparator used to compare values.
         * @returns {*} Returns the extremum value.
         */
        function baseExtremum(array, iteratee, comparator) {
          var index = -1,
              length = array.length;

          while (++index < length) {
            var value = array[index],
                current = iteratee(value);

            if (current != null && (computed === undefined$1
                  ? (current === current && !isSymbol(current))
                  : comparator(current, computed)
                )) {
              var computed = current,
                  result = value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.fill` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         */
        function baseFill(array, value, start, end) {
          var length = array.length;

          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = (end === undefined$1 || end > length) ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }

        /**
         * The base implementation of `_.filter` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function baseFilter(collection, predicate) {
          var result = [];
          baseEach(collection, function(value, index, collection) {
            if (predicate(value, index, collection)) {
              result.push(value);
            }
          });
          return result;
        }

        /**
         * The base implementation of `_.flatten` with support for restricting flattening.
         *
         * @private
         * @param {Array} array The array to flatten.
         * @param {number} depth The maximum recursion depth.
         * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
         * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
         * @param {Array} [result=[]] The initial result value.
         * @returns {Array} Returns the new flattened array.
         */
        function baseFlatten(array, depth, predicate, isStrict, result) {
          var index = -1,
              length = array.length;

          predicate || (predicate = isFlattenable);
          result || (result = []);

          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                // Recursively flatten arrays (susceptible to call stack limits).
                baseFlatten(value, depth - 1, predicate, isStrict, result);
              } else {
                arrayPush(result, value);
              }
            } else if (!isStrict) {
              result[result.length] = value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `baseForOwn` which iterates over `object`
         * properties returned by `keysFunc` and invokes `iteratee` for each property.
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseFor = createBaseFor();

        /**
         * This function is like `baseFor` except that it iterates over properties
         * in the opposite order.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @returns {Object} Returns `object`.
         */
        var baseForRight = createBaseFor(true);

        /**
         * The base implementation of `_.forOwn` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwn(object, iteratee) {
          return object && baseFor(object, iteratee, keys);
        }

        /**
         * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Object} Returns `object`.
         */
        function baseForOwnRight(object, iteratee) {
          return object && baseForRight(object, iteratee, keys);
        }

        /**
         * The base implementation of `_.functions` which creates an array of
         * `object` function property names filtered from `props`.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Array} props The property names to filter.
         * @returns {Array} Returns the function names.
         */
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }

        /**
         * The base implementation of `_.get` without support for default values.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @returns {*} Returns the resolved value.
         */
        function baseGet(object, path) {
          path = castPath(path, object);

          var index = 0,
              length = path.length;

          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return (index && index == length) ? object : undefined$1;
        }

        /**
         * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
         * `keysFunc` and `symbolsFunc` to get the enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Function} keysFunc The function to get the keys of `object`.
         * @param {Function} symbolsFunc The function to get the symbols of `object`.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result = keysFunc(object);
          return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
        }

        /**
         * The base implementation of `getTag` without fallbacks for buggy environments.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return (symToStringTag && symToStringTag in Object(value))
            ? getRawTag(value)
            : objectToString(value);
        }

        /**
         * The base implementation of `_.gt` which doesn't coerce arguments.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`,
         *  else `false`.
         */
        function baseGt(value, other) {
          return value > other;
        }

        /**
         * The base implementation of `_.has` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }

        /**
         * The base implementation of `_.hasIn` without support for deep paths.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {Array|string} key The key to check.
         * @returns {boolean} Returns `true` if `key` exists, else `false`.
         */
        function baseHasIn(object, key) {
          return object != null && key in Object(object);
        }

        /**
         * The base implementation of `_.inRange` which doesn't coerce arguments.
         *
         * @private
         * @param {number} number The number to check.
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
         */
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }

        /**
         * The base implementation of methods like `_.intersection`, without support
         * for iteratee shorthands, that accepts an array of arrays to inspect.
         *
         * @private
         * @param {Array} arrays The arrays to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of shared values.
         */
        function baseIntersection(arrays, iteratee, comparator) {
          var includes = comparator ? arrayIncludesWith : arrayIncludes,
              length = arrays[0].length,
              othLength = arrays.length,
              othIndex = othLength,
              caches = Array(othLength),
              maxLength = Infinity,
              result = [];

          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee) {
              array = arrayMap(array, baseUnary(iteratee));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
              ? new SetCache(othIndex && array)
              : undefined$1;
          }
          array = arrays[0];

          var index = -1,
              seen = caches[0];

          outer:
          while (++index < length && result.length < maxLength) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            value = (comparator || value !== 0) ? value : 0;
            if (!(seen
                  ? cacheHas(seen, computed)
                  : includes(result, computed, comparator)
                )) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache
                      ? cacheHas(cache, computed)
                      : includes(arrays[othIndex], computed, comparator))
                    ) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.invert` and `_.invertBy` which inverts
         * `object` with values transformed by `iteratee` and set by `setter`.
         *
         * @private
         * @param {Object} object The object to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform values.
         * @param {Object} accumulator The initial inverted object.
         * @returns {Function} Returns `accumulator`.
         */
        function baseInverter(object, setter, iteratee, accumulator) {
          baseForOwn(object, function(value, key, object) {
            setter(accumulator, iteratee(value), key, object);
          });
          return accumulator;
        }

        /**
         * The base implementation of `_.invoke` without support for individual
         * method arguments.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {Array} args The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         */
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined$1 : apply(func, object, args);
        }

        /**
         * The base implementation of `_.isArguments`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         */
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }

        /**
         * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
         */
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }

        /**
         * The base implementation of `_.isDate` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
         */
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }

        /**
         * The base implementation of `_.isEqual` which supports partial comparisons
         * and tracks traversed objects.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {boolean} bitmask The bitmask flags.
         *  1 - Unordered comparison
         *  2 - Partial comparison
         * @param {Function} [customizer] The function to customize comparisons.
         * @param {Object} [stack] Tracks traversed `value` and `other` objects.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         */
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }

        /**
         * A specialized version of `baseIsEqual` for arrays and objects which performs
         * deep comparisons and tracks traversed objects enabling objects with circular
         * references to be compared.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} [stack] Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = objIsArr ? arrayTag : getTag(object),
              othTag = othIsArr ? arrayTag : getTag(other);

          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;

          var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;

          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack);
            return (objIsArr || isTypedArray(object))
              ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
              : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object,
                  othUnwrapped = othIsWrapped ? other.value() : other;

              stack || (stack = new Stack);
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack);
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }

        /**
         * The base implementation of `_.isMap` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         */
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }

        /**
         * The base implementation of `_.isMatch` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Array} matchData The property names, values, and compare flags to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         */
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length,
              length = index,
              noCustomizer = !customizer;

          if (object == null) {
            return !length;
          }
          object = Object(object);
          while (index--) {
            var data = matchData[index];
            if ((noCustomizer && data[2])
                  ? data[1] !== object[data[0]]
                  : !(data[0] in object)
                ) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0],
                objValue = object[key],
                srcValue = data[1];

            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack;
              if (customizer) {
                var result = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result === undefined$1
                    ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                    : result
                  )) {
                return false;
              }
            }
          }
          return true;
        }

        /**
         * The base implementation of `_.isNative` without bad shim checks.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         */
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }

        /**
         * The base implementation of `_.isRegExp` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
         */
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }

        /**
         * The base implementation of `_.isSet` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         */
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }

        /**
         * The base implementation of `_.isTypedArray` without Node.js optimizations.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         */
        function baseIsTypedArray(value) {
          return isObjectLike(value) &&
            isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }

        /**
         * The base implementation of `_.iteratee`.
         *
         * @private
         * @param {*} [value=_.identity] The value to convert to an iteratee.
         * @returns {Function} Returns the iteratee.
         */
        function baseIteratee(value) {
          // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
          // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
          if (typeof value == 'function') {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == 'object') {
            return isArray(value)
              ? baseMatchesProperty(value[0], value[1])
              : baseMatches(value);
          }
          return property(value);
        }

        /**
         * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result = [];
          for (var key in Object(object)) {
            if (hasOwnProperty.call(object, key) && key != 'constructor') {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object),
              result = [];

          for (var key in object) {
            if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.lt` which doesn't coerce arguments.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`,
         *  else `false`.
         */
        function baseLt(value, other) {
          return value < other;
        }

        /**
         * The base implementation of `_.map` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function baseMap(collection, iteratee) {
          var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];

          baseEach(collection, function(value, key, collection) {
            result[++index] = iteratee(value, key, collection);
          });
          return result;
        }

        /**
         * The base implementation of `_.matches` which doesn't clone `source`.
         *
         * @private
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }

        /**
         * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
         *
         * @private
         * @param {string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return (objValue === undefined$1 && objValue === srcValue)
              ? hasIn(object, path)
              : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }

        /**
         * The base implementation of `_.merge` without support for multiple sources.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} [customizer] The function to customize merged values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack);
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            }
            else {
              var newValue = customizer
                ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
                : undefined$1;

              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }

        /**
         * A specialized version of `baseMerge` for arrays and objects which performs
         * deep merges and tracks traversed objects enabling objects with circular
         * references to be merged.
         *
         * @private
         * @param {Object} object The destination object.
         * @param {Object} source The source object.
         * @param {string} key The key of the value to merge.
         * @param {number} srcIndex The index of `source`.
         * @param {Function} mergeFunc The function to merge values.
         * @param {Function} [customizer] The function to customize assigned values.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         */
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key),
              srcValue = safeGet(source, key),
              stacked = stack.get(srcValue);

          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer
            ? customizer(objValue, srcValue, (key + ''), object, source, stack)
            : undefined$1;

          var isCommon = newValue === undefined$1;

          if (isCommon) {
            var isArr = isArray(srcValue),
                isBuff = !isArr && isBuffer(srcValue),
                isTyped = !isArr && !isBuff && isTypedArray(srcValue);

            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              }
              else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              }
              else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              }
              else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              }
              else {
                newValue = [];
              }
            }
            else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              }
              else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            }
            else {
              isCommon = false;
            }
          }
          if (isCommon) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack['delete'](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }

        /**
         * The base implementation of `_.nth` which doesn't coerce arguments.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {number} n The index of the element to return.
         * @returns {*} Returns the nth element of `array`.
         */
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined$1;
        }

        /**
         * The base implementation of `_.orderBy` without param guards.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
         * @param {string[]} orders The sort orders of `iteratees`.
         * @returns {Array} Returns the new sorted array.
         */
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee) {
              if (isArray(iteratee)) {
                return function(value) {
                  return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
                }
              }
              return iteratee;
            });
          } else {
            iteratees = [identity];
          }

          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

          var result = baseMap(collection, function(value, key, collection) {
            var criteria = arrayMap(iteratees, function(iteratee) {
              return iteratee(value);
            });
            return { 'criteria': criteria, 'index': ++index, 'value': value };
          });

          return baseSortBy(result, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }

        /**
         * The base implementation of `_.pick` without support for individual
         * property identifiers.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @returns {Object} Returns the new object.
         */
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }

        /**
         * The base implementation of  `_.pickBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Object} object The source object.
         * @param {string[]} paths The property paths to pick.
         * @param {Function} predicate The function invoked per property.
         * @returns {Object} Returns the new object.
         */
        function basePickBy(object, paths, predicate) {
          var index = -1,
              length = paths.length,
              result = {};

          while (++index < length) {
            var path = paths[index],
                value = baseGet(object, path);

            if (predicate(value, path)) {
              baseSet(result, castPath(path, object), value);
            }
          }
          return result;
        }

        /**
         * A specialized version of `baseProperty` which supports deep paths.
         *
         * @private
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }

        /**
         * The base implementation of `_.pullAllBy` without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns `array`.
         */
        function basePullAll(array, values, iteratee, comparator) {
          var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
              index = -1,
              length = values.length,
              seen = array;

          if (array === values) {
            values = copyArray(values);
          }
          if (iteratee) {
            seen = arrayMap(array, baseUnary(iteratee));
          }
          while (++index < length) {
            var fromIndex = 0,
                value = values[index],
                computed = iteratee ? iteratee(value) : value;

            while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }

        /**
         * The base implementation of `_.pullAt` without support for individual
         * indexes or capturing the removed elements.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {number[]} indexes The indexes of elements to remove.
         * @returns {Array} Returns `array`.
         */
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0,
              lastIndex = length - 1;

          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }

        /**
         * The base implementation of `_.random` without support for returning
         * floating-point numbers.
         *
         * @private
         * @param {number} lower The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the random number.
         */
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }

        /**
         * The base implementation of `_.range` and `_.rangeRight` which doesn't
         * coerce arguments.
         *
         * @private
         * @param {number} start The start of the range.
         * @param {number} end The end of the range.
         * @param {number} step The value to increment or decrement by.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the range of numbers.
         */
        function baseRange(start, end, step, fromRight) {
          var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);

          while (length--) {
            result[fromRight ? length : ++index] = start;
            start += step;
          }
          return result;
        }

        /**
         * The base implementation of `_.repeat` which doesn't coerce arguments.
         *
         * @private
         * @param {string} string The string to repeat.
         * @param {number} n The number of times to repeat the string.
         * @returns {string} Returns the repeated string.
         */
        function baseRepeat(string, n) {
          var result = '';
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result;
          }
          // Leverage the exponentiation by squaring algorithm for a faster repeat.
          // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
          do {
            if (n % 2) {
              result += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);

          return result;
        }

        /**
         * The base implementation of `_.rest` which doesn't validate or coerce arguments.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         */
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + '');
        }

        /**
         * The base implementation of `_.sample`.
         *
         * @private
         * @param {Array|Object} collection The collection to sample.
         * @returns {*} Returns the random element.
         */
        function baseSample(collection) {
          return arraySample(values(collection));
        }

        /**
         * The base implementation of `_.sampleSize` without param guards.
         *
         * @private
         * @param {Array|Object} collection The collection to sample.
         * @param {number} n The number of elements to sample.
         * @returns {Array} Returns the random elements.
         */
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }

        /**
         * The base implementation of `_.set`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);

          var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;

          while (nested != null && ++index < length) {
            var key = toKey(path[index]),
                newValue = value;

            if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
              return object;
            }

            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject(objValue)
                  ? objValue
                  : (isIndex(path[index + 1]) ? [] : {});
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }

        /**
         * The base implementation of `setData` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };

        /**
         * The base implementation of `setToString` without support for hot loop shorting.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, 'toString', {
            'configurable': true,
            'enumerable': false,
            'value': constant(string),
            'writable': true
          });
        };

        /**
         * The base implementation of `_.shuffle`.
         *
         * @private
         * @param {Array|Object} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         */
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }

        /**
         * The base implementation of `_.slice` without an iteratee call guard.
         *
         * @private
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseSlice(array, start, end) {
          var index = -1,
              length = array.length;

          if (start < 0) {
            start = -start > length ? 0 : (length + start);
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : ((end - start) >>> 0);
          start >>>= 0;

          var result = Array(length);
          while (++index < length) {
            result[index] = array[index + start];
          }
          return result;
        }

        /**
         * The base implementation of `_.some` without support for iteratee shorthands.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function baseSome(collection, predicate) {
          var result;

          baseEach(collection, function(value, index, collection) {
            result = predicate(value, index, collection);
            return !result;
          });
          return !!result;
        }

        /**
         * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
         * performs a binary search of `array` to determine the index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function baseSortedIndex(array, value, retHighest) {
          var low = 0,
              high = array == null ? low : array.length;

          if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = (low + high) >>> 1,
                  computed = array[mid];

              if (computed !== null && !isSymbol(computed) &&
                  (retHighest ? (computed <= value) : (computed < value))) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }

        /**
         * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
         * which invokes `iteratee` for `value` and each element of `array` to compute
         * their sort ranking. The iteratee is invoked with one argument; (value).
         *
         * @private
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} iteratee The iteratee invoked per element.
         * @param {boolean} [retHighest] Specify returning the highest qualified index.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         */
        function baseSortedIndexBy(array, value, iteratee, retHighest) {
          var low = 0,
              high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }

          value = iteratee(value);
          var valIsNaN = value !== value,
              valIsNull = value === null,
              valIsSymbol = isSymbol(value),
              valIsUndefined = value === undefined$1;

          while (low < high) {
            var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                othIsDefined = computed !== undefined$1,
                othIsNull = computed === null,
                othIsReflexive = computed === computed,
                othIsSymbol = isSymbol(computed);

            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? (computed <= value) : (computed < value);
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }

        /**
         * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
         * support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseSortedUniq(array, iteratee) {
          var index = -1,
              length = array.length,
              resIndex = 0,
              result = [];

          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.toNumber` which doesn't ensure correct
         * conversions of binary, hexadecimal, or octal string values.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         */
        function baseToNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }

        /**
         * The base implementation of `_.toString` which doesn't convert nullish
         * values to empty strings.
         *
         * @private
         * @param {*} value The value to process.
         * @returns {string} Returns the string.
         */
        function baseToString(value) {
          // Exit early for strings to avoid a performance hit in some environments.
          if (typeof value == 'string') {
            return value;
          }
          if (isArray(value)) {
            // Recursively convert values (susceptible to call stack limits).
            return arrayMap(value, baseToString) + '';
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : '';
          }
          var result = (value + '');
          return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }

        /**
         * The base implementation of `_.uniqBy` without support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         */
        function baseUniq(array, iteratee, comparator) {
          var index = -1,
              includes = arrayIncludes,
              length = array.length,
              isCommon = true,
              result = [],
              seen = result;

          if (comparator) {
            isCommon = false;
            includes = arrayIncludesWith;
          }
          else if (length >= LARGE_ARRAY_SIZE) {
            var set = iteratee ? null : createSet(array);
            if (set) {
              return setToArray(set);
            }
            isCommon = false;
            includes = cacheHas;
            seen = new SetCache;
          }
          else {
            seen = iteratee ? [] : result;
          }
          outer:
          while (++index < length) {
            var value = array[index],
                computed = iteratee ? iteratee(value) : value;

            value = (comparator || value !== 0) ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee) {
                seen.push(computed);
              }
              result.push(value);
            }
            else if (!includes(seen, computed, comparator)) {
              if (seen !== result) {
                seen.push(computed);
              }
              result.push(value);
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.unset`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The property path to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         */
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }

        /**
         * The base implementation of `_.update`.
         *
         * @private
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to update.
         * @param {Function} updater The function to produce the updated value.
         * @param {Function} [customizer] The function to customize path creation.
         * @returns {Object} Returns `object`.
         */
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }

        /**
         * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
         * without support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to query.
         * @param {Function} predicate The function invoked per iteration.
         * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Array} Returns the slice of `array`.
         */
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length,
              index = fromRight ? length : -1;

          while ((fromRight ? index-- : ++index < length) &&
            predicate(array[index], index, array)) {}

          return isDrop
            ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
            : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
        }

        /**
         * The base implementation of `wrapperValue` which returns the result of
         * performing a sequence of actions on the unwrapped `value`, where each
         * successive action is supplied the return value of the previous.
         *
         * @private
         * @param {*} value The unwrapped value.
         * @param {Array} actions Actions to perform to resolve the unwrapped value.
         * @returns {*} Returns the resolved value.
         */
        function baseWrapperValue(value, actions) {
          var result = value;
          if (result instanceof LazyWrapper) {
            result = result.value();
          }
          return arrayReduce(actions, function(result, action) {
            return action.func.apply(action.thisArg, arrayPush([result], action.args));
          }, result);
        }

        /**
         * The base implementation of methods like `_.xor`, without support for
         * iteratee shorthands, that accepts an array of arrays to inspect.
         *
         * @private
         * @param {Array} arrays The arrays to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of values.
         */
        function baseXor(arrays, iteratee, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1,
              result = Array(length);

          while (++index < length) {
            var array = arrays[index],
                othIndex = -1;

            while (++othIndex < length) {
              if (othIndex != index) {
                result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result, 1), iteratee, comparator);
        }

        /**
         * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
         *
         * @private
         * @param {Array} props The property identifiers.
         * @param {Array} values The property values.
         * @param {Function} assignFunc The function to assign values.
         * @returns {Object} Returns the new object.
         */
        function baseZipObject(props, values, assignFunc) {
          var index = -1,
              length = props.length,
              valsLength = values.length,
              result = {};

          while (++index < length) {
            var value = index < valsLength ? values[index] : undefined$1;
            assignFunc(result, props[index], value);
          }
          return result;
        }

        /**
         * Casts `value` to an empty array if it's not an array like object.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Array|Object} Returns the cast array-like object.
         */
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }

        /**
         * Casts `value` to `identity` if it's not a function.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {Function} Returns cast function.
         */
        function castFunction(value) {
          return typeof value == 'function' ? value : identity;
        }

        /**
         * Casts `value` to a path array if it's not one.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {Object} [object] The object to query keys on.
         * @returns {Array} Returns the cast property path array.
         */
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }

        /**
         * A `baseRest` alias which can be replaced with `identity` by module
         * replacement plugins.
         *
         * @private
         * @type {Function}
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */
        var castRest = baseRest;

        /**
         * Casts `array` to a slice if it's needed.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {number} start The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the cast slice.
         */
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined$1 ? length : end;
          return (!start && end >= length) ? array : baseSlice(array, start, end);
        }

        /**
         * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
         *
         * @private
         * @param {number|Object} id The timer id or timeout object of the timer to clear.
         */
        var clearTimeout = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };

        /**
         * Creates a clone of  `buffer`.
         *
         * @private
         * @param {Buffer} buffer The buffer to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Buffer} Returns the cloned buffer.
         */
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length,
              result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

          buffer.copy(result);
          return result;
        }

        /**
         * Creates a clone of `arrayBuffer`.
         *
         * @private
         * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
         * @returns {ArrayBuffer} Returns the cloned array buffer.
         */
        function cloneArrayBuffer(arrayBuffer) {
          var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array(result).set(new Uint8Array(arrayBuffer));
          return result;
        }

        /**
         * Creates a clone of `dataView`.
         *
         * @private
         * @param {Object} dataView The data view to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned data view.
         */
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }

        /**
         * Creates a clone of `regexp`.
         *
         * @private
         * @param {Object} regexp The regexp to clone.
         * @returns {Object} Returns the cloned regexp.
         */
        function cloneRegExp(regexp) {
          var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result.lastIndex = regexp.lastIndex;
          return result;
        }

        /**
         * Creates a clone of the `symbol` object.
         *
         * @private
         * @param {Object} symbol The symbol object to clone.
         * @returns {Object} Returns the cloned symbol object.
         */
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
        }

        /**
         * Creates a clone of `typedArray`.
         *
         * @private
         * @param {Object} typedArray The typed array to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the cloned typed array.
         */
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }

        /**
         * Compares values to sort them in ascending order.
         *
         * @private
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {number} Returns the sort order indicator for `value`.
         */
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1,
                valIsNull = value === null,
                valIsReflexive = value === value,
                valIsSymbol = isSymbol(value);

            var othIsDefined = other !== undefined$1,
                othIsNull = other === null,
                othIsReflexive = other === other,
                othIsSymbol = isSymbol(other);

            if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
                (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
                (valIsNull && othIsDefined && othIsReflexive) ||
                (!valIsDefined && othIsReflexive) ||
                !valIsReflexive) {
              return 1;
            }
            if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
                (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
                (othIsNull && valIsDefined && valIsReflexive) ||
                (!othIsDefined && valIsReflexive) ||
                !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }

        /**
         * Used by `_.orderBy` to compare multiple properties of a value to another
         * and stable sort them.
         *
         * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
         * specify an order of "desc" for descending or "asc" for ascending sort order
         * of corresponding values.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {boolean[]|string[]} orders The order to sort by for each property.
         * @returns {number} Returns the sort order indicator for `object`.
         */
        function compareMultiple(object, other, orders) {
          var index = -1,
              objCriteria = object.criteria,
              othCriteria = other.criteria,
              length = objCriteria.length,
              ordersLength = orders.length;

          while (++index < length) {
            var result = compareAscending(objCriteria[index], othCriteria[index]);
            if (result) {
              if (index >= ordersLength) {
                return result;
              }
              var order = orders[index];
              return result * (order == 'desc' ? -1 : 1);
            }
          }
          // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
          // that causes it, under certain circumstances, to provide the same value for
          // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
          // for more details.
          //
          // This also ensures a stable sort in V8 and other engines.
          // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
          return object.index - other.index;
        }

        /**
         * Creates an array that is the composition of partially applied arguments,
         * placeholders, and provided arguments into a single array of arguments.
         *
         * @private
         * @param {Array} args The provided arguments.
         * @param {Array} partials The arguments to prepend to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @params {boolean} [isCurried] Specify composing for a curried function.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1,
              argsLength = args.length,
              holdersLength = holders.length,
              leftIndex = -1,
              leftLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(leftLength + rangeLength),
              isUncurried = !isCurried;

          while (++leftIndex < leftLength) {
            result[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result[leftIndex++] = args[argsIndex++];
          }
          return result;
        }

        /**
         * This function is like `composeArgs` except that the arguments composition
         * is tailored for `_.partialRight`.
         *
         * @private
         * @param {Array} args The provided arguments.
         * @param {Array} partials The arguments to append to those provided.
         * @param {Array} holders The `partials` placeholder indexes.
         * @params {boolean} [isCurried] Specify composing for a curried function.
         * @returns {Array} Returns the new array of composed arguments.
         */
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1,
              argsLength = args.length,
              holdersIndex = -1,
              holdersLength = holders.length,
              rightIndex = -1,
              rightLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(rangeLength + rightLength),
              isUncurried = !isCurried;

          while (++argsIndex < rangeLength) {
            result[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result;
        }

        /**
         * Copies the values of `source` to `array`.
         *
         * @private
         * @param {Array} source The array to copy values from.
         * @param {Array} [array=[]] The array to copy values to.
         * @returns {Array} Returns `array`.
         */
        function copyArray(source, array) {
          var index = -1,
              length = source.length;

          array || (array = Array(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }

        /**
         * Copies properties of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy properties from.
         * @param {Array} props The property identifiers to copy.
         * @param {Object} [object={}] The object to copy properties to.
         * @param {Function} [customizer] The function to customize copied values.
         * @returns {Object} Returns `object`.
         */
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});

          var index = -1,
              length = props.length;

          while (++index < length) {
            var key = props[index];

            var newValue = customizer
              ? customizer(object[key], source[key], key, object, source)
              : undefined$1;

            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }

        /**
         * Copies own symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }

        /**
         * Copies own and inherited symbols of `source` to `object`.
         *
         * @private
         * @param {Object} source The object to copy symbols from.
         * @param {Object} [object={}] The object to copy symbols to.
         * @returns {Object} Returns `object`.
         */
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }

        /**
         * Creates a function like `_.groupBy`.
         *
         * @private
         * @param {Function} setter The function to set accumulator values.
         * @param {Function} [initializer] The accumulator object initializer.
         * @returns {Function} Returns the new aggregator function.
         */
        function createAggregator(setter, initializer) {
          return function(collection, iteratee) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator,
                accumulator = initializer ? initializer() : {};

            return func(collection, setter, getIteratee(iteratee, 2), accumulator);
          };
        }

        /**
         * Creates a function like `_.assign`.
         *
         * @private
         * @param {Function} assigner The function to assign values.
         * @returns {Function} Returns the new assigner function.
         */
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined$1,
                guard = length > 2 ? sources[2] : undefined$1;

            customizer = (assigner.length > 3 && typeof customizer == 'function')
              ? (length--, customizer)
              : undefined$1;

            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined$1 : customizer;
              length = 1;
            }
            object = Object(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }

        /**
         * Creates a `baseEach` or `baseEachRight` function.
         *
         * @private
         * @param {Function} eachFunc The function to iterate over a collection.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee);
            }
            var length = collection.length,
                index = fromRight ? length : -1,
                iterable = Object(collection);

            while ((fromRight ? index-- : ++index < length)) {
              if (iteratee(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }

        /**
         * Creates a base function for methods like `_.forIn` and `_.forOwn`.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new base function.
         */
        function createBaseFor(fromRight) {
          return function(object, iteratee, keysFunc) {
            var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length;

            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }

        /**
         * Creates a function that wraps `func` to invoke it with the optional `this`
         * binding of `thisArg`.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG,
              Ctor = createCtor(func);

          function wrapper() {
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }

        /**
         * Creates a function like `_.lowerFirst`.
         *
         * @private
         * @param {string} methodName The name of the `String` case method to use.
         * @returns {Function} Returns the new case function.
         */
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);

            var strSymbols = hasUnicode(string)
              ? stringToArray(string)
              : undefined$1;

            var chr = strSymbols
              ? strSymbols[0]
              : string.charAt(0);

            var trailing = strSymbols
              ? castSlice(strSymbols, 1).join('')
              : string.slice(1);

            return chr[methodName]() + trailing;
          };
        }

        /**
         * Creates a function like `_.camelCase`.
         *
         * @private
         * @param {Function} callback The function to combine each word.
         * @returns {Function} Returns the new compounder function.
         */
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
          };
        }

        /**
         * Creates a function that produces an instance of `Ctor` regardless of
         * whether it was invoked as part of a `new` expression or by `call` or `apply`.
         *
         * @private
         * @param {Function} Ctor The constructor to wrap.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCtor(Ctor) {
          return function() {
            // Use a `switch` statement to work with class constructors. See
            // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
            // for more details.
            var args = arguments;
            switch (args.length) {
              case 0: return new Ctor;
              case 1: return new Ctor(args[0]);
              case 2: return new Ctor(args[0], args[1]);
              case 3: return new Ctor(args[0], args[1], args[2]);
              case 4: return new Ctor(args[0], args[1], args[2], args[3]);
              case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);

            // Mimic the constructor's `return` behavior.
            // See https://es5.github.io/#x13.2.2 for more details.
            return isObject(result) ? result : thisBinding;
          };
        }

        /**
         * Creates a function that wraps `func` to enable currying.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {number} arity The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);

          function wrapper() {
            var length = arguments.length,
                args = Array(length),
                index = length,
                placeholder = getHolder(wrapper);

            while (index--) {
              args[index] = arguments[index];
            }
            var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
              ? []
              : replaceHolders(args, placeholder);

            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
                args, holders, undefined$1, undefined$1, arity - length);
            }
            var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }

        /**
         * Creates a `_.find` or `_.findLast` function.
         *
         * @private
         * @param {Function} findIndexFunc The function to find the collection index.
         * @returns {Function} Returns the new find function.
         */
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object(collection);
            if (!isArrayLike(collection)) {
              var iteratee = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) { return iteratee(iterable[key], key, iterable); };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
          };
        }

        /**
         * Creates a `_.flow` or `_.flowRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new flow function.
         */
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length,
                index = length,
                prereq = LodashWrapper.prototype.thru;

            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];

              var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined$1;

              if (data && isLaziable(data[0]) &&
                    data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                    !data[4].length && data[9] == 1
                  ) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = (func.length == 1 && isLaziable(func))
                  ? wrapper[funcName]()
                  : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments,
                  value = args[0];

              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;

              while (++index < length) {
                result = funcs[index].call(this, result);
              }
              return result;
            };
          });
        }

        /**
         * Creates a function that wraps `func` to invoke it with optional `this`
         * binding of `thisArg`, partial application, and currying.
         *
         * @private
         * @param {Function|string} func The function or method name to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to
         *  the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [partialsRight] The arguments to append to those provided
         *  to the new function.
         * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG,
              isBind = bitmask & WRAP_BIND_FLAG,
              isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
              isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
              isFlip = bitmask & WRAP_FLIP_FLAG,
              Ctor = isBindKey ? undefined$1 : createCtor(func);

          function wrapper() {
            var length = arguments.length,
                args = Array(length),
                index = length;

            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper),
                  holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func, bitmask, createHybrid, wrapper.placeholder, thisArg,
                args, newHolders, argPos, ary, arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;

            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary < length) {
              args.length = ary;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }

        /**
         * Creates a function like `_.invertBy`.
         *
         * @private
         * @param {Function} setter The function to set accumulator values.
         * @param {Function} toIteratee The function to resolve iteratees.
         * @returns {Function} Returns the new inverter function.
         */
        function createInverter(setter, toIteratee) {
          return function(object, iteratee) {
            return baseInverter(object, setter, toIteratee(iteratee), {});
          };
        }

        /**
         * Creates a function that performs a mathematical operation on two values.
         *
         * @private
         * @param {Function} operator The function to perform the operation.
         * @param {number} [defaultValue] The value used for `undefined` arguments.
         * @returns {Function} Returns the new mathematical operation function.
         */
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result = value;
            }
            if (other !== undefined$1) {
              if (result === undefined$1) {
                return other;
              }
              if (typeof value == 'string' || typeof other == 'string') {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result = operator(value, other);
            }
            return result;
          };
        }

        /**
         * Creates a function like `_.over`.
         *
         * @private
         * @param {Function} arrayFunc The function to iterate over iteratees.
         * @returns {Function} Returns the new over function.
         */
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee) {
                return apply(iteratee, thisArg, args);
              });
            });
          });
        }

        /**
         * Creates the padding for `string` based on `length`. The `chars` string
         * is truncated if the number of characters exceeds `length`.
         *
         * @private
         * @param {number} length The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padding for `string`.
         */
        function createPadding(length, chars) {
          chars = chars === undefined$1 ? ' ' : baseToString(chars);

          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars)
            ? castSlice(stringToArray(result), 0, length).join('')
            : result.slice(0, length);
        }

        /**
         * Creates a function that wraps `func` to invoke it with the `this` binding
         * of `thisArg` and `partials` prepended to the arguments it receives.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} partials The arguments to prepend to those provided to
         *  the new function.
         * @returns {Function} Returns the new wrapped function.
         */
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG,
              Ctor = createCtor(func);

          function wrapper() {
            var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength),
                fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }

        /**
         * Creates a `_.range` or `_.rangeRight` function.
         *
         * @private
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {Function} Returns the new range function.
         */
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
              end = step = undefined$1;
            }
            // Ensure the sign of `-0` is preserved.
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }

        /**
         * Creates a function that performs a relational operation on two values.
         *
         * @private
         * @param {Function} operator The function to perform the operation.
         * @returns {Function} Returns the new relational operation function.
         */
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == 'string' && typeof other == 'string')) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }

        /**
         * Creates a function that wraps `func` to continue currying.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @param {Function} wrapFunc The function to create the `func` wrapper.
         * @param {*} placeholder The placeholder value.
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to prepend to those provided to
         *  the new function.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG,
              newHolders = isCurry ? holders : undefined$1,
              newHoldersRight = isCurry ? undefined$1 : holders,
              newPartials = isCurry ? partials : undefined$1,
              newPartialsRight = isCurry ? undefined$1 : partials;

          bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
            newHoldersRight, argPos, ary, arity
          ];

          var result = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData(result, newData);
          }
          result.placeholder = placeholder;
          return setWrapToString(result, func, bitmask);
        }

        /**
         * Creates a function like `_.round`.
         *
         * @private
         * @param {string} methodName The name of the `Math` method to use when rounding.
         * @returns {Function} Returns the new round function.
         */
        function createRound(methodName) {
          var func = Math[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              // Shift with exponential notation to avoid floating-point issues.
              // See [MDN](https://mdn.io/round#Examples) for more details.
              var pair = (toString(number) + 'e').split('e'),
                  value = func(pair[0] + 'e' + (+pair[1] + precision));

              pair = (toString(value) + 'e').split('e');
              return +(pair[0] + 'e' + (+pair[1] - precision));
            }
            return func(number);
          };
        }

        /**
         * Creates a set object of `values`.
         *
         * @private
         * @param {Array} values The values to add to the set.
         * @returns {Object} Returns the new set.
         */
        var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
          return new Set(values);
        };

        /**
         * Creates a `_.toPairs` or `_.toPairsIn` function.
         *
         * @private
         * @param {Function} keysFunc The function to get the keys of a given object.
         * @returns {Function} Returns the new pairs function.
         */
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }

        /**
         * Creates a function that either curries or invokes `func` with optional
         * `this` binding and partially applied arguments.
         *
         * @private
         * @param {Function|string} func The function or method name to wrap.
         * @param {number} bitmask The bitmask flags.
         *    1 - `_.bind`
         *    2 - `_.bindKey`
         *    4 - `_.curry` or `_.curryRight` of a bound function
         *    8 - `_.curry`
         *   16 - `_.curryRight`
         *   32 - `_.partial`
         *   64 - `_.partialRight`
         *  128 - `_.rearg`
         *  256 - `_.ary`
         *  512 - `_.flip`
         * @param {*} [thisArg] The `this` binding of `func`.
         * @param {Array} [partials] The arguments to be partially applied.
         * @param {Array} [holders] The `partials` placeholder indexes.
         * @param {Array} [argPos] The argument positions of the new function.
         * @param {number} [ary] The arity cap of `func`.
         * @param {number} [arity] The arity of `func`.
         * @returns {Function} Returns the new wrapped function.
         */
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined$1;
          }
          ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;

          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials,
                holdersRight = holders;

            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func);

          var newData = [
            func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
            argPos, ary, arity
          ];

          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1
            ? (isBindKey ? 0 : func.length)
            : nativeMax(newData[9] - length, 0);

          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result = createPartial(func, bitmask, thisArg, partials);
          } else {
            result = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result, newData), func, bitmask);
        }

        /**
         * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
         * of source objects to the destination object for all destination properties
         * that resolve to `undefined`.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to assign.
         * @param {Object} object The parent object of `objValue`.
         * @returns {*} Returns the value to assign.
         */
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined$1 ||
              (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            return srcValue;
          }
          return objValue;
        }

        /**
         * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
         * objects into destination objects that are passed thru.
         *
         * @private
         * @param {*} objValue The destination value.
         * @param {*} srcValue The source value.
         * @param {string} key The key of the property to merge.
         * @param {Object} object The parent object of `objValue`.
         * @param {Object} source The parent object of `srcValue`.
         * @param {Object} [stack] Tracks traversed source values and their merged
         *  counterparts.
         * @returns {*} Returns the value to assign.
         */
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            // Recursively merge objects and arrays (susceptible to call stack limits).
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
            stack['delete'](srcValue);
          }
          return objValue;
        }

        /**
         * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
         * objects.
         *
         * @private
         * @param {*} value The value to inspect.
         * @param {string} key The key of the property to inspect.
         * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
         */
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined$1 : value;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for arrays with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Array} array The array to compare.
         * @param {Array} other The other array to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `array` and `other` objects.
         * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
         */
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              arrLength = array.length,
              othLength = other.length;

          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          // Check that cyclic values are equal.
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1,
              result = true,
              seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

          stack.set(array, other);
          stack.set(other, array);

          // Ignore non-index properties.
          while (++index < arrLength) {
            var arrValue = array[index],
                othValue = other[index];

            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, arrValue, index, other, array, stack)
                : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result = false;
              break;
            }
            // Recursively compare arrays (susceptible to call stack limits).
            if (seen) {
              if (!arraySome(other, function(othValue, othIndex) {
                    if (!cacheHas(seen, othIndex) &&
                        (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                      return seen.push(othIndex);
                    }
                  })) {
                result = false;
                break;
              }
            } else if (!(
                  arrValue === othValue ||
                    equalFunc(arrValue, othValue, bitmask, customizer, stack)
                )) {
              result = false;
              break;
            }
          }
          stack['delete'](array);
          stack['delete'](other);
          return result;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for comparing objects of
         * the same `toStringTag`.
         *
         * **Note:** This function only supports comparing values with tags of
         * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {string} tag The `toStringTag` of the objects to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if ((object.byteLength != other.byteLength) ||
                  (object.byteOffset != other.byteOffset)) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;

            case arrayBufferTag:
              if ((object.byteLength != other.byteLength) ||
                  !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                return false;
              }
              return true;

            case boolTag:
            case dateTag:
            case numberTag:
              // Coerce booleans to `1` or `0` and dates to milliseconds.
              // Invalid dates are coerced to `NaN`.
              return eq(+object, +other);

            case errorTag:
              return object.name == other.name && object.message == other.message;

            case regexpTag:
            case stringTag:
              // Coerce regexes to strings and treat strings, primitives and objects,
              // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
              // for more details.
              return object == (other + '');

            case mapTag:
              var convert = mapToArray;

            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);

              if (object.size != other.size && !isPartial) {
                return false;
              }
              // Assume cyclic values are equal.
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;

              // Recursively compare objects (susceptible to call stack limits).
              stack.set(object, other);
              var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack['delete'](object);
              return result;

            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }

        /**
         * A specialized version of `baseIsEqualDeep` for objects with support for
         * partial deep comparisons.
         *
         * @private
         * @param {Object} object The object to compare.
         * @param {Object} other The other object to compare.
         * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
         * @param {Function} customizer The function to customize comparisons.
         * @param {Function} equalFunc The function to determine equivalents of values.
         * @param {Object} stack Tracks traversed `object` and `other` objects.
         * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
         */
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              objProps = getAllKeys(object),
              objLength = objProps.length,
              othProps = getAllKeys(other),
              othLength = othProps.length;

          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          // Check that cyclic values are equal.
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result = true;
          stack.set(object, other);
          stack.set(other, object);

          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key],
                othValue = other[key];

            if (customizer) {
              var compared = isPartial
                ? customizer(othValue, objValue, key, other, object, stack)
                : customizer(objValue, othValue, key, object, other, stack);
            }
            // Recursively compare objects (susceptible to call stack limits).
            if (!(compared === undefined$1
                  ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
                  : compared
                )) {
              result = false;
              break;
            }
            skipCtor || (skipCtor = key == 'constructor');
          }
          if (result && !skipCtor) {
            var objCtor = object.constructor,
                othCtor = other.constructor;

            // Non `Object` object instances with different constructors are not equal.
            if (objCtor != othCtor &&
                ('constructor' in object && 'constructor' in other) &&
                !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
                  typeof othCtor == 'function' && othCtor instanceof othCtor)) {
              result = false;
            }
          }
          stack['delete'](object);
          stack['delete'](other);
          return result;
        }

        /**
         * A specialized version of `baseRest` which flattens the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @returns {Function} Returns the new function.
         */
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + '');
        }

        /**
         * Creates an array of own enumerable property names and symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }

        /**
         * Creates an array of own and inherited enumerable property names and
         * symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names and symbols.
         */
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }

        /**
         * Gets metadata for `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {*} Returns the metadata for `func`.
         */
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };

        /**
         * Gets the name of `func`.
         *
         * @private
         * @param {Function} func The function to query.
         * @returns {string} Returns the function name.
         */
        function getFuncName(func) {
          var result = (func.name + ''),
              array = realNames[result],
              length = hasOwnProperty.call(realNames, result) ? array.length : 0;

          while (length--) {
            var data = array[length],
                otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result;
        }

        /**
         * Gets the argument placeholder value for `func`.
         *
         * @private
         * @param {Function} func The function to inspect.
         * @returns {*} Returns the placeholder value.
         */
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
          return object.placeholder;
        }

        /**
         * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
         * this function returns the custom method, otherwise it returns `baseIteratee`.
         * If arguments are provided, the chosen function is invoked with them and
         * its result is returned.
         *
         * @private
         * @param {*} [value] The value to convert to an iteratee.
         * @param {number} [arity] The arity of the created iteratee.
         * @returns {Function} Returns the chosen function or its result.
         */
        function getIteratee() {
          var result = lodash.iteratee || iteratee;
          result = result === iteratee ? baseIteratee : result;
          return arguments.length ? result(arguments[0], arguments[1]) : result;
        }

        /**
         * Gets the data for `map`.
         *
         * @private
         * @param {Object} map The map to query.
         * @param {string} key The reference key.
         * @returns {*} Returns the map data.
         */
        function getMapData(map, key) {
          var data = map.__data__;
          return isKeyable(key)
            ? data[typeof key == 'string' ? 'string' : 'hash']
            : data.map;
        }

        /**
         * Gets the property names, values, and compare flags of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the match data of `object`.
         */
        function getMatchData(object) {
          var result = keys(object),
              length = result.length;

          while (length--) {
            var key = result[length],
                value = object[key];

            result[length] = [key, value, isStrictComparable(value)];
          }
          return result;
        }

        /**
         * Gets the native function at `key` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the method to get.
         * @returns {*} Returns the function if it's native, else `undefined`.
         */
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined$1;
        }

        /**
         * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the raw `toStringTag`.
         */
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag),
              tag = value[symToStringTag];

          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e) {}

          var result = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result;
        }

        /**
         * Creates an array of the own enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };

        /**
         * Creates an array of the own and inherited enumerable symbols of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of symbols.
         */
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result = [];
          while (object) {
            arrayPush(result, getSymbols(object));
            object = getPrototype(object);
          }
          return result;
        };

        /**
         * Gets the `toStringTag` of `value`.
         *
         * @private
         * @param {*} value The value to query.
         * @returns {string} Returns the `toStringTag`.
         */
        var getTag = baseGetTag;

        // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
        if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
            (Map && getTag(new Map) != mapTag) ||
            (Promise && getTag(Promise.resolve()) != promiseTag) ||
            (Set && getTag(new Set) != setTag) ||
            (WeakMap && getTag(new WeakMap) != weakMapTag)) {
          getTag = function(value) {
            var result = baseGetTag(value),
                Ctor = result == objectTag ? value.constructor : undefined$1,
                ctorString = Ctor ? toSource(Ctor) : '';

            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString: return dataViewTag;
                case mapCtorString: return mapTag;
                case promiseCtorString: return promiseTag;
                case setCtorString: return setTag;
                case weakMapCtorString: return weakMapTag;
              }
            }
            return result;
          };
        }

        /**
         * Gets the view, applying any `transforms` to the `start` and `end` positions.
         *
         * @private
         * @param {number} start The start of the view.
         * @param {number} end The end of the view.
         * @param {Array} transforms The transformations to apply to the view.
         * @returns {Object} Returns an object containing the `start` and `end`
         *  positions of the view.
         */
        function getView(start, end, transforms) {
          var index = -1,
              length = transforms.length;

          while (++index < length) {
            var data = transforms[index],
                size = data.size;

            switch (data.type) {
              case 'drop':      start += size; break;
              case 'dropRight': end -= size; break;
              case 'take':      end = nativeMin(end, start + size); break;
              case 'takeRight': start = nativeMax(start, end - size); break;
            }
          }
          return { 'start': start, 'end': end };
        }

        /**
         * Extracts wrapper details from the `source` body comment.
         *
         * @private
         * @param {string} source The source to inspect.
         * @returns {Array} Returns the wrapper details.
         */
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }

        /**
         * Checks if `path` exists on `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @param {Function} hasFunc The function to check properties.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         */
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);

          var index = -1,
              length = path.length,
              result = false;

          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result || ++index != length) {
            return result;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) &&
            (isArray(object) || isArguments(object));
        }

        /**
         * Initializes an array clone.
         *
         * @private
         * @param {Array} array The array to clone.
         * @returns {Array} Returns the initialized clone.
         */
        function initCloneArray(array) {
          var length = array.length,
              result = new array.constructor(length);

          // Add properties assigned by `RegExp#exec`.
          if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
            result.index = array.index;
            result.input = array.input;
          }
          return result;
        }

        /**
         * Initializes an object clone.
         *
         * @private
         * @param {Object} object The object to clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneObject(object) {
          return (typeof object.constructor == 'function' && !isPrototype(object))
            ? baseCreate(getPrototype(object))
            : {};
        }

        /**
         * Initializes an object clone based on its `toStringTag`.
         *
         * **Note:** This function only supports cloning values with tags of
         * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
         *
         * @private
         * @param {Object} object The object to clone.
         * @param {string} tag The `toStringTag` of the object to clone.
         * @param {boolean} [isDeep] Specify a deep clone.
         * @returns {Object} Returns the initialized clone.
         */
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);

            case boolTag:
            case dateTag:
              return new Ctor(+object);

            case dataViewTag:
              return cloneDataView(object, isDeep);

            case float32Tag: case float64Tag:
            case int8Tag: case int16Tag: case int32Tag:
            case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
              return cloneTypedArray(object, isDeep);

            case mapTag:
              return new Ctor;

            case numberTag:
            case stringTag:
              return new Ctor(object);

            case regexpTag:
              return cloneRegExp(object);

            case setTag:
              return new Ctor;

            case symbolTag:
              return cloneSymbol(object);
          }
        }

        /**
         * Inserts wrapper `details` in a comment at the top of the `source` body.
         *
         * @private
         * @param {string} source The source to modify.
         * @returns {Array} details The details to insert.
         * @returns {string} Returns the modified source.
         */
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
          details = details.join(length > 2 ? ', ' : ' ');
          return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
        }

        /**
         * Checks if `value` is a flattenable `arguments` object or array.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
         */
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) ||
            !!(spreadableSymbol && value && value[spreadableSymbol]);
        }

        /**
         * Checks if `value` is a valid array-like index.
         *
         * @private
         * @param {*} value The value to check.
         * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
         * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
         */
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;

          return !!length &&
            (type == 'number' ||
              (type != 'symbol' && reIsUint.test(value))) &&
                (value > -1 && value % 1 == 0 && value < length);
        }

        /**
         * Checks if the given arguments are from an iteratee call.
         *
         * @private
         * @param {*} value The potential iteratee value argument.
         * @param {*} index The potential iteratee index or key argument.
         * @param {*} object The potential iteratee object argument.
         * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
         *  else `false`.
         */
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == 'number'
                ? (isArrayLike(object) && isIndex(index, object.length))
                : (type == 'string' && index in object)
              ) {
            return eq(object[index], value);
          }
          return false;
        }

        /**
         * Checks if `value` is a property name and not a property path.
         *
         * @private
         * @param {*} value The value to check.
         * @param {Object} [object] The object to query keys on.
         * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
         */
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == 'number' || type == 'symbol' || type == 'boolean' ||
              value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
            (object != null && value in Object(object));
        }

        /**
         * Checks if `value` is suitable for use as unique object key.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
         */
        function isKeyable(value) {
          var type = typeof value;
          return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
            ? (value !== '__proto__')
            : (value === null);
        }

        /**
         * Checks if `func` has a lazy counterpart.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
         *  else `false`.
         */
        function isLaziable(func) {
          var funcName = getFuncName(func),
              other = lodash[funcName];

          if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }

        /**
         * Checks if `func` has its source masked.
         *
         * @private
         * @param {Function} func The function to check.
         * @returns {boolean} Returns `true` if `func` is masked, else `false`.
         */
        function isMasked(func) {
          return !!maskSrcKey && (maskSrcKey in func);
        }

        /**
         * Checks if `func` is capable of being masked.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
         */
        var isMaskable = coreJsData ? isFunction : stubFalse;

        /**
         * Checks if `value` is likely a prototype object.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
         */
        function isPrototype(value) {
          var Ctor = value && value.constructor,
              proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

          return value === proto;
        }

        /**
         * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` if suitable for strict
         *  equality comparisons, else `false`.
         */
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }

        /**
         * A specialized version of `matchesProperty` for source values suitable
         * for strict equality comparisons, i.e. `===`.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         */
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue &&
              (srcValue !== undefined$1 || (key in Object(object)));
          };
        }

        /**
         * A specialized version of `_.memoize` which clears the memoized function's
         * cache when it exceeds `MAX_MEMOIZE_SIZE`.
         *
         * @private
         * @param {Function} func The function to have its output memoized.
         * @returns {Function} Returns the new memoized function.
         */
        function memoizeCapped(func) {
          var result = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });

          var cache = result.cache;
          return result;
        }

        /**
         * Merges the function metadata of `source` into `data`.
         *
         * Merging metadata reduces the number of wrappers used to invoke a function.
         * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
         * may be applied regardless of execution order. Methods like `_.ary` and
         * `_.rearg` modify function arguments, making the order in which they are
         * executed important, preventing the merging of metadata. However, we make
         * an exception for a safe combined case where curried functions have `_.ary`
         * and or `_.rearg` applied.
         *
         * @private
         * @param {Array} data The destination metadata.
         * @param {Array} source The source metadata.
         * @returns {Array} Returns `data`.
         */
        function mergeData(data, source) {
          var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

          var isCombo =
            ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
            ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
            ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

          // Exit early if metadata can't be merged.
          if (!(isCommon || isCombo)) {
            return data;
          }
          // Use source `thisArg` if available.
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            // Set when currying a bound function.
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          // Compose partial arguments.
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          // Compose partial right arguments.
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          // Use source `argPos` if available.
          value = source[7];
          if (value) {
            data[7] = value;
          }
          // Use source `ary` if it's smaller.
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          // Use source `arity` if one is not provided.
          if (data[9] == null) {
            data[9] = source[9];
          }
          // Use source `func` and merge bitmasks.
          data[0] = source[0];
          data[1] = newBitmask;

          return data;
        }

        /**
         * This function is like
         * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * except that it includes inherited enumerable properties.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         */
        function nativeKeysIn(object) {
          var result = [];
          if (object != null) {
            for (var key in Object(object)) {
              result.push(key);
            }
          }
          return result;
        }

        /**
         * Converts `value` to a string using `Object.prototype.toString`.
         *
         * @private
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         */
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }

        /**
         * A specialized version of `baseRest` which transforms the rest array.
         *
         * @private
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @param {Function} transform The rest array transform.
         * @returns {Function} Returns the new function.
         */
        function overRest(func, start, transform) {
          start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
          return function() {
            var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length);

            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform(array);
            return apply(func, this, otherArgs);
          };
        }

        /**
         * Gets the parent value at `path` of `object`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} path The path to get the parent value of.
         * @returns {*} Returns the parent value.
         */
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }

        /**
         * Reorder `array` according to the specified indexes where the element at
         * the first index is assigned as the first element, the element at
         * the second index is assigned as the second element, and so on.
         *
         * @private
         * @param {Array} array The array to reorder.
         * @param {Array} indexes The arranged array indexes.
         * @returns {Array} Returns `array`.
         */
        function reorder(array, indexes) {
          var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = copyArray(array);

          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
          }
          return array;
        }

        /**
         * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
         *
         * @private
         * @param {Object} object The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function safeGet(object, key) {
          if (key === 'constructor' && typeof object[key] === 'function') {
            return;
          }

          if (key == '__proto__') {
            return;
          }

          return object[key];
        }

        /**
         * Sets metadata for `func`.
         *
         * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
         * period of time, it will trip its breaker and transition to an identity
         * function to avoid garbage collection pauses in V8. See
         * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
         * for more details.
         *
         * @private
         * @param {Function} func The function to associate metadata with.
         * @param {*} data The metadata.
         * @returns {Function} Returns `func`.
         */
        var setData = shortOut(baseSetData);

        /**
         * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
         *
         * @private
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @returns {number|Object} Returns the timer id or timeout object.
         */
        var setTimeout = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };

        /**
         * Sets the `toString` method of `func` to return `string`.
         *
         * @private
         * @param {Function} func The function to modify.
         * @param {Function} string The `toString` result.
         * @returns {Function} Returns `func`.
         */
        var setToString = shortOut(baseSetToString);

        /**
         * Sets the `toString` method of `wrapper` to mimic the source of `reference`
         * with wrapper details in a comment at the top of the source body.
         *
         * @private
         * @param {Function} wrapper The function to modify.
         * @param {Function} reference The reference function.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @returns {Function} Returns `wrapper`.
         */
        function setWrapToString(wrapper, reference, bitmask) {
          var source = (reference + '');
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }

        /**
         * Creates a function that'll short out and invoke `identity` instead
         * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
         * milliseconds.
         *
         * @private
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new shortable function.
         */
        function shortOut(func) {
          var count = 0,
              lastCalled = 0;

          return function() {
            var stamp = nativeNow(),
                remaining = HOT_SPAN - (stamp - lastCalled);

            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }

        /**
         * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
         *
         * @private
         * @param {Array} array The array to shuffle.
         * @param {number} [size=array.length] The size of `array`.
         * @returns {Array} Returns `array`.
         */
        function shuffleSelf(array, size) {
          var index = -1,
              length = array.length,
              lastIndex = length - 1;

          size = size === undefined$1 ? length : size;
          while (++index < size) {
            var rand = baseRandom(index, lastIndex),
                value = array[rand];

            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size;
          return array;
        }

        /**
         * Converts `string` to a property path array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the property path array.
         */
        var stringToPath = memoizeCapped(function(string) {
          var result = [];
          if (string.charCodeAt(0) === 46 /* . */) {
            result.push('');
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
          });
          return result;
        });

        /**
         * Converts `value` to a string key if it's not a string or symbol.
         *
         * @private
         * @param {*} value The value to inspect.
         * @returns {string|symbol} Returns the key.
         */
        function toKey(value) {
          if (typeof value == 'string' || isSymbol(value)) {
            return value;
          }
          var result = (value + '');
          return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
        }

        /**
         * Converts `func` to its source code.
         *
         * @private
         * @param {Function} func The function to convert.
         * @returns {string} Returns the source code.
         */
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {}
            try {
              return (func + '');
            } catch (e) {}
          }
          return '';
        }

        /**
         * Updates wrapper `details` based on `bitmask` flags.
         *
         * @private
         * @returns {Array} details The details to modify.
         * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
         * @returns {Array} Returns `details`.
         */
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = '_.' + pair[0];
            if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }

        /**
         * Creates a clone of `wrapper`.
         *
         * @private
         * @param {Object} wrapper The wrapper to clone.
         * @returns {Object} Returns the cloned wrapper.
         */
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result.__actions__ = copyArray(wrapper.__actions__);
          result.__index__  = wrapper.__index__;
          result.__values__ = wrapper.__values__;
          return result;
        }

        /*------------------------------------------------------------------------*/

        /**
         * Creates an array of elements split into groups the length of `size`.
         * If `array` can't be split evenly, the final chunk will be the remaining
         * elements.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to process.
         * @param {number} [size=1] The length of each chunk
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the new array of chunks.
         * @example
         *
         * _.chunk(['a', 'b', 'c', 'd'], 2);
         * // => [['a', 'b'], ['c', 'd']]
         *
         * _.chunk(['a', 'b', 'c', 'd'], 3);
         * // => [['a', 'b', 'c'], ['d']]
         */
        function chunk(array, size, guard) {
          if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
            size = 1;
          } else {
            size = nativeMax(toInteger(size), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size < 1) {
            return [];
          }
          var index = 0,
              resIndex = 0,
              result = Array(nativeCeil(length / size));

          while (index < length) {
            result[resIndex++] = baseSlice(array, index, (index += size));
          }
          return result;
        }

        /**
         * Creates an array with all falsey values removed. The values `false`, `null`,
         * `0`, `""`, `undefined`, and `NaN` are falsey.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to compact.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.compact([0, 1, false, 2, '', 3]);
         * // => [1, 2, 3]
         */
        function compact(array) {
          var index = -1,
              length = array == null ? 0 : array.length,
              resIndex = 0,
              result = [];

          while (++index < length) {
            var value = array[index];
            if (value) {
              result[resIndex++] = value;
            }
          }
          return result;
        }

        /**
         * Creates a new array concatenating `array` with any additional arrays
         * and/or values.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to concatenate.
         * @param {...*} [values] The values to concatenate.
         * @returns {Array} Returns the new concatenated array.
         * @example
         *
         * var array = [1];
         * var other = _.concat(array, 2, [3], [[4]]);
         *
         * console.log(other);
         * // => [1, 2, 3, [4]]
         *
         * console.log(array);
         * // => [1]
         */
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array(length - 1),
              array = arguments[0],
              index = length;

          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }

        /**
         * Creates an array of `array` values not included in the other given arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. The order and references of result values are
         * determined by the first array.
         *
         * **Note:** Unlike `_.pullAll`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.without, _.xor
         * @example
         *
         * _.difference([2, 1], [2, 3]);
         * // => [1]
         */
        var difference = baseRest(function(array, values) {
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
            : [];
        });

        /**
         * This method is like `_.difference` except that it accepts `iteratee` which
         * is invoked for each element of `array` and `values` to generate the criterion
         * by which they're compared. The order and references of result values are
         * determined by the first array. The iteratee is invoked with one argument:
         * (value).
         *
         * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        var differenceBy = baseRest(function(array, values) {
          var iteratee = last(values);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined$1;
          }
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
            : [];
        });

        /**
         * This method is like `_.difference` except that it accepts `comparator`
         * which is invoked to compare elements of `array` to `values`. The order and
         * references of result values are determined by the first array. The comparator
         * is invoked with two arguments: (arrVal, othVal).
         *
         * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...Array} [values] The values to exclude.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         *
         * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }]
         */
        var differenceWith = baseRest(function(array, values) {
          var comparator = last(values);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array)
            ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
            : [];
        });

        /**
         * Creates a slice of `array` with `n` elements dropped from the beginning.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.drop([1, 2, 3]);
         * // => [2, 3]
         *
         * _.drop([1, 2, 3], 2);
         * // => [3]
         *
         * _.drop([1, 2, 3], 5);
         * // => []
         *
         * _.drop([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }

        /**
         * Creates a slice of `array` with `n` elements dropped from the end.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to drop.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.dropRight([1, 2, 3]);
         * // => [1, 2]
         *
         * _.dropRight([1, 2, 3], 2);
         * // => [1]
         *
         * _.dropRight([1, 2, 3], 5);
         * // => []
         *
         * _.dropRight([1, 2, 3], 0);
         * // => [1, 2, 3]
         */
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }

        /**
         * Creates a slice of `array` excluding elements dropped from the end.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.dropRightWhile(users, function(o) { return !o.active; });
         * // => objects for ['barney']
         *
         * // The `_.matches` iteratee shorthand.
         * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
         * // => objects for ['barney', 'fred']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.dropRightWhile(users, ['active', false]);
         * // => objects for ['barney']
         *
         * // The `_.property` iteratee shorthand.
         * _.dropRightWhile(users, 'active');
         * // => objects for ['barney', 'fred', 'pebbles']
         */
        function dropRightWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), true, true)
            : [];
        }

        /**
         * Creates a slice of `array` excluding elements dropped from the beginning.
         * Elements are dropped until `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.dropWhile(users, function(o) { return !o.active; });
         * // => objects for ['pebbles']
         *
         * // The `_.matches` iteratee shorthand.
         * _.dropWhile(users, { 'user': 'barney', 'active': false });
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.dropWhile(users, ['active', false]);
         * // => objects for ['pebbles']
         *
         * // The `_.property` iteratee shorthand.
         * _.dropWhile(users, 'active');
         * // => objects for ['barney', 'fred', 'pebbles']
         */
        function dropWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), true)
            : [];
        }

        /**
         * Fills elements of `array` with `value` from `start` up to, but not
         * including, `end`.
         *
         * **Note:** This method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Array
         * @param {Array} array The array to fill.
         * @param {*} value The value to fill `array` with.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.fill(array, 'a');
         * console.log(array);
         * // => ['a', 'a', 'a']
         *
         * _.fill(Array(3), 2);
         * // => [2, 2, 2]
         *
         * _.fill([4, 6, 8, 10], '*', 1, 3);
         * // => [4, '*', '*', 10]
         */
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }

        /**
         * This method is like `_.find` except that it returns the index of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.findIndex(users, function(o) { return o.user == 'barney'; });
         * // => 0
         *
         * // The `_.matches` iteratee shorthand.
         * _.findIndex(users, { 'user': 'fred', 'active': false });
         * // => 1
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findIndex(users, ['active', false]);
         * // => 0
         *
         * // The `_.property` iteratee shorthand.
         * _.findIndex(users, 'active');
         * // => 2
         */
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }

        /**
         * This method is like `_.findIndex` except that it iterates over elements
         * of `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=array.length-1] The index to search from.
         * @returns {number} Returns the index of the found element, else `-1`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
         * // => 2
         *
         * // The `_.matches` iteratee shorthand.
         * _.findLastIndex(users, { 'user': 'barney', 'active': true });
         * // => 0
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findLastIndex(users, ['active', false]);
         * // => 2
         *
         * // The `_.property` iteratee shorthand.
         * _.findLastIndex(users, 'active');
         * // => 0
         */
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = fromIndex < 0
              ? nativeMax(length + index, 0)
              : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }

        /**
         * Flattens `array` a single level deep.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flatten([1, [2, [3, [4]], 5]]);
         * // => [1, 2, [3, [4]], 5]
         */
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }

        /**
         * Recursively flattens `array`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * _.flattenDeep([1, [2, [3, [4]], 5]]);
         * // => [1, 2, 3, 4, 5]
         */
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }

        /**
         * Recursively flatten `array` up to `depth` times.
         *
         * @static
         * @memberOf _
         * @since 4.4.0
         * @category Array
         * @param {Array} array The array to flatten.
         * @param {number} [depth=1] The maximum recursion depth.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * var array = [1, [2, [3, [4]], 5]];
         *
         * _.flattenDepth(array, 1);
         * // => [1, 2, [3, [4]], 5]
         *
         * _.flattenDepth(array, 2);
         * // => [1, 2, 3, [4], 5]
         */
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }

        /**
         * The inverse of `_.toPairs`; this method returns an object composed
         * from key-value `pairs`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} pairs The key-value pairs.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.fromPairs([['a', 1], ['b', 2]]);
         * // => { 'a': 1, 'b': 2 }
         */
        function fromPairs(pairs) {
          var index = -1,
              length = pairs == null ? 0 : pairs.length,
              result = {};

          while (++index < length) {
            var pair = pairs[index];
            result[pair[0]] = pair[1];
          }
          return result;
        }

        /**
         * Gets the first element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @alias first
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the first element of `array`.
         * @example
         *
         * _.head([1, 2, 3]);
         * // => 1
         *
         * _.head([]);
         * // => undefined
         */
        function head(array) {
          return (array && array.length) ? array[0] : undefined$1;
        }

        /**
         * Gets the index at which the first occurrence of `value` is found in `array`
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. If `fromIndex` is negative, it's used as the
         * offset from the end of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.indexOf([1, 2, 1, 2], 2);
         * // => 1
         *
         * // Search from the `fromIndex`.
         * _.indexOf([1, 2, 1, 2], 2, 2);
         * // => 3
         */
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }

        /**
         * Gets all but the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.initial([1, 2, 3]);
         * // => [1, 2]
         */
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }

        /**
         * Creates an array of unique values that are included in all given arrays
         * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons. The order and references of result values are
         * determined by the first array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * _.intersection([2, 1], [2, 3]);
         * // => [2]
         */
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped)
            : [];
        });

        /**
         * This method is like `_.intersection` except that it accepts `iteratee`
         * which is invoked for each element of each `arrays` to generate the criterion
         * by which they're compared. The order and references of result values are
         * determined by the first array. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [2.1]
         *
         * // The `_.property` iteratee shorthand.
         * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }]
         */
        var intersectionBy = baseRest(function(arrays) {
          var iteratee = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject);

          if (iteratee === last(mapped)) {
            iteratee = undefined$1;
          } else {
            mapped.pop();
          }
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped, getIteratee(iteratee, 2))
            : [];
        });

        /**
         * This method is like `_.intersection` except that it accepts `comparator`
         * which is invoked to compare elements of `arrays`. The order and references
         * of result values are determined by the first array. The comparator is
         * invoked with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of intersecting values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.intersectionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }]
         */
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject);

          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return (mapped.length && mapped[0] === arrays[0])
            ? baseIntersection(mapped, undefined$1, comparator)
            : [];
        });

        /**
         * Converts all elements in `array` into a string separated by `separator`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to convert.
         * @param {string} [separator=','] The element separator.
         * @returns {string} Returns the joined string.
         * @example
         *
         * _.join(['a', 'b', 'c'], '~');
         * // => 'a~b~c'
         */
        function join(array, separator) {
          return array == null ? '' : nativeJoin.call(array, separator);
        }

        /**
         * Gets the last element of `array`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {*} Returns the last element of `array`.
         * @example
         *
         * _.last([1, 2, 3]);
         * // => 3
         */
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined$1;
        }

        /**
         * This method is like `_.indexOf` except that it iterates over elements of
         * `array` from right to left.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=array.length-1] The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.lastIndexOf([1, 2, 1, 2], 2);
         * // => 3
         *
         * // Search from the `fromIndex`.
         * _.lastIndexOf([1, 2, 1, 2], 2, 2);
         * // => 1
         */
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined$1) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value
            ? strictLastIndexOf(array, value, index)
            : baseFindIndex(array, baseIsNaN, index, true);
        }

        /**
         * Gets the element at index `n` of `array`. If `n` is negative, the nth
         * element from the end is returned.
         *
         * @static
         * @memberOf _
         * @since 4.11.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=0] The index of the element to return.
         * @returns {*} Returns the nth element of `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'd'];
         *
         * _.nth(array, 1);
         * // => 'b'
         *
         * _.nth(array, -2);
         * // => 'c';
         */
        function nth(array, n) {
          return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
        }

        /**
         * Removes all given values from `array` using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
         * to remove elements from an array by predicate.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...*} [values] The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
         *
         * _.pull(array, 'a', 'c');
         * console.log(array);
         * // => ['b', 'b']
         */
        var pull = baseRest(pullAll);

        /**
         * This method is like `_.pull` except that it accepts an array of values to remove.
         *
         * **Note:** Unlike `_.difference`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
         *
         * _.pullAll(array, ['a', 'c']);
         * console.log(array);
         * // => ['b', 'b']
         */
        function pullAll(array, values) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values)
            : array;
        }

        /**
         * This method is like `_.pullAll` except that it accepts `iteratee` which is
         * invoked for each element of `array` and `values` to generate the criterion
         * by which they're compared. The iteratee is invoked with one argument: (value).
         *
         * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
         *
         * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
         * console.log(array);
         * // => [{ 'x': 2 }]
         */
        function pullAllBy(array, values, iteratee) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values, getIteratee(iteratee, 2))
            : array;
        }

        /**
         * This method is like `_.pullAll` except that it accepts `comparator` which
         * is invoked to compare elements of `array` to `values`. The comparator is
         * invoked with two arguments: (arrVal, othVal).
         *
         * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Array} values The values to remove.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
         *
         * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
         * console.log(array);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
         */
        function pullAllWith(array, values, comparator) {
          return (array && array.length && values && values.length)
            ? basePullAll(array, values, undefined$1, comparator)
            : array;
        }

        /**
         * Removes elements from `array` corresponding to `indexes` and returns an
         * array of removed elements.
         *
         * **Note:** Unlike `_.at`, this method mutates `array`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {...(number|number[])} [indexes] The indexes of elements to remove.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = ['a', 'b', 'c', 'd'];
         * var pulled = _.pullAt(array, [1, 3]);
         *
         * console.log(array);
         * // => ['a', 'c']
         *
         * console.log(pulled);
         * // => ['b', 'd']
         */
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length,
              result = baseAt(array, indexes);

          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));

          return result;
        });

        /**
         * Removes all elements from `array` that `predicate` returns truthy for
         * and returns an array of the removed elements. The predicate is invoked
         * with three arguments: (value, index, array).
         *
         * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
         * to pull elements from an array by value.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new array of removed elements.
         * @example
         *
         * var array = [1, 2, 3, 4];
         * var evens = _.remove(array, function(n) {
         *   return n % 2 == 0;
         * });
         *
         * console.log(array);
         * // => [1, 3]
         *
         * console.log(evens);
         * // => [2, 4]
         */
        function remove(array, predicate) {
          var result = [];
          if (!(array && array.length)) {
            return result;
          }
          var index = -1,
              indexes = [],
              length = array.length;

          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result;
        }

        /**
         * Reverses `array` so that the first element becomes the last, the second
         * element becomes the second to last, and so on.
         *
         * **Note:** This method mutates `array` and is based on
         * [`Array#reverse`](https://mdn.io/Array/reverse).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to modify.
         * @returns {Array} Returns `array`.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _.reverse(array);
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }

        /**
         * Creates a slice of `array` from `start` up to, but not including, `end`.
         *
         * **Note:** This method is used instead of
         * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
         * returned.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to slice.
         * @param {number} [start=0] The start position.
         * @param {number} [end=array.length] The end position.
         * @returns {Array} Returns the slice of `array`.
         */
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          }
          else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$1 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }

        /**
         * Uses a binary search to determine the lowest index at which `value`
         * should be inserted into `array` in order to maintain its sort order.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedIndex([30, 50], 40);
         * // => 1
         */
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }

        /**
         * This method is like `_.sortedIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * var objects = [{ 'x': 4 }, { 'x': 5 }];
         *
         * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
         * // => 0
         *
         * // The `_.property` iteratee shorthand.
         * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
         * // => 0
         */
        function sortedIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
        }

        /**
         * This method is like `_.indexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
         * // => 1
         */
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * This method is like `_.sortedIndex` except that it returns the highest
         * index at which `value` should be inserted into `array` in order to
         * maintain its sort order.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
         * // => 4
         */
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }

        /**
         * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
         * which is invoked for `value` and each element of `array` to compute their
         * sort ranking. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The sorted array to inspect.
         * @param {*} value The value to evaluate.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the index at which `value` should be inserted
         *  into `array`.
         * @example
         *
         * var objects = [{ 'x': 4 }, { 'x': 5 }];
         *
         * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
         * // => 1
         *
         * // The `_.property` iteratee shorthand.
         * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
         * // => 1
         */
        function sortedLastIndexBy(array, value, iteratee) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
        }

        /**
         * This method is like `_.lastIndexOf` except that it performs a binary
         * search on a sorted `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns the index of the matched value, else `-1`.
         * @example
         *
         * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
         * // => 3
         */
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * This method is like `_.uniq` except that it's designed and optimized
         * for sorted arrays.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniq([1, 1, 2]);
         * // => [1, 2]
         */
        function sortedUniq(array) {
          return (array && array.length)
            ? baseSortedUniq(array)
            : [];
        }

        /**
         * This method is like `_.uniqBy` except that it's designed and optimized
         * for sorted arrays.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
         * // => [1.1, 2.3]
         */
        function sortedUniqBy(array, iteratee) {
          return (array && array.length)
            ? baseSortedUniq(array, getIteratee(iteratee, 2))
            : [];
        }

        /**
         * Gets all but the first element of `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.tail([1, 2, 3]);
         * // => [2, 3]
         */
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }

        /**
         * Creates a slice of `array` with `n` elements taken from the beginning.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.take([1, 2, 3]);
         * // => [1]
         *
         * _.take([1, 2, 3], 2);
         * // => [1, 2]
         *
         * _.take([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.take([1, 2, 3], 0);
         * // => []
         */
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }

        /**
         * Creates a slice of `array` with `n` elements taken from the end.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {number} [n=1] The number of elements to take.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * _.takeRight([1, 2, 3]);
         * // => [3]
         *
         * _.takeRight([1, 2, 3], 2);
         * // => [2, 3]
         *
         * _.takeRight([1, 2, 3], 5);
         * // => [1, 2, 3]
         *
         * _.takeRight([1, 2, 3], 0);
         * // => []
         */
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = (guard || n === undefined$1) ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }

        /**
         * Creates a slice of `array` with elements taken from the end. Elements are
         * taken until `predicate` returns falsey. The predicate is invoked with
         * three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': true },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': false }
         * ];
         *
         * _.takeRightWhile(users, function(o) { return !o.active; });
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.matches` iteratee shorthand.
         * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
         * // => objects for ['pebbles']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.takeRightWhile(users, ['active', false]);
         * // => objects for ['fred', 'pebbles']
         *
         * // The `_.property` iteratee shorthand.
         * _.takeRightWhile(users, 'active');
         * // => []
         */
        function takeRightWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3), false, true)
            : [];
        }

        /**
         * Creates a slice of `array` with elements taken from the beginning. Elements
         * are taken until `predicate` returns falsey. The predicate is invoked with
         * three arguments: (value, index, array).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Array
         * @param {Array} array The array to query.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the slice of `array`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'active': false },
         *   { 'user': 'fred',    'active': false },
         *   { 'user': 'pebbles', 'active': true }
         * ];
         *
         * _.takeWhile(users, function(o) { return !o.active; });
         * // => objects for ['barney', 'fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.takeWhile(users, { 'user': 'barney', 'active': false });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.takeWhile(users, ['active', false]);
         * // => objects for ['barney', 'fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.takeWhile(users, 'active');
         * // => []
         */
        function takeWhile(array, predicate) {
          return (array && array.length)
            ? baseWhile(array, getIteratee(predicate, 3))
            : [];
        }

        /**
         * Creates an array of unique values, in order, from all given arrays using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.union([2], [1, 2]);
         * // => [2, 1]
         */
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });

        /**
         * This method is like `_.union` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by
         * which uniqueness is computed. Result values are chosen from the first
         * array in which the value occurs. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * _.unionBy([2.1], [1.2, 2.3], Math.floor);
         * // => [2.1, 1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        var unionBy = baseRest(function(arrays) {
          var iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined$1;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
        });

        /**
         * This method is like `_.union` except that it accepts `comparator` which
         * is invoked to compare elements of `arrays`. Result values are chosen from
         * the first array in which the value occurs. The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of combined values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.unionWith(objects, others, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
        });

        /**
         * Creates a duplicate-free version of an array, using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons, in which only the first occurrence of each element
         * is kept. The order of result values is determined by the order they occur
         * in the array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.uniq([2, 1, 2]);
         * // => [2, 1]
         */
        function uniq(array) {
          return (array && array.length) ? baseUniq(array) : [];
        }

        /**
         * This method is like `_.uniq` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * uniqueness is computed. The order of result values is determined by the
         * order they occur in the array. The iteratee is invoked with one argument:
         * (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
         * // => [2.1, 1.2]
         *
         * // The `_.property` iteratee shorthand.
         * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 1 }, { 'x': 2 }]
         */
        function uniqBy(array, iteratee) {
          return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
        }

        /**
         * This method is like `_.uniq` except that it accepts `comparator` which
         * is invoked to compare elements of `array`. The order of result values is
         * determined by the order they occur in the array.The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new duplicate free array.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.uniqWith(objects, _.isEqual);
         * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
         */
        function uniqWith(array, comparator) {
          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
        }

        /**
         * This method is like `_.zip` except that it accepts an array of grouped
         * elements and creates an array regrouping the elements to their pre-zip
         * configuration.
         *
         * @static
         * @memberOf _
         * @since 1.2.0
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
         * // => [['a', 1, true], ['b', 2, false]]
         *
         * _.unzip(zipped);
         * // => [['a', 'b'], [1, 2], [true, false]]
         */
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }

        /**
         * This method is like `_.unzip` except that it accepts `iteratee` to specify
         * how regrouped values should be combined. The iteratee is invoked with the
         * elements of each group: (...group).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Array
         * @param {Array} array The array of grouped elements to process.
         * @param {Function} [iteratee=_.identity] The function to combine
         *  regrouped values.
         * @returns {Array} Returns the new array of regrouped elements.
         * @example
         *
         * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
         * // => [[1, 10, 100], [2, 20, 200]]
         *
         * _.unzipWith(zipped, _.add);
         * // => [3, 30, 300]
         */
        function unzipWith(array, iteratee) {
          if (!(array && array.length)) {
            return [];
          }
          var result = unzip(array);
          if (iteratee == null) {
            return result;
          }
          return arrayMap(result, function(group) {
            return apply(iteratee, undefined$1, group);
          });
        }

        /**
         * Creates an array excluding all given values using
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * for equality comparisons.
         *
         * **Note:** Unlike `_.pull`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {Array} array The array to inspect.
         * @param {...*} [values] The values to exclude.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.difference, _.xor
         * @example
         *
         * _.without([2, 1, 2, 3], 1, 2);
         * // => [3]
         */
        var without = baseRest(function(array, values) {
          return isArrayLikeObject(array)
            ? baseDifference(array, values)
            : [];
        });

        /**
         * Creates an array of unique values that is the
         * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
         * of the given arrays. The order of result values is determined by the order
         * they occur in the arrays.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @returns {Array} Returns the new array of filtered values.
         * @see _.difference, _.without
         * @example
         *
         * _.xor([2, 1], [2, 3]);
         * // => [1, 3]
         */
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });

        /**
         * This method is like `_.xor` except that it accepts `iteratee` which is
         * invoked for each element of each `arrays` to generate the criterion by
         * which by which they're compared. The order of result values is determined
         * by the order they occur in the arrays. The iteratee is invoked with one
         * argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
         * // => [1.2, 3.4]
         *
         * // The `_.property` iteratee shorthand.
         * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
         * // => [{ 'x': 2 }]
         */
        var xorBy = baseRest(function(arrays) {
          var iteratee = last(arrays);
          if (isArrayLikeObject(iteratee)) {
            iteratee = undefined$1;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
        });

        /**
         * This method is like `_.xor` except that it accepts `comparator` which is
         * invoked to compare elements of `arrays`. The order of result values is
         * determined by the order they occur in the arrays. The comparator is invoked
         * with two arguments: (arrVal, othVal).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Array
         * @param {...Array} [arrays] The arrays to inspect.
         * @param {Function} [comparator] The comparator invoked per element.
         * @returns {Array} Returns the new array of filtered values.
         * @example
         *
         * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
         * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
         *
         * _.xorWith(objects, others, _.isEqual);
         * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
         */
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == 'function' ? comparator : undefined$1;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        });

        /**
         * Creates an array of grouped elements, the first of which contains the
         * first elements of the given arrays, the second of which contains the
         * second elements of the given arrays, and so on.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zip(['a', 'b'], [1, 2], [true, false]);
         * // => [['a', 1, true], ['b', 2, false]]
         */
        var zip = baseRest(unzip);

        /**
         * This method is like `_.fromPairs` except that it accepts two arrays,
         * one of property identifiers and one of corresponding values.
         *
         * @static
         * @memberOf _
         * @since 0.4.0
         * @category Array
         * @param {Array} [props=[]] The property identifiers.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObject(['a', 'b'], [1, 2]);
         * // => { 'a': 1, 'b': 2 }
         */
        function zipObject(props, values) {
          return baseZipObject(props || [], values || [], assignValue);
        }

        /**
         * This method is like `_.zipObject` except that it supports property paths.
         *
         * @static
         * @memberOf _
         * @since 4.1.0
         * @category Array
         * @param {Array} [props=[]] The property identifiers.
         * @param {Array} [values=[]] The property values.
         * @returns {Object} Returns the new object.
         * @example
         *
         * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
         * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
         */
        function zipObjectDeep(props, values) {
          return baseZipObject(props || [], values || [], baseSet);
        }

        /**
         * This method is like `_.zip` except that it accepts `iteratee` to specify
         * how grouped values should be combined. The iteratee is invoked with the
         * elements of each group: (...group).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Array
         * @param {...Array} [arrays] The arrays to process.
         * @param {Function} [iteratee=_.identity] The function to combine
         *  grouped values.
         * @returns {Array} Returns the new array of grouped elements.
         * @example
         *
         * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
         *   return a + b + c;
         * });
         * // => [111, 222]
         */
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length,
              iteratee = length > 1 ? arrays[length - 1] : undefined$1;

          iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
          return unzipWith(arrays, iteratee);
        });

        /*------------------------------------------------------------------------*/

        /**
         * Creates a `lodash` wrapper instance that wraps `value` with explicit method
         * chain sequences enabled. The result of such sequences must be unwrapped
         * with `_#value`.
         *
         * @static
         * @memberOf _
         * @since 1.3.0
         * @category Seq
         * @param {*} value The value to wrap.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36 },
         *   { 'user': 'fred',    'age': 40 },
         *   { 'user': 'pebbles', 'age': 1 }
         * ];
         *
         * var youngest = _
         *   .chain(users)
         *   .sortBy('age')
         *   .map(function(o) {
         *     return o.user + ' is ' + o.age;
         *   })
         *   .head()
         *   .value();
         * // => 'pebbles is 1'
         */
        function chain(value) {
          var result = lodash(value);
          result.__chain__ = true;
          return result;
        }

        /**
         * This method invokes `interceptor` and returns `value`. The interceptor
         * is invoked with one argument; (value). The purpose of this method is to
         * "tap into" a method chain sequence in order to modify intermediate results.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns `value`.
         * @example
         *
         * _([1, 2, 3])
         *  .tap(function(array) {
         *    // Mutate input array.
         *    array.pop();
         *  })
         *  .reverse()
         *  .value();
         * // => [2, 1]
         */
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }

        /**
         * This method is like `_.tap` except that it returns the result of `interceptor`.
         * The purpose of this method is to "pass thru" values replacing intermediate
         * results in a method chain sequence.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Seq
         * @param {*} value The value to provide to `interceptor`.
         * @param {Function} interceptor The function to invoke.
         * @returns {*} Returns the result of `interceptor`.
         * @example
         *
         * _('  abc  ')
         *  .chain()
         *  .trim()
         *  .thru(function(value) {
         *    return [value];
         *  })
         *  .value();
         * // => ['abc']
         */
        function thru(value, interceptor) {
          return interceptor(value);
        }

        /**
         * This method is the wrapper version of `_.at`.
         *
         * @name at
         * @memberOf _
         * @since 1.0.0
         * @category Seq
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
         *
         * _(object).at(['a[0].b.c', 'a[1]']).value();
         * // => [3, 4]
         */
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length,
              start = length ? paths[0] : 0,
              value = this.__wrapped__,
              interceptor = function(object) { return baseAt(object, paths); };

          if (length > 1 || this.__actions__.length ||
              !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            'func': thru,
            'args': [interceptor],
            'thisArg': undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined$1);
            }
            return array;
          });
        });

        /**
         * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
         *
         * @name chain
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 40 }
         * ];
         *
         * // A sequence without explicit chaining.
         * _(users).head();
         * // => { 'user': 'barney', 'age': 36 }
         *
         * // A sequence with explicit chaining.
         * _(users)
         *   .chain()
         *   .head()
         *   .pick('user')
         *   .value();
         * // => { 'user': 'barney' }
         */
        function wrapperChain() {
          return chain(this);
        }

        /**
         * Executes the chain sequence and returns the wrapped result.
         *
         * @name commit
         * @memberOf _
         * @since 3.2.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2];
         * var wrapped = _(array).push(3);
         *
         * console.log(array);
         * // => [1, 2]
         *
         * wrapped = wrapped.commit();
         * console.log(array);
         * // => [1, 2, 3]
         *
         * wrapped.last();
         * // => 3
         *
         * console.log(array);
         * // => [1, 2, 3]
         */
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }

        /**
         * Gets the next value on a wrapped object following the
         * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
         *
         * @name next
         * @memberOf _
         * @since 4.0.0
         * @category Seq
         * @returns {Object} Returns the next iterator value.
         * @example
         *
         * var wrapped = _([1, 2]);
         *
         * wrapped.next();
         * // => { 'done': false, 'value': 1 }
         *
         * wrapped.next();
         * // => { 'done': false, 'value': 2 }
         *
         * wrapped.next();
         * // => { 'done': true, 'value': undefined }
         */
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length,
              value = done ? undefined$1 : this.__values__[this.__index__++];

          return { 'done': done, 'value': value };
        }

        /**
         * Enables the wrapper to be iterable.
         *
         * @name Symbol.iterator
         * @memberOf _
         * @since 4.0.0
         * @category Seq
         * @returns {Object} Returns the wrapper object.
         * @example
         *
         * var wrapped = _([1, 2]);
         *
         * wrapped[Symbol.iterator]() === wrapped;
         * // => true
         *
         * Array.from(wrapped);
         * // => [1, 2]
         */
        function wrapperToIterator() {
          return this;
        }

        /**
         * Creates a clone of the chain sequence planting `value` as the wrapped value.
         *
         * @name plant
         * @memberOf _
         * @since 3.2.0
         * @category Seq
         * @param {*} value The value to plant.
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var wrapped = _([1, 2]).map(square);
         * var other = wrapped.plant([3, 4]);
         *
         * other.value();
         * // => [9, 16]
         *
         * wrapped.value();
         * // => [1, 4]
         */
        function wrapperPlant(value) {
          var result,
              parent = this;

          while (parent instanceof baseLodash) {
            var clone = wrapperClone(parent);
            clone.__index__ = 0;
            clone.__values__ = undefined$1;
            if (result) {
              previous.__wrapped__ = clone;
            } else {
              result = clone;
            }
            var previous = clone;
            parent = parent.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result;
        }

        /**
         * This method is the wrapper version of `_.reverse`.
         *
         * **Note:** This method mutates the wrapped array.
         *
         * @name reverse
         * @memberOf _
         * @since 0.1.0
         * @category Seq
         * @returns {Object} Returns the new `lodash` wrapper instance.
         * @example
         *
         * var array = [1, 2, 3];
         *
         * _(array).reverse().value()
         * // => [3, 2, 1]
         *
         * console.log(array);
         * // => [3, 2, 1]
         */
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              'func': thru,
              'args': [reverse],
              'thisArg': undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }

        /**
         * Executes the chain sequence to resolve the unwrapped value.
         *
         * @name value
         * @memberOf _
         * @since 0.1.0
         * @alias toJSON, valueOf
         * @category Seq
         * @returns {*} Returns the resolved unwrapped value.
         * @example
         *
         * _([1, 2, 3]).value();
         * // => [1, 2, 3]
         */
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The corresponding value of
         * each key is the number of times the key was returned by `iteratee`. The
         * iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.countBy([6.1, 4.2, 6.3], Math.floor);
         * // => { '4': 1, '6': 2 }
         *
         * // The `_.property` iteratee shorthand.
         * _.countBy(['one', 'two', 'three'], 'length');
         * // => { '3': 2, '5': 1 }
         */
        var countBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            ++result[key];
          } else {
            baseAssignValue(result, key, 1);
          }
        });

        /**
         * Checks if `predicate` returns truthy for **all** elements of `collection`.
         * Iteration is stopped once `predicate` returns falsey. The predicate is
         * invoked with three arguments: (value, index|key, collection).
         *
         * **Note:** This method returns `true` for
         * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
         * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
         * elements of empty collections.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         * @example
         *
         * _.every([true, 1, null, 'yes'], Boolean);
         * // => false
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.every(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.every(users, ['active', false]);
         * // => true
         *
         * // The `_.property` iteratee shorthand.
         * _.every(users, 'active');
         * // => false
         */
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Iterates over elements of `collection`, returning an array of all elements
         * `predicate` returns truthy for. The predicate is invoked with three
         * arguments: (value, index|key, collection).
         *
         * **Note:** Unlike `_.remove`, this method returns a new array.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         * @see _.reject
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * _.filter(users, function(o) { return !o.active; });
         * // => objects for ['fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.filter(users, { 'age': 36, 'active': true });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.filter(users, ['active', false]);
         * // => objects for ['fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.filter(users, 'active');
         * // => objects for ['barney']
         *
         * // Combining several predicates using `_.overEvery` or `_.overSome`.
         * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
         * // => objects for ['fred', 'barney']
         */
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Iterates over elements of `collection`, returning the first element
         * `predicate` returns truthy for. The predicate is invoked with three
         * arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=0] The index to search from.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': true },
         *   { 'user': 'fred',    'age': 40, 'active': false },
         *   { 'user': 'pebbles', 'age': 1,  'active': true }
         * ];
         *
         * _.find(users, function(o) { return o.age < 40; });
         * // => object for 'barney'
         *
         * // The `_.matches` iteratee shorthand.
         * _.find(users, { 'age': 1, 'active': true });
         * // => object for 'pebbles'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.find(users, ['active', false]);
         * // => object for 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.find(users, 'active');
         * // => object for 'barney'
         */
        var find = createFind(findIndex);

        /**
         * This method is like `_.find` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param {number} [fromIndex=collection.length-1] The index to search from.
         * @returns {*} Returns the matched element, else `undefined`.
         * @example
         *
         * _.findLast([1, 2, 3, 4], function(n) {
         *   return n % 2 == 1;
         * });
         * // => 3
         */
        var findLast = createFind(findLastIndex);

        /**
         * Creates a flattened array of values by running each element in `collection`
         * thru `iteratee` and flattening the mapped results. The iteratee is invoked
         * with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [n, n];
         * }
         *
         * _.flatMap([1, 2], duplicate);
         * // => [1, 1, 2, 2]
         */
        function flatMap(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), 1);
        }

        /**
         * This method is like `_.flatMap` except that it recursively flattens the
         * mapped results.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [[[n, n]]];
         * }
         *
         * _.flatMapDeep([1, 2], duplicate);
         * // => [1, 1, 2, 2]
         */
        function flatMapDeep(collection, iteratee) {
          return baseFlatten(map(collection, iteratee), INFINITY);
        }

        /**
         * This method is like `_.flatMap` except that it recursively flattens the
         * mapped results up to `depth` times.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {number} [depth=1] The maximum recursion depth.
         * @returns {Array} Returns the new flattened array.
         * @example
         *
         * function duplicate(n) {
         *   return [[[n, n]]];
         * }
         *
         * _.flatMapDepth([1, 2], duplicate, 2);
         * // => [[1, 1], [2, 2]]
         */
        function flatMapDepth(collection, iteratee, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee), depth);
        }

        /**
         * Iterates over elements of `collection` and invokes `iteratee` for each element.
         * The iteratee is invoked with three arguments: (value, index|key, collection).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * **Note:** As with other "Collections" methods, objects with a "length"
         * property are iterated like arrays. To avoid this behavior use `_.forIn`
         * or `_.forOwn` for object iteration.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @alias each
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @see _.forEachRight
         * @example
         *
         * _.forEach([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => Logs `1` then `2`.
         *
         * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forEach(collection, iteratee) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.forEach` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @alias eachRight
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array|Object} Returns `collection`.
         * @see _.forEach
         * @example
         *
         * _.forEachRight([1, 2], function(value) {
         *   console.log(value);
         * });
         * // => Logs `2` then `1`.
         */
        function forEachRight(collection, iteratee) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The order of grouped values
         * is determined by the order they occur in `collection`. The corresponding
         * value of each key is an array of elements responsible for generating the
         * key. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * _.groupBy([6.1, 4.2, 6.3], Math.floor);
         * // => { '4': [4.2], '6': [6.1, 6.3] }
         *
         * // The `_.property` iteratee shorthand.
         * _.groupBy(['one', 'two', 'three'], 'length');
         * // => { '3': ['one', 'two'], '5': ['three'] }
         */
        var groupBy = createAggregator(function(result, value, key) {
          if (hasOwnProperty.call(result, key)) {
            result[key].push(value);
          } else {
            baseAssignValue(result, key, [value]);
          }
        });

        /**
         * Checks if `value` is in `collection`. If `collection` is a string, it's
         * checked for a substring of `value`, otherwise
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * is used for equality comparisons. If `fromIndex` is negative, it's used as
         * the offset from the end of `collection`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @param {*} value The value to search for.
         * @param {number} [fromIndex=0] The index to search from.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
         * @returns {boolean} Returns `true` if `value` is found, else `false`.
         * @example
         *
         * _.includes([1, 2, 3], 1);
         * // => true
         *
         * _.includes([1, 2, 3], 1, 2);
         * // => false
         *
         * _.includes({ 'a': 1, 'b': 2 }, 1);
         * // => true
         *
         * _.includes('abcd', 'bc');
         * // => true
         */
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection)
            ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
            : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
        }

        /**
         * Invokes the method at `path` of each element in `collection`, returning
         * an array of the results of each invoked method. Any additional arguments
         * are provided to each invoked method. If `path` is a function, it's invoked
         * for, and `this` bound to, each element in `collection`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Array|Function|string} path The path of the method to invoke or
         *  the function invoked per iteration.
         * @param {...*} [args] The arguments to invoke each method with.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
         * // => [[1, 5, 7], [1, 2, 3]]
         *
         * _.invokeMap([123, 456], String.prototype.split, '');
         * // => [['1', '2', '3'], ['4', '5', '6']]
         */
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1,
              isFunc = typeof path == 'function',
              result = isArrayLike(collection) ? Array(collection.length) : [];

          baseEach(collection, function(value) {
            result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result;
        });

        /**
         * Creates an object composed of keys generated from the results of running
         * each element of `collection` thru `iteratee`. The corresponding value of
         * each key is the last element responsible for generating the key. The
         * iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
         * @returns {Object} Returns the composed aggregate object.
         * @example
         *
         * var array = [
         *   { 'dir': 'left', 'code': 97 },
         *   { 'dir': 'right', 'code': 100 }
         * ];
         *
         * _.keyBy(array, function(o) {
         *   return String.fromCharCode(o.code);
         * });
         * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
         *
         * _.keyBy(array, 'dir');
         * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
         */
        var keyBy = createAggregator(function(result, value, key) {
          baseAssignValue(result, key, value);
        });

        /**
         * Creates an array of values by running each element in `collection` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
         *
         * The guarded methods are:
         * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
         * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
         * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
         * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * _.map([4, 8], square);
         * // => [16, 64]
         *
         * _.map({ 'a': 4, 'b': 8 }, square);
         * // => [16, 64] (iteration order is not guaranteed)
         *
         * var users = [
         *   { 'user': 'barney' },
         *   { 'user': 'fred' }
         * ];
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, 'user');
         * // => ['barney', 'fred']
         */
        function map(collection, iteratee) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.sortBy` except that it allows specifying the sort
         * orders of the iteratees to sort by. If `orders` is unspecified, all values
         * are sorted in ascending order. Otherwise, specify an order of "desc" for
         * descending or "asc" for ascending sort order of corresponding values.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
         *  The iteratees to sort by.
         * @param {string[]} [orders] The sort orders of `iteratees`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 34 },
         *   { 'user': 'fred',   'age': 40 },
         *   { 'user': 'barney', 'age': 36 }
         * ];
         *
         * // Sort by `user` in ascending order and by `age` in descending order.
         * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
         */
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }

        /**
         * Creates an array of elements split into two groups, the first of which
         * contains elements `predicate` returns truthy for, the second of which
         * contains elements `predicate` returns falsey for. The predicate is
         * invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the array of grouped elements.
         * @example
         *
         * var users = [
         *   { 'user': 'barney',  'age': 36, 'active': false },
         *   { 'user': 'fred',    'age': 40, 'active': true },
         *   { 'user': 'pebbles', 'age': 1,  'active': false }
         * ];
         *
         * _.partition(users, function(o) { return o.active; });
         * // => objects for [['fred'], ['barney', 'pebbles']]
         *
         * // The `_.matches` iteratee shorthand.
         * _.partition(users, { 'age': 1, 'active': false });
         * // => objects for [['pebbles'], ['barney', 'fred']]
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.partition(users, ['active', false]);
         * // => objects for [['barney', 'pebbles'], ['fred']]
         *
         * // The `_.property` iteratee shorthand.
         * _.partition(users, 'active');
         * // => objects for [['fred'], ['barney', 'pebbles']]
         */
        var partition = createAggregator(function(result, value, key) {
          result[key ? 0 : 1].push(value);
        }, function() { return [[], []]; });

        /**
         * Reduces `collection` to a value which is the accumulated result of running
         * each element in `collection` thru `iteratee`, where each successive
         * invocation is supplied the return value of the previous. If `accumulator`
         * is not given, the first element of `collection` is used as the initial
         * value. The iteratee is invoked with four arguments:
         * (accumulator, value, index|key, collection).
         *
         * Many lodash methods are guarded to work as iteratees for methods like
         * `_.reduce`, `_.reduceRight`, and `_.transform`.
         *
         * The guarded methods are:
         * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
         * and `sortBy`
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @returns {*} Returns the accumulated value.
         * @see _.reduceRight
         * @example
         *
         * _.reduce([1, 2], function(sum, n) {
         *   return sum + n;
         * }, 0);
         * // => 3
         *
         * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         *   return result;
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
         */
        function reduce(collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce,
              initAccum = arguments.length < 3;

          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
        }

        /**
         * This method is like `_.reduce` except that it iterates over elements of
         * `collection` from right to left.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @returns {*} Returns the accumulated value.
         * @see _.reduce
         * @example
         *
         * var array = [[0, 1], [2, 3], [4, 5]];
         *
         * _.reduceRight(array, function(flattened, other) {
         *   return flattened.concat(other);
         * }, []);
         * // => [4, 5, 2, 3, 0, 1]
         */
        function reduceRight(collection, iteratee, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce,
              initAccum = arguments.length < 3;

          return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
        }

        /**
         * The opposite of `_.filter`; this method returns the elements of `collection`
         * that `predicate` does **not** return truthy for.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         * @see _.filter
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': false },
         *   { 'user': 'fred',   'age': 40, 'active': true }
         * ];
         *
         * _.reject(users, function(o) { return !o.active; });
         * // => objects for ['fred']
         *
         * // The `_.matches` iteratee shorthand.
         * _.reject(users, { 'age': 40, 'active': true });
         * // => objects for ['barney']
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.reject(users, ['active', false]);
         * // => objects for ['fred']
         *
         * // The `_.property` iteratee shorthand.
         * _.reject(users, 'active');
         * // => objects for ['barney']
         */
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }

        /**
         * Gets a random element from `collection`.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to sample.
         * @returns {*} Returns the random element.
         * @example
         *
         * _.sample([1, 2, 3, 4]);
         * // => 2
         */
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }

        /**
         * Gets `n` random elements at unique keys from `collection` up to the
         * size of `collection`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Collection
         * @param {Array|Object} collection The collection to sample.
         * @param {number} [n=1] The number of elements to sample.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the random elements.
         * @example
         *
         * _.sampleSize([1, 2, 3], 2);
         * // => [3, 1]
         *
         * _.sampleSize([1, 2, 3], 4);
         * // => [2, 3, 1]
         */
        function sampleSize(collection, n, guard) {
          if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }

        /**
         * Creates an array of shuffled values, using a version of the
         * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to shuffle.
         * @returns {Array} Returns the new shuffled array.
         * @example
         *
         * _.shuffle([1, 2, 3, 4]);
         * // => [4, 1, 3, 2]
         */
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }

        /**
         * Gets the size of `collection` by returning its length for array-like
         * values or the number of own enumerable string keyed properties for objects.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object|string} collection The collection to inspect.
         * @returns {number} Returns the collection size.
         * @example
         *
         * _.size([1, 2, 3]);
         * // => 3
         *
         * _.size({ 'a': 1, 'b': 2 });
         * // => 2
         *
         * _.size('pebbles');
         * // => 7
         */
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }

        /**
         * Checks if `predicate` returns truthy for **any** element of `collection`.
         * Iteration is stopped once `predicate` returns truthy. The predicate is
         * invoked with three arguments: (value, index|key, collection).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         * @example
         *
         * _.some([null, 0, 'yes', false], Boolean);
         * // => true
         *
         * var users = [
         *   { 'user': 'barney', 'active': true },
         *   { 'user': 'fred',   'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.some(users, { 'user': 'barney', 'active': false });
         * // => false
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.some(users, ['active', false]);
         * // => true
         *
         * // The `_.property` iteratee shorthand.
         * _.some(users, 'active');
         * // => true
         */
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }

        /**
         * Creates an array of elements, sorted in ascending order by the results of
         * running each element in a collection thru each iteratee. This method
         * performs a stable sort, that is, it preserves the original sort order of
         * equal elements. The iteratees are invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Collection
         * @param {Array|Object} collection The collection to iterate over.
         * @param {...(Function|Function[])} [iteratees=[_.identity]]
         *  The iteratees to sort by.
         * @returns {Array} Returns the new sorted array.
         * @example
         *
         * var users = [
         *   { 'user': 'fred',   'age': 48 },
         *   { 'user': 'barney', 'age': 36 },
         *   { 'user': 'fred',   'age': 30 },
         *   { 'user': 'barney', 'age': 34 }
         * ];
         *
         * _.sortBy(users, [function(o) { return o.user; }]);
         * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
         *
         * _.sortBy(users, ['user', 'age']);
         * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
         */
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });

        /*------------------------------------------------------------------------*/

        /**
         * Gets the timestamp of the number of milliseconds that have elapsed since
         * the Unix epoch (1 January 1970 00:00:00 UTC).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Date
         * @returns {number} Returns the timestamp.
         * @example
         *
         * _.defer(function(stamp) {
         *   console.log(_.now() - stamp);
         * }, _.now());
         * // => Logs the number of milliseconds it took for the deferred invocation.
         */
        var now = ctxNow || function() {
          return root.Date.now();
        };

        /*------------------------------------------------------------------------*/

        /**
         * The opposite of `_.before`; this method creates a function that invokes
         * `func` once it's called `n` or more times.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {number} n The number of calls before `func` is invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var saves = ['profile', 'settings'];
         *
         * var done = _.after(saves.length, function() {
         *   console.log('done saving!');
         * });
         *
         * _.forEach(saves, function(type) {
         *   asyncSave({ 'type': type, 'complete': done });
         * });
         * // => Logs 'done saving!' after the two async saves have completed.
         */
        function after(n, func) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }

        /**
         * Creates a function that invokes `func`, with up to `n` arguments,
         * ignoring any additional arguments.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @param {number} [n=func.length] The arity cap.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new capped function.
         * @example
         *
         * _.map(['6', '8', '10'], _.ary(parseInt, 1));
         * // => [6, 8, 10]
         */
        function ary(func, n, guard) {
          n = guard ? undefined$1 : n;
          n = (func && n == null) ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
        }

        /**
         * Creates a function that invokes `func`, with the `this` binding and arguments
         * of the created function, while it's called less than `n` times. Subsequent
         * calls to the created function return the result of the last `func` invocation.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {number} n The number of calls at which `func` is no longer invoked.
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * jQuery(element).on('click', _.before(5, addContactToList));
         * // => Allows adding up to 4 contacts to the list.
         */
        function before(n, func) {
          var result;
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined$1;
            }
            return result;
          };
        }

        /**
         * Creates a function that invokes `func` with the `this` binding of `thisArg`
         * and `partials` prepended to the arguments it receives.
         *
         * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for partially applied arguments.
         *
         * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
         * property of bound functions.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to bind.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * function greet(greeting, punctuation) {
         *   return greeting + ' ' + this.user + punctuation;
         * }
         *
         * var object = { 'user': 'fred' };
         *
         * var bound = _.bind(greet, object, 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * // Bound with placeholders.
         * var bound = _.bind(greet, object, _, '!');
         * bound('hi');
         * // => 'hi fred!'
         */
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });

        /**
         * Creates a function that invokes the method at `object[key]` with `partials`
         * prepended to the arguments it receives.
         *
         * This method differs from `_.bind` by allowing bound functions to reference
         * methods that may be redefined or don't yet exist. See
         * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
         * for more details.
         *
         * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * @static
         * @memberOf _
         * @since 0.10.0
         * @category Function
         * @param {Object} object The object to invoke the method on.
         * @param {string} key The key of the method.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new bound function.
         * @example
         *
         * var object = {
         *   'user': 'fred',
         *   'greet': function(greeting, punctuation) {
         *     return greeting + ' ' + this.user + punctuation;
         *   }
         * };
         *
         * var bound = _.bindKey(object, 'greet', 'hi');
         * bound('!');
         * // => 'hi fred!'
         *
         * object.greet = function(greeting, punctuation) {
         *   return greeting + 'ya ' + this.user + punctuation;
         * };
         *
         * bound('!');
         * // => 'hiya fred!'
         *
         * // Bound with placeholders.
         * var bound = _.bindKey(object, 'greet', _, '!');
         * bound('hi');
         * // => 'hiya fred!'
         */
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });

        /**
         * Creates a function that accepts arguments of `func` and either invokes
         * `func` returning its result, if at least `arity` number of arguments have
         * been provided, or returns a function that accepts the remaining `func`
         * arguments, and so on. The arity of `func` may be specified if `func.length`
         * is not sufficient.
         *
         * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
         * may be used as a placeholder for provided arguments.
         *
         * **Note:** This method doesn't set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curry(abc);
         *
         * curried(1)(2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2)(3);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // Curried with placeholders.
         * curried(1)(_, 3)(2);
         * // => [1, 2, 3]
         */
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result.placeholder = curry.placeholder;
          return result;
        }

        /**
         * This method is like `_.curry` except that arguments are applied to `func`
         * in the manner of `_.partialRight` instead of `_.partial`.
         *
         * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for provided arguments.
         *
         * **Note:** This method doesn't set the "length" property of curried functions.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to curry.
         * @param {number} [arity=func.length] The arity of `func`.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the new curried function.
         * @example
         *
         * var abc = function(a, b, c) {
         *   return [a, b, c];
         * };
         *
         * var curried = _.curryRight(abc);
         *
         * curried(3)(2)(1);
         * // => [1, 2, 3]
         *
         * curried(2, 3)(1);
         * // => [1, 2, 3]
         *
         * curried(1, 2, 3);
         * // => [1, 2, 3]
         *
         * // Curried with placeholders.
         * curried(3)(1, _)(2);
         * // => [1, 2, 3]
         */
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result.placeholder = curryRight.placeholder;
          return result;
        }

        /**
         * Creates a debounced function that delays invoking `func` until after `wait`
         * milliseconds have elapsed since the last time the debounced function was
         * invoked. The debounced function comes with a `cancel` method to cancel
         * delayed `func` invocations and a `flush` method to immediately invoke them.
         * Provide `options` to indicate whether `func` should be invoked on the
         * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
         * with the last arguments provided to the debounced function. Subsequent
         * calls to the debounced function return the result of the last `func`
         * invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the debounced function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.debounce` and `_.throttle`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to debounce.
         * @param {number} [wait=0] The number of milliseconds to delay.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=false]
         *  Specify invoking on the leading edge of the timeout.
         * @param {number} [options.maxWait]
         *  The maximum time `func` is allowed to be delayed before it's invoked.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new debounced function.
         * @example
         *
         * // Avoid costly calculations while the window size is in flux.
         * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
         *
         * // Invoke `sendMail` when clicked, debouncing subsequent calls.
         * jQuery(element).on('click', _.debounce(sendMail, 300, {
         *   'leading': true,
         *   'trailing': false
         * }));
         *
         * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
         * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
         * var source = new EventSource('/stream');
         * jQuery(source).on('message', debounced);
         *
         * // Cancel the trailing debounced invocation.
         * jQuery(window).on('popstate', debounced.cancel);
         */
        function debounce(func, wait, options) {
          var lastArgs,
              lastThis,
              maxWait,
              result,
              timerId,
              lastCallTime,
              lastInvokeTime = 0,
              leading = false,
              maxing = false,
              trailing = true;

          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = 'maxWait' in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }

          function invokeFunc(time) {
            var args = lastArgs,
                thisArg = lastThis;

            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result = func.apply(thisArg, args);
            return result;
          }

          function leadingEdge(time) {
            // Reset any `maxWait` timer.
            lastInvokeTime = time;
            // Start the timer for the trailing edge.
            timerId = setTimeout(timerExpired, wait);
            // Invoke the leading edge.
            return leading ? invokeFunc(time) : result;
          }

          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime,
                timeWaiting = wait - timeSinceLastCall;

            return maxing
              ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
              : timeWaiting;
          }

          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime;

            // Either this is the first call, activity has stopped and we're at the
            // trailing edge, the system time has gone backwards and we're treating
            // it as the trailing edge, or we've hit the `maxWait` limit.
            return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
              (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
          }

          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            // Restart the timer.
            timerId = setTimeout(timerExpired, remainingWait(time));
          }

          function trailingEdge(time) {
            timerId = undefined$1;

            // Only invoke if we have `lastArgs` which means `func` has been
            // debounced at least once.
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result;
          }

          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }

          function flush() {
            return timerId === undefined$1 ? result : trailingEdge(now());
          }

          function debounced() {
            var time = now(),
                isInvoking = shouldInvoke(time);

            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;

            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                // Handle invocations in a tight loop.
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout(timerExpired, wait);
            }
            return result;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }

        /**
         * Defers invoking the `func` until the current call stack has cleared. Any
         * additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to defer.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.defer(function(text) {
         *   console.log(text);
         * }, 'deferred');
         * // => Logs 'deferred' after one millisecond.
         */
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });

        /**
         * Invokes `func` after `wait` milliseconds. Any additional arguments are
         * provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to delay.
         * @param {number} wait The number of milliseconds to delay invocation.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {number} Returns the timer id.
         * @example
         *
         * _.delay(function(text) {
         *   console.log(text);
         * }, 1000, 'later');
         * // => Logs 'later' after one second.
         */
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });

        /**
         * Creates a function that invokes `func` with arguments reversed.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to flip arguments for.
         * @returns {Function} Returns the new flipped function.
         * @example
         *
         * var flipped = _.flip(function() {
         *   return _.toArray(arguments);
         * });
         *
         * flipped('a', 'b', 'c', 'd');
         * // => ['d', 'c', 'b', 'a']
         */
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }

        /**
         * Creates a function that memoizes the result of `func`. If `resolver` is
         * provided, it determines the cache key for storing the result based on the
         * arguments provided to the memoized function. By default, the first argument
         * provided to the memoized function is used as the map cache key. The `func`
         * is invoked with the `this` binding of the memoized function.
         *
         * **Note:** The cache is exposed as the `cache` property on the memoized
         * function. Its creation may be customized by replacing the `_.memoize.Cache`
         * constructor with one whose instances implement the
         * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
         * method interface of `clear`, `delete`, `get`, `has`, and `set`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to have its output memoized.
         * @param {Function} [resolver] The function to resolve the cache key.
         * @returns {Function} Returns the new memoized function.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         * var other = { 'c': 3, 'd': 4 };
         *
         * var values = _.memoize(_.values);
         * values(object);
         * // => [1, 2]
         *
         * values(other);
         * // => [3, 4]
         *
         * object.a = 2;
         * values(object);
         * // => [1, 2]
         *
         * // Modify the result cache.
         * values.cache.set(object, ['a', 'b']);
         * values(object);
         * // => ['a', 'b']
         *
         * // Replace `_.memoize.Cache`.
         * _.memoize.Cache = WeakMap;
         */
        function memoize(func, resolver) {
          if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;

            if (cache.has(key)) {
              return cache.get(key);
            }
            var result = func.apply(this, args);
            memoized.cache = cache.set(key, result) || cache;
            return result;
          };
          memoized.cache = new (memoize.Cache || MapCache);
          return memoized;
        }

        // Expose `MapCache`.
        memoize.Cache = MapCache;

        /**
         * Creates a function that negates the result of the predicate `func`. The
         * `func` predicate is invoked with the `this` binding and arguments of the
         * created function.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} predicate The predicate to negate.
         * @returns {Function} Returns the new negated function.
         * @example
         *
         * function isEven(n) {
         *   return n % 2 == 0;
         * }
         *
         * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
         * // => [1, 3, 5]
         */
        function negate(predicate) {
          if (typeof predicate != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0: return !predicate.call(this);
              case 1: return !predicate.call(this, args[0]);
              case 2: return !predicate.call(this, args[0], args[1]);
              case 3: return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }

        /**
         * Creates a function that is restricted to invoking `func` once. Repeat calls
         * to the function return the value of the first invocation. The `func` is
         * invoked with the `this` binding and arguments of the created function.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to restrict.
         * @returns {Function} Returns the new restricted function.
         * @example
         *
         * var initialize = _.once(createApplication);
         * initialize();
         * initialize();
         * // => `createApplication` is invoked once
         */
        function once(func) {
          return before(2, func);
        }

        /**
         * Creates a function that invokes `func` with its arguments transformed.
         *
         * @static
         * @since 4.0.0
         * @memberOf _
         * @category Function
         * @param {Function} func The function to wrap.
         * @param {...(Function|Function[])} [transforms=[_.identity]]
         *  The argument transforms.
         * @returns {Function} Returns the new function.
         * @example
         *
         * function doubled(n) {
         *   return n * 2;
         * }
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var func = _.overArgs(function(x, y) {
         *   return [x, y];
         * }, [square, doubled]);
         *
         * func(9, 3);
         * // => [81, 6]
         *
         * func(10, 5);
         * // => [100, 10]
         */
        var overArgs = castRest(function(func, transforms) {
          transforms = (transforms.length == 1 && isArray(transforms[0]))
            ? arrayMap(transforms[0], baseUnary(getIteratee()))
            : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1,
                length = nativeMin(args.length, funcsLength);

            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });

        /**
         * Creates a function that invokes `func` with `partials` prepended to the
         * arguments it receives. This method is like `_.bind` except it does **not**
         * alter the `this` binding.
         *
         * The `_.partial.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method doesn't set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @since 0.2.0
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * function greet(greeting, name) {
         *   return greeting + ' ' + name;
         * }
         *
         * var sayHelloTo = _.partial(greet, 'hello');
         * sayHelloTo('fred');
         * // => 'hello fred'
         *
         * // Partially applied with placeholders.
         * var greetFred = _.partial(greet, _, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         */
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });

        /**
         * This method is like `_.partial` except that partially applied arguments
         * are appended to the arguments it receives.
         *
         * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
         * builds, may be used as a placeholder for partially applied arguments.
         *
         * **Note:** This method doesn't set the "length" property of partially
         * applied functions.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Function
         * @param {Function} func The function to partially apply arguments to.
         * @param {...*} [partials] The arguments to be partially applied.
         * @returns {Function} Returns the new partially applied function.
         * @example
         *
         * function greet(greeting, name) {
         *   return greeting + ' ' + name;
         * }
         *
         * var greetFred = _.partialRight(greet, 'fred');
         * greetFred('hi');
         * // => 'hi fred'
         *
         * // Partially applied with placeholders.
         * var sayHelloTo = _.partialRight(greet, 'hello', _);
         * sayHelloTo('fred');
         * // => 'hello fred'
         */
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });

        /**
         * Creates a function that invokes `func` with arguments arranged according
         * to the specified `indexes` where the argument value at the first index is
         * provided as the first argument, the argument value at the second index is
         * provided as the second argument, and so on.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Function
         * @param {Function} func The function to rearrange arguments for.
         * @param {...(number|number[])} indexes The arranged argument indexes.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var rearged = _.rearg(function(a, b, c) {
         *   return [a, b, c];
         * }, [2, 0, 1]);
         *
         * rearged('b', 'c', 'a')
         * // => ['a', 'b', 'c']
         */
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });

        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * created function and arguments from `start` and beyond provided as
         * an array.
         *
         * **Note:** This method is based on the
         * [rest parameter](https://mdn.io/rest_parameters).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to apply a rest parameter to.
         * @param {number} [start=func.length-1] The start position of the rest parameter.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.rest(function(what, names) {
         *   return what + ' ' + _.initial(names).join(', ') +
         *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
         * });
         *
         * say('hello', 'fred', 'barney', 'pebbles');
         * // => 'hello fred, barney, & pebbles'
         */
        function rest(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start === undefined$1 ? start : toInteger(start);
          return baseRest(func, start);
        }

        /**
         * Creates a function that invokes `func` with the `this` binding of the
         * create function and an array of arguments much like
         * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
         *
         * **Note:** This method is based on the
         * [spread operator](https://mdn.io/spread_operator).
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Function
         * @param {Function} func The function to spread arguments over.
         * @param {number} [start=0] The start position of the spread.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var say = _.spread(function(who, what) {
         *   return who + ' says ' + what;
         * });
         *
         * say(['fred', 'hello']);
         * // => 'fred says hello'
         *
         * var numbers = Promise.all([
         *   Promise.resolve(40),
         *   Promise.resolve(36)
         * ]);
         *
         * numbers.then(_.spread(function(x, y) {
         *   return x + y;
         * }));
         * // => a Promise of 76
         */
        function spread(func, start) {
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start],
                otherArgs = castSlice(args, 0, start);

            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }

        /**
         * Creates a throttled function that only invokes `func` at most once per
         * every `wait` milliseconds. The throttled function comes with a `cancel`
         * method to cancel delayed `func` invocations and a `flush` method to
         * immediately invoke them. Provide `options` to indicate whether `func`
         * should be invoked on the leading and/or trailing edge of the `wait`
         * timeout. The `func` is invoked with the last arguments provided to the
         * throttled function. Subsequent calls to the throttled function return the
         * result of the last `func` invocation.
         *
         * **Note:** If `leading` and `trailing` options are `true`, `func` is
         * invoked on the trailing edge of the timeout only if the throttled function
         * is invoked more than once during the `wait` timeout.
         *
         * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
         * until to the next tick, similar to `setTimeout` with a timeout of `0`.
         *
         * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
         * for details over the differences between `_.throttle` and `_.debounce`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {Function} func The function to throttle.
         * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.leading=true]
         *  Specify invoking on the leading edge of the timeout.
         * @param {boolean} [options.trailing=true]
         *  Specify invoking on the trailing edge of the timeout.
         * @returns {Function} Returns the new throttled function.
         * @example
         *
         * // Avoid excessively updating the position while scrolling.
         * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
         *
         * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
         * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
         * jQuery(element).on('click', throttled);
         *
         * // Cancel the trailing throttled invocation.
         * jQuery(window).on('popstate', throttled.cancel);
         */
        function throttle(func, wait, options) {
          var leading = true,
              trailing = true;

          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = 'leading' in options ? !!options.leading : leading;
            trailing = 'trailing' in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            'leading': leading,
            'maxWait': wait,
            'trailing': trailing
          });
        }

        /**
         * Creates a function that accepts up to one argument, ignoring any
         * additional arguments.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Function
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         * @example
         *
         * _.map(['6', '8', '10'], _.unary(parseInt));
         * // => [6, 8, 10]
         */
        function unary(func) {
          return ary(func, 1);
        }

        /**
         * Creates a function that provides `value` to `wrapper` as its first
         * argument. Any additional arguments provided to the function are appended
         * to those provided to the `wrapper`. The wrapper is invoked with the `this`
         * binding of the created function.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Function
         * @param {*} value The value to wrap.
         * @param {Function} [wrapper=identity] The wrapper function.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var p = _.wrap(_.escape, function(func, text) {
         *   return '<p>' + func(text) + '</p>';
         * });
         *
         * p('fred, barney, & pebbles');
         * // => '<p>fred, barney, &amp; pebbles</p>'
         */
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Casts `value` as an array if it's not one.
         *
         * @static
         * @memberOf _
         * @since 4.4.0
         * @category Lang
         * @param {*} value The value to inspect.
         * @returns {Array} Returns the cast array.
         * @example
         *
         * _.castArray(1);
         * // => [1]
         *
         * _.castArray({ 'a': 1 });
         * // => [{ 'a': 1 }]
         *
         * _.castArray('abc');
         * // => ['abc']
         *
         * _.castArray(null);
         * // => [null]
         *
         * _.castArray(undefined);
         * // => [undefined]
         *
         * _.castArray();
         * // => []
         *
         * var array = [1, 2, 3];
         * console.log(_.castArray(array) === array);
         * // => true
         */
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }

        /**
         * Creates a shallow clone of `value`.
         *
         * **Note:** This method is loosely based on the
         * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
         * and supports cloning arrays, array buffers, booleans, date objects, maps,
         * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
         * arrays. The own enumerable properties of `arguments` objects are cloned
         * as plain objects. An empty object is returned for uncloneable values such
         * as error objects, functions, DOM nodes, and WeakMaps.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to clone.
         * @returns {*} Returns the cloned value.
         * @see _.cloneDeep
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var shallow = _.clone(objects);
         * console.log(shallow[0] === objects[0]);
         * // => true
         */
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }

        /**
         * This method is like `_.clone` except that it accepts `customizer` which
         * is invoked to produce the cloned value. If `customizer` returns `undefined`,
         * cloning is handled by the method instead. The `customizer` is invoked with
         * up to four arguments; (value [, index|key, object, stack]).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to clone.
         * @param {Function} [customizer] The function to customize cloning.
         * @returns {*} Returns the cloned value.
         * @see _.cloneDeepWith
         * @example
         *
         * function customizer(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(false);
         *   }
         * }
         *
         * var el = _.cloneWith(document.body, customizer);
         *
         * console.log(el === document.body);
         * // => false
         * console.log(el.nodeName);
         * // => 'BODY'
         * console.log(el.childNodes.length);
         * // => 0
         */
        function cloneWith(value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }

        /**
         * This method is like `_.clone` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @returns {*} Returns the deep cloned value.
         * @see _.clone
         * @example
         *
         * var objects = [{ 'a': 1 }, { 'b': 2 }];
         *
         * var deep = _.cloneDeep(objects);
         * console.log(deep[0] === objects[0]);
         * // => false
         */
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }

        /**
         * This method is like `_.cloneWith` except that it recursively clones `value`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to recursively clone.
         * @param {Function} [customizer] The function to customize cloning.
         * @returns {*} Returns the deep cloned value.
         * @see _.cloneWith
         * @example
         *
         * function customizer(value) {
         *   if (_.isElement(value)) {
         *     return value.cloneNode(true);
         *   }
         * }
         *
         * var el = _.cloneDeepWith(document.body, customizer);
         *
         * console.log(el === document.body);
         * // => false
         * console.log(el.nodeName);
         * // => 'BODY'
         * console.log(el.childNodes.length);
         * // => 20
         */
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }

        /**
         * Checks if `object` conforms to `source` by invoking the predicate
         * properties of `source` with the corresponding property values of `object`.
         *
         * **Note:** This method is equivalent to `_.conforms` when `source` is
         * partially applied.
         *
         * @static
         * @memberOf _
         * @since 4.14.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property predicates to conform to.
         * @returns {boolean} Returns `true` if `object` conforms, else `false`.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         *
         * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
         * // => true
         *
         * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
         * // => false
         */
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }

        /**
         * Performs a
         * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
         * comparison between two values to determine if they are equivalent.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.eq(object, object);
         * // => true
         *
         * _.eq(object, other);
         * // => false
         *
         * _.eq('a', 'a');
         * // => true
         *
         * _.eq('a', Object('a'));
         * // => false
         *
         * _.eq(NaN, NaN);
         * // => true
         */
        function eq(value, other) {
          return value === other || (value !== value && other !== other);
        }

        /**
         * Checks if `value` is greater than `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than `other`,
         *  else `false`.
         * @see _.lt
         * @example
         *
         * _.gt(3, 1);
         * // => true
         *
         * _.gt(3, 3);
         * // => false
         *
         * _.gt(1, 3);
         * // => false
         */
        var gt = createRelationalOperation(baseGt);

        /**
         * Checks if `value` is greater than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is greater than or equal to
         *  `other`, else `false`.
         * @see _.lte
         * @example
         *
         * _.gte(3, 1);
         * // => true
         *
         * _.gte(3, 3);
         * // => true
         *
         * _.gte(1, 3);
         * // => false
         */
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });

        /**
         * Checks if `value` is likely an `arguments` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an `arguments` object,
         *  else `false`.
         * @example
         *
         * _.isArguments(function() { return arguments; }());
         * // => true
         *
         * _.isArguments([1, 2, 3]);
         * // => false
         */
        var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
            !propertyIsEnumerable.call(value, 'callee');
        };

        /**
         * Checks if `value` is classified as an `Array` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array, else `false`.
         * @example
         *
         * _.isArray([1, 2, 3]);
         * // => true
         *
         * _.isArray(document.body.children);
         * // => false
         *
         * _.isArray('abc');
         * // => false
         *
         * _.isArray(_.noop);
         * // => false
         */
        var isArray = Array.isArray;

        /**
         * Checks if `value` is classified as an `ArrayBuffer` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
         * @example
         *
         * _.isArrayBuffer(new ArrayBuffer(2));
         * // => true
         *
         * _.isArrayBuffer(new Array(2));
         * // => false
         */
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

        /**
         * Checks if `value` is array-like. A value is considered array-like if it's
         * not a function and has a `value.length` that's an integer greater than or
         * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
         * @example
         *
         * _.isArrayLike([1, 2, 3]);
         * // => true
         *
         * _.isArrayLike(document.body.children);
         * // => true
         *
         * _.isArrayLike('abc');
         * // => true
         *
         * _.isArrayLike(_.noop);
         * // => false
         */
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }

        /**
         * This method is like `_.isArrayLike` except that it also checks if `value`
         * is an object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an array-like object,
         *  else `false`.
         * @example
         *
         * _.isArrayLikeObject([1, 2, 3]);
         * // => true
         *
         * _.isArrayLikeObject(document.body.children);
         * // => true
         *
         * _.isArrayLikeObject('abc');
         * // => false
         *
         * _.isArrayLikeObject(_.noop);
         * // => false
         */
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }

        /**
         * Checks if `value` is classified as a boolean primitive or object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
         * @example
         *
         * _.isBoolean(false);
         * // => true
         *
         * _.isBoolean(null);
         * // => false
         */
        function isBoolean(value) {
          return value === true || value === false ||
            (isObjectLike(value) && baseGetTag(value) == boolTag);
        }

        /**
         * Checks if `value` is a buffer.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
         * @example
         *
         * _.isBuffer(new Buffer(2));
         * // => true
         *
         * _.isBuffer(new Uint8Array(2));
         * // => false
         */
        var isBuffer = nativeIsBuffer || stubFalse;

        /**
         * Checks if `value` is classified as a `Date` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
         * @example
         *
         * _.isDate(new Date);
         * // => true
         *
         * _.isDate('Mon April 23 2012');
         * // => false
         */
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

        /**
         * Checks if `value` is likely a DOM element.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
         * @example
         *
         * _.isElement(document.body);
         * // => true
         *
         * _.isElement('<body>');
         * // => false
         */
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }

        /**
         * Checks if `value` is an empty object, collection, map, or set.
         *
         * Objects are considered empty if they have no own enumerable string keyed
         * properties.
         *
         * Array-like values such as `arguments` objects, arrays, buffers, strings, or
         * jQuery-like collections are considered empty if they have a `length` of `0`.
         * Similarly, maps and sets are considered empty if they have a `size` of `0`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is empty, else `false`.
         * @example
         *
         * _.isEmpty(null);
         * // => true
         *
         * _.isEmpty(true);
         * // => true
         *
         * _.isEmpty(1);
         * // => true
         *
         * _.isEmpty([1, 2, 3]);
         * // => false
         *
         * _.isEmpty({ 'a': 1 });
         * // => false
         */
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) &&
              (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
                isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }

        /**
         * Performs a deep comparison between two values to determine if they are
         * equivalent.
         *
         * **Note:** This method supports comparing arrays, array buffers, booleans,
         * date objects, error objects, maps, numbers, `Object` objects, regexes,
         * sets, strings, symbols, and typed arrays. `Object` objects are compared
         * by their own, not inherited, enumerable properties. Functions and DOM
         * nodes are compared by strict equality, i.e. `===`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * var object = { 'a': 1 };
         * var other = { 'a': 1 };
         *
         * _.isEqual(object, other);
         * // => true
         *
         * object === other;
         * // => false
         */
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }

        /**
         * This method is like `_.isEqual` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
         * are handled by the method instead. The `customizer` is invoked with up to
         * six arguments: (objValue, othValue [, index|key, object, other, stack]).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, othValue) {
         *   if (isGreeting(objValue) && isGreeting(othValue)) {
         *     return true;
         *   }
         * }
         *
         * var array = ['hello', 'goodbye'];
         * var other = ['hi', 'goodbye'];
         *
         * _.isEqualWith(array, other, customizer);
         * // => true
         */
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          var result = customizer ? customizer(value, other) : undefined$1;
          return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
        }

        /**
         * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
         * `SyntaxError`, `TypeError`, or `URIError` object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
         * @example
         *
         * _.isError(new Error);
         * // => true
         *
         * _.isError(Error);
         * // => false
         */
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag ||
            (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
        }

        /**
         * Checks if `value` is a finite primitive number.
         *
         * **Note:** This method is based on
         * [`Number.isFinite`](https://mdn.io/Number/isFinite).
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
         * @example
         *
         * _.isFinite(3);
         * // => true
         *
         * _.isFinite(Number.MIN_VALUE);
         * // => true
         *
         * _.isFinite(Infinity);
         * // => false
         *
         * _.isFinite('3');
         * // => false
         */
        function isFinite(value) {
          return typeof value == 'number' && nativeIsFinite(value);
        }

        /**
         * Checks if `value` is classified as a `Function` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a function, else `false`.
         * @example
         *
         * _.isFunction(_);
         * // => true
         *
         * _.isFunction(/abc/);
         * // => false
         */
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          // The use of `Object#toString` avoids issues with the `typeof` operator
          // in Safari 9 which returns 'object' for typed arrays and other constructors.
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }

        /**
         * Checks if `value` is an integer.
         *
         * **Note:** This method is based on
         * [`Number.isInteger`](https://mdn.io/Number/isInteger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
         * @example
         *
         * _.isInteger(3);
         * // => true
         *
         * _.isInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isInteger(Infinity);
         * // => false
         *
         * _.isInteger('3');
         * // => false
         */
        function isInteger(value) {
          return typeof value == 'number' && value == toInteger(value);
        }

        /**
         * Checks if `value` is a valid array-like length.
         *
         * **Note:** This method is loosely based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
         * @example
         *
         * _.isLength(3);
         * // => true
         *
         * _.isLength(Number.MIN_VALUE);
         * // => false
         *
         * _.isLength(Infinity);
         * // => false
         *
         * _.isLength('3');
         * // => false
         */
        function isLength(value) {
          return typeof value == 'number' &&
            value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }

        /**
         * Checks if `value` is the
         * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
         * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is an object, else `false`.
         * @example
         *
         * _.isObject({});
         * // => true
         *
         * _.isObject([1, 2, 3]);
         * // => true
         *
         * _.isObject(_.noop);
         * // => true
         *
         * _.isObject(null);
         * // => false
         */
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == 'object' || type == 'function');
        }

        /**
         * Checks if `value` is object-like. A value is object-like if it's not `null`
         * and has a `typeof` result of "object".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
         * @example
         *
         * _.isObjectLike({});
         * // => true
         *
         * _.isObjectLike([1, 2, 3]);
         * // => true
         *
         * _.isObjectLike(_.noop);
         * // => false
         *
         * _.isObjectLike(null);
         * // => false
         */
        function isObjectLike(value) {
          return value != null && typeof value == 'object';
        }

        /**
         * Checks if `value` is classified as a `Map` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a map, else `false`.
         * @example
         *
         * _.isMap(new Map);
         * // => true
         *
         * _.isMap(new WeakMap);
         * // => false
         */
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

        /**
         * Performs a partial deep comparison between `object` and `source` to
         * determine if `object` contains equivalent property values.
         *
         * **Note:** This method is equivalent to `_.matches` when `source` is
         * partially applied.
         *
         * Partial comparisons will match empty array and empty object `source`
         * values against any array or object value, respectively. See `_.isEqual`
         * for a list of supported value comparisons.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * var object = { 'a': 1, 'b': 2 };
         *
         * _.isMatch(object, { 'b': 2 });
         * // => true
         *
         * _.isMatch(object, { 'b': 1 });
         * // => false
         */
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }

        /**
         * This method is like `_.isMatch` except that it accepts `customizer` which
         * is invoked to compare values. If `customizer` returns `undefined`, comparisons
         * are handled by the method instead. The `customizer` is invoked with five
         * arguments: (objValue, srcValue, index|key, object, source).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {Object} object The object to inspect.
         * @param {Object} source The object of property values to match.
         * @param {Function} [customizer] The function to customize comparisons.
         * @returns {boolean} Returns `true` if `object` is a match, else `false`.
         * @example
         *
         * function isGreeting(value) {
         *   return /^h(?:i|ello)$/.test(value);
         * }
         *
         * function customizer(objValue, srcValue) {
         *   if (isGreeting(objValue) && isGreeting(srcValue)) {
         *     return true;
         *   }
         * }
         *
         * var object = { 'greeting': 'hello' };
         * var source = { 'greeting': 'hi' };
         *
         * _.isMatchWith(object, source, customizer);
         * // => true
         */
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }

        /**
         * Checks if `value` is `NaN`.
         *
         * **Note:** This method is based on
         * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
         * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
         * `undefined` and other non-number values.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
         * @example
         *
         * _.isNaN(NaN);
         * // => true
         *
         * _.isNaN(new Number(NaN));
         * // => true
         *
         * isNaN(undefined);
         * // => true
         *
         * _.isNaN(undefined);
         * // => false
         */
        function isNaN(value) {
          // An `NaN` primitive is the only value that is not equal to itself.
          // Perform the `toStringTag` check first to avoid errors with some
          // ActiveX objects in IE.
          return isNumber(value) && value != +value;
        }

        /**
         * Checks if `value` is a pristine native function.
         *
         * **Note:** This method can't reliably detect native functions in the presence
         * of the core-js package because core-js circumvents this kind of detection.
         * Despite multiple requests, the core-js maintainer has made it clear: any
         * attempt to fix the detection will be obstructed. As a result, we're left
         * with little choice but to throw an error. Unfortunately, this also affects
         * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
         * which rely on core-js.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a native function,
         *  else `false`.
         * @example
         *
         * _.isNative(Array.prototype.push);
         * // => true
         *
         * _.isNative(_);
         * // => false
         */
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }

        /**
         * Checks if `value` is `null`.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
         * @example
         *
         * _.isNull(null);
         * // => true
         *
         * _.isNull(void 0);
         * // => false
         */
        function isNull(value) {
          return value === null;
        }

        /**
         * Checks if `value` is `null` or `undefined`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
         * @example
         *
         * _.isNil(null);
         * // => true
         *
         * _.isNil(void 0);
         * // => true
         *
         * _.isNil(NaN);
         * // => false
         */
        function isNil(value) {
          return value == null;
        }

        /**
         * Checks if `value` is classified as a `Number` primitive or object.
         *
         * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
         * classified as numbers, use the `_.isFinite` method.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a number, else `false`.
         * @example
         *
         * _.isNumber(3);
         * // => true
         *
         * _.isNumber(Number.MIN_VALUE);
         * // => true
         *
         * _.isNumber(Infinity);
         * // => true
         *
         * _.isNumber('3');
         * // => false
         */
        function isNumber(value) {
          return typeof value == 'number' ||
            (isObjectLike(value) && baseGetTag(value) == numberTag);
        }

        /**
         * Checks if `value` is a plain object, that is, an object created by the
         * `Object` constructor or one with a `[[Prototype]]` of `null`.
         *
         * @static
         * @memberOf _
         * @since 0.8.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * _.isPlainObject(new Foo);
         * // => false
         *
         * _.isPlainObject([1, 2, 3]);
         * // => false
         *
         * _.isPlainObject({ 'x': 0, 'y': 0 });
         * // => true
         *
         * _.isPlainObject(Object.create(null));
         * // => true
         */
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
          return typeof Ctor == 'function' && Ctor instanceof Ctor &&
            funcToString.call(Ctor) == objectCtorString;
        }

        /**
         * Checks if `value` is classified as a `RegExp` object.
         *
         * @static
         * @memberOf _
         * @since 0.1.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
         * @example
         *
         * _.isRegExp(/abc/);
         * // => true
         *
         * _.isRegExp('/abc/');
         * // => false
         */
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

        /**
         * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
         * double precision number which isn't the result of a rounded unsafe integer.
         *
         * **Note:** This method is based on
         * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
         * @example
         *
         * _.isSafeInteger(3);
         * // => true
         *
         * _.isSafeInteger(Number.MIN_VALUE);
         * // => false
         *
         * _.isSafeInteger(Infinity);
         * // => false
         *
         * _.isSafeInteger('3');
         * // => false
         */
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }

        /**
         * Checks if `value` is classified as a `Set` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a set, else `false`.
         * @example
         *
         * _.isSet(new Set);
         * // => true
         *
         * _.isSet(new WeakSet);
         * // => false
         */
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

        /**
         * Checks if `value` is classified as a `String` primitive or object.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a string, else `false`.
         * @example
         *
         * _.isString('abc');
         * // => true
         *
         * _.isString(1);
         * // => false
         */
        function isString(value) {
          return typeof value == 'string' ||
            (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
        }

        /**
         * Checks if `value` is classified as a `Symbol` primitive or object.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
         * @example
         *
         * _.isSymbol(Symbol.iterator);
         * // => true
         *
         * _.isSymbol('abc');
         * // => false
         */
        function isSymbol(value) {
          return typeof value == 'symbol' ||
            (isObjectLike(value) && baseGetTag(value) == symbolTag);
        }

        /**
         * Checks if `value` is classified as a typed array.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
         * @example
         *
         * _.isTypedArray(new Uint8Array);
         * // => true
         *
         * _.isTypedArray([]);
         * // => false
         */
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

        /**
         * Checks if `value` is `undefined`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
         * @example
         *
         * _.isUndefined(void 0);
         * // => true
         *
         * _.isUndefined(null);
         * // => false
         */
        function isUndefined(value) {
          return value === undefined$1;
        }

        /**
         * Checks if `value` is classified as a `WeakMap` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
         * @example
         *
         * _.isWeakMap(new WeakMap);
         * // => true
         *
         * _.isWeakMap(new Map);
         * // => false
         */
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }

        /**
         * Checks if `value` is classified as a `WeakSet` object.
         *
         * @static
         * @memberOf _
         * @since 4.3.0
         * @category Lang
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
         * @example
         *
         * _.isWeakSet(new WeakSet);
         * // => true
         *
         * _.isWeakSet(new Set);
         * // => false
         */
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }

        /**
         * Checks if `value` is less than `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than `other`,
         *  else `false`.
         * @see _.gt
         * @example
         *
         * _.lt(1, 3);
         * // => true
         *
         * _.lt(3, 3);
         * // => false
         *
         * _.lt(3, 1);
         * // => false
         */
        var lt = createRelationalOperation(baseLt);

        /**
         * Checks if `value` is less than or equal to `other`.
         *
         * @static
         * @memberOf _
         * @since 3.9.0
         * @category Lang
         * @param {*} value The value to compare.
         * @param {*} other The other value to compare.
         * @returns {boolean} Returns `true` if `value` is less than or equal to
         *  `other`, else `false`.
         * @see _.gte
         * @example
         *
         * _.lte(1, 3);
         * // => true
         *
         * _.lte(3, 3);
         * // => true
         *
         * _.lte(3, 1);
         * // => false
         */
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });

        /**
         * Converts `value` to an array.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Array} Returns the converted array.
         * @example
         *
         * _.toArray({ 'a': 1, 'b': 2 });
         * // => [1, 2]
         *
         * _.toArray('abc');
         * // => ['a', 'b', 'c']
         *
         * _.toArray(1);
         * // => []
         *
         * _.toArray(null);
         * // => []
         */
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value),
              func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

          return func(value);
        }

        /**
         * Converts `value` to a finite number.
         *
         * @static
         * @memberOf _
         * @since 4.12.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted number.
         * @example
         *
         * _.toFinite(3.2);
         * // => 3.2
         *
         * _.toFinite(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toFinite(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toFinite('3.2');
         * // => 3.2
         */
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = (value < 0 ? -1 : 1);
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }

        /**
         * Converts `value` to an integer.
         *
         * **Note:** This method is loosely based on
         * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toInteger(3.2);
         * // => 3
         *
         * _.toInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toInteger(Infinity);
         * // => 1.7976931348623157e+308
         *
         * _.toInteger('3.2');
         * // => 3
         */
        function toInteger(value) {
          var result = toFinite(value),
              remainder = result % 1;

          return result === result ? (remainder ? result - remainder : result) : 0;
        }

        /**
         * Converts `value` to an integer suitable for use as the length of an
         * array-like object.
         *
         * **Note:** This method is based on
         * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toLength(3.2);
         * // => 3
         *
         * _.toLength(Number.MIN_VALUE);
         * // => 0
         *
         * _.toLength(Infinity);
         * // => 4294967295
         *
         * _.toLength('3.2');
         * // => 3
         */
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }

        /**
         * Converts `value` to a number.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to process.
         * @returns {number} Returns the number.
         * @example
         *
         * _.toNumber(3.2);
         * // => 3.2
         *
         * _.toNumber(Number.MIN_VALUE);
         * // => 5e-324
         *
         * _.toNumber(Infinity);
         * // => Infinity
         *
         * _.toNumber('3.2');
         * // => 3.2
         */
        function toNumber(value) {
          if (typeof value == 'number') {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
            value = isObject(other) ? (other + '') : other;
          }
          if (typeof value != 'string') {
            return value === 0 ? value : +value;
          }
          value = value.replace(reTrim, '');
          var isBinary = reIsBinary.test(value);
          return (isBinary || reIsOctal.test(value))
            ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
            : (reIsBadHex.test(value) ? NAN : +value);
        }

        /**
         * Converts `value` to a plain object flattening inherited enumerable string
         * keyed properties of `value` to own properties of the plain object.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {Object} Returns the converted plain object.
         * @example
         *
         * function Foo() {
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.assign({ 'a': 1 }, new Foo);
         * // => { 'a': 1, 'b': 2 }
         *
         * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
         * // => { 'a': 1, 'b': 2, 'c': 3 }
         */
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }

        /**
         * Converts `value` to a safe integer. A safe integer can be compared and
         * represented correctly.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.toSafeInteger(3.2);
         * // => 3
         *
         * _.toSafeInteger(Number.MIN_VALUE);
         * // => 0
         *
         * _.toSafeInteger(Infinity);
         * // => 9007199254740991
         *
         * _.toSafeInteger('3.2');
         * // => 3
         */
        function toSafeInteger(value) {
          return value
            ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
            : (value === 0 ? value : 0);
        }

        /**
         * Converts `value` to a string. An empty string is returned for `null`
         * and `undefined` values. The sign of `-0` is preserved.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Lang
         * @param {*} value The value to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.toString(null);
         * // => ''
         *
         * _.toString(-0);
         * // => '-0'
         *
         * _.toString([1, 2, 3]);
         * // => '1,2,3'
         */
        function toString(value) {
          return value == null ? '' : baseToString(value);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Assigns own enumerable string keyed properties of source objects to the
         * destination object. Source objects are applied from left to right.
         * Subsequent sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object` and is loosely based on
         * [`Object.assign`](https://mdn.io/Object/assign).
         *
         * @static
         * @memberOf _
         * @since 0.10.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.assignIn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * function Bar() {
         *   this.c = 3;
         * }
         *
         * Foo.prototype.b = 2;
         * Bar.prototype.d = 4;
         *
         * _.assign({ 'a': 0 }, new Foo, new Bar);
         * // => { 'a': 1, 'c': 3 }
         */
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });

        /**
         * This method is like `_.assign` except that it iterates over own and
         * inherited source properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias extend
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.assign
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         * }
         *
         * function Bar() {
         *   this.c = 3;
         * }
         *
         * Foo.prototype.b = 2;
         * Bar.prototype.d = 4;
         *
         * _.assignIn({ 'a': 0 }, new Foo, new Bar);
         * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
         */
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });

        /**
         * This method is like `_.assignIn` except that it accepts `customizer`
         * which is invoked to produce the assigned values. If `customizer` returns
         * `undefined`, assignment is handled by the method instead. The `customizer`
         * is invoked with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias extendWith
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @see _.assignWith
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignInWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });

        /**
         * This method is like `_.assign` except that it accepts `customizer`
         * which is invoked to produce the assigned values. If `customizer` returns
         * `undefined`, assignment is handled by the method instead. The `customizer`
         * is invoked with five arguments: (objValue, srcValue, key, object, source).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @see _.assignInWith
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   return _.isUndefined(objValue) ? srcValue : objValue;
         * }
         *
         * var defaults = _.partialRight(_.assignWith, customizer);
         *
         * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });

        /**
         * Creates an array of values corresponding to `paths` of `object`.
         *
         * @static
         * @memberOf _
         * @since 1.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Array} Returns the picked values.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
         *
         * _.at(object, ['a[0].b.c', 'a[1]']);
         * // => [3, 4]
         */
        var at = flatRest(baseAt);

        /**
         * Creates an object that inherits from the `prototype` object. If a
         * `properties` object is given, its own enumerable string keyed properties
         * are assigned to the created object.
         *
         * @static
         * @memberOf _
         * @since 2.3.0
         * @category Object
         * @param {Object} prototype The object to inherit from.
         * @param {Object} [properties] The properties to assign to the object.
         * @returns {Object} Returns the new object.
         * @example
         *
         * function Shape() {
         *   this.x = 0;
         *   this.y = 0;
         * }
         *
         * function Circle() {
         *   Shape.call(this);
         * }
         *
         * Circle.prototype = _.create(Shape.prototype, {
         *   'constructor': Circle
         * });
         *
         * var circle = new Circle;
         * circle instanceof Circle;
         * // => true
         *
         * circle instanceof Shape;
         * // => true
         */
        function create(prototype, properties) {
          var result = baseCreate(prototype);
          return properties == null ? result : baseAssign(result, properties);
        }

        /**
         * Assigns own and inherited enumerable string keyed properties of source
         * objects to the destination object for all destination properties that
         * resolve to `undefined`. Source objects are applied from left to right.
         * Once a property is set, additional values of the same property are ignored.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.defaultsDeep
         * @example
         *
         * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
         * // => { 'a': 1, 'b': 2 }
         */
        var defaults = baseRest(function(object, sources) {
          object = Object(object);

          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined$1;

          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }

          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;

            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];

              if (value === undefined$1 ||
                  (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
                object[key] = source[key];
              }
            }
          }

          return object;
        });

        /**
         * This method is like `_.defaults` except that it recursively assigns
         * default properties.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @see _.defaults
         * @example
         *
         * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
         * // => { 'a': { 'b': 2, 'c': 3 } }
         */
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply(mergeWith, undefined$1, args);
        });

        /**
         * This method is like `_.find` except that it returns the key of the first
         * element `predicate` returns truthy for instead of the element itself.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {string|undefined} Returns the key of the matched element,
         *  else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findKey(users, function(o) { return o.age < 40; });
         * // => 'barney' (iteration order is not guaranteed)
         *
         * // The `_.matches` iteratee shorthand.
         * _.findKey(users, { 'age': 1, 'active': true });
         * // => 'pebbles'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findKey(users, ['active', false]);
         * // => 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.findKey(users, 'active');
         * // => 'barney'
         */
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }

        /**
         * This method is like `_.findKey` except that it iterates over elements of
         * a collection in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @param {Function} [predicate=_.identity] The function invoked per iteration.
         * @returns {string|undefined} Returns the key of the matched element,
         *  else `undefined`.
         * @example
         *
         * var users = {
         *   'barney':  { 'age': 36, 'active': true },
         *   'fred':    { 'age': 40, 'active': false },
         *   'pebbles': { 'age': 1,  'active': true }
         * };
         *
         * _.findLastKey(users, function(o) { return o.age < 40; });
         * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
         *
         * // The `_.matches` iteratee shorthand.
         * _.findLastKey(users, { 'age': 36, 'active': true });
         * // => 'barney'
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.findLastKey(users, ['active', false]);
         * // => 'fred'
         *
         * // The `_.property` iteratee shorthand.
         * _.findLastKey(users, 'active');
         * // => 'pebbles'
         */
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }

        /**
         * Iterates over own and inherited enumerable string keyed properties of an
         * object and invokes `iteratee` for each property. The iteratee is invoked
         * with three arguments: (value, key, object). Iteratee functions may exit
         * iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 0.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forInRight
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forIn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
         */
        function forIn(object, iteratee) {
          return object == null
            ? object
            : baseFor(object, getIteratee(iteratee, 3), keysIn);
        }

        /**
         * This method is like `_.forIn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forIn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forInRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
         */
        function forInRight(object, iteratee) {
          return object == null
            ? object
            : baseForRight(object, getIteratee(iteratee, 3), keysIn);
        }

        /**
         * Iterates over own enumerable string keyed properties of an object and
         * invokes `iteratee` for each property. The iteratee is invoked with three
         * arguments: (value, key, object). Iteratee functions may exit iteration
         * early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 0.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forOwnRight
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwn(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'a' then 'b' (iteration order is not guaranteed).
         */
        function forOwn(object, iteratee) {
          return object && baseForOwn(object, getIteratee(iteratee, 3));
        }

        /**
         * This method is like `_.forOwn` except that it iterates over properties of
         * `object` in the opposite order.
         *
         * @static
         * @memberOf _
         * @since 2.0.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns `object`.
         * @see _.forOwn
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.forOwnRight(new Foo, function(value, key) {
         *   console.log(key);
         * });
         * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
         */
        function forOwnRight(object, iteratee) {
          return object && baseForOwnRight(object, getIteratee(iteratee, 3));
        }

        /**
         * Creates an array of function property names from own enumerable properties
         * of `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the function names.
         * @see _.functionsIn
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functions(new Foo);
         * // => ['a', 'b']
         */
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }

        /**
         * Creates an array of function property names from own and inherited
         * enumerable properties of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to inspect.
         * @returns {Array} Returns the function names.
         * @see _.functions
         * @example
         *
         * function Foo() {
         *   this.a = _.constant('a');
         *   this.b = _.constant('b');
         * }
         *
         * Foo.prototype.c = _.constant('c');
         *
         * _.functionsIn(new Foo);
         * // => ['a', 'b', 'c']
         */
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }

        /**
         * Gets the value at `path` of `object`. If the resolved value is
         * `undefined`, the `defaultValue` is returned in its place.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to get.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.get(object, 'a[0].b.c');
         * // => 3
         *
         * _.get(object, ['a', '0', 'b', 'c']);
         * // => 3
         *
         * _.get(object, 'a.b.c', 'default');
         * // => 'default'
         */
        function get(object, path, defaultValue) {
          var result = object == null ? undefined$1 : baseGet(object, path);
          return result === undefined$1 ? defaultValue : result;
        }

        /**
         * Checks if `path` is a direct property of `object`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = { 'a': { 'b': 2 } };
         * var other = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.has(object, 'a');
         * // => true
         *
         * _.has(object, 'a.b');
         * // => true
         *
         * _.has(object, ['a', 'b']);
         * // => true
         *
         * _.has(other, 'a');
         * // => false
         */
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }

        /**
         * Checks if `path` is a direct or inherited property of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path to check.
         * @returns {boolean} Returns `true` if `path` exists, else `false`.
         * @example
         *
         * var object = _.create({ 'a': _.create({ 'b': 2 }) });
         *
         * _.hasIn(object, 'a');
         * // => true
         *
         * _.hasIn(object, 'a.b');
         * // => true
         *
         * _.hasIn(object, ['a', 'b']);
         * // => true
         *
         * _.hasIn(object, 'b');
         * // => false
         */
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }

        /**
         * Creates an object composed of the inverted keys and values of `object`.
         * If `object` contains duplicate values, subsequent values overwrite
         * property assignments of previous values.
         *
         * @static
         * @memberOf _
         * @since 0.7.0
         * @category Object
         * @param {Object} object The object to invert.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invert(object);
         * // => { '1': 'c', '2': 'b' }
         */
        var invert = createInverter(function(result, value, key) {
          if (value != null &&
              typeof value.toString != 'function') {
            value = nativeObjectToString.call(value);
          }

          result[value] = key;
        }, constant(identity));

        /**
         * This method is like `_.invert` except that the inverted object is generated
         * from the results of running each element of `object` thru `iteratee`. The
         * corresponding inverted value of each inverted key is an array of keys
         * responsible for generating the inverted value. The iteratee is invoked
         * with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.1.0
         * @category Object
         * @param {Object} object The object to invert.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {Object} Returns the new inverted object.
         * @example
         *
         * var object = { 'a': 1, 'b': 2, 'c': 1 };
         *
         * _.invertBy(object);
         * // => { '1': ['a', 'c'], '2': ['b'] }
         *
         * _.invertBy(object, function(value) {
         *   return 'group' + value;
         * });
         * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
         */
        var invertBy = createInverter(function(result, value, key) {
          if (value != null &&
              typeof value.toString != 'function') {
            value = nativeObjectToString.call(value);
          }

          if (hasOwnProperty.call(result, value)) {
            result[value].push(key);
          } else {
            result[value] = [key];
          }
        }, getIteratee);

        /**
         * Invokes the method at `path` of `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {*} Returns the result of the invoked method.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
         *
         * _.invoke(object, 'a[0].b.c.slice', 1, 3);
         * // => [2, 3]
         */
        var invoke = baseRest(baseInvoke);

        /**
         * Creates an array of the own enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects. See the
         * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
         * for more details.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keys(new Foo);
         * // => ['a', 'b'] (iteration order is not guaranteed)
         *
         * _.keys('hi');
         * // => ['0', '1']
         */
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }

        /**
         * Creates an array of the own and inherited enumerable property names of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property names.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.keysIn(new Foo);
         * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
         */
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }

        /**
         * The opposite of `_.mapValues`; this method creates an object with the
         * same values as `object` and keys generated by running each own enumerable
         * string keyed property of `object` thru `iteratee`. The iteratee is invoked
         * with three arguments: (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 3.8.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapValues
         * @example
         *
         * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
         *   return key + value;
         * });
         * // => { 'a1': 1, 'b2': 2 }
         */
        function mapKeys(object, iteratee) {
          var result = {};
          iteratee = getIteratee(iteratee, 3);

          baseForOwn(object, function(value, key, object) {
            baseAssignValue(result, iteratee(value, key, object), value);
          });
          return result;
        }

        /**
         * Creates an object with the same keys as `object` and values generated
         * by running each own enumerable string keyed property of `object` thru
         * `iteratee`. The iteratee is invoked with three arguments:
         * (value, key, object).
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Object} Returns the new mapped object.
         * @see _.mapKeys
         * @example
         *
         * var users = {
         *   'fred':    { 'user': 'fred',    'age': 40 },
         *   'pebbles': { 'user': 'pebbles', 'age': 1 }
         * };
         *
         * _.mapValues(users, function(o) { return o.age; });
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         *
         * // The `_.property` iteratee shorthand.
         * _.mapValues(users, 'age');
         * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
         */
        function mapValues(object, iteratee) {
          var result = {};
          iteratee = getIteratee(iteratee, 3);

          baseForOwn(object, function(value, key, object) {
            baseAssignValue(result, key, iteratee(value, key, object));
          });
          return result;
        }

        /**
         * This method is like `_.assign` except that it recursively merges own and
         * inherited enumerable string keyed properties of source objects into the
         * destination object. Source properties that resolve to `undefined` are
         * skipped if a destination value exists. Array and plain object properties
         * are merged recursively. Other objects and value types are overridden by
         * assignment. Source objects are applied from left to right. Subsequent
         * sources overwrite property assignments of previous sources.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 0.5.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} [sources] The source objects.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {
         *   'a': [{ 'b': 2 }, { 'd': 4 }]
         * };
         *
         * var other = {
         *   'a': [{ 'c': 3 }, { 'e': 5 }]
         * };
         *
         * _.merge(object, other);
         * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
         */
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });

        /**
         * This method is like `_.merge` except that it accepts `customizer` which
         * is invoked to produce the merged values of the destination and source
         * properties. If `customizer` returns `undefined`, merging is handled by the
         * method instead. The `customizer` is invoked with six arguments:
         * (objValue, srcValue, key, object, source, stack).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The destination object.
         * @param {...Object} sources The source objects.
         * @param {Function} customizer The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * function customizer(objValue, srcValue) {
         *   if (_.isArray(objValue)) {
         *     return objValue.concat(srcValue);
         *   }
         * }
         *
         * var object = { 'a': [1], 'b': [2] };
         * var other = { 'a': [3], 'b': [4] };
         *
         * _.mergeWith(object, other, customizer);
         * // => { 'a': [1, 3], 'b': [2, 4] }
         */
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });

        /**
         * The opposite of `_.pick`; this method creates an object composed of the
         * own and inherited enumerable property paths of `object` that are not omitted.
         *
         * **Note:** This method is considerably slower than `_.pick`.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to omit.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omit(object, ['a', 'c']);
         * // => { 'b': '2' }
         */
        var omit = flatRest(function(object, paths) {
          var result = {};
          if (object == null) {
            return result;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result);
          if (isDeep) {
            result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result, paths[length]);
          }
          return result;
        });

        /**
         * The opposite of `_.pickBy`; this method creates an object composed of
         * the own and inherited enumerable string keyed properties of `object` that
         * `predicate` doesn't return truthy for. The predicate is invoked with two
         * arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The source object.
         * @param {Function} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.omitBy(object, _.isNumber);
         * // => { 'b': '2' }
         */
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }

        /**
         * Creates an object composed of the picked `object` properties.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The source object.
         * @param {...(string|string[])} [paths] The property paths to pick.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pick(object, ['a', 'c']);
         * // => { 'a': 1, 'c': 3 }
         */
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });

        /**
         * Creates an object composed of the `object` properties `predicate` returns
         * truthy for. The predicate is invoked with two arguments: (value, key).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The source object.
         * @param {Function} [predicate=_.identity] The function invoked per property.
         * @returns {Object} Returns the new object.
         * @example
         *
         * var object = { 'a': 1, 'b': '2', 'c': 3 };
         *
         * _.pickBy(object, _.isNumber);
         * // => { 'a': 1, 'c': 3 }
         */
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }

        /**
         * This method is like `_.get` except that if the resolved value is a
         * function it's invoked with the `this` binding of its parent object and
         * its result is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @param {Array|string} path The path of the property to resolve.
         * @param {*} [defaultValue] The value returned for `undefined` resolved values.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
         *
         * _.result(object, 'a[0].b.c1');
         * // => 3
         *
         * _.result(object, 'a[0].b.c2');
         * // => 4
         *
         * _.result(object, 'a[0].b.c3', 'default');
         * // => 'default'
         *
         * _.result(object, 'a[0].b.c3', _.constant('default'));
         * // => 'default'
         */
        function result(object, path, defaultValue) {
          path = castPath(path, object);

          var index = -1,
              length = path.length;

          // Ensure the loop is entered when path is empty.
          if (!length) {
            length = 1;
            object = undefined$1;
          }
          while (++index < length) {
            var value = object == null ? undefined$1 : object[toKey(path[index])];
            if (value === undefined$1) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }

        /**
         * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
         * it's created. Arrays are created for missing index properties while objects
         * are created for all other missing properties. Use `_.setWith` to customize
         * `path` creation.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.set(object, 'a[0].b.c', 4);
         * console.log(object.a[0].b.c);
         * // => 4
         *
         * _.set(object, ['x', '0', 'y', 'z'], 5);
         * console.log(object.x[0].y.z);
         * // => 5
         */
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }

        /**
         * This method is like `_.set` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {*} value The value to set.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.setWith(object, '[0][1]', 'a', Object);
         * // => { '0': { '1': 'a' } }
         */
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return object == null ? object : baseSet(object, path, value, customizer);
        }

        /**
         * Creates an array of own enumerable string keyed-value pairs for `object`
         * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
         * entries are returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias entries
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the key-value pairs.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.toPairs(new Foo);
         * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
         */
        var toPairs = createToPairs(keys);

        /**
         * Creates an array of own and inherited enumerable string keyed-value pairs
         * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
         * or set, its entries are returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @alias entriesIn
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the key-value pairs.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.toPairsIn(new Foo);
         * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
         */
        var toPairsIn = createToPairs(keysIn);

        /**
         * An alternative to `_.reduce`; this method transforms `object` to a new
         * `accumulator` object which is the result of running each of its own
         * enumerable string keyed properties thru `iteratee`, with each invocation
         * potentially mutating the `accumulator` object. If `accumulator` is not
         * provided, a new object with the same `[[Prototype]]` will be used. The
         * iteratee is invoked with four arguments: (accumulator, value, key, object).
         * Iteratee functions may exit iteration early by explicitly returning `false`.
         *
         * @static
         * @memberOf _
         * @since 1.3.0
         * @category Object
         * @param {Object} object The object to iterate over.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @param {*} [accumulator] The custom accumulator value.
         * @returns {*} Returns the accumulated value.
         * @example
         *
         * _.transform([2, 3, 4], function(result, n) {
         *   result.push(n *= n);
         *   return n % 2 == 0;
         * }, []);
         * // => [4, 9]
         *
         * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
         *   (result[value] || (result[value] = [])).push(key);
         * }, {});
         * // => { '1': ['a', 'c'], '2': ['b'] }
         */
        function transform(object, iteratee, accumulator) {
          var isArr = isArray(object),
              isArrLike = isArr || isBuffer(object) || isTypedArray(object);

          iteratee = getIteratee(iteratee, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor : [];
            }
            else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            }
            else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
            return iteratee(accumulator, value, index, object);
          });
          return accumulator;
        }

        /**
         * Removes the property at `path` of `object`.
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to unset.
         * @returns {boolean} Returns `true` if the property is deleted, else `false`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 7 } }] };
         * _.unset(object, 'a[0].b.c');
         * // => true
         *
         * console.log(object);
         * // => { 'a': [{ 'b': {} }] };
         *
         * _.unset(object, ['a', '0', 'b', 'c']);
         * // => true
         *
         * console.log(object);
         * // => { 'a': [{ 'b': {} }] };
         */
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }

        /**
         * This method is like `_.set` except that accepts `updater` to produce the
         * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
         * is invoked with one argument: (value).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {Function} updater The function to produce the updated value.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = { 'a': [{ 'b': { 'c': 3 } }] };
         *
         * _.update(object, 'a[0].b.c', function(n) { return n * n; });
         * console.log(object.a[0].b.c);
         * // => 9
         *
         * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
         * console.log(object.x[0].y.z);
         * // => 0
         */
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }

        /**
         * This method is like `_.update` except that it accepts `customizer` which is
         * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
         * path creation is handled by the method instead. The `customizer` is invoked
         * with three arguments: (nsValue, key, nsObject).
         *
         * **Note:** This method mutates `object`.
         *
         * @static
         * @memberOf _
         * @since 4.6.0
         * @category Object
         * @param {Object} object The object to modify.
         * @param {Array|string} path The path of the property to set.
         * @param {Function} updater The function to produce the updated value.
         * @param {Function} [customizer] The function to customize assigned values.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var object = {};
         *
         * _.updateWith(object, '[0][1]', _.constant('a'), Object);
         * // => { '0': { '1': 'a' } }
         */
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == 'function' ? customizer : undefined$1;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }

        /**
         * Creates an array of the own enumerable string keyed property values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.values(new Foo);
         * // => [1, 2] (iteration order is not guaranteed)
         *
         * _.values('hi');
         * // => ['h', 'i']
         */
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }

        /**
         * Creates an array of the own and inherited enumerable string keyed property
         * values of `object`.
         *
         * **Note:** Non-object values are coerced to objects.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Object
         * @param {Object} object The object to query.
         * @returns {Array} Returns the array of property values.
         * @example
         *
         * function Foo() {
         *   this.a = 1;
         *   this.b = 2;
         * }
         *
         * Foo.prototype.c = 3;
         *
         * _.valuesIn(new Foo);
         * // => [1, 2, 3] (iteration order is not guaranteed)
         */
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }

        /*------------------------------------------------------------------------*/

        /**
         * Clamps `number` within the inclusive `lower` and `upper` bounds.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Number
         * @param {number} number The number to clamp.
         * @param {number} [lower] The lower bound.
         * @param {number} upper The upper bound.
         * @returns {number} Returns the clamped number.
         * @example
         *
         * _.clamp(-10, -5, 5);
         * // => -5
         *
         * _.clamp(10, -5, 5);
         * // => 5
         */
        function clamp(number, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }

        /**
         * Checks if `n` is between `start` and up to, but not including, `end`. If
         * `end` is not specified, it's set to `start` with `start` then set to `0`.
         * If `start` is greater than `end` the params are swapped to support
         * negative ranges.
         *
         * @static
         * @memberOf _
         * @since 3.3.0
         * @category Number
         * @param {number} number The number to check.
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
         * @see _.range, _.rangeRight
         * @example
         *
         * _.inRange(3, 2, 4);
         * // => true
         *
         * _.inRange(4, 8);
         * // => true
         *
         * _.inRange(4, 2);
         * // => false
         *
         * _.inRange(2, 2);
         * // => false
         *
         * _.inRange(1.2, 2);
         * // => true
         *
         * _.inRange(5.2, 4);
         * // => false
         *
         * _.inRange(-3, -2, -6);
         * // => true
         */
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }

        /**
         * Produces a random number between the inclusive `lower` and `upper` bounds.
         * If only one argument is provided a number between `0` and the given number
         * is returned. If `floating` is `true`, or either `lower` or `upper` are
         * floats, a floating-point number is returned instead of an integer.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @memberOf _
         * @since 0.7.0
         * @category Number
         * @param {number} [lower=0] The lower bound.
         * @param {number} [upper=1] The upper bound.
         * @param {boolean} [floating] Specify returning a floating-point number.
         * @returns {number} Returns the random number.
         * @example
         *
         * _.random(0, 5);
         * // => an integer between 0 and 5
         *
         * _.random(5);
         * // => also an integer between 0 and 5
         *
         * _.random(5, true);
         * // => a floating-point number between 0 and 5
         *
         * _.random(1.2, 5.2);
         * // => a floating-point number between 1.2 and 5.2
         */
        function random(lower, upper, floating) {
          if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == 'boolean') {
              floating = upper;
              upper = undefined$1;
            }
            else if (typeof lower == 'boolean') {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          }
          else {
            lower = toFinite(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
          }
          return baseRandom(lower, upper);
        }

        /*------------------------------------------------------------------------*/

        /**
         * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the camel cased string.
         * @example
         *
         * _.camelCase('Foo Bar');
         * // => 'fooBar'
         *
         * _.camelCase('--foo-bar--');
         * // => 'fooBar'
         *
         * _.camelCase('__FOO_BAR__');
         * // => 'fooBar'
         */
        var camelCase = createCompounder(function(result, word, index) {
          word = word.toLowerCase();
          return result + (index ? capitalize(word) : word);
        });

        /**
         * Converts the first character of `string` to upper case and the remaining
         * to lower case.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to capitalize.
         * @returns {string} Returns the capitalized string.
         * @example
         *
         * _.capitalize('FRED');
         * // => 'Fred'
         */
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }

        /**
         * Deburrs `string` by converting
         * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
         * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
         * letters to basic Latin letters and removing
         * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to deburr.
         * @returns {string} Returns the deburred string.
         * @example
         *
         * _.deburr('déjà vu');
         * // => 'deja vu'
         */
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
        }

        /**
         * Checks if `string` ends with the given target string.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {string} [target] The string to search for.
         * @param {number} [position=string.length] The position to search up to.
         * @returns {boolean} Returns `true` if `string` ends with `target`,
         *  else `false`.
         * @example
         *
         * _.endsWith('abc', 'c');
         * // => true
         *
         * _.endsWith('abc', 'b');
         * // => false
         *
         * _.endsWith('abc', 'b', 2);
         * // => true
         */
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);

          var length = string.length;
          position = position === undefined$1
            ? length
            : baseClamp(toInteger(position), 0, length);

          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }

        /**
         * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
         * corresponding HTML entities.
         *
         * **Note:** No other characters are escaped. To escape additional
         * characters use a third-party library like [_he_](https://mths.be/he).
         *
         * Though the ">" character is escaped for symmetry, characters like
         * ">" and "/" don't need escaping in HTML and have no special meaning
         * unless they're part of a tag or unquoted attribute value. See
         * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
         * (under "semi-related fun fact") for more details.
         *
         * When working with HTML you should always
         * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
         * XSS vectors.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escape('fred, barney, & pebbles');
         * // => 'fred, barney, &amp; pebbles'
         */
        function escape(string) {
          string = toString(string);
          return (string && reHasUnescapedHtml.test(string))
            ? string.replace(reUnescapedHtml, escapeHtmlChar)
            : string;
        }

        /**
         * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
         * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to escape.
         * @returns {string} Returns the escaped string.
         * @example
         *
         * _.escapeRegExp('[lodash](https://lodash.com/)');
         * // => '\[lodash\]\(https://lodash\.com/\)'
         */
        function escapeRegExp(string) {
          string = toString(string);
          return (string && reHasRegExpChar.test(string))
            ? string.replace(reRegExpChar, '\\$&')
            : string;
        }

        /**
         * Converts `string` to
         * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the kebab cased string.
         * @example
         *
         * _.kebabCase('Foo Bar');
         * // => 'foo-bar'
         *
         * _.kebabCase('fooBar');
         * // => 'foo-bar'
         *
         * _.kebabCase('__FOO_BAR__');
         * // => 'foo-bar'
         */
        var kebabCase = createCompounder(function(result, word, index) {
          return result + (index ? '-' : '') + word.toLowerCase();
        });

        /**
         * Converts `string`, as space separated words, to lower case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the lower cased string.
         * @example
         *
         * _.lowerCase('--Foo-Bar--');
         * // => 'foo bar'
         *
         * _.lowerCase('fooBar');
         * // => 'foo bar'
         *
         * _.lowerCase('__FOO_BAR__');
         * // => 'foo bar'
         */
        var lowerCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + word.toLowerCase();
        });

        /**
         * Converts the first character of `string` to lower case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.lowerFirst('Fred');
         * // => 'fred'
         *
         * _.lowerFirst('FRED');
         * // => 'fRED'
         */
        var lowerFirst = createCaseFirst('toLowerCase');

        /**
         * Pads `string` on the left and right sides if it's shorter than `length`.
         * Padding characters are truncated if they can't be evenly divided by `length`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.pad('abc', 8);
         * // => '  abc   '
         *
         * _.pad('abc', 8, '_-');
         * // => '_-abc_-_'
         *
         * _.pad('abc', 3);
         * // => 'abc'
         */
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return (
            createPadding(nativeFloor(mid), chars) +
            string +
            createPadding(nativeCeil(mid), chars)
          );
        }

        /**
         * Pads `string` on the right side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padEnd('abc', 6);
         * // => 'abc   '
         *
         * _.padEnd('abc', 6, '_-');
         * // => 'abc_-_'
         *
         * _.padEnd('abc', 3);
         * // => 'abc'
         */
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          return (length && strLength < length)
            ? (string + createPadding(length - strLength, chars))
            : string;
        }

        /**
         * Pads `string` on the left side if it's shorter than `length`. Padding
         * characters are truncated if they exceed `length`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to pad.
         * @param {number} [length=0] The padding length.
         * @param {string} [chars=' '] The string used as padding.
         * @returns {string} Returns the padded string.
         * @example
         *
         * _.padStart('abc', 6);
         * // => '   abc'
         *
         * _.padStart('abc', 6, '_-');
         * // => '_-_abc'
         *
         * _.padStart('abc', 3);
         * // => 'abc'
         */
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);

          var strLength = length ? stringSize(string) : 0;
          return (length && strLength < length)
            ? (createPadding(length - strLength, chars) + string)
            : string;
        }

        /**
         * Converts `string` to an integer of the specified radix. If `radix` is
         * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
         * hexadecimal, in which case a `radix` of `16` is used.
         *
         * **Note:** This method aligns with the
         * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category String
         * @param {string} string The string to convert.
         * @param {number} [radix=10] The radix to interpret `value` by.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {number} Returns the converted integer.
         * @example
         *
         * _.parseInt('08');
         * // => 8
         *
         * _.map(['6', '08', '10'], _.parseInt);
         * // => [6, 8, 10]
         */
        function parseInt(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
        }

        /**
         * Repeats the given string `n` times.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to repeat.
         * @param {number} [n=1] The number of times to repeat the string.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the repeated string.
         * @example
         *
         * _.repeat('*', 3);
         * // => '***'
         *
         * _.repeat('abc', 2);
         * // => 'abcabc'
         *
         * _.repeat('abc', 0);
         * // => ''
         */
        function repeat(string, n, guard) {
          if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }

        /**
         * Replaces matches for `pattern` in `string` with `replacement`.
         *
         * **Note:** This method is based on
         * [`String#replace`](https://mdn.io/String/replace).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to modify.
         * @param {RegExp|string} pattern The pattern to replace.
         * @param {Function|string} replacement The match replacement.
         * @returns {string} Returns the modified string.
         * @example
         *
         * _.replace('Hi Fred', 'Fred', 'Barney');
         * // => 'Hi Barney'
         */
        function replace() {
          var args = arguments,
              string = toString(args[0]);

          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }

        /**
         * Converts `string` to
         * [snake case](https://en.wikipedia.org/wiki/Snake_case).
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the snake cased string.
         * @example
         *
         * _.snakeCase('Foo Bar');
         * // => 'foo_bar'
         *
         * _.snakeCase('fooBar');
         * // => 'foo_bar'
         *
         * _.snakeCase('--FOO-BAR--');
         * // => 'foo_bar'
         */
        var snakeCase = createCompounder(function(result, word, index) {
          return result + (index ? '_' : '') + word.toLowerCase();
        });

        /**
         * Splits `string` by `separator`.
         *
         * **Note:** This method is based on
         * [`String#split`](https://mdn.io/String/split).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to split.
         * @param {RegExp|string} separator The separator pattern to split by.
         * @param {number} [limit] The length to truncate results to.
         * @returns {Array} Returns the string segments.
         * @example
         *
         * _.split('a-b-c', '-', 2);
         * // => ['a', 'b']
         */
        function split(string, separator, limit) {
          if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (
                typeof separator == 'string' ||
                (separator != null && !isRegExp(separator))
              )) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }

        /**
         * Converts `string` to
         * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
         *
         * @static
         * @memberOf _
         * @since 3.1.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the start cased string.
         * @example
         *
         * _.startCase('--foo-bar--');
         * // => 'Foo Bar'
         *
         * _.startCase('fooBar');
         * // => 'Foo Bar'
         *
         * _.startCase('__FOO_BAR__');
         * // => 'FOO BAR'
         */
        var startCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + upperFirst(word);
        });

        /**
         * Checks if `string` starts with the given target string.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {string} [target] The string to search for.
         * @param {number} [position=0] The position to search from.
         * @returns {boolean} Returns `true` if `string` starts with `target`,
         *  else `false`.
         * @example
         *
         * _.startsWith('abc', 'a');
         * // => true
         *
         * _.startsWith('abc', 'b');
         * // => false
         *
         * _.startsWith('abc', 'b', 1);
         * // => true
         */
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null
            ? 0
            : baseClamp(toInteger(position), 0, string.length);

          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }

        /**
         * Creates a compiled template function that can interpolate data properties
         * in "interpolate" delimiters, HTML-escape interpolated data properties in
         * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
         * properties may be accessed as free variables in the template. If a setting
         * object is given, it takes precedence over `_.templateSettings` values.
         *
         * **Note:** In the development build `_.template` utilizes
         * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
         * for easier debugging.
         *
         * For more information on precompiling templates see
         * [lodash's custom builds documentation](https://lodash.com/custom-builds).
         *
         * For more information on Chrome extension sandboxes see
         * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category String
         * @param {string} [string=''] The template string.
         * @param {Object} [options={}] The options object.
         * @param {RegExp} [options.escape=_.templateSettings.escape]
         *  The HTML "escape" delimiter.
         * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
         *  The "evaluate" delimiter.
         * @param {Object} [options.imports=_.templateSettings.imports]
         *  An object to import into the template as free variables.
         * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
         *  The "interpolate" delimiter.
         * @param {string} [options.sourceURL='lodash.templateSources[n]']
         *  The sourceURL of the compiled template.
         * @param {string} [options.variable='obj']
         *  The data object variable name.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Function} Returns the compiled template function.
         * @example
         *
         * // Use the "interpolate" delimiter to create a compiled template.
         * var compiled = _.template('hello <%= user %>!');
         * compiled({ 'user': 'fred' });
         * // => 'hello fred!'
         *
         * // Use the HTML "escape" delimiter to escape data property values.
         * var compiled = _.template('<b><%- value %></b>');
         * compiled({ 'value': '<script>' });
         * // => '<b>&lt;script&gt;</b>'
         *
         * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
         * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the internal `print` function in "evaluate" delimiters.
         * var compiled = _.template('<% print("hello " + user); %>!');
         * compiled({ 'user': 'barney' });
         * // => 'hello barney!'
         *
         * // Use the ES template literal delimiter as an "interpolate" delimiter.
         * // Disable support by replacing the "interpolate" delimiter.
         * var compiled = _.template('hello ${ user }!');
         * compiled({ 'user': 'pebbles' });
         * // => 'hello pebbles!'
         *
         * // Use backslashes to treat delimiters as plain text.
         * var compiled = _.template('<%= "\\<%- value %\\>" %>');
         * compiled({ 'value': 'ignored' });
         * // => '<%- value %>'
         *
         * // Use the `imports` option to import `jQuery` as `jq`.
         * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
         * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
         * compiled({ 'users': ['fred', 'barney'] });
         * // => '<li>fred</li><li>barney</li>'
         *
         * // Use the `sourceURL` option to specify a custom sourceURL for the template.
         * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
         * compiled(data);
         * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
         *
         * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
         * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
         * compiled.source;
         * // => function(data) {
         * //   var __t, __p = '';
         * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
         * //   return __p;
         * // }
         *
         * // Use custom template delimiters.
         * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
         * var compiled = _.template('hello {{ user }}!');
         * compiled({ 'user': 'mustache' });
         * // => 'hello mustache!'
         *
         * // Use the `source` property to inline compiled templates for meaningful
         * // line numbers in error messages and stack traces.
         * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
         *   var JST = {\
         *     "main": ' + _.template(mainText).source + '\
         *   };\
         * ');
         */
        function template(string, options, guard) {
          // Based on John Resig's `tmpl` implementation
          // (http://ejohn.org/blog/javascript-micro-templating/)
          // and Laura Doktorova's doT.js (https://github.com/olado/doT).
          var settings = lodash.templateSettings;

          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined$1;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);

          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);

          var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";

          // Compile the regexp to match each delimiter.
          var reDelimiters = RegExp(
            (options.escape || reNoMatch).source + '|' +
            interpolate.source + '|' +
            (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
            (options.evaluate || reNoMatch).source + '|$'
          , 'g');

          // Use a sourceURL for easier debugging.
          // The sourceURL gets injected into the source that's eval-ed, so be careful
          // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
          // and escape the comment, thus injecting code that gets evaled.
          var sourceURL = '//# sourceURL=' +
            (hasOwnProperty.call(options, 'sourceURL')
              ? (options.sourceURL + '').replace(/\s/g, ' ')
              : ('lodash.templateSources[' + (++templateCounter) + ']')
            ) + '\n';

          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);

            // Escape characters that can't be included in string literals.
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

            // Replace delimiters with snippets.
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;

            // The JS engine embedded in Adobe products needs `match` returned in
            // order to produce the correct `offset` value.
            return match;
          });

          source += "';\n";

          // If `variable` is not specified wrap a with-statement around the generated
          // code to add the data object to the top of the scope chain.
          var variable = hasOwnProperty.call(options, 'variable') && options.variable;
          if (!variable) {
            source = 'with (obj) {\n' + source + '\n}\n';
          }
          // Cleanup code by stripping empty strings.
          source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
            .replace(reEmptyStringMiddle, '$1')
            .replace(reEmptyStringTrailing, '$1;');

          // Frame code as the function body.
          source = 'function(' + (variable || 'obj') + ') {\n' +
            (variable
              ? ''
              : 'obj || (obj = {});\n'
            ) +
            "var __t, __p = ''" +
            (isEscaping
               ? ', __e = _.escape'
               : ''
            ) +
            (isEvaluating
              ? ', __j = Array.prototype.join;\n' +
                "function print() { __p += __j.call(arguments, '') }\n"
              : ';\n'
            ) +
            source +
            'return __p\n}';

          var result = attempt(function() {
            return Function(importsKeys, sourceURL + 'return ' + source)
              .apply(undefined$1, importsValues);
          });

          // Provide the compiled function's source by its `toString` method or
          // the `source` property as a convenience for inlining compiled templates.
          result.source = source;
          if (isError(result)) {
            throw result;
          }
          return result;
        }

        /**
         * Converts `string`, as a whole, to lower case just like
         * [String#toLowerCase](https://mdn.io/toLowerCase).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the lower cased string.
         * @example
         *
         * _.toLower('--Foo-Bar--');
         * // => '--foo-bar--'
         *
         * _.toLower('fooBar');
         * // => 'foobar'
         *
         * _.toLower('__FOO_BAR__');
         * // => '__foo_bar__'
         */
        function toLower(value) {
          return toString(value).toLowerCase();
        }

        /**
         * Converts `string`, as a whole, to upper case just like
         * [String#toUpperCase](https://mdn.io/toUpperCase).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the upper cased string.
         * @example
         *
         * _.toUpper('--foo-bar--');
         * // => '--FOO-BAR--'
         *
         * _.toUpper('fooBar');
         * // => 'FOOBAR'
         *
         * _.toUpper('__foo_bar__');
         * // => '__FOO_BAR__'
         */
        function toUpper(value) {
          return toString(value).toUpperCase();
        }

        /**
         * Removes leading and trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trim('  abc  ');
         * // => 'abc'
         *
         * _.trim('-_-abc-_-', '_-');
         * // => 'abc'
         *
         * _.map(['  foo  ', '  bar  '], _.trim);
         * // => ['foo', 'bar']
         */
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrim, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              chrSymbols = stringToArray(chars),
              start = charsStartIndex(strSymbols, chrSymbols),
              end = charsEndIndex(strSymbols, chrSymbols) + 1;

          return castSlice(strSymbols, start, end).join('');
        }

        /**
         * Removes trailing whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimEnd('  abc  ');
         * // => '  abc'
         *
         * _.trimEnd('-_-abc-_-', '_-');
         * // => '-_-abc'
         */
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimEnd, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

          return castSlice(strSymbols, 0, end).join('');
        }

        /**
         * Removes leading whitespace or specified characters from `string`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to trim.
         * @param {string} [chars=whitespace] The characters to trim.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {string} Returns the trimmed string.
         * @example
         *
         * _.trimStart('  abc  ');
         * // => 'abc  '
         *
         * _.trimStart('-_-abc-_-', '_-');
         * // => 'abc-_-'
         */
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined$1)) {
            return string.replace(reTrimStart, '');
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string),
              start = charsStartIndex(strSymbols, stringToArray(chars));

          return castSlice(strSymbols, start).join('');
        }

        /**
         * Truncates `string` if it's longer than the given maximum string length.
         * The last characters of the truncated string are replaced with the omission
         * string which defaults to "...".
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to truncate.
         * @param {Object} [options={}] The options object.
         * @param {number} [options.length=30] The maximum string length.
         * @param {string} [options.omission='...'] The string to indicate text is omitted.
         * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
         * @returns {string} Returns the truncated string.
         * @example
         *
         * _.truncate('hi-diddly-ho there, neighborino');
         * // => 'hi-diddly-ho there, neighbo...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': ' '
         * });
         * // => 'hi-diddly-ho there,...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'length': 24,
         *   'separator': /,? +/
         * });
         * // => 'hi-diddly-ho there...'
         *
         * _.truncate('hi-diddly-ho there, neighborino', {
         *   'omission': ' [...]'
         * });
         * // => 'hi-diddly-ho there, neig [...]'
         */
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;

          if (isObject(options)) {
            var separator = 'separator' in options ? options.separator : separator;
            length = 'length' in options ? toInteger(options.length) : length;
            omission = 'omission' in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);

          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result = strSymbols
            ? castSlice(strSymbols, 0, end).join('')
            : string.slice(0, end);

          if (separator === undefined$1) {
            return result + omission;
          }
          if (strSymbols) {
            end += (result.length - end);
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match,
                  substring = result;

              if (!separator.global) {
                separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
              }
              separator.lastIndex = 0;
              while ((match = separator.exec(substring))) {
                var newEnd = match.index;
              }
              result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result.lastIndexOf(separator);
            if (index > -1) {
              result = result.slice(0, index);
            }
          }
          return result + omission;
        }

        /**
         * The inverse of `_.escape`; this method converts the HTML entities
         * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
         * their corresponding characters.
         *
         * **Note:** No other HTML entities are unescaped. To unescape additional
         * HTML entities use a third-party library like [_he_](https://mths.be/he).
         *
         * @static
         * @memberOf _
         * @since 0.6.0
         * @category String
         * @param {string} [string=''] The string to unescape.
         * @returns {string} Returns the unescaped string.
         * @example
         *
         * _.unescape('fred, barney, &amp; pebbles');
         * // => 'fred, barney, & pebbles'
         */
        function unescape(string) {
          string = toString(string);
          return (string && reHasEscapedHtml.test(string))
            ? string.replace(reEscapedHtml, unescapeHtmlChar)
            : string;
        }

        /**
         * Converts `string`, as space separated words, to upper case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the upper cased string.
         * @example
         *
         * _.upperCase('--foo-bar');
         * // => 'FOO BAR'
         *
         * _.upperCase('fooBar');
         * // => 'FOO BAR'
         *
         * _.upperCase('__foo_bar__');
         * // => 'FOO BAR'
         */
        var upperCase = createCompounder(function(result, word, index) {
          return result + (index ? ' ' : '') + word.toUpperCase();
        });

        /**
         * Converts the first character of `string` to upper case.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category String
         * @param {string} [string=''] The string to convert.
         * @returns {string} Returns the converted string.
         * @example
         *
         * _.upperFirst('fred');
         * // => 'Fred'
         *
         * _.upperFirst('FRED');
         * // => 'FRED'
         */
        var upperFirst = createCaseFirst('toUpperCase');

        /**
         * Splits `string` into an array of its words.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category String
         * @param {string} [string=''] The string to inspect.
         * @param {RegExp|string} [pattern] The pattern to match words.
         * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
         * @returns {Array} Returns the words of `string`.
         * @example
         *
         * _.words('fred, barney, & pebbles');
         * // => ['fred', 'barney', 'pebbles']
         *
         * _.words('fred, barney, & pebbles', /[^, ]+/g);
         * // => ['fred', 'barney', '&', 'pebbles']
         */
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined$1 : pattern;

          if (pattern === undefined$1) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }

        /*------------------------------------------------------------------------*/

        /**
         * Attempts to invoke `func`, returning either the result or the caught error
         * object. Any additional arguments are provided to `func` when it's invoked.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Function} func The function to attempt.
         * @param {...*} [args] The arguments to invoke `func` with.
         * @returns {*} Returns the `func` result or error object.
         * @example
         *
         * // Avoid throwing errors for invalid selectors.
         * var elements = _.attempt(function(selector) {
         *   return document.querySelectorAll(selector);
         * }, '>_>');
         *
         * if (_.isError(elements)) {
         *   elements = [];
         * }
         */
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e) {
            return isError(e) ? e : new Error(e);
          }
        });

        /**
         * Binds methods of an object to the object itself, overwriting the existing
         * method.
         *
         * **Note:** This method doesn't set the "length" property of bound functions.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {Object} object The object to bind and assign the bound methods to.
         * @param {...(string|string[])} methodNames The object method names to bind.
         * @returns {Object} Returns `object`.
         * @example
         *
         * var view = {
         *   'label': 'docs',
         *   'click': function() {
         *     console.log('clicked ' + this.label);
         *   }
         * };
         *
         * _.bindAll(view, ['click']);
         * jQuery(element).on('click', view.click);
         * // => Logs 'clicked docs' when clicked.
         */
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });

        /**
         * Creates a function that iterates over `pairs` and invokes the corresponding
         * function of the first predicate to return truthy. The predicate-function
         * pairs are invoked with the `this` binding and arguments of the created
         * function.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {Array} pairs The predicate-function pairs.
         * @returns {Function} Returns the new composite function.
         * @example
         *
         * var func = _.cond([
         *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
         *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
         *   [_.stubTrue,                      _.constant('no match')]
         * ]);
         *
         * func({ 'a': 1, 'b': 2 });
         * // => 'matches A'
         *
         * func({ 'a': 0, 'b': 1 });
         * // => 'matches B'
         *
         * func({ 'a': '1', 'b': '2' });
         * // => 'no match'
         */
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length,
              toIteratee = getIteratee();

          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });

          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }

        /**
         * Creates a function that invokes the predicate properties of `source` with
         * the corresponding property values of a given object, returning `true` if
         * all predicates return truthy, else `false`.
         *
         * **Note:** The created function is equivalent to `_.conformsTo` with
         * `source` partially applied.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {Object} source The object of property predicates to conform to.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 2, 'b': 1 },
         *   { 'a': 1, 'b': 2 }
         * ];
         *
         * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
         * // => [{ 'a': 1, 'b': 2 }]
         */
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that returns `value`.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {*} value The value to return from the new function.
         * @returns {Function} Returns the new constant function.
         * @example
         *
         * var objects = _.times(2, _.constant({ 'a': 1 }));
         *
         * console.log(objects);
         * // => [{ 'a': 1 }, { 'a': 1 }]
         *
         * console.log(objects[0] === objects[1]);
         * // => true
         */
        function constant(value) {
          return function() {
            return value;
          };
        }

        /**
         * Checks `value` to determine whether a default value should be returned in
         * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
         * or `undefined`.
         *
         * @static
         * @memberOf _
         * @since 4.14.0
         * @category Util
         * @param {*} value The value to check.
         * @param {*} defaultValue The default value.
         * @returns {*} Returns the resolved value.
         * @example
         *
         * _.defaultTo(1, 10);
         * // => 1
         *
         * _.defaultTo(undefined, 10);
         * // => 10
         */
        function defaultTo(value, defaultValue) {
          return (value == null || value !== value) ? defaultValue : value;
        }

        /**
         * Creates a function that returns the result of invoking the given functions
         * with the `this` binding of the created function, where each successive
         * invocation is supplied the return value of the previous.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {...(Function|Function[])} [funcs] The functions to invoke.
         * @returns {Function} Returns the new composite function.
         * @see _.flowRight
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flow([_.add, square]);
         * addSquare(1, 2);
         * // => 9
         */
        var flow = createFlow();

        /**
         * This method is like `_.flow` except that it creates a function that
         * invokes the given functions from right to left.
         *
         * @static
         * @since 3.0.0
         * @memberOf _
         * @category Util
         * @param {...(Function|Function[])} [funcs] The functions to invoke.
         * @returns {Function} Returns the new composite function.
         * @see _.flow
         * @example
         *
         * function square(n) {
         *   return n * n;
         * }
         *
         * var addSquare = _.flowRight([square, _.add]);
         * addSquare(1, 2);
         * // => 9
         */
        var flowRight = createFlow(true);

        /**
         * This method returns the first argument it receives.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {*} value Any value.
         * @returns {*} Returns `value`.
         * @example
         *
         * var object = { 'a': 1 };
         *
         * console.log(_.identity(object) === object);
         * // => true
         */
        function identity(value) {
          return value;
        }

        /**
         * Creates a function that invokes `func` with the arguments of the created
         * function. If `func` is a property name, the created function returns the
         * property value for a given element. If `func` is an array or object, the
         * created function returns `true` for elements that contain the equivalent
         * source properties, otherwise it returns `false`.
         *
         * @static
         * @since 4.0.0
         * @memberOf _
         * @category Util
         * @param {*} [func=_.identity] The value to convert to a callback.
         * @returns {Function} Returns the callback.
         * @example
         *
         * var users = [
         *   { 'user': 'barney', 'age': 36, 'active': true },
         *   { 'user': 'fred',   'age': 40, 'active': false }
         * ];
         *
         * // The `_.matches` iteratee shorthand.
         * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
         * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
         *
         * // The `_.matchesProperty` iteratee shorthand.
         * _.filter(users, _.iteratee(['user', 'fred']));
         * // => [{ 'user': 'fred', 'age': 40 }]
         *
         * // The `_.property` iteratee shorthand.
         * _.map(users, _.iteratee('user'));
         * // => ['barney', 'fred']
         *
         * // Create custom iteratee shorthands.
         * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
         *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
         *     return func.test(string);
         *   };
         * });
         *
         * _.filter(['abc', 'def'], /ef/);
         * // => ['def']
         */
        function iteratee(func) {
          return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that performs a partial deep comparison between a given
         * object and `source`, returning `true` if the given object has equivalent
         * property values, else `false`.
         *
         * **Note:** The created function is equivalent to `_.isMatch` with `source`
         * partially applied.
         *
         * Partial comparisons will match empty array and empty object `source`
         * values against any array or object value, respectively. See `_.isEqual`
         * for a list of supported value comparisons.
         *
         * **Note:** Multiple values can be checked by combining several matchers
         * using `_.overSome`
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Object} source The object of property values to match.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 1, 'b': 2, 'c': 3 },
         *   { 'a': 4, 'b': 5, 'c': 6 }
         * ];
         *
         * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
         * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
         *
         * // Checking for several possible values
         * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
         * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
         */
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that performs a partial deep comparison between the
         * value at `path` of a given object to `srcValue`, returning `true` if the
         * object value is equivalent, else `false`.
         *
         * **Note:** Partial comparisons will match empty array and empty object
         * `srcValue` values against any array or object value, respectively. See
         * `_.isEqual` for a list of supported value comparisons.
         *
         * **Note:** Multiple values can be checked by combining several matchers
         * using `_.overSome`
         *
         * @static
         * @memberOf _
         * @since 3.2.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @param {*} srcValue The value to match.
         * @returns {Function} Returns the new spec function.
         * @example
         *
         * var objects = [
         *   { 'a': 1, 'b': 2, 'c': 3 },
         *   { 'a': 4, 'b': 5, 'c': 6 }
         * ];
         *
         * _.find(objects, _.matchesProperty('a', 4));
         * // => { 'a': 4, 'b': 5, 'c': 6 }
         *
         * // Checking for several possible values
         * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
         * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
         */
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }

        /**
         * Creates a function that invokes the method at `path` of a given object.
         * Any additional arguments are provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Util
         * @param {Array|string} path The path of the method to invoke.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new invoker function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': _.constant(2) } },
         *   { 'a': { 'b': _.constant(1) } }
         * ];
         *
         * _.map(objects, _.method('a.b'));
         * // => [2, 1]
         *
         * _.map(objects, _.method(['a', 'b']));
         * // => [2, 1]
         */
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });

        /**
         * The opposite of `_.method`; this method creates a function that invokes
         * the method at a given path of `object`. Any additional arguments are
         * provided to the invoked method.
         *
         * @static
         * @memberOf _
         * @since 3.7.0
         * @category Util
         * @param {Object} object The object to query.
         * @param {...*} [args] The arguments to invoke the method with.
         * @returns {Function} Returns the new invoker function.
         * @example
         *
         * var array = _.times(3, _.constant),
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.methodOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
         * // => [2, 0]
         */
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });

        /**
         * Adds all own enumerable string keyed function properties of a source
         * object to the destination object. If `object` is a function, then methods
         * are added to its prototype as well.
         *
         * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
         * avoid conflicts caused by modifying the original.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {Function|Object} [object=lodash] The destination object.
         * @param {Object} source The object of functions to add.
         * @param {Object} [options={}] The options object.
         * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
         * @returns {Function|Object} Returns `object`.
         * @example
         *
         * function vowels(string) {
         *   return _.filter(string, function(v) {
         *     return /[aeiou]/i.test(v);
         *   });
         * }
         *
         * _.mixin({ 'vowels': vowels });
         * _.vowels('fred');
         * // => ['e']
         *
         * _('fred').vowels().value();
         * // => ['e']
         *
         * _.mixin({ 'vowels': vowels }, { 'chain': false });
         * _('fred').vowels();
         * // => ['e']
         */
        function mixin(object, source, options) {
          var props = keys(source),
              methodNames = baseFunctions(source, props);

          if (options == null &&
              !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
              isFunc = isFunction(object);

          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain || chainAll) {
                  var result = object(this.__wrapped__),
                      actions = result.__actions__ = copyArray(this.__actions__);

                  actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
                  result.__chain__ = chainAll;
                  return result;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });

          return object;
        }

        /**
         * Reverts the `_` variable to its previous value and returns a reference to
         * the `lodash` function.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @returns {Function} Returns the `lodash` function.
         * @example
         *
         * var lodash = _.noConflict();
         */
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }

        /**
         * This method returns `undefined`.
         *
         * @static
         * @memberOf _
         * @since 2.3.0
         * @category Util
         * @example
         *
         * _.times(2, _.noop);
         * // => [undefined, undefined]
         */
        function noop() {
          // No operation performed.
        }

        /**
         * Creates a function that gets the argument at index `n`. If `n` is negative,
         * the nth argument from the end is returned.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {number} [n=0] The index of the argument to return.
         * @returns {Function} Returns the new pass-thru function.
         * @example
         *
         * var func = _.nthArg(1);
         * func('a', 'b', 'c', 'd');
         * // => 'b'
         *
         * var func = _.nthArg(-2);
         * func('a', 'b', 'c', 'd');
         * // => 'c'
         */
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }

        /**
         * Creates a function that invokes `iteratees` with the arguments it receives
         * and returns their results.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [iteratees=[_.identity]]
         *  The iteratees to invoke.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.over([Math.max, Math.min]);
         *
         * func(1, 2, 3, 4);
         * // => [4, 1]
         */
        var over = createOver(arrayMap);

        /**
         * Creates a function that checks if **all** of the `predicates` return
         * truthy when invoked with the arguments it receives.
         *
         * Following shorthands are possible for providing predicates.
         * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
         * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [predicates=[_.identity]]
         *  The predicates to check.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.overEvery([Boolean, isFinite]);
         *
         * func('1');
         * // => true
         *
         * func(null);
         * // => false
         *
         * func(NaN);
         * // => false
         */
        var overEvery = createOver(arrayEvery);

        /**
         * Creates a function that checks if **any** of the `predicates` return
         * truthy when invoked with the arguments it receives.
         *
         * Following shorthands are possible for providing predicates.
         * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
         * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {...(Function|Function[])} [predicates=[_.identity]]
         *  The predicates to check.
         * @returns {Function} Returns the new function.
         * @example
         *
         * var func = _.overSome([Boolean, isFinite]);
         *
         * func('1');
         * // => true
         *
         * func(null);
         * // => true
         *
         * func(NaN);
         * // => false
         *
         * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
         * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
         */
        var overSome = createOver(arraySome);

        /**
         * Creates a function that returns the value at `path` of a given object.
         *
         * @static
         * @memberOf _
         * @since 2.4.0
         * @category Util
         * @param {Array|string} path The path of the property to get.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var objects = [
         *   { 'a': { 'b': 2 } },
         *   { 'a': { 'b': 1 } }
         * ];
         *
         * _.map(objects, _.property('a.b'));
         * // => [2, 1]
         *
         * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
         * // => [1, 2]
         */
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }

        /**
         * The opposite of `_.property`; this method creates a function that returns
         * the value at a given path of `object`.
         *
         * @static
         * @memberOf _
         * @since 3.0.0
         * @category Util
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new accessor function.
         * @example
         *
         * var array = [0, 1, 2],
         *     object = { 'a': array, 'b': array, 'c': array };
         *
         * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
         * // => [2, 0]
         *
         * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
         * // => [2, 0]
         */
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined$1 : baseGet(object, path);
          };
        }

        /**
         * Creates an array of numbers (positive and/or negative) progressing from
         * `start` up to, but not including, `end`. A step of `-1` is used if a negative
         * `start` is specified without an `end` or `step`. If `end` is not specified,
         * it's set to `start` with `start` then set to `0`.
         *
         * **Note:** JavaScript follows the IEEE-754 standard for resolving
         * floating-point values which can produce unexpected results.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.rangeRight
         * @example
         *
         * _.range(4);
         * // => [0, 1, 2, 3]
         *
         * _.range(-4);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 5);
         * // => [1, 2, 3, 4]
         *
         * _.range(0, 20, 5);
         * // => [0, 5, 10, 15]
         *
         * _.range(0, -4, -1);
         * // => [0, -1, -2, -3]
         *
         * _.range(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.range(0);
         * // => []
         */
        var range = createRange();

        /**
         * This method is like `_.range` except that it populates values in
         * descending order.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {number} [start=0] The start of the range.
         * @param {number} end The end of the range.
         * @param {number} [step=1] The value to increment or decrement by.
         * @returns {Array} Returns the range of numbers.
         * @see _.inRange, _.range
         * @example
         *
         * _.rangeRight(4);
         * // => [3, 2, 1, 0]
         *
         * _.rangeRight(-4);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 5);
         * // => [4, 3, 2, 1]
         *
         * _.rangeRight(0, 20, 5);
         * // => [15, 10, 5, 0]
         *
         * _.rangeRight(0, -4, -1);
         * // => [-3, -2, -1, 0]
         *
         * _.rangeRight(1, 4, 0);
         * // => [1, 1, 1]
         *
         * _.rangeRight(0);
         * // => []
         */
        var rangeRight = createRange(true);

        /**
         * This method returns a new empty array.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Array} Returns the new empty array.
         * @example
         *
         * var arrays = _.times(2, _.stubArray);
         *
         * console.log(arrays);
         * // => [[], []]
         *
         * console.log(arrays[0] === arrays[1]);
         * // => false
         */
        function stubArray() {
          return [];
        }

        /**
         * This method returns `false`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `false`.
         * @example
         *
         * _.times(2, _.stubFalse);
         * // => [false, false]
         */
        function stubFalse() {
          return false;
        }

        /**
         * This method returns a new empty object.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {Object} Returns the new empty object.
         * @example
         *
         * var objects = _.times(2, _.stubObject);
         *
         * console.log(objects);
         * // => [{}, {}]
         *
         * console.log(objects[0] === objects[1]);
         * // => false
         */
        function stubObject() {
          return {};
        }

        /**
         * This method returns an empty string.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {string} Returns the empty string.
         * @example
         *
         * _.times(2, _.stubString);
         * // => ['', '']
         */
        function stubString() {
          return '';
        }

        /**
         * This method returns `true`.
         *
         * @static
         * @memberOf _
         * @since 4.13.0
         * @category Util
         * @returns {boolean} Returns `true`.
         * @example
         *
         * _.times(2, _.stubTrue);
         * // => [true, true]
         */
        function stubTrue() {
          return true;
        }

        /**
         * Invokes the iteratee `n` times, returning an array of the results of
         * each invocation. The iteratee is invoked with one argument; (index).
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} [iteratee=_.identity] The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         * @example
         *
         * _.times(3, String);
         * // => ['0', '1', '2']
         *
         *  _.times(4, _.constant(0));
         * // => [0, 0, 0, 0]
         */
        function times(n, iteratee) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH,
              length = nativeMin(n, MAX_ARRAY_LENGTH);

          iteratee = getIteratee(iteratee);
          n -= MAX_ARRAY_LENGTH;

          var result = baseTimes(length, iteratee);
          while (++index < n) {
            iteratee(index);
          }
          return result;
        }

        /**
         * Converts `value` to a property path array.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Util
         * @param {*} value The value to convert.
         * @returns {Array} Returns the new property path array.
         * @example
         *
         * _.toPath('a.b.c');
         * // => ['a', 'b', 'c']
         *
         * _.toPath('a[0].b.c');
         * // => ['a', '0', 'b', 'c']
         */
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }

        /**
         * Generates a unique ID. If `prefix` is given, the ID is appended to it.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Util
         * @param {string} [prefix=''] The value to prefix the ID with.
         * @returns {string} Returns the unique ID.
         * @example
         *
         * _.uniqueId('contact_');
         * // => 'contact_104'
         *
         * _.uniqueId();
         * // => '105'
         */
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }

        /*------------------------------------------------------------------------*/

        /**
         * Adds two numbers.
         *
         * @static
         * @memberOf _
         * @since 3.4.0
         * @category Math
         * @param {number} augend The first number in an addition.
         * @param {number} addend The second number in an addition.
         * @returns {number} Returns the total.
         * @example
         *
         * _.add(6, 4);
         * // => 10
         */
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);

        /**
         * Computes `number` rounded up to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round up.
         * @param {number} [precision=0] The precision to round up to.
         * @returns {number} Returns the rounded up number.
         * @example
         *
         * _.ceil(4.006);
         * // => 5
         *
         * _.ceil(6.004, 2);
         * // => 6.01
         *
         * _.ceil(6040, -2);
         * // => 6100
         */
        var ceil = createRound('ceil');

        /**
         * Divide two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {number} dividend The first number in a division.
         * @param {number} divisor The second number in a division.
         * @returns {number} Returns the quotient.
         * @example
         *
         * _.divide(6, 4);
         * // => 1.5
         */
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);

        /**
         * Computes `number` rounded down to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round down.
         * @param {number} [precision=0] The precision to round down to.
         * @returns {number} Returns the rounded down number.
         * @example
         *
         * _.floor(4.006);
         * // => 4
         *
         * _.floor(0.046, 2);
         * // => 0.04
         *
         * _.floor(4060, -2);
         * // => 4000
         */
        var floor = createRound('floor');

        /**
         * Computes the maximum value of `array`. If `array` is empty or falsey,
         * `undefined` is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * _.max([4, 2, 8, 6]);
         * // => 8
         *
         * _.max([]);
         * // => undefined
         */
        function max(array) {
          return (array && array.length)
            ? baseExtremum(array, identity, baseGt)
            : undefined$1;
        }

        /**
         * This method is like `_.max` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {*} Returns the maximum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.maxBy(objects, function(o) { return o.n; });
         * // => { 'n': 2 }
         *
         * // The `_.property` iteratee shorthand.
         * _.maxBy(objects, 'n');
         * // => { 'n': 2 }
         */
        function maxBy(array, iteratee) {
          return (array && array.length)
            ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
            : undefined$1;
        }

        /**
         * Computes the mean of the values in `array`.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the mean.
         * @example
         *
         * _.mean([4, 2, 8, 6]);
         * // => 5
         */
        function mean(array) {
          return baseMean(array, identity);
        }

        /**
         * This method is like `_.mean` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the value to be averaged.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the mean.
         * @example
         *
         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
         *
         * _.meanBy(objects, function(o) { return o.n; });
         * // => 5
         *
         * // The `_.property` iteratee shorthand.
         * _.meanBy(objects, 'n');
         * // => 5
         */
        function meanBy(array, iteratee) {
          return baseMean(array, getIteratee(iteratee, 2));
        }

        /**
         * Computes the minimum value of `array`. If `array` is empty or falsey,
         * `undefined` is returned.
         *
         * @static
         * @since 0.1.0
         * @memberOf _
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * _.min([4, 2, 8, 6]);
         * // => 2
         *
         * _.min([]);
         * // => undefined
         */
        function min(array) {
          return (array && array.length)
            ? baseExtremum(array, identity, baseLt)
            : undefined$1;
        }

        /**
         * This method is like `_.min` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the criterion by which
         * the value is ranked. The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {*} Returns the minimum value.
         * @example
         *
         * var objects = [{ 'n': 1 }, { 'n': 2 }];
         *
         * _.minBy(objects, function(o) { return o.n; });
         * // => { 'n': 1 }
         *
         * // The `_.property` iteratee shorthand.
         * _.minBy(objects, 'n');
         * // => { 'n': 1 }
         */
        function minBy(array, iteratee) {
          return (array && array.length)
            ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
            : undefined$1;
        }

        /**
         * Multiply two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.7.0
         * @category Math
         * @param {number} multiplier The first number in a multiplication.
         * @param {number} multiplicand The second number in a multiplication.
         * @returns {number} Returns the product.
         * @example
         *
         * _.multiply(6, 4);
         * // => 24
         */
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);

        /**
         * Computes `number` rounded to `precision`.
         *
         * @static
         * @memberOf _
         * @since 3.10.0
         * @category Math
         * @param {number} number The number to round.
         * @param {number} [precision=0] The precision to round to.
         * @returns {number} Returns the rounded number.
         * @example
         *
         * _.round(4.006);
         * // => 4
         *
         * _.round(4.006, 2);
         * // => 4.01
         *
         * _.round(4060, -2);
         * // => 4100
         */
        var round = createRound('round');

        /**
         * Subtract two numbers.
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {number} minuend The first number in a subtraction.
         * @param {number} subtrahend The second number in a subtraction.
         * @returns {number} Returns the difference.
         * @example
         *
         * _.subtract(6, 4);
         * // => 2
         */
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);

        /**
         * Computes the sum of the values in `array`.
         *
         * @static
         * @memberOf _
         * @since 3.4.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @returns {number} Returns the sum.
         * @example
         *
         * _.sum([4, 2, 8, 6]);
         * // => 20
         */
        function sum(array) {
          return (array && array.length)
            ? baseSum(array, identity)
            : 0;
        }

        /**
         * This method is like `_.sum` except that it accepts `iteratee` which is
         * invoked for each element in `array` to generate the value to be summed.
         * The iteratee is invoked with one argument: (value).
         *
         * @static
         * @memberOf _
         * @since 4.0.0
         * @category Math
         * @param {Array} array The array to iterate over.
         * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
         * @returns {number} Returns the sum.
         * @example
         *
         * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
         *
         * _.sumBy(objects, function(o) { return o.n; });
         * // => 20
         *
         * // The `_.property` iteratee shorthand.
         * _.sumBy(objects, 'n');
         * // => 20
         */
        function sumBy(array, iteratee) {
          return (array && array.length)
            ? baseSum(array, getIteratee(iteratee, 2))
            : 0;
        }

        /*------------------------------------------------------------------------*/

        // Add methods that return wrapped values in chain sequences.
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;

        // Add aliases.
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;

        // Add methods to `lodash.prototype`.
        mixin(lodash, lodash);

        /*------------------------------------------------------------------------*/

        // Add methods that return unwrapped values in chain sequences.
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;

        // Add aliases.
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;

        mixin(lodash, (function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }()), { 'chain': false });

        /*------------------------------------------------------------------------*/

        /**
         * The semantic version number.
         *
         * @static
         * @memberOf _
         * @type {string}
         */
        lodash.VERSION = VERSION;

        // Assign default placeholders.
        arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });

        // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
        arrayEach(['drop', 'take'], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

            var result = (this.__filtered__ && !index)
              ? new LazyWrapper(this)
              : this.clone();

            if (result.__filtered__) {
              result.__takeCount__ = nativeMin(n, result.__takeCount__);
            } else {
              result.__views__.push({
                'size': nativeMin(n, MAX_ARRAY_LENGTH),
                'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
              });
            }
            return result;
          };

          LazyWrapper.prototype[methodName + 'Right'] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });

        // Add `LazyWrapper` methods that accept an `iteratee` value.
        arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
          var type = index + 1,
              isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

          LazyWrapper.prototype[methodName] = function(iteratee) {
            var result = this.clone();
            result.__iteratees__.push({
              'iteratee': getIteratee(iteratee, 3),
              'type': type
            });
            result.__filtered__ = result.__filtered__ || isFilter;
            return result;
          };
        });

        // Add `LazyWrapper` methods for `_.head` and `_.last`.
        arrayEach(['head', 'last'], function(methodName, index) {
          var takeName = 'take' + (index ? 'Right' : '');

          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });

        // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
        arrayEach(['initial', 'tail'], function(methodName, index) {
          var dropName = 'drop' + (index ? '' : 'Right');

          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });

        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };

        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };

        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };

        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == 'function') {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });

        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };

        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);

          var result = this;
          if (result.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result);
          }
          if (start < 0) {
            result = result.takeRight(-start);
          } else if (start) {
            result = result.drop(start);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result = end < 0 ? result.dropRight(-end) : result.take(end - start);
          }
          return result;
        };

        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };

        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };

        // Add `LazyWrapper` methods to `lodash.prototype`.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
              isTaker = /^(?:head|last)$/.test(methodName),
              lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
              retUnwrapped = isTaker || /^find/.test(methodName);

          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__,
                args = isTaker ? [1] : arguments,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);

            var interceptor = function(value) {
              var result = lodashFunc.apply(lodash, arrayPush([value], args));
              return (isTaker && chainAll) ? result[0] : result;
            };

            if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
              // Avoid lazy use if the iteratee has a "length" value other than `1`.
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__,
                isHybrid = !!this.__actions__.length,
                isUnwrapped = retUnwrapped && !chainAll,
                onlyLazy = isLazy && !isHybrid;

            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result = func.apply(value, args);
              result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
              return new LodashWrapper(result, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result = this.thru(interceptor);
            return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
          };
        });

        // Add `Array` methods to `lodash.prototype`.
        arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
          var func = arrayProto[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:pop|shift)$/.test(methodName);

          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value) {
              return func.apply(isArray(value) ? value : [], args);
            });
          };
        });

        // Map minified method names to their real names.
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + '';
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ 'name': methodName, 'func': lodashFunc });
          }
        });

        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          'name': 'wrapper',
          'func': undefined$1
        }];

        // Add methods to `LazyWrapper`.
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;

        // Add chain sequence methods to the `lodash` wrapper.
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

        // Add lazy aliases.
        lodash.prototype.first = lodash.prototype.head;

        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      });

      /*--------------------------------------------------------------------------*/

      // Export lodash.
      var _ = runInContext();

      // Some AMD build optimizers, like r.js, check for condition patterns like:
      if (freeModule) {
        // Export for Node.js.
        (freeModule.exports = _)._ = _;
        // Export for CommonJS support.
        freeExports._ = _;
      }
      else {
        // Export to the global object.
        root._ = _;
      }
    }.call(commonjsGlobal));
    });

    function filterKey(text, filter) {
      return lodash.lowerCase(text).includes(filter);
    }

    function filterItem(item, keys, filter) {
      if (Array.isArray(keys)) return keys.some(key => filterKey(item[key], filter));
      return filterKey(item[keys], filter);
    }

    function filterCategory(categories, category, filter, key, filterMethod) {
      const { label } = category;
      const filtered = category[key].filter(item => filterMethod(item, filter));
      if (filtered.length > 0) categories.push({ label, [key]: filtered });
      return categories;
    }

    function filterCategories(categories, filter, reduceMethod) {
      if (filter) {
        const normalizedFilter = lodash.lowerCase(filter);
        return categories.reduce((result, category) => reduceMethod(result, category, normalizedFilter), []);
      }
      return categories;
    }

    function filterIndicatorItem(item, filter) {
      const keys = ['label', 'value'];
      return filterItem(item, keys, filter);
    }

    function filterIndicatorCategory(categories, category, filter) {
      return filterCategory(categories, category, filter, 'indicators', filterIndicatorItem);
    }

    function filterIndicatorCategories(categories, filter) {
      return filterCategories(categories, filter, filterIndicatorCategory);
    }

    function filterNavigationItem(item, filter) {
      return filterItem(item, 'label', filter);
    }

    function filterNavigationCategory(categories, category, filter) {
      return filterCategory(categories, category, filter, 'indicators', filterNavigationItem);
    }

    function filterNavigationCategories(categories, filter) {
      return filterCategories(categories, filter, filterNavigationCategory);
    }

    function filterComparisonIndicators(data, filter) {
      if (filter) {
        const normalizedFilter = lodash.lowerCase(filter);
        return data.filter(item => filterItem(item, 'label', normalizedFilter));
      }
      return data;
    }

    function filterSelectItem(result, item, index, key, filter) {
      const isFiltered = filterKey(item[key], filter);
      if (isFiltered) {
        result.push({
          ...item,
          index,
        });
      }
      return result;
    }

    function filterSelectOptions(data, filter, filterOnly = false) {
      if (filter) {
        const normalizedFilter = lodash.lowerCase(filter);
        return data.reduce((result, item, index) => filterSelectItem(result, item, index, 'label', normalizedFilter), []);
      }
      if (!filterOnly)
        return data;
      return []
    }

    function filterSelectGroup(categories, category, filter) {
      const { label } = category;
      const options = category.options.reduce((result, item, index) => filterSelectItem(result, item, index, 'label', filter), []);
      if (options.length > 0) categories.push({ label, options });
      return categories;
    }

    function filterSelectGroups(data, filter) {
      if (filter) {
        const normalizedFilter = lodash.lowerCase(filter);
        return data.reduce((result, item) => filterSelectGroup(result, item, normalizedFilter), []);
      }
      return data;
    }

    /* src/js/components/dropdownDrawer/DropdownDrawer.svelte generated by Svelte v3.24.0 */
    const file$m = "src/js/components/dropdownDrawer/DropdownDrawer.svelte";

    // (26:0) <Dropdown   {isActive}   on:dropdownclose>
    function create_default_slot$4(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[10], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			set_style(div, "--shift", /*shift*/ ctx[2]);
    			attr_dev(div, "class", "txcm-dropdownDrawer");
    			toggle_class(div, "txcm-dropdownDrawer-is-opened", /*isActive*/ ctx[0]);
    			add_location(div, file$m, 28, 4, 643);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			/*div_binding*/ ctx[8](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "click", stop_propagation(/*click_handler*/ ctx[5]), false, false, true),
    					listen_dev(div, "wheel", stop_propagation(/*wheel_handler*/ ctx[6]), false, false, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1024) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[10], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*shift*/ 4) {
    				set_style(div, "--shift", /*shift*/ ctx[2]);
    			}

    			if (dirty & /*isActive*/ 1) {
    				toggle_class(div, "txcm-dropdownDrawer-is-opened", /*isActive*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			/*div_binding*/ ctx[8](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(26:0) <Dropdown   {isActive}   on:dropdownclose>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$r(ctx) {
    	let dropdown;
    	let current;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[7]);

    	dropdown = new Dropdown({
    			props: {
    				isActive: /*isActive*/ ctx[0],
    				$$slots: { default: [create_default_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown.$on("dropdownclose", /*dropdownclose_handler*/ ctx[9]);

    	const block = {
    		c: function create() {
    			create_component(dropdown.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(dropdown, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "resize", /*onwindowresize*/ ctx[7]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const dropdown_changes = {};
    			if (dirty & /*isActive*/ 1) dropdown_changes.isActive = /*isActive*/ ctx[0];

    			if (dirty & /*$$scope, shift, node, isActive*/ 1031) {
    				dropdown_changes.$$scope = { dirty, ctx };
    			}

    			dropdown.$set(dropdown_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dropdown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dropdown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dropdown, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const RIGHT_MARGIN = 8;

    function instance$r($$self, $$props, $$invalidate) {
    	let { isActive } = $$props;
    	let node;
    	let shift = 0;
    	let screenWidth;

    	function updateShift() {
    		if (isActive && node) {
    			const { x } = node.parentNode.getBoundingClientRect();
    			const { width } = node.getBoundingClientRect();
    			const diff = screenWidth - (x + width + RIGHT_MARGIN);
    			if (diff < 0) return `translateX(100%) translateX(${diff}px)`;
    			return "translateX(100%)";
    		}

    		return "translateX(0)";
    	}

    	const writable_props = ["isActive"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DropdownDrawer> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DropdownDrawer", $$slots, ['default']);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function wheel_handler(event) {
    		bubble($$self, event);
    	}

    	function onwindowresize() {
    		$$invalidate(3, screenWidth = window.innerWidth);
    	}

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			node = $$value;
    			$$invalidate(1, node);
    		});
    	}

    	function dropdownclose_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    		if ("$$scope" in $$props) $$invalidate(10, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Dropdown,
    		RIGHT_MARGIN,
    		isActive,
    		node,
    		shift,
    		screenWidth,
    		updateShift
    	});

    	$$self.$inject_state = $$props => {
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    		if ("node" in $$props) $$invalidate(1, node = $$props.node);
    		if ("shift" in $$props) $$invalidate(2, shift = $$props.shift);
    		if ("screenWidth" in $$props) $$invalidate(3, screenWidth = $$props.screenWidth);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*isActive*/ 1) {
    			 $$invalidate(2, shift = updateShift());
    		}
    	};

    	return [
    		isActive,
    		node,
    		shift,
    		screenWidth,
    		$$slots,
    		click_handler,
    		wheel_handler,
    		onwindowresize,
    		div_binding,
    		dropdownclose_handler,
    		$$scope
    	];
    }

    class DropdownDrawer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, { isActive: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DropdownDrawer",
    			options,
    			id: create_fragment$r.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*isActive*/ ctx[0] === undefined && !("isActive" in props)) {
    			console.warn("<DropdownDrawer> was created without expected prop 'isActive'");
    		}
    	}

    	get isActive() {
    		throw new Error("<DropdownDrawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isActive(value) {
    		throw new Error("<DropdownDrawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/dropdownDrawer/DropdownDrawerControls.svelte generated by Svelte v3.24.0 */

    const file$n = "src/js/components/dropdownDrawer/DropdownDrawerControls.svelte";

    function create_fragment$s(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "txcm-dropdownDrawerControls");
    			add_location(div, file$n, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DropdownDrawerControls> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DropdownDrawerControls", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, $$slots];
    }

    class DropdownDrawerControls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DropdownDrawerControls",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* src/js/components/list/ListFilter.svelte generated by Svelte v3.24.0 */
    const file$o = "src/js/components/list/ListFilter.svelte";

    function create_fragment$t(ctx) {
    	let form;
    	let svg;
    	let use;
    	let t0;
    	let input;
    	let t1;
    	let button;
    	let int;
    	let form_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: "Сбросить" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			form = element("form");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t0 = space();
    			input = element("input");
    			t1 = space();
    			button = element("button");
    			create_component(int.$$.fragment);
    			xlink_attr(use, "xlink:href", "#txspt-icons-search");
    			add_location(use, file$o, 22, 8, 492);
    			attr_dev(svg, "class", "txcm-listFilterIcon");
    			add_location(svg, file$o, 20, 4, 444);
    			attr_dev(input, "class", "txcm-listFilterInput");
    			attr_dev(input, "type", "search");
    			attr_dev(input, "placeholder", /*searchLabel*/ ctx[2]);
    			add_location(input, file$o, 25, 4, 558);
    			attr_dev(button, "class", "txcm-listFilterCancel");
    			attr_dev(button, "type", "button");
    			add_location(button, file$o, 30, 4, 674);
    			attr_dev(form, "class", form_class_value = `txcm-listFilter ${/*theme*/ ctx[1]}`);
    			add_location(form, file$o, 17, 0, 369);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, svg);
    			append_dev(svg, use);
    			append_dev(form, t0);
    			append_dev(form, input);
    			set_input_value(input, /*value*/ ctx[0]);
    			append_dev(form, t1);
    			append_dev(form, button);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[6]),
    					listen_dev(button, "click", /*onCancelClick*/ ctx[4], false, false, false),
    					listen_dev(form, "submit", prevent_default(/*submit_handler*/ ctx[5]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*searchLabel*/ 4) {
    				attr_dev(input, "placeholder", /*searchLabel*/ ctx[2]);
    			}

    			if (dirty & /*value*/ 1) {
    				set_input_value(input, /*value*/ ctx[0]);
    			}

    			if (!current || dirty & /*theme*/ 2 && form_class_value !== (form_class_value = `txcm-listFilter ${/*theme*/ ctx[1]}`)) {
    				attr_dev(form, "class", form_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(int);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $locale;
    	let { value } = $$props;
    	let { theme = "" } = $$props;
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(7, $locale = value));

    	function onCancelClick() {
    		$$invalidate(0, value = "");
    	}

    	const writable_props = ["value", "theme"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ListFilter> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ListFilter", $$slots, []);

    	function submit_handler(event) {
    		bubble($$self, event);
    	}

    	function input_input_handler() {
    		value = this.value;
    		$$invalidate(0, value);
    	}

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("theme" in $$props) $$invalidate(1, theme = $$props.theme);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		getUIState,
    		translate,
    		value,
    		theme,
    		locale,
    		onCancelClick,
    		searchLabel,
    		$locale
    	});

    	$$self.$inject_state = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("theme" in $$props) $$invalidate(1, theme = $$props.theme);
    		if ("searchLabel" in $$props) $$invalidate(2, searchLabel = $$props.searchLabel);
    	};

    	let searchLabel;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$locale*/ 128) {
    			 $$invalidate(2, searchLabel = translate("Поиск", $locale));
    		}
    	};

    	return [
    		value,
    		theme,
    		searchLabel,
    		locale,
    		onCancelClick,
    		submit_handler,
    		input_input_handler
    	];
    }

    class ListFilter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, { value: 0, theme: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ListFilter",
    			options,
    			id: create_fragment$t.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[0] === undefined && !("value" in props)) {
    			console.warn("<ListFilter> was created without expected prop 'value'");
    		}
    	}

    	get value() {
    		throw new Error("<ListFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<ListFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get theme() {
    		throw new Error("<ListFilter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set theme(value) {
    		throw new Error("<ListFilter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/controlledSelect/ControlledSelectContainer.svelte generated by Svelte v3.24.0 */
    const file$p = "src/js/components/controlledSelect/ControlledSelectContainer.svelte";

    // (155:8) <DropdownDrawerControls>
    function create_default_slot_1$1(ctx) {
    	let button0;
    	let int0;
    	let t;
    	let button1;
    	let int1;
    	let current;
    	let mounted;
    	let dispose;
    	int0 = new Int({ props: { key: "Отмена" }, $$inline: true });

    	int1 = new Int({
    			props: { key: /*acceptLabel*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			create_component(int0.$$.fragment);
    			t = space();
    			button1 = element("button");
    			create_component(int1.$$.fragment);
    			attr_dev(button0, "class", "txcm-dropdownDrawerCancel");
    			add_location(button0, file$p, 155, 10, 4042);
    			attr_dev(button1, "class", "txcm-dropdownDrawerApply");
    			add_location(button1, file$p, 161, 10, 4215);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			mount_component(int0, button0, null);
    			insert_dev(target, t, anchor);
    			insert_dev(target, button1, anchor);
    			mount_component(int1, button1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*onCancelClick*/ ctx[11], false, false, false),
    					listen_dev(button1, "click", /*onApplyClick*/ ctx[12], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const int1_changes = {};
    			if (dirty[0] & /*acceptLabel*/ 16) int1_changes.key = /*acceptLabel*/ ctx[4];
    			int1.$set(int1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			destroy_component(int0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(button1);
    			destroy_component(int1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(155:8) <DropdownDrawerControls>",
    		ctx
    	});

    	return block;
    }

    // (149:4) <DropdownDrawer       {isActive}       on:dropdownclose={onDropdownClose}>
    function create_default_slot$5(ctx) {
    	let listfilter;
    	let updating_value;
    	let t0;
    	let t1;
    	let dropdowndrawercontrols;
    	let current;

    	function listfilter_value_binding(value) {
    		/*listfilter_value_binding*/ ctx[20].call(null, value);
    	}

    	let listfilter_props = {};

    	if (/*filter*/ ctx[1] !== void 0) {
    		listfilter_props.value = /*filter*/ ctx[1];
    	}

    	listfilter = new ListFilter({ props: listfilter_props, $$inline: true });
    	binding_callbacks.push(() => bind(listfilter, "value", listfilter_value_binding));
    	const default_slot_template = /*$$slots*/ ctx[19].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[21], null);

    	dropdowndrawercontrols = new DropdownDrawerControls({
    			props: {
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(listfilter.$$.fragment);
    			t0 = space();
    			if (default_slot) default_slot.c();
    			t1 = space();
    			create_component(dropdowndrawercontrols.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(listfilter, target, anchor);
    			insert_dev(target, t0, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t1, anchor);
    			mount_component(dropdowndrawercontrols, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listfilter_changes = {};

    			if (!updating_value && dirty[0] & /*filter*/ 2) {
    				updating_value = true;
    				listfilter_changes.value = /*filter*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			listfilter.$set(listfilter_changes);

    			if (default_slot) {
    				if (default_slot.p && dirty[0] & /*$$scope*/ 2097152) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[21], dirty, null, null);
    				}
    			}

    			const dropdowndrawercontrols_changes = {};

    			if (dirty[0] & /*$$scope, acceptLabel*/ 2097168) {
    				dropdowndrawercontrols_changes.$$scope = { dirty, ctx };
    			}

    			dropdowndrawercontrols.$set(dropdowndrawercontrols_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listfilter.$$.fragment, local);
    			transition_in(default_slot, local);
    			transition_in(dropdowndrawercontrols.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listfilter.$$.fragment, local);
    			transition_out(default_slot, local);
    			transition_out(dropdowndrawercontrols.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(listfilter, detaching);
    			if (detaching) detach_dev(t0);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdowndrawercontrols, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(149:4) <DropdownDrawer       {isActive}       on:dropdownclose={onDropdownClose}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let div;
    	let button0;
    	let int0;
    	let t0;
    	let svg;
    	let use;
    	let t1;
    	let button1;
    	let int1;
    	let t2;
    	let dropdowndrawer;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	int0 = new Int({
    			props: { key: /*toggleLabel*/ ctx[5] },
    			$$inline: true
    		});

    	int1 = new Int({
    			props: { key: "Сбросить" },
    			$$inline: true
    		});

    	dropdowndrawer = new DropdownDrawer({
    			props: {
    				isActive: /*isActive*/ ctx[6],
    				$$slots: { default: [create_default_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdowndrawer.$on("dropdownclose", /*onDropdownClose*/ ctx[10]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			create_component(int0.$$.fragment);
    			t0 = space();
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t1 = space();
    			button1 = element("button");
    			create_component(int1.$$.fragment);
    			t2 = space();
    			create_component(dropdowndrawer.$$.fragment);
    			xlink_attr(use, "xlink:href", "#txspt-icons-fatArrow");
    			add_location(use, file$p, 137, 12, 3608);
    			attr_dev(svg, "class", "txcm-controlledSelectToggleIcon");
    			add_location(svg, file$p, 135, 8, 3540);
    			attr_dev(button0, "class", "txcm-controlledSelectToggle");
    			button0.disabled = /*disabled*/ ctx[3];
    			toggle_class(button0, "txcm-controlledSelectToggle-has-selected", /*hasSelected*/ ctx[8](/*pick*/ ctx[0]));
    			toggle_class(button0, "txcm-controlledSelectToggle-is-opened", /*isActive*/ ctx[6]);
    			add_location(button0, file$p, 127, 4, 3255);
    			attr_dev(button1, "class", "txcm-controlledSelectReset");
    			button1.disabled = /*disabled*/ ctx[3];
    			add_location(button1, file$p, 141, 4, 3698);
    			attr_dev(div, "class", div_class_value = `txcm-controlledSelect ${/*theme*/ ctx[2]}`);
    			add_location(div, file$p, 125, 0, 3202);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			mount_component(int0, button0, null);
    			append_dev(button0, t0);
    			append_dev(button0, svg);
    			append_dev(svg, use);
    			append_dev(div, t1);
    			append_dev(div, button1);
    			mount_component(int1, button1, null);
    			append_dev(div, t2);
    			mount_component(dropdowndrawer, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*onToggleClick*/ ctx[9], false, false, false),
    					listen_dev(button1, "click", /*onResetClick*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const int0_changes = {};
    			if (dirty[0] & /*toggleLabel*/ 32) int0_changes.key = /*toggleLabel*/ ctx[5];
    			int0.$set(int0_changes);

    			if (!current || dirty[0] & /*disabled*/ 8) {
    				prop_dev(button0, "disabled", /*disabled*/ ctx[3]);
    			}

    			if (dirty[0] & /*hasSelected, pick*/ 257) {
    				toggle_class(button0, "txcm-controlledSelectToggle-has-selected", /*hasSelected*/ ctx[8](/*pick*/ ctx[0]));
    			}

    			if (dirty[0] & /*isActive*/ 64) {
    				toggle_class(button0, "txcm-controlledSelectToggle-is-opened", /*isActive*/ ctx[6]);
    			}

    			if (!current || dirty[0] & /*disabled*/ 8) {
    				prop_dev(button1, "disabled", /*disabled*/ ctx[3]);
    			}

    			const dropdowndrawer_changes = {};
    			if (dirty[0] & /*isActive*/ 64) dropdowndrawer_changes.isActive = /*isActive*/ ctx[6];

    			if (dirty[0] & /*$$scope, acceptLabel, filter*/ 2097170) {
    				dropdowndrawer_changes.$$scope = { dirty, ctx };
    			}

    			dropdowndrawer.$set(dropdowndrawer_changes);

    			if (!current || dirty[0] & /*theme*/ 4 && div_class_value !== (div_class_value = `txcm-controlledSelect ${/*theme*/ ctx[2]}`)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			transition_in(dropdowndrawer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			transition_out(dropdowndrawer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int0);
    			destroy_component(int1);
    			destroy_component(dropdowndrawer);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let $locale;
    	let { label } = $$props;
    	let { pick } = $$props;
    	let { selected } = $$props;
    	let { options } = $$props;
    	let { theme } = $$props;
    	let { multiple } = $$props;
    	let { grouped } = $$props;
    	let { filter } = $$props;
    	let { disabled } = $$props;
    	let { acceptLabel } = $$props;
    	let toggleLabel = label;
    	let isActive = false;
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(22, $locale = value));

    	function changeSelected() {
    		updateSelected();
    		renderToggleLabel();
    	}

    	function hasSelected() {
    		if (multiple) return pick.length > 0;
    		return pick !== null;
    	}

    	function renderSelectedMultipleLabel() {
    		const text = options[selected[0]].label;
    		if (selected.length === 1) return text;
    		const count = selected.length - 1;
    		return `${translate(text, $locale)}, +${count}`;
    	}

    	function renderSelectedUniqueLabel() {
    		return options[selected].label;
    	}

    	function renderSelectedMultipleGroupedLabel() {
    		const indexEements = selected[0].split("-");
    		const groupIndex = parseInt(indexEements[0], 10);
    		const optionIndex = parseInt(indexEements[1], 10);
    		const text = options[groupIndex].options[optionIndex].label;
    		if (selected.length === 1) return text;
    		const count = selected.length - 1;
    		return `${translate(text, $locale)}, +${count}`;
    	}

    	function renderSelectedLabel() {
    		if (grouped) return renderSelectedMultipleGroupedLabel();
    		if (multiple) return renderSelectedMultipleLabel();
    		return renderSelectedUniqueLabel();
    	}

    	function renderToggleLabel() {
    		$$invalidate(5, toggleLabel = hasSelected() ? renderSelectedLabel() : label);
    	}

    	function show() {
    		$$invalidate(6, isActive = true);
    	}

    	function resetSelected() {
    		if (grouped || multiple) $$invalidate(14, selected = []); else $$invalidate(14, selected = null);
    	}

    	function updateSelected() {
    		if (grouped) $$invalidate(14, selected = findGroupedIndexes(options, pick)); else if (multiple) $$invalidate(14, selected = findIndexes(options, pick)); else $$invalidate(14, selected = findIndex(options, pick));
    	}

    	function resetPick() {
    		if (grouped || multiple) $$invalidate(0, pick = []); else $$invalidate(0, pick = null);
    	}

    	function updatePick() {
    		if (grouped) $$invalidate(0, pick = findGroupedValues(options, selected)); else if (multiple) $$invalidate(0, pick = findValues(options, selected)); else $$invalidate(0, pick = findValue(options, selected));
    	}

    	function hide() {
    		if (isActive) $$invalidate(6, isActive = false);
    	}

    	function onToggleClick() {
    		if (!isActive) setTimeout(show, 5);
    	}

    	function onDropdownClose() {
    		updateSelected();
    		hide();
    	}

    	function onCancelClick() {
    		updateSelected();
    		hide();
    	}

    	function onApplyClick() {
    		updatePick();
    		hide();
    	}

    	function onResetClick() {
    		resetPick();
    		resetSelected();
    		hide();
    	}

    	const writable_props = [
    		"label",
    		"pick",
    		"selected",
    		"options",
    		"theme",
    		"multiple",
    		"grouped",
    		"filter",
    		"disabled",
    		"acceptLabel"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ControlledSelectContainer> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ControlledSelectContainer", $$slots, ['default']);

    	function listfilter_value_binding(value) {
    		filter = value;
    		$$invalidate(1, filter);
    	}

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(15, label = $$props.label);
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("selected" in $$props) $$invalidate(14, selected = $$props.selected);
    		if ("options" in $$props) $$invalidate(16, options = $$props.options);
    		if ("theme" in $$props) $$invalidate(2, theme = $$props.theme);
    		if ("multiple" in $$props) $$invalidate(17, multiple = $$props.multiple);
    		if ("grouped" in $$props) $$invalidate(18, grouped = $$props.grouped);
    		if ("filter" in $$props) $$invalidate(1, filter = $$props.filter);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    		if ("acceptLabel" in $$props) $$invalidate(4, acceptLabel = $$props.acceptLabel);
    		if ("$$scope" in $$props) $$invalidate(21, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		findIndex,
    		findIndexes,
    		findGroupedIndexes,
    		findValue,
    		findValues,
    		findGroupedValues,
    		Int,
    		DropdownDrawer,
    		DropdownDrawerControls,
    		ListFilter,
    		getUIState,
    		translate,
    		label,
    		pick,
    		selected,
    		options,
    		theme,
    		multiple,
    		grouped,
    		filter,
    		disabled,
    		acceptLabel,
    		toggleLabel,
    		isActive,
    		locale,
    		changeSelected,
    		hasSelected,
    		renderSelectedMultipleLabel,
    		renderSelectedUniqueLabel,
    		renderSelectedMultipleGroupedLabel,
    		renderSelectedLabel,
    		renderToggleLabel,
    		show,
    		resetSelected,
    		updateSelected,
    		resetPick,
    		updatePick,
    		hide,
    		onToggleClick,
    		onDropdownClose,
    		onCancelClick,
    		onApplyClick,
    		onResetClick,
    		$locale
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(15, label = $$props.label);
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("selected" in $$props) $$invalidate(14, selected = $$props.selected);
    		if ("options" in $$props) $$invalidate(16, options = $$props.options);
    		if ("theme" in $$props) $$invalidate(2, theme = $$props.theme);
    		if ("multiple" in $$props) $$invalidate(17, multiple = $$props.multiple);
    		if ("grouped" in $$props) $$invalidate(18, grouped = $$props.grouped);
    		if ("filter" in $$props) $$invalidate(1, filter = $$props.filter);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    		if ("acceptLabel" in $$props) $$invalidate(4, acceptLabel = $$props.acceptLabel);
    		if ("toggleLabel" in $$props) $$invalidate(5, toggleLabel = $$props.toggleLabel);
    		if ("isActive" in $$props) $$invalidate(6, isActive = $$props.isActive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*pick, $locale*/ 4194305) {
    			 changeSelected();
    		}

    		if ($$self.$$.dirty[0] & /*pick*/ 1) {
    			 changeSelected();
    		}
    	};

    	return [
    		pick,
    		filter,
    		theme,
    		disabled,
    		acceptLabel,
    		toggleLabel,
    		isActive,
    		locale,
    		hasSelected,
    		onToggleClick,
    		onDropdownClose,
    		onCancelClick,
    		onApplyClick,
    		onResetClick,
    		selected,
    		label,
    		options,
    		multiple,
    		grouped,
    		$$slots,
    		listfilter_value_binding,
    		$$scope
    	];
    }

    class ControlledSelectContainer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$u,
    			create_fragment$u,
    			safe_not_equal,
    			{
    				label: 15,
    				pick: 0,
    				selected: 14,
    				options: 16,
    				theme: 2,
    				multiple: 17,
    				grouped: 18,
    				filter: 1,
    				disabled: 3,
    				acceptLabel: 4
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ControlledSelectContainer",
    			options,
    			id: create_fragment$u.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[15] === undefined && !("label" in props)) {
    			console.warn("<ControlledSelectContainer> was created without expected prop 'label'");
    		}

    		if (/*pick*/ ctx[0] === undefined && !("pick" in props)) {
    			console.warn("<ControlledSelectContainer> was created without expected prop 'pick'");
    		}

    		if (/*selected*/ ctx[14] === undefined && !("selected" in props)) {
    			console.warn("<ControlledSelectContainer> was created without expected prop 'selected'");
    		}

    		if (/*options*/ ctx[16] === undefined && !("options" in props)) {
    			console.warn("<ControlledSelectContainer> was created without expected prop 'options'");
    		}

    		if (/*theme*/ ctx[2] === undefined && !("theme" in props)) {
    			console.warn("<ControlledSelectContainer> was created without expected prop 'theme'");
    		}

    		if (/*multiple*/ ctx[17] === undefined && !("multiple" in props)) {
    			console.warn("<ControlledSelectContainer> was created without expected prop 'multiple'");
    		}

    		if (/*grouped*/ ctx[18] === undefined && !("grouped" in props)) {
    			console.warn("<ControlledSelectContainer> was created without expected prop 'grouped'");
    		}

    		if (/*filter*/ ctx[1] === undefined && !("filter" in props)) {
    			console.warn("<ControlledSelectContainer> was created without expected prop 'filter'");
    		}

    		if (/*disabled*/ ctx[3] === undefined && !("disabled" in props)) {
    			console.warn("<ControlledSelectContainer> was created without expected prop 'disabled'");
    		}

    		if (/*acceptLabel*/ ctx[4] === undefined && !("acceptLabel" in props)) {
    			console.warn("<ControlledSelectContainer> was created without expected prop 'acceptLabel'");
    		}
    	}

    	get label() {
    		throw new Error("<ControlledSelectContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<ControlledSelectContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pick() {
    		throw new Error("<ControlledSelectContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pick(value) {
    		throw new Error("<ControlledSelectContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<ControlledSelectContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<ControlledSelectContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<ControlledSelectContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<ControlledSelectContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get theme() {
    		throw new Error("<ControlledSelectContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set theme(value) {
    		throw new Error("<ControlledSelectContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiple() {
    		throw new Error("<ControlledSelectContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiple(value) {
    		throw new Error("<ControlledSelectContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get grouped() {
    		throw new Error("<ControlledSelectContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set grouped(value) {
    		throw new Error("<ControlledSelectContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filter() {
    		throw new Error("<ControlledSelectContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filter(value) {
    		throw new Error("<ControlledSelectContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<ControlledSelectContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<ControlledSelectContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get acceptLabel() {
    		throw new Error("<ControlledSelectContainer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set acceptLabel(value) {
    		throw new Error("<ControlledSelectContainer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/controlledSelect/ControlledSelectUnique.svelte generated by Svelte v3.24.0 */
    const file$q = "src/js/components/controlledSelect/ControlledSelectUnique.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i];
    	child_ctx[20] = i;
    	return child_ctx;
    }

    // (43:4) {#each options as option, index}
    function create_each_block$8(ctx) {
    	let input;
    	let input_id_value;
    	let input_value_value;
    	let input_disabled_value;
    	let t0;
    	let label_1;
    	let int;
    	let t1;
    	let svg;
    	let use;
    	let t2;
    	let label_1_for_value;
    	let label_1_data_option_value;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*option*/ ctx[18].label },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			input = element("input");
    			t0 = space();
    			label_1 = element("label");
    			create_component(int.$$.fragment);
    			t1 = space();
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t2 = space();
    			attr_dev(input, "class", "txcm-controlledSelectInput");
    			attr_dev(input, "type", "radio");
    			attr_dev(input, "name", /*name*/ ctx[2]);
    			attr_dev(input, "id", input_id_value = renderID(/*name*/ ctx[2], /*option*/ ctx[18].index || /*index*/ ctx[20]));
    			input.__value = input_value_value = /*option*/ ctx[18].index || /*index*/ ctx[20];
    			input.value = input.__value;
    			input.disabled = input_disabled_value = /*option*/ ctx[18].disabled;
    			/*$$binding_groups*/ ctx[13][0].push(input);
    			add_location(input, file$q, 43, 6, 1023);
    			xlink_attr(use, "xlink:href", "#txspt-icons-checkmark");
    			add_location(use, file$q, 60, 14, 1576);
    			attr_dev(svg, "class", "txcm-controlledSelectIcon");
    			add_location(svg, file$q, 58, 10, 1510);
    			attr_dev(label_1, "for", label_1_for_value = renderID(/*name*/ ctx[2], /*option*/ ctx[18].index || /*index*/ ctx[20]));
    			attr_dev(label_1, "class", "txcm-controlledSelectLabel");
    			attr_dev(label_1, "data-option", label_1_data_option_value = /*option*/ ctx[18].index || /*index*/ ctx[20]);
    			add_location(label_1, file$q, 51, 6, 1272);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = input.__value === /*selected*/ ctx[10];
    			insert_dev(target, t0, anchor);
    			insert_dev(target, label_1, anchor);
    			mount_component(int, label_1, null);
    			append_dev(label_1, t1);
    			append_dev(label_1, svg);
    			append_dev(svg, use);
    			append_dev(label_1, t2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*input_change_handler*/ ctx[12]),
    					listen_dev(label_1, "click", /*onLabelClick*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*name*/ 4) {
    				attr_dev(input, "name", /*name*/ ctx[2]);
    			}

    			if (!current || dirty & /*name, options*/ 12 && input_id_value !== (input_id_value = renderID(/*name*/ ctx[2], /*option*/ ctx[18].index || /*index*/ ctx[20]))) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (!current || dirty & /*options*/ 8 && input_value_value !== (input_value_value = /*option*/ ctx[18].index || /*index*/ ctx[20])) {
    				prop_dev(input, "__value", input_value_value);
    				input.value = input.__value;
    			}

    			if (!current || dirty & /*options*/ 8 && input_disabled_value !== (input_disabled_value = /*option*/ ctx[18].disabled)) {
    				prop_dev(input, "disabled", input_disabled_value);
    			}

    			if (dirty & /*selected*/ 1024) {
    				input.checked = input.__value === /*selected*/ ctx[10];
    			}

    			const int_changes = {};
    			if (dirty & /*options*/ 8) int_changes.key = /*option*/ ctx[18].label;
    			int.$set(int_changes);

    			if (!current || dirty & /*name, options*/ 12 && label_1_for_value !== (label_1_for_value = renderID(/*name*/ ctx[2], /*option*/ ctx[18].index || /*index*/ ctx[20]))) {
    				attr_dev(label_1, "for", label_1_for_value);
    			}

    			if (!current || dirty & /*options*/ 8 && label_1_data_option_value !== (label_1_data_option_value = /*option*/ ctx[18].index || /*index*/ ctx[20])) {
    				attr_dev(label_1, "data-option", label_1_data_option_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*$$binding_groups*/ ctx[13][0].splice(/*$$binding_groups*/ ctx[13][0].indexOf(input), 1);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(label_1);
    			destroy_component(int);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(43:4) {#each options as option, index}",
    		ctx
    	});

    	return block;
    }

    // (32:0) <ControlledSelectContainer   bind:filter   bind:pick   bind:selected   {label}   {options}   {theme}   {multiple}   {grouped}   {disabled}   {acceptLabel}>
    function create_default_slot$6(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*options*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*renderID, name, options, onLabelClick, selected*/ 3084) {
    				each_value = /*options*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(32:0) <ControlledSelectContainer   bind:filter   bind:pick   bind:selected   {label}   {options}   {theme}   {multiple}   {grouped}   {disabled}   {acceptLabel}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let controlledselectcontainer;
    	let updating_filter;
    	let updating_pick;
    	let updating_selected;
    	let current;

    	function controlledselectcontainer_filter_binding(value) {
    		/*controlledselectcontainer_filter_binding*/ ctx[14].call(null, value);
    	}

    	function controlledselectcontainer_pick_binding(value) {
    		/*controlledselectcontainer_pick_binding*/ ctx[15].call(null, value);
    	}

    	function controlledselectcontainer_selected_binding(value) {
    		/*controlledselectcontainer_selected_binding*/ ctx[16].call(null, value);
    	}

    	let controlledselectcontainer_props = {
    		label: /*label*/ ctx[1],
    		options: /*options*/ ctx[3],
    		theme: /*theme*/ ctx[4],
    		multiple: /*multiple*/ ctx[5],
    		grouped: /*grouped*/ ctx[6],
    		disabled: /*disabled*/ ctx[7],
    		acceptLabel: /*acceptLabel*/ ctx[8],
    		$$slots: { default: [create_default_slot$6] },
    		$$scope: { ctx }
    	};

    	if (/*filter*/ ctx[9] !== void 0) {
    		controlledselectcontainer_props.filter = /*filter*/ ctx[9];
    	}

    	if (/*pick*/ ctx[0] !== void 0) {
    		controlledselectcontainer_props.pick = /*pick*/ ctx[0];
    	}

    	if (/*selected*/ ctx[10] !== void 0) {
    		controlledselectcontainer_props.selected = /*selected*/ ctx[10];
    	}

    	controlledselectcontainer = new ControlledSelectContainer({
    			props: controlledselectcontainer_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(controlledselectcontainer, "filter", controlledselectcontainer_filter_binding));
    	binding_callbacks.push(() => bind(controlledselectcontainer, "pick", controlledselectcontainer_pick_binding));
    	binding_callbacks.push(() => bind(controlledselectcontainer, "selected", controlledselectcontainer_selected_binding));

    	const block = {
    		c: function create() {
    			create_component(controlledselectcontainer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(controlledselectcontainer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const controlledselectcontainer_changes = {};
    			if (dirty & /*label*/ 2) controlledselectcontainer_changes.label = /*label*/ ctx[1];
    			if (dirty & /*options*/ 8) controlledselectcontainer_changes.options = /*options*/ ctx[3];
    			if (dirty & /*theme*/ 16) controlledselectcontainer_changes.theme = /*theme*/ ctx[4];
    			if (dirty & /*multiple*/ 32) controlledselectcontainer_changes.multiple = /*multiple*/ ctx[5];
    			if (dirty & /*grouped*/ 64) controlledselectcontainer_changes.grouped = /*grouped*/ ctx[6];
    			if (dirty & /*disabled*/ 128) controlledselectcontainer_changes.disabled = /*disabled*/ ctx[7];
    			if (dirty & /*acceptLabel*/ 256) controlledselectcontainer_changes.acceptLabel = /*acceptLabel*/ ctx[8];

    			if (dirty & /*$$scope, options, name, selected*/ 2098188) {
    				controlledselectcontainer_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_filter && dirty & /*filter*/ 512) {
    				updating_filter = true;
    				controlledselectcontainer_changes.filter = /*filter*/ ctx[9];
    				add_flush_callback(() => updating_filter = false);
    			}

    			if (!updating_pick && dirty & /*pick*/ 1) {
    				updating_pick = true;
    				controlledselectcontainer_changes.pick = /*pick*/ ctx[0];
    				add_flush_callback(() => updating_pick = false);
    			}

    			if (!updating_selected && dirty & /*selected*/ 1024) {
    				updating_selected = true;
    				controlledselectcontainer_changes.selected = /*selected*/ ctx[10];
    				add_flush_callback(() => updating_selected = false);
    			}

    			controlledselectcontainer.$set(controlledselectcontainer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(controlledselectcontainer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(controlledselectcontainer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(controlledselectcontainer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	let { pick } = $$props;
    	let { name } = $$props;
    	let { options } = $$props;
    	let { theme } = $$props;
    	let { multiple } = $$props;
    	let { grouped } = $$props;
    	let { disabled } = $$props;
    	let { acceptLabel } = $$props;
    	let filter = "";
    	let selected = findIndex(options, pick);

    	function onLabelClick(event) {
    		const { option } = event.target.dataset;

    		if (selected === parseInt(option, 10)) {
    			event.preventDefault();
    			$$invalidate(10, selected = null);
    		}
    	}

    	const writable_props = [
    		"label",
    		"pick",
    		"name",
    		"options",
    		"theme",
    		"multiple",
    		"grouped",
    		"disabled",
    		"acceptLabel"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ControlledSelectUnique> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ControlledSelectUnique", $$slots, []);
    	const $$binding_groups = [[]];

    	function input_change_handler() {
    		selected = this.__value;
    		$$invalidate(10, selected);
    	}

    	function controlledselectcontainer_filter_binding(value) {
    		filter = value;
    		$$invalidate(9, filter);
    	}

    	function controlledselectcontainer_pick_binding(value) {
    		pick = value;
    		$$invalidate(0, pick);
    	}

    	function controlledselectcontainer_selected_binding(value) {
    		selected = value;
    		$$invalidate(10, selected);
    	}

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("name" in $$props) $$invalidate(2, name = $$props.name);
    		if ("options" in $$props) $$invalidate(3, options = $$props.options);
    		if ("theme" in $$props) $$invalidate(4, theme = $$props.theme);
    		if ("multiple" in $$props) $$invalidate(5, multiple = $$props.multiple);
    		if ("grouped" in $$props) $$invalidate(6, grouped = $$props.grouped);
    		if ("disabled" in $$props) $$invalidate(7, disabled = $$props.disabled);
    		if ("acceptLabel" in $$props) $$invalidate(8, acceptLabel = $$props.acceptLabel);
    	};

    	$$self.$capture_state = () => ({
    		findIndex,
    		renderID,
    		filterSelectOptions,
    		Int,
    		ControlledSelectContainer,
    		label,
    		pick,
    		name,
    		options,
    		theme,
    		multiple,
    		grouped,
    		disabled,
    		acceptLabel,
    		filter,
    		selected,
    		onLabelClick,
    		filtered
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("name" in $$props) $$invalidate(2, name = $$props.name);
    		if ("options" in $$props) $$invalidate(3, options = $$props.options);
    		if ("theme" in $$props) $$invalidate(4, theme = $$props.theme);
    		if ("multiple" in $$props) $$invalidate(5, multiple = $$props.multiple);
    		if ("grouped" in $$props) $$invalidate(6, grouped = $$props.grouped);
    		if ("disabled" in $$props) $$invalidate(7, disabled = $$props.disabled);
    		if ("acceptLabel" in $$props) $$invalidate(8, acceptLabel = $$props.acceptLabel);
    		if ("filter" in $$props) $$invalidate(9, filter = $$props.filter);
    		if ("selected" in $$props) $$invalidate(10, selected = $$props.selected);
    		if ("filtered" in $$props) filtered = $$props.filtered;
    	};

    	let filtered;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*options, filter*/ 520) {
    			 filtered = filterSelectOptions(options, filter);
    		}
    	};

    	return [
    		pick,
    		label,
    		name,
    		options,
    		theme,
    		multiple,
    		grouped,
    		disabled,
    		acceptLabel,
    		filter,
    		selected,
    		onLabelClick,
    		input_change_handler,
    		$$binding_groups,
    		controlledselectcontainer_filter_binding,
    		controlledselectcontainer_pick_binding,
    		controlledselectcontainer_selected_binding
    	];
    }

    class ControlledSelectUnique extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {
    			label: 1,
    			pick: 0,
    			name: 2,
    			options: 3,
    			theme: 4,
    			multiple: 5,
    			grouped: 6,
    			disabled: 7,
    			acceptLabel: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ControlledSelectUnique",
    			options,
    			id: create_fragment$v.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[1] === undefined && !("label" in props)) {
    			console.warn("<ControlledSelectUnique> was created without expected prop 'label'");
    		}

    		if (/*pick*/ ctx[0] === undefined && !("pick" in props)) {
    			console.warn("<ControlledSelectUnique> was created without expected prop 'pick'");
    		}

    		if (/*name*/ ctx[2] === undefined && !("name" in props)) {
    			console.warn("<ControlledSelectUnique> was created without expected prop 'name'");
    		}

    		if (/*options*/ ctx[3] === undefined && !("options" in props)) {
    			console.warn("<ControlledSelectUnique> was created without expected prop 'options'");
    		}

    		if (/*theme*/ ctx[4] === undefined && !("theme" in props)) {
    			console.warn("<ControlledSelectUnique> was created without expected prop 'theme'");
    		}

    		if (/*multiple*/ ctx[5] === undefined && !("multiple" in props)) {
    			console.warn("<ControlledSelectUnique> was created without expected prop 'multiple'");
    		}

    		if (/*grouped*/ ctx[6] === undefined && !("grouped" in props)) {
    			console.warn("<ControlledSelectUnique> was created without expected prop 'grouped'");
    		}

    		if (/*disabled*/ ctx[7] === undefined && !("disabled" in props)) {
    			console.warn("<ControlledSelectUnique> was created without expected prop 'disabled'");
    		}

    		if (/*acceptLabel*/ ctx[8] === undefined && !("acceptLabel" in props)) {
    			console.warn("<ControlledSelectUnique> was created without expected prop 'acceptLabel'");
    		}
    	}

    	get label() {
    		throw new Error("<ControlledSelectUnique>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<ControlledSelectUnique>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pick() {
    		throw new Error("<ControlledSelectUnique>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pick(value) {
    		throw new Error("<ControlledSelectUnique>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<ControlledSelectUnique>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<ControlledSelectUnique>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<ControlledSelectUnique>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<ControlledSelectUnique>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get theme() {
    		throw new Error("<ControlledSelectUnique>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set theme(value) {
    		throw new Error("<ControlledSelectUnique>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiple() {
    		throw new Error("<ControlledSelectUnique>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiple(value) {
    		throw new Error("<ControlledSelectUnique>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get grouped() {
    		throw new Error("<ControlledSelectUnique>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set grouped(value) {
    		throw new Error("<ControlledSelectUnique>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<ControlledSelectUnique>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<ControlledSelectUnique>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get acceptLabel() {
    		throw new Error("<ControlledSelectUnique>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set acceptLabel(value) {
    		throw new Error("<ControlledSelectUnique>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/list/ListGroup.svelte generated by Svelte v3.24.0 */
    const file$r = "src/js/components/list/ListGroup.svelte";

    // (26:0) {#if !isEmpty}
    function create_if_block$4(ctx) {
    	let t;
    	let div;
    	let current;
    	let if_block = !/*isSingle*/ ctx[3] && create_if_block_1$1(ctx);
    	const default_slot_template = /*$$slots*/ ctx[10].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[9], null);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "txcm-listGroup");
    			toggle_class(div, "txcm-listGroup-is-single", /*isSingle*/ ctx[3]);
    			toggle_class(div, "txcm-listGroup-is-active", /*isActive*/ ctx[4]);
    			toggle_class(div, "txcm-listGroup-is-empty", /*isEmpty*/ ctx[2]);
    			toggle_class(div, "txcm-listGroup-is-fixed", /*fixed*/ ctx[1]);
    			add_location(div, file$r, 40, 2, 865);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*isSingle*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isSingle*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 512) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[9], dirty, null, null);
    				}
    			}

    			if (dirty & /*isSingle*/ 8) {
    				toggle_class(div, "txcm-listGroup-is-single", /*isSingle*/ ctx[3]);
    			}

    			if (dirty & /*isActive*/ 16) {
    				toggle_class(div, "txcm-listGroup-is-active", /*isActive*/ ctx[4]);
    			}

    			if (dirty & /*isEmpty*/ 4) {
    				toggle_class(div, "txcm-listGroup-is-empty", /*isEmpty*/ ctx[2]);
    			}

    			if (dirty & /*fixed*/ 2) {
    				toggle_class(div, "txcm-listGroup-is-fixed", /*fixed*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(26:0) {#if !isEmpty}",
    		ctx
    	});

    	return block;
    }

    // (27:2) {#if !isSingle}
    function create_if_block_1$1(ctx) {
    	let button;
    	let int;
    	let t;
    	let svg;
    	let use;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*label*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(int.$$.fragment);
    			t = space();
    			svg = svg_element("svg");
    			use = svg_element("use");
    			xlink_attr(use, "xlink:href", "#txspt-icons-fatArrow");
    			add_location(use, file$r, 35, 12, 769);
    			attr_dev(svg, "class", "txcm-listGroupToggleIcon");
    			add_location(svg, file$r, 33, 8, 708);
    			attr_dev(button, "class", "txcm-listGroupToggle");
    			toggle_class(button, "txcm-listGroupToggle-is-active", /*isActive*/ ctx[4]);
    			add_location(button, file$r, 27, 4, 533);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(int, button, null);
    			append_dev(button, t);
    			append_dev(button, svg);
    			append_dev(svg, use);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onToggleClick*/ ctx[5], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*label*/ 1) int_changes.key = /*label*/ ctx[0];
    			int.$set(int_changes);

    			if (dirty & /*isActive*/ 16) {
    				toggle_class(button, "txcm-listGroupToggle-is-active", /*isActive*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(27:2) {#if !isSingle}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = !/*isEmpty*/ ctx[2] && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*isEmpty*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isEmpty*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$4(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { label = null } = $$props;
    	let { count } = $$props;
    	let { length } = $$props;
    	let { filter = "" } = $$props;
    	let { fixed = false } = $$props;
    	let isOpened = false;

    	function toggle() {
    		$$invalidate(11, isOpened = !isOpened);
    	}

    	function onToggleClick() {
    		toggle();
    	}

    	const writable_props = ["label", "count", "length", "filter", "fixed"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ListGroup> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ListGroup", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("count" in $$props) $$invalidate(6, count = $$props.count);
    		if ("length" in $$props) $$invalidate(7, length = $$props.length);
    		if ("filter" in $$props) $$invalidate(8, filter = $$props.filter);
    		if ("fixed" in $$props) $$invalidate(1, fixed = $$props.fixed);
    		if ("$$scope" in $$props) $$invalidate(9, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		label,
    		count,
    		length,
    		filter,
    		fixed,
    		isOpened,
    		toggle,
    		onToggleClick,
    		isEmpty,
    		isSingle,
    		isFiltered,
    		isActive
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("count" in $$props) $$invalidate(6, count = $$props.count);
    		if ("length" in $$props) $$invalidate(7, length = $$props.length);
    		if ("filter" in $$props) $$invalidate(8, filter = $$props.filter);
    		if ("fixed" in $$props) $$invalidate(1, fixed = $$props.fixed);
    		if ("isOpened" in $$props) $$invalidate(11, isOpened = $$props.isOpened);
    		if ("isEmpty" in $$props) $$invalidate(2, isEmpty = $$props.isEmpty);
    		if ("isSingle" in $$props) $$invalidate(3, isSingle = $$props.isSingle);
    		if ("isFiltered" in $$props) $$invalidate(12, isFiltered = $$props.isFiltered);
    		if ("isActive" in $$props) $$invalidate(4, isActive = $$props.isActive);
    	};

    	let isEmpty;
    	let isSingle;
    	let isFiltered;
    	let isActive;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*length*/ 128) {
    			 $$invalidate(2, isEmpty = length === 0);
    		}

    		if ($$self.$$.dirty & /*fixed, count*/ 66) {
    			 $$invalidate(3, isSingle = fixed || count === 1);
    		}

    		if ($$self.$$.dirty & /*filter*/ 256) {
    			 $$invalidate(12, isFiltered = !!filter);
    		}

    		if ($$self.$$.dirty & /*fixed, isSingle, isOpened, isFiltered*/ 6154) {
    			 $$invalidate(4, isActive = fixed || isSingle || isOpened || isFiltered);
    		}
    	};

    	return [
    		label,
    		fixed,
    		isEmpty,
    		isSingle,
    		isActive,
    		onToggleClick,
    		count,
    		length,
    		filter,
    		$$scope,
    		$$slots
    	];
    }

    class ListGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {
    			label: 0,
    			count: 6,
    			length: 7,
    			filter: 8,
    			fixed: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ListGroup",
    			options,
    			id: create_fragment$w.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*count*/ ctx[6] === undefined && !("count" in props)) {
    			console.warn("<ListGroup> was created without expected prop 'count'");
    		}

    		if (/*length*/ ctx[7] === undefined && !("length" in props)) {
    			console.warn("<ListGroup> was created without expected prop 'length'");
    		}
    	}

    	get label() {
    		throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get length() {
    		throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set length(value) {
    		throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filter() {
    		throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filter(value) {
    		throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get fixed() {
    		throw new Error("<ListGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set fixed(value) {
    		throw new Error("<ListGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/controlledSelect/ControlledSelectGroupedMultiple.svelte generated by Svelte v3.24.0 */
    const file$s = "src/js/components/controlledSelect/ControlledSelectGroupedMultiple.svelte";

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[22] = i;
    	return child_ctx;
    }

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	child_ctx[19] = i;
    	return child_ctx;
    }

    // (41:10) {#each group.options as option, optionIndex (option.value)}
    function create_each_block_1$1(key_1, ctx) {
    	let input;
    	let input_id_value;
    	let input_value_value;
    	let input_disabled_value;
    	let t0;
    	let label_1;
    	let int;
    	let t1;
    	let svg;
    	let use;
    	let label_1_for_value;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*option*/ ctx[20].label },
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			input = element("input");
    			t0 = space();
    			label_1 = element("label");
    			create_component(int.$$.fragment);
    			t1 = space();
    			svg = svg_element("svg");
    			use = svg_element("use");
    			attr_dev(input, "class", "txcm-controlledSelectInput");
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "name", /*name*/ ctx[2]);
    			attr_dev(input, "id", input_id_value = renderID(/*name*/ ctx[2], `${/*index*/ ctx[19]}-${/*optionIndex*/ ctx[22]}`));
    			input.__value = input_value_value = `${/*index*/ ctx[19]}-${/*optionIndex*/ ctx[22]}`;
    			input.value = input.__value;
    			input.disabled = input_disabled_value = /*option*/ ctx[20].disabled;
    			/*$$binding_groups*/ ctx[13][0].push(input);
    			add_location(input, file$s, 41, 12, 1109);
    			xlink_attr(use, "xlink:href", "#txspt-icons-checkmark");
    			add_location(use, file$s, 56, 20, 1691);
    			attr_dev(svg, "class", "txcm-controlledSelectIcon");
    			add_location(svg, file$s, 54, 16, 1613);
    			attr_dev(label_1, "for", label_1_for_value = renderID(/*name*/ ctx[2], `${/*index*/ ctx[19]}-${/*optionIndex*/ ctx[22]}`));
    			attr_dev(label_1, "class", "txcm-controlledSelectLabel");
    			add_location(label_1, file$s, 49, 12, 1417);
    			this.first = input;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = ~/*selected*/ ctx[10].indexOf(input.__value);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, label_1, anchor);
    			mount_component(int, label_1, null);
    			append_dev(label_1, t1);
    			append_dev(label_1, svg);
    			append_dev(svg, use);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[12]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*name*/ 4) {
    				attr_dev(input, "name", /*name*/ ctx[2]);
    			}

    			if (!current || dirty & /*name, filtered*/ 2052 && input_id_value !== (input_id_value = renderID(/*name*/ ctx[2], `${/*index*/ ctx[19]}-${/*optionIndex*/ ctx[22]}`))) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (!current || dirty & /*filtered*/ 2048 && input_value_value !== (input_value_value = `${/*index*/ ctx[19]}-${/*optionIndex*/ ctx[22]}`)) {
    				prop_dev(input, "__value", input_value_value);
    				input.value = input.__value;
    			}

    			if (!current || dirty & /*filtered*/ 2048 && input_disabled_value !== (input_disabled_value = /*option*/ ctx[20].disabled)) {
    				prop_dev(input, "disabled", input_disabled_value);
    			}

    			if (dirty & /*selected*/ 1024) {
    				input.checked = ~/*selected*/ ctx[10].indexOf(input.__value);
    			}

    			const int_changes = {};
    			if (dirty & /*filtered*/ 2048) int_changes.key = /*option*/ ctx[20].label;
    			int.$set(int_changes);

    			if (!current || dirty & /*name, filtered*/ 2052 && label_1_for_value !== (label_1_for_value = renderID(/*name*/ ctx[2], `${/*index*/ ctx[19]}-${/*optionIndex*/ ctx[22]}`))) {
    				attr_dev(label_1, "for", label_1_for_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*$$binding_groups*/ ctx[13][0].splice(/*$$binding_groups*/ ctx[13][0].indexOf(input), 1);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(label_1);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(41:10) {#each group.options as option, optionIndex (option.value)}",
    		ctx
    	});

    	return block;
    }

    // (37:6) <ListGroup         label={group.label}         count={options.length}         length={group.length}>
    function create_default_slot_1$2(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t;
    	let current;
    	let each_value_1 = /*group*/ ctx[17].options;
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*option*/ ctx[20].value;
    	validate_each_keys(ctx, each_value_1, get_each_context_1$1, get_key);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$1(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$1(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*renderID, name, filtered, selected*/ 3076) {
    				const each_value_1 = /*group*/ ctx[17].options;
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$1, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, t.parentNode, outro_and_destroy_block, create_each_block_1$1, t, get_each_context_1$1);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(37:6) <ListGroup         label={group.label}         count={options.length}         length={group.length}>",
    		ctx
    	});

    	return block;
    }

    // (36:4) {#each filtered as group, index (group.value)}
    function create_each_block$9(key_1, ctx) {
    	let first;
    	let listgroup;
    	let current;

    	listgroup = new ListGroup({
    			props: {
    				label: /*group*/ ctx[17].label,
    				count: /*options*/ ctx[3].length,
    				length: /*group*/ ctx[17].length,
    				$$slots: { default: [create_default_slot_1$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(listgroup.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(listgroup, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listgroup_changes = {};
    			if (dirty & /*filtered*/ 2048) listgroup_changes.label = /*group*/ ctx[17].label;
    			if (dirty & /*options*/ 8) listgroup_changes.count = /*options*/ ctx[3].length;
    			if (dirty & /*filtered*/ 2048) listgroup_changes.length = /*group*/ ctx[17].length;

    			if (dirty & /*$$scope, filtered, name, selected*/ 8391684) {
    				listgroup_changes.$$scope = { dirty, ctx };
    			}

    			listgroup.$set(listgroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listgroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listgroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(listgroup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(36:4) {#each filtered as group, index (group.value)}",
    		ctx
    	});

    	return block;
    }

    // (25:0) <ControlledSelectContainer   bind:filter   bind:pick   bind:selected   {label}   {options}   {theme}   {multiple}   {grouped}   {disabled}   {acceptLabel}>
    function create_default_slot$7(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = /*filtered*/ ctx[11];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*group*/ ctx[17].value;
    	validate_each_keys(ctx, each_value, get_each_context$9, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$9(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$9(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*filtered, options, renderID, name, selected*/ 3084) {
    				const each_value = /*filtered*/ ctx[11];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$9, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$9, each_1_anchor, get_each_context$9);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(25:0) <ControlledSelectContainer   bind:filter   bind:pick   bind:selected   {label}   {options}   {theme}   {multiple}   {grouped}   {disabled}   {acceptLabel}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$x(ctx) {
    	let controlledselectcontainer;
    	let updating_filter;
    	let updating_pick;
    	let updating_selected;
    	let current;

    	function controlledselectcontainer_filter_binding(value) {
    		/*controlledselectcontainer_filter_binding*/ ctx[14].call(null, value);
    	}

    	function controlledselectcontainer_pick_binding(value) {
    		/*controlledselectcontainer_pick_binding*/ ctx[15].call(null, value);
    	}

    	function controlledselectcontainer_selected_binding(value) {
    		/*controlledselectcontainer_selected_binding*/ ctx[16].call(null, value);
    	}

    	let controlledselectcontainer_props = {
    		label: /*label*/ ctx[1],
    		options: /*options*/ ctx[3],
    		theme: /*theme*/ ctx[4],
    		multiple: /*multiple*/ ctx[5],
    		grouped: /*grouped*/ ctx[6],
    		disabled: /*disabled*/ ctx[7],
    		acceptLabel: /*acceptLabel*/ ctx[8],
    		$$slots: { default: [create_default_slot$7] },
    		$$scope: { ctx }
    	};

    	if (/*filter*/ ctx[9] !== void 0) {
    		controlledselectcontainer_props.filter = /*filter*/ ctx[9];
    	}

    	if (/*pick*/ ctx[0] !== void 0) {
    		controlledselectcontainer_props.pick = /*pick*/ ctx[0];
    	}

    	if (/*selected*/ ctx[10] !== void 0) {
    		controlledselectcontainer_props.selected = /*selected*/ ctx[10];
    	}

    	controlledselectcontainer = new ControlledSelectContainer({
    			props: controlledselectcontainer_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(controlledselectcontainer, "filter", controlledselectcontainer_filter_binding));
    	binding_callbacks.push(() => bind(controlledselectcontainer, "pick", controlledselectcontainer_pick_binding));
    	binding_callbacks.push(() => bind(controlledselectcontainer, "selected", controlledselectcontainer_selected_binding));

    	const block = {
    		c: function create() {
    			create_component(controlledselectcontainer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(controlledselectcontainer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const controlledselectcontainer_changes = {};
    			if (dirty & /*label*/ 2) controlledselectcontainer_changes.label = /*label*/ ctx[1];
    			if (dirty & /*options*/ 8) controlledselectcontainer_changes.options = /*options*/ ctx[3];
    			if (dirty & /*theme*/ 16) controlledselectcontainer_changes.theme = /*theme*/ ctx[4];
    			if (dirty & /*multiple*/ 32) controlledselectcontainer_changes.multiple = /*multiple*/ ctx[5];
    			if (dirty & /*grouped*/ 64) controlledselectcontainer_changes.grouped = /*grouped*/ ctx[6];
    			if (dirty & /*disabled*/ 128) controlledselectcontainer_changes.disabled = /*disabled*/ ctx[7];
    			if (dirty & /*acceptLabel*/ 256) controlledselectcontainer_changes.acceptLabel = /*acceptLabel*/ ctx[8];

    			if (dirty & /*$$scope, filtered, options, name, selected*/ 8391692) {
    				controlledselectcontainer_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_filter && dirty & /*filter*/ 512) {
    				updating_filter = true;
    				controlledselectcontainer_changes.filter = /*filter*/ ctx[9];
    				add_flush_callback(() => updating_filter = false);
    			}

    			if (!updating_pick && dirty & /*pick*/ 1) {
    				updating_pick = true;
    				controlledselectcontainer_changes.pick = /*pick*/ ctx[0];
    				add_flush_callback(() => updating_pick = false);
    			}

    			if (!updating_selected && dirty & /*selected*/ 1024) {
    				updating_selected = true;
    				controlledselectcontainer_changes.selected = /*selected*/ ctx[10];
    				add_flush_callback(() => updating_selected = false);
    			}

    			controlledselectcontainer.$set(controlledselectcontainer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(controlledselectcontainer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(controlledselectcontainer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(controlledselectcontainer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	let { pick } = $$props;
    	let { name } = $$props;
    	let { options } = $$props;
    	let { theme } = $$props;
    	let { multiple } = $$props;
    	let { grouped } = $$props;
    	let { disabled } = $$props;
    	let { acceptLabel } = $$props;
    	let filter = "";
    	let selected = findGroupedIndexes(options, pick);

    	const writable_props = [
    		"label",
    		"pick",
    		"name",
    		"options",
    		"theme",
    		"multiple",
    		"grouped",
    		"disabled",
    		"acceptLabel"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ControlledSelectGroupedMultiple> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ControlledSelectGroupedMultiple", $$slots, []);
    	const $$binding_groups = [[]];

    	function input_change_handler() {
    		selected = get_binding_group_value($$binding_groups[0], this.__value, this.checked);
    		$$invalidate(10, selected);
    	}

    	function controlledselectcontainer_filter_binding(value) {
    		filter = value;
    		$$invalidate(9, filter);
    	}

    	function controlledselectcontainer_pick_binding(value) {
    		pick = value;
    		$$invalidate(0, pick);
    	}

    	function controlledselectcontainer_selected_binding(value) {
    		selected = value;
    		$$invalidate(10, selected);
    	}

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("name" in $$props) $$invalidate(2, name = $$props.name);
    		if ("options" in $$props) $$invalidate(3, options = $$props.options);
    		if ("theme" in $$props) $$invalidate(4, theme = $$props.theme);
    		if ("multiple" in $$props) $$invalidate(5, multiple = $$props.multiple);
    		if ("grouped" in $$props) $$invalidate(6, grouped = $$props.grouped);
    		if ("disabled" in $$props) $$invalidate(7, disabled = $$props.disabled);
    		if ("acceptLabel" in $$props) $$invalidate(8, acceptLabel = $$props.acceptLabel);
    	};

    	$$self.$capture_state = () => ({
    		renderID,
    		findGroupedIndexes,
    		filterSelectGroups,
    		Int,
    		ListGroup,
    		ControlledSelectContainer,
    		label,
    		pick,
    		name,
    		options,
    		theme,
    		multiple,
    		grouped,
    		disabled,
    		acceptLabel,
    		filter,
    		selected,
    		filtered
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("name" in $$props) $$invalidate(2, name = $$props.name);
    		if ("options" in $$props) $$invalidate(3, options = $$props.options);
    		if ("theme" in $$props) $$invalidate(4, theme = $$props.theme);
    		if ("multiple" in $$props) $$invalidate(5, multiple = $$props.multiple);
    		if ("grouped" in $$props) $$invalidate(6, grouped = $$props.grouped);
    		if ("disabled" in $$props) $$invalidate(7, disabled = $$props.disabled);
    		if ("acceptLabel" in $$props) $$invalidate(8, acceptLabel = $$props.acceptLabel);
    		if ("filter" in $$props) $$invalidate(9, filter = $$props.filter);
    		if ("selected" in $$props) $$invalidate(10, selected = $$props.selected);
    		if ("filtered" in $$props) $$invalidate(11, filtered = $$props.filtered);
    	};

    	let filtered;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*options, filter*/ 520) {
    			 $$invalidate(11, filtered = filterSelectGroups(options, filter));
    		}
    	};

    	return [
    		pick,
    		label,
    		name,
    		options,
    		theme,
    		multiple,
    		grouped,
    		disabled,
    		acceptLabel,
    		filter,
    		selected,
    		filtered,
    		input_change_handler,
    		$$binding_groups,
    		controlledselectcontainer_filter_binding,
    		controlledselectcontainer_pick_binding,
    		controlledselectcontainer_selected_binding
    	];
    }

    class ControlledSelectGroupedMultiple extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {
    			label: 1,
    			pick: 0,
    			name: 2,
    			options: 3,
    			theme: 4,
    			multiple: 5,
    			grouped: 6,
    			disabled: 7,
    			acceptLabel: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ControlledSelectGroupedMultiple",
    			options,
    			id: create_fragment$x.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[1] === undefined && !("label" in props)) {
    			console.warn("<ControlledSelectGroupedMultiple> was created without expected prop 'label'");
    		}

    		if (/*pick*/ ctx[0] === undefined && !("pick" in props)) {
    			console.warn("<ControlledSelectGroupedMultiple> was created without expected prop 'pick'");
    		}

    		if (/*name*/ ctx[2] === undefined && !("name" in props)) {
    			console.warn("<ControlledSelectGroupedMultiple> was created without expected prop 'name'");
    		}

    		if (/*options*/ ctx[3] === undefined && !("options" in props)) {
    			console.warn("<ControlledSelectGroupedMultiple> was created without expected prop 'options'");
    		}

    		if (/*theme*/ ctx[4] === undefined && !("theme" in props)) {
    			console.warn("<ControlledSelectGroupedMultiple> was created without expected prop 'theme'");
    		}

    		if (/*multiple*/ ctx[5] === undefined && !("multiple" in props)) {
    			console.warn("<ControlledSelectGroupedMultiple> was created without expected prop 'multiple'");
    		}

    		if (/*grouped*/ ctx[6] === undefined && !("grouped" in props)) {
    			console.warn("<ControlledSelectGroupedMultiple> was created without expected prop 'grouped'");
    		}

    		if (/*disabled*/ ctx[7] === undefined && !("disabled" in props)) {
    			console.warn("<ControlledSelectGroupedMultiple> was created without expected prop 'disabled'");
    		}

    		if (/*acceptLabel*/ ctx[8] === undefined && !("acceptLabel" in props)) {
    			console.warn("<ControlledSelectGroupedMultiple> was created without expected prop 'acceptLabel'");
    		}
    	}

    	get label() {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pick() {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pick(value) {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get theme() {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set theme(value) {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiple() {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiple(value) {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get grouped() {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set grouped(value) {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get acceptLabel() {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set acceptLabel(value) {
    		throw new Error("<ControlledSelectGroupedMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/controlledSelect/ControlledSelectMultiple.svelte generated by Svelte v3.24.0 */
    const file$t = "src/js/components/controlledSelect/ControlledSelectMultiple.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[18] = list[i];
    	child_ctx[20] = i;
    	return child_ctx;
    }

    // (45:4) {#each filtered as option, index (renderID(name, option.index || index))}
    function create_each_block$a(key_1, ctx) {
    	let input;
    	let input_id_value;
    	let input_value_value;
    	let input_disabled_value;
    	let t0;
    	let label_1;
    	let int;
    	let t1;
    	let svg;
    	let use;
    	let t2;
    	let label_1_for_value;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*option*/ ctx[18].label },
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			input = element("input");
    			t0 = space();
    			label_1 = element("label");
    			create_component(int.$$.fragment);
    			t1 = space();
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t2 = space();
    			attr_dev(input, "class", "txcm-controlledSelectInput");
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "name", /*name*/ ctx[2]);
    			attr_dev(input, "id", input_id_value = renderID(/*name*/ ctx[2], /*option*/ ctx[18].index || /*index*/ ctx[20]));
    			input.__value = input_value_value = /*option*/ ctx[18].index || /*index*/ ctx[20];
    			input.value = input.__value;
    			input.disabled = input_disabled_value = /*option*/ ctx[18].disabled;
    			/*$$binding_groups*/ ctx[13][0].push(input);
    			add_location(input, file$t, 45, 6, 1126);
    			xlink_attr(use, "xlink:href", "#txspt-icons-checkmark");
    			add_location(use, file$t, 60, 14, 1606);
    			attr_dev(svg, "class", "txcm-controlledSelectIcon");
    			add_location(svg, file$t, 58, 10, 1540);
    			attr_dev(label_1, "for", label_1_for_value = renderID(/*name*/ ctx[2], /*option*/ ctx[18].index || /*index*/ ctx[20]));
    			attr_dev(label_1, "class", "txcm-controlledSelectLabel");
    			add_location(label_1, file$t, 53, 6, 1378);
    			this.first = input;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = ~/*selected*/ ctx[10].indexOf(input.__value);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, label_1, anchor);
    			mount_component(int, label_1, null);
    			append_dev(label_1, t1);
    			append_dev(label_1, svg);
    			append_dev(svg, use);
    			append_dev(label_1, t2);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[12]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*name*/ 4) {
    				attr_dev(input, "name", /*name*/ ctx[2]);
    			}

    			if (!current || dirty & /*name, filtered*/ 2052 && input_id_value !== (input_id_value = renderID(/*name*/ ctx[2], /*option*/ ctx[18].index || /*index*/ ctx[20]))) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (!current || dirty & /*filtered*/ 2048 && input_value_value !== (input_value_value = /*option*/ ctx[18].index || /*index*/ ctx[20])) {
    				prop_dev(input, "__value", input_value_value);
    				input.value = input.__value;
    			}

    			if (!current || dirty & /*filtered*/ 2048 && input_disabled_value !== (input_disabled_value = /*option*/ ctx[18].disabled)) {
    				prop_dev(input, "disabled", input_disabled_value);
    			}

    			if (dirty & /*selected*/ 1024) {
    				input.checked = ~/*selected*/ ctx[10].indexOf(input.__value);
    			}

    			const int_changes = {};
    			if (dirty & /*filtered*/ 2048) int_changes.key = /*option*/ ctx[18].label;
    			int.$set(int_changes);

    			if (!current || dirty & /*name, filtered*/ 2052 && label_1_for_value !== (label_1_for_value = renderID(/*name*/ ctx[2], /*option*/ ctx[18].index || /*index*/ ctx[20]))) {
    				attr_dev(label_1, "for", label_1_for_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*$$binding_groups*/ ctx[13][0].splice(/*$$binding_groups*/ ctx[13][0].indexOf(input), 1);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(label_1);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(45:4) {#each filtered as option, index (renderID(name, option.index || index))}",
    		ctx
    	});

    	return block;
    }

    // (34:0) <ControlledSelectContainer   bind:filter   bind:pick   bind:selected   {label}   {options}   {theme}   {multiple}   {grouped}   {disabled}   {acceptLabel}>
    function create_default_slot$8(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = /*filtered*/ ctx[11];
    	validate_each_argument(each_value);
    	const get_key = ctx => renderID(/*name*/ ctx[2], /*option*/ ctx[18].index || /*index*/ ctx[20]);
    	validate_each_keys(ctx, each_value, get_each_context$a, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$a(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$a(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*renderID, name, filtered, selected*/ 3076) {
    				const each_value = /*filtered*/ ctx[11];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$a, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$a, each_1_anchor, get_each_context$a);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(34:0) <ControlledSelectContainer   bind:filter   bind:pick   bind:selected   {label}   {options}   {theme}   {multiple}   {grouped}   {disabled}   {acceptLabel}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let controlledselectcontainer;
    	let updating_filter;
    	let updating_pick;
    	let updating_selected;
    	let current;

    	function controlledselectcontainer_filter_binding(value) {
    		/*controlledselectcontainer_filter_binding*/ ctx[14].call(null, value);
    	}

    	function controlledselectcontainer_pick_binding(value) {
    		/*controlledselectcontainer_pick_binding*/ ctx[15].call(null, value);
    	}

    	function controlledselectcontainer_selected_binding(value) {
    		/*controlledselectcontainer_selected_binding*/ ctx[16].call(null, value);
    	}

    	let controlledselectcontainer_props = {
    		label: /*label*/ ctx[1],
    		options: /*options*/ ctx[3],
    		theme: /*theme*/ ctx[4],
    		multiple: /*multiple*/ ctx[5],
    		grouped: /*grouped*/ ctx[6],
    		disabled: /*disabled*/ ctx[7],
    		acceptLabel: /*acceptLabel*/ ctx[8],
    		$$slots: { default: [create_default_slot$8] },
    		$$scope: { ctx }
    	};

    	if (/*filter*/ ctx[9] !== void 0) {
    		controlledselectcontainer_props.filter = /*filter*/ ctx[9];
    	}

    	if (/*pick*/ ctx[0] !== void 0) {
    		controlledselectcontainer_props.pick = /*pick*/ ctx[0];
    	}

    	if (/*selected*/ ctx[10] !== void 0) {
    		controlledselectcontainer_props.selected = /*selected*/ ctx[10];
    	}

    	controlledselectcontainer = new ControlledSelectContainer({
    			props: controlledselectcontainer_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(controlledselectcontainer, "filter", controlledselectcontainer_filter_binding));
    	binding_callbacks.push(() => bind(controlledselectcontainer, "pick", controlledselectcontainer_pick_binding));
    	binding_callbacks.push(() => bind(controlledselectcontainer, "selected", controlledselectcontainer_selected_binding));

    	const block = {
    		c: function create() {
    			create_component(controlledselectcontainer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(controlledselectcontainer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const controlledselectcontainer_changes = {};
    			if (dirty & /*label*/ 2) controlledselectcontainer_changes.label = /*label*/ ctx[1];
    			if (dirty & /*options*/ 8) controlledselectcontainer_changes.options = /*options*/ ctx[3];
    			if (dirty & /*theme*/ 16) controlledselectcontainer_changes.theme = /*theme*/ ctx[4];
    			if (dirty & /*multiple*/ 32) controlledselectcontainer_changes.multiple = /*multiple*/ ctx[5];
    			if (dirty & /*grouped*/ 64) controlledselectcontainer_changes.grouped = /*grouped*/ ctx[6];
    			if (dirty & /*disabled*/ 128) controlledselectcontainer_changes.disabled = /*disabled*/ ctx[7];
    			if (dirty & /*acceptLabel*/ 256) controlledselectcontainer_changes.acceptLabel = /*acceptLabel*/ ctx[8];

    			if (dirty & /*$$scope, filtered, name, selected*/ 2100228) {
    				controlledselectcontainer_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_filter && dirty & /*filter*/ 512) {
    				updating_filter = true;
    				controlledselectcontainer_changes.filter = /*filter*/ ctx[9];
    				add_flush_callback(() => updating_filter = false);
    			}

    			if (!updating_pick && dirty & /*pick*/ 1) {
    				updating_pick = true;
    				controlledselectcontainer_changes.pick = /*pick*/ ctx[0];
    				add_flush_callback(() => updating_pick = false);
    			}

    			if (!updating_selected && dirty & /*selected*/ 1024) {
    				updating_selected = true;
    				controlledselectcontainer_changes.selected = /*selected*/ ctx[10];
    				add_flush_callback(() => updating_selected = false);
    			}

    			controlledselectcontainer.$set(controlledselectcontainer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(controlledselectcontainer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(controlledselectcontainer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(controlledselectcontainer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	let { pick } = $$props;
    	let { name } = $$props;
    	let { options } = $$props;
    	let { theme } = $$props;
    	let { multiple } = $$props;
    	let { grouped } = $$props;
    	let { disabled } = $$props;
    	let { acceptLabel } = $$props;
    	let filter = "";
    	let selected = findIndexes(options, pick);
    	let filtered = [];

    	function filerSelectOptionsAsync() {
    		new Promise(resolve => {
    				return resolve(filterSelectOptions(options, filter, label === "Магазин"));
    			}).then(items => {
    			$$invalidate(11, filtered = items);
    		});
    	}

    	const writable_props = [
    		"label",
    		"pick",
    		"name",
    		"options",
    		"theme",
    		"multiple",
    		"grouped",
    		"disabled",
    		"acceptLabel"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ControlledSelectMultiple> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ControlledSelectMultiple", $$slots, []);
    	const $$binding_groups = [[]];

    	function input_change_handler() {
    		selected = get_binding_group_value($$binding_groups[0], this.__value, this.checked);
    		$$invalidate(10, selected);
    	}

    	function controlledselectcontainer_filter_binding(value) {
    		filter = value;
    		$$invalidate(9, filter);
    	}

    	function controlledselectcontainer_pick_binding(value) {
    		pick = value;
    		$$invalidate(0, pick);
    	}

    	function controlledselectcontainer_selected_binding(value) {
    		selected = value;
    		$$invalidate(10, selected);
    	}

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("name" in $$props) $$invalidate(2, name = $$props.name);
    		if ("options" in $$props) $$invalidate(3, options = $$props.options);
    		if ("theme" in $$props) $$invalidate(4, theme = $$props.theme);
    		if ("multiple" in $$props) $$invalidate(5, multiple = $$props.multiple);
    		if ("grouped" in $$props) $$invalidate(6, grouped = $$props.grouped);
    		if ("disabled" in $$props) $$invalidate(7, disabled = $$props.disabled);
    		if ("acceptLabel" in $$props) $$invalidate(8, acceptLabel = $$props.acceptLabel);
    	};

    	$$self.$capture_state = () => ({
    		renderID,
    		findIndexes,
    		filterSelectOptions,
    		Int,
    		ControlledSelectContainer,
    		label,
    		pick,
    		name,
    		options,
    		theme,
    		multiple,
    		grouped,
    		disabled,
    		acceptLabel,
    		filter,
    		selected,
    		filtered,
    		filerSelectOptionsAsync
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("name" in $$props) $$invalidate(2, name = $$props.name);
    		if ("options" in $$props) $$invalidate(3, options = $$props.options);
    		if ("theme" in $$props) $$invalidate(4, theme = $$props.theme);
    		if ("multiple" in $$props) $$invalidate(5, multiple = $$props.multiple);
    		if ("grouped" in $$props) $$invalidate(6, grouped = $$props.grouped);
    		if ("disabled" in $$props) $$invalidate(7, disabled = $$props.disabled);
    		if ("acceptLabel" in $$props) $$invalidate(8, acceptLabel = $$props.acceptLabel);
    		if ("filter" in $$props) $$invalidate(9, filter = $$props.filter);
    		if ("selected" in $$props) $$invalidate(10, selected = $$props.selected);
    		if ("filtered" in $$props) $$invalidate(11, filtered = $$props.filtered);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*options, filter, label*/ 522) {
    			 filerSelectOptionsAsync();
    		}
    	};

    	return [
    		pick,
    		label,
    		name,
    		options,
    		theme,
    		multiple,
    		grouped,
    		disabled,
    		acceptLabel,
    		filter,
    		selected,
    		filtered,
    		input_change_handler,
    		$$binding_groups,
    		controlledselectcontainer_filter_binding,
    		controlledselectcontainer_pick_binding,
    		controlledselectcontainer_selected_binding
    	];
    }

    class ControlledSelectMultiple extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {
    			label: 1,
    			pick: 0,
    			name: 2,
    			options: 3,
    			theme: 4,
    			multiple: 5,
    			grouped: 6,
    			disabled: 7,
    			acceptLabel: 8
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ControlledSelectMultiple",
    			options,
    			id: create_fragment$y.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[1] === undefined && !("label" in props)) {
    			console.warn("<ControlledSelectMultiple> was created without expected prop 'label'");
    		}

    		if (/*pick*/ ctx[0] === undefined && !("pick" in props)) {
    			console.warn("<ControlledSelectMultiple> was created without expected prop 'pick'");
    		}

    		if (/*name*/ ctx[2] === undefined && !("name" in props)) {
    			console.warn("<ControlledSelectMultiple> was created without expected prop 'name'");
    		}

    		if (/*options*/ ctx[3] === undefined && !("options" in props)) {
    			console.warn("<ControlledSelectMultiple> was created without expected prop 'options'");
    		}

    		if (/*theme*/ ctx[4] === undefined && !("theme" in props)) {
    			console.warn("<ControlledSelectMultiple> was created without expected prop 'theme'");
    		}

    		if (/*multiple*/ ctx[5] === undefined && !("multiple" in props)) {
    			console.warn("<ControlledSelectMultiple> was created without expected prop 'multiple'");
    		}

    		if (/*grouped*/ ctx[6] === undefined && !("grouped" in props)) {
    			console.warn("<ControlledSelectMultiple> was created without expected prop 'grouped'");
    		}

    		if (/*disabled*/ ctx[7] === undefined && !("disabled" in props)) {
    			console.warn("<ControlledSelectMultiple> was created without expected prop 'disabled'");
    		}

    		if (/*acceptLabel*/ ctx[8] === undefined && !("acceptLabel" in props)) {
    			console.warn("<ControlledSelectMultiple> was created without expected prop 'acceptLabel'");
    		}
    	}

    	get label() {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pick() {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pick(value) {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get theme() {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set theme(value) {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiple() {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiple(value) {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get grouped() {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set grouped(value) {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get acceptLabel() {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set acceptLabel(value) {
    		throw new Error("<ControlledSelectMultiple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/controlledSelect/ControlledSelect.svelte generated by Svelte v3.24.0 */

    function create_fragment$z(ctx) {
    	let switch_instance;
    	let updating_pick;
    	let switch_instance_anchor;
    	let current;

    	function switch_instance_pick_binding(value) {
    		/*switch_instance_pick_binding*/ ctx[9].call(null, value);
    	}

    	var switch_value = pickComponent(/*multiple*/ ctx[8], /*grouped*/ ctx[4]);

    	function switch_props(ctx) {
    		let switch_instance_props = {
    			label: /*label*/ ctx[1],
    			name: /*name*/ ctx[2],
    			options: /*options*/ ctx[3],
    			theme: /*theme*/ ctx[5],
    			multiple: /*multiple*/ ctx[8],
    			grouped: /*grouped*/ ctx[4],
    			disabled: /*disabled*/ ctx[6],
    			acceptLabel: /*acceptLabel*/ ctx[7]
    		};

    		if (/*pick*/ ctx[0] !== void 0) {
    			switch_instance_props.pick = /*pick*/ ctx[0];
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind(switch_instance, "pick", switch_instance_pick_binding));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*label*/ 2) switch_instance_changes.label = /*label*/ ctx[1];
    			if (dirty & /*name*/ 4) switch_instance_changes.name = /*name*/ ctx[2];
    			if (dirty & /*options*/ 8) switch_instance_changes.options = /*options*/ ctx[3];
    			if (dirty & /*theme*/ 32) switch_instance_changes.theme = /*theme*/ ctx[5];
    			if (dirty & /*grouped*/ 16) switch_instance_changes.grouped = /*grouped*/ ctx[4];
    			if (dirty & /*disabled*/ 64) switch_instance_changes.disabled = /*disabled*/ ctx[6];
    			if (dirty & /*acceptLabel*/ 128) switch_instance_changes.acceptLabel = /*acceptLabel*/ ctx[7];

    			if (!updating_pick && dirty & /*pick*/ 1) {
    				updating_pick = true;
    				switch_instance_changes.pick = /*pick*/ ctx[0];
    				add_flush_callback(() => updating_pick = false);
    			}

    			if (switch_value !== (switch_value = pickComponent(/*multiple*/ ctx[8], /*grouped*/ ctx[4]))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind(switch_instance, "pick", switch_instance_pick_binding));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function pickComponent(multiple, grouped) {
    	if (grouped) return ControlledSelectGroupedMultiple;
    	if (multiple) return ControlledSelectMultiple;
    	return ControlledSelectUnique;
    }

    function isMultiple$1(grouped, pick) {
    	return grouped || Array.isArray(pick);
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { pick = [] } = $$props;
    	let { label } = $$props;
    	let { name } = $$props;
    	let { options = [] } = $$props;
    	let { grouped = false } = $$props;
    	let { theme = "" } = $$props;
    	let { disabled = false } = $$props;
    	let { acceptLabel = "Применить фильтр" } = $$props;
    	const multiple = isMultiple$1(grouped, pick);

    	const writable_props = [
    		"pick",
    		"label",
    		"name",
    		"options",
    		"grouped",
    		"theme",
    		"disabled",
    		"acceptLabel"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ControlledSelect> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ControlledSelect", $$slots, []);

    	function switch_instance_pick_binding(value) {
    		pick = value;
    		$$invalidate(0, pick);
    	}

    	$$self.$set = $$props => {
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("name" in $$props) $$invalidate(2, name = $$props.name);
    		if ("options" in $$props) $$invalidate(3, options = $$props.options);
    		if ("grouped" in $$props) $$invalidate(4, grouped = $$props.grouped);
    		if ("theme" in $$props) $$invalidate(5, theme = $$props.theme);
    		if ("disabled" in $$props) $$invalidate(6, disabled = $$props.disabled);
    		if ("acceptLabel" in $$props) $$invalidate(7, acceptLabel = $$props.acceptLabel);
    	};

    	$$self.$capture_state = () => ({
    		ControlledSelectMultiple,
    		ControlledSelectGroupedMultiple,
    		ControlledSelectUnique,
    		pickComponent,
    		isMultiple: isMultiple$1,
    		pick,
    		label,
    		name,
    		options,
    		grouped,
    		theme,
    		disabled,
    		acceptLabel,
    		multiple
    	});

    	$$self.$inject_state = $$props => {
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("name" in $$props) $$invalidate(2, name = $$props.name);
    		if ("options" in $$props) $$invalidate(3, options = $$props.options);
    		if ("grouped" in $$props) $$invalidate(4, grouped = $$props.grouped);
    		if ("theme" in $$props) $$invalidate(5, theme = $$props.theme);
    		if ("disabled" in $$props) $$invalidate(6, disabled = $$props.disabled);
    		if ("acceptLabel" in $$props) $$invalidate(7, acceptLabel = $$props.acceptLabel);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		pick,
    		label,
    		name,
    		options,
    		grouped,
    		theme,
    		disabled,
    		acceptLabel,
    		multiple,
    		switch_instance_pick_binding
    	];
    }

    class ControlledSelect extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$z, create_fragment$z, safe_not_equal, {
    			pick: 0,
    			label: 1,
    			name: 2,
    			options: 3,
    			grouped: 4,
    			theme: 5,
    			disabled: 6,
    			acceptLabel: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ControlledSelect",
    			options,
    			id: create_fragment$z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[1] === undefined && !("label" in props)) {
    			console.warn("<ControlledSelect> was created without expected prop 'label'");
    		}

    		if (/*name*/ ctx[2] === undefined && !("name" in props)) {
    			console.warn("<ControlledSelect> was created without expected prop 'name'");
    		}
    	}

    	get pick() {
    		throw new Error("<ControlledSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pick(value) {
    		throw new Error("<ControlledSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<ControlledSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<ControlledSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get name() {
    		throw new Error("<ControlledSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set name(value) {
    		throw new Error("<ControlledSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<ControlledSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<ControlledSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get grouped() {
    		throw new Error("<ControlledSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set grouped(value) {
    		throw new Error("<ControlledSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get theme() {
    		throw new Error("<ControlledSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set theme(value) {
    		throw new Error("<ControlledSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<ControlledSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<ControlledSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get acceptLabel() {
    		throw new Error("<ControlledSelect>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set acceptLabel(value) {
    		throw new Error("<ControlledSelect>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/filter/FilterElement.svelte generated by Svelte v3.24.0 */

    function create_fragment$A(ctx) {
    	let switch_instance;
    	let updating_pick;
    	let switch_instance_anchor;
    	let current;

    	const switch_instance_spread_levels = [
    		/*pickProps*/ ctx[7](/*element*/ ctx[0]),
    		{ options: /*options*/ ctx[1] },
    		{ name: /*name*/ ctx[4] },
    		{ disabled: /*disabled*/ ctx[2] }
    	];

    	function switch_instance_pick_binding(value) {
    		/*switch_instance_pick_binding*/ ctx[8].call(null, value);
    	}

    	var switch_value = /*pickElement*/ ctx[6](/*element*/ ctx[0].type);

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		if (/*pick*/ ctx[3] !== void 0) {
    			switch_instance_props.pick = /*pick*/ ctx[3];
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    		binding_callbacks.push(() => bind(switch_instance, "pick", switch_instance_pick_binding));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = (dirty & /*pickProps, element, options, name, disabled*/ 151)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*pickProps, element*/ 129 && get_spread_object(/*pickProps*/ ctx[7](/*element*/ ctx[0])),
    					dirty & /*options*/ 2 && { options: /*options*/ ctx[1] },
    					dirty & /*name*/ 16 && { name: /*name*/ ctx[4] },
    					dirty & /*disabled*/ 4 && { disabled: /*disabled*/ ctx[2] }
    				])
    			: {};

    			if (!updating_pick && dirty & /*pick*/ 8) {
    				updating_pick = true;
    				switch_instance_changes.pick = /*pick*/ ctx[3];
    				add_flush_callback(() => updating_pick = false);
    			}

    			if (switch_value !== (switch_value = /*pickElement*/ ctx[6](/*element*/ ctx[0].type))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					binding_callbacks.push(() => bind(switch_instance, "pick", switch_instance_pick_binding));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function pickProp(props, propName, elementData) {
    	return {
    		...props,
    		[propName]: elementData[propName]
    	};
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let $valueStore;

    	const ELEMENTS = {
    		stepper: Stepper,
    		pick: Pick,
    		picks: Picks,
    		select: Select,
    		controlledSelect: ControlledSelect
    	};

    	const PROPS = {
    		stepper: ["cancel", "options"],
    		picks: [],
    		pick: ["label", "value"],
    		select: ["label"],
    		controlledSelect: ["label"]
    	};

    	let { element } = $$props;
    	let { options } = $$props;
    	let { disabled } = $$props;
    	const { data } = element;
    	const { name } = data;
    	const valueStore = getFilterState(name);
    	validate_store(valueStore, "valueStore");
    	component_subscribe($$self, valueStore, value => $$invalidate(9, $valueStore = value));
    	let { pick } = data;

    	function shouldUpdate() {
    		const valueFromStore = $valueStore;

    		if (Array.isArray(valueFromStore)) {
    			return pick.length !== valueFromStore.length || pick.some((pickValue, index) => pickValue !== valueFromStore[index]);
    		}

    		return pick !== valueFromStore;
    	}

    	async function updatePick() {
    		await tick();
    		if (shouldUpdate()) $$invalidate(3, pick = $valueStore);
    	}

    	function pickElement(type) {
    		if (ELEMENTS[type]) return ELEMENTS[type];
    		return ELEMENTS.pick;
    	}

    	function pickProps() {
    		const { type, data: elementData } = element;
    		const names = PROPS[type] || PROPS.pick;
    		return names.reduce((props, propName) => pickProp(props, propName, elementData), {});
    	}

    	function updateFilterElement() {
    		if (shouldUpdate()) updateFilter({ [name]: pick });
    	}

    	const writable_props = ["element", "options", "disabled"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FilterElement> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FilterElement", $$slots, []);

    	function switch_instance_pick_binding(value) {
    		pick = value;
    		$$invalidate(3, pick);
    	}

    	$$self.$set = $$props => {
    		if ("element" in $$props) $$invalidate(0, element = $$props.element);
    		if ("options" in $$props) $$invalidate(1, options = $$props.options);
    		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
    	};

    	$$self.$capture_state = () => ({
    		tick,
    		updateFilter,
    		getFilterState,
    		Pick,
    		Select,
    		Stepper,
    		Picks,
    		ControlledSelect,
    		ELEMENTS,
    		PROPS,
    		element,
    		options,
    		disabled,
    		data,
    		name,
    		valueStore,
    		pick,
    		shouldUpdate,
    		updatePick,
    		pickElement,
    		pickProp,
    		pickProps,
    		updateFilterElement,
    		$valueStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("element" in $$props) $$invalidate(0, element = $$props.element);
    		if ("options" in $$props) $$invalidate(1, options = $$props.options);
    		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
    		if ("pick" in $$props) $$invalidate(3, pick = $$props.pick);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$valueStore*/ 512) {
    			 updatePick();
    		}

    		if ($$self.$$.dirty & /*pick*/ 8) {
    			 updateFilterElement();
    		}
    	};

    	return [
    		element,
    		options,
    		disabled,
    		pick,
    		name,
    		valueStore,
    		pickElement,
    		pickProps,
    		switch_instance_pick_binding
    	];
    }

    class FilterElement extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { element: 0, options: 1, disabled: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FilterElement",
    			options,
    			id: create_fragment$A.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*element*/ ctx[0] === undefined && !("element" in props)) {
    			console.warn("<FilterElement> was created without expected prop 'element'");
    		}

    		if (/*options*/ ctx[1] === undefined && !("options" in props)) {
    			console.warn("<FilterElement> was created without expected prop 'options'");
    		}

    		if (/*disabled*/ ctx[2] === undefined && !("disabled" in props)) {
    			console.warn("<FilterElement> was created without expected prop 'disabled'");
    		}
    	}

    	get element() {
    		throw new Error("<FilterElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set element(value) {
    		throw new Error("<FilterElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<FilterElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<FilterElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<FilterElement>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<FilterElement>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/filter/FilterGroup.svelte generated by Svelte v3.24.0 */
    const file$u = "src/js/components/filter/FilterGroup.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (28:2) {#each elements as element}
    function create_each_block$b(ctx) {
    	let filterelement;
    	let current;

    	filterelement = new FilterElement({
    			props: {
    				element: /*element*/ ctx[6],
    				disabled: /*disabled*/ ctx[1],
    				options: /*generateElementOptions*/ ctx[3](/*element*/ ctx[6], /*options*/ ctx[0])
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(filterelement.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(filterelement, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const filterelement_changes = {};
    			if (dirty & /*disabled*/ 2) filterelement_changes.disabled = /*disabled*/ ctx[1];
    			if (dirty & /*options*/ 1) filterelement_changes.options = /*generateElementOptions*/ ctx[3](/*element*/ ctx[6], /*options*/ ctx[0]);
    			filterelement.$set(filterelement_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(filterelement.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(filterelement.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(filterelement, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(28:2) {#each elements as element}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let div;
    	let current;
    	let each_value = /*elements*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-filterGroup");
    			add_location(div, file$u, 26, 0, 664);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*elements, disabled, generateElementOptions, options*/ 15) {
    				each_value = /*elements*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function generateEmptyElementOptions({ type }) {
    	if (type === "pick") return null;
    	return [];
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { group } = $$props;
    	let { options } = $$props;
    	let { disabled } = $$props;
    	const { options: elements } = group;

    	function findElementOptions({ type, data }) {
    		const elementData = options.find(element => element.key === data.name);
    		if (!elementData) return generateEmptyElementOptions(type);
    		return elementData.data;
    	}

    	function generateElementOptions(element) {
    		if (!options) return generateEmptyElementOptions(element);
    		return findElementOptions(element);
    	}

    	const writable_props = ["group", "options", "disabled"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FilterGroup> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FilterGroup", $$slots, []);

    	$$self.$set = $$props => {
    		if ("group" in $$props) $$invalidate(4, group = $$props.group);
    		if ("options" in $$props) $$invalidate(0, options = $$props.options);
    		if ("disabled" in $$props) $$invalidate(1, disabled = $$props.disabled);
    	};

    	$$self.$capture_state = () => ({
    		FilterElement,
    		group,
    		options,
    		disabled,
    		elements,
    		generateEmptyElementOptions,
    		findElementOptions,
    		generateElementOptions
    	});

    	$$self.$inject_state = $$props => {
    		if ("group" in $$props) $$invalidate(4, group = $$props.group);
    		if ("options" in $$props) $$invalidate(0, options = $$props.options);
    		if ("disabled" in $$props) $$invalidate(1, disabled = $$props.disabled);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [options, disabled, elements, generateElementOptions, group];
    }

    class FilterGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, { group: 4, options: 0, disabled: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FilterGroup",
    			options,
    			id: create_fragment$B.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*group*/ ctx[4] === undefined && !("group" in props)) {
    			console.warn("<FilterGroup> was created without expected prop 'group'");
    		}

    		if (/*options*/ ctx[0] === undefined && !("options" in props)) {
    			console.warn("<FilterGroup> was created without expected prop 'options'");
    		}

    		if (/*disabled*/ ctx[1] === undefined && !("disabled" in props)) {
    			console.warn("<FilterGroup> was created without expected prop 'disabled'");
    		}
    	}

    	get group() {
    		throw new Error("<FilterGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set group(value) {
    		throw new Error("<FilterGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get options() {
    		throw new Error("<FilterGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<FilterGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<FilterGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<FilterGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/filter/FilterReset.svelte generated by Svelte v3.24.0 */
    const file$v = "src/js/components/filter/FilterReset.svelte";

    function create_fragment$C(ctx) {
    	let button;
    	let int;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: "Сбросить" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(int.$$.fragment);
    			attr_dev(button, "class", "txcm-filterReset");
    			button.disabled = /*disabled*/ ctx[0];
    			add_location(button, file$v, 26, 0, 600);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", prevent_default(/*onClick*/ ctx[1]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*disabled*/ 1) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function flattenGroup(group) {
    	return group.reduce(
    		(result, option) => ({
    			...result,
    			[option.data.name]: option.data.pick
    		}),
    		{}
    	);
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { config } = $$props;
    	let { disabled } = $$props;

    	function flattenConfig() {
    		return config.reduce(
    			(result, group) => ({
    				...result,
    				...flattenGroup(group.options)
    			}),
    			{}
    		);
    	}

    	function dropFilter() {
    		updateFilter(defaults);
    	}

    	function onClick() {
    		dropFilter();
    	}

    	const writable_props = ["config", "disabled"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FilterReset> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FilterReset", $$slots, []);

    	$$self.$set = $$props => {
    		if ("config" in $$props) $$invalidate(2, config = $$props.config);
    		if ("disabled" in $$props) $$invalidate(0, disabled = $$props.disabled);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		updateFilter,
    		config,
    		disabled,
    		flattenGroup,
    		flattenConfig,
    		dropFilter,
    		onClick,
    		defaults
    	});

    	$$self.$inject_state = $$props => {
    		if ("config" in $$props) $$invalidate(2, config = $$props.config);
    		if ("disabled" in $$props) $$invalidate(0, disabled = $$props.disabled);
    		if ("defaults" in $$props) defaults = $$props.defaults;
    	};

    	let defaults;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*config*/ 4) {
    			 defaults = flattenConfig();
    		}
    	};

    	return [disabled, onClick, config];
    }

    class FilterReset extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, { config: 2, disabled: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FilterReset",
    			options,
    			id: create_fragment$C.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*config*/ ctx[2] === undefined && !("config" in props)) {
    			console.warn("<FilterReset> was created without expected prop 'config'");
    		}

    		if (/*disabled*/ ctx[0] === undefined && !("disabled" in props)) {
    			console.warn("<FilterReset> was created without expected prop 'disabled'");
    		}
    	}

    	get config() {
    		throw new Error("<FilterReset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set config(value) {
    		throw new Error("<FilterReset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<FilterReset>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<FilterReset>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/filter/Filter.svelte generated by Svelte v3.24.0 */
    const file$w = "src/js/components/filter/Filter.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (28:4) {#each config as group, index (index)}
    function create_each_block$c(key_1, ctx) {
    	let first;
    	let filtergroup;
    	let current;

    	filtergroup = new FilterGroup({
    			props: {
    				group: /*group*/ ctx[7],
    				disabled: /*disabled*/ ctx[0],
    				options: /*normaizedData*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(filtergroup.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(filtergroup, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const filtergroup_changes = {};
    			if (dirty & /*disabled*/ 1) filtergroup_changes.disabled = /*disabled*/ ctx[0];
    			if (dirty & /*normaizedData*/ 2) filtergroup_changes.options = /*normaizedData*/ ctx[1];
    			filtergroup.$set(filtergroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(filtergroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(filtergroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(filtergroup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(28:4) {#each config as group, index (index)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let div;
    	let headerfilter;
    	let t0;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let filterreset;
    	let sectionScroll_action;
    	let current;
    	let mounted;
    	let dispose;

    	headerfilter = new HeaderFilter({
    			props: {
    				dashboard: /*dashboard*/ ctx[3],
    				variant: "filter"
    			},
    			$$inline: true
    		});

    	let each_value = /*config*/ ctx[2];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*index*/ ctx[9];
    	validate_each_keys(ctx, each_value, get_each_context$c, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$c(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$c(key, child_ctx));
    	}

    	filterreset = new FilterReset({
    			props: {
    				config: /*config*/ ctx[2],
    				disabled: /*disabled*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(headerfilter.$$.fragment);
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(filterreset.$$.fragment);
    			attr_dev(div, "class", "txcm-filter");
    			add_location(div, file$w, 21, 0, 552);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(headerfilter, div, null);
    			append_dev(div, t0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t1);
    			mount_component(filterreset, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(sectionScroll_action = sectionScroll.call(null, div));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*config, disabled, normaizedData*/ 7) {
    				const each_value = /*config*/ ctx[2];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$c, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$c, t1, get_each_context$c);
    				check_outros();
    			}

    			const filterreset_changes = {};
    			if (dirty & /*disabled*/ 1) filterreset_changes.disabled = /*disabled*/ ctx[0];
    			filterreset.$set(filterreset_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(headerfilter.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(filterreset.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(headerfilter.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(filterreset.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(headerfilter);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(filterreset);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { disabled } = $$props;
    	const context = getContext("config");
    	const config = context.getFilterConfig();
    	const dashboard = context.getDashboard();

    	function normalizeData() {
    		return data;
    	}

    	const writable_props = ["data", "disabled"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Filter> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Filter", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(4, data = $$props.data);
    		if ("disabled" in $$props) $$invalidate(0, disabled = $$props.disabled);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		sectionScroll,
    		HeaderFilter,
    		FilterGroup,
    		FilterReset,
    		data,
    		disabled,
    		context,
    		config,
    		dashboard,
    		normalizeData,
    		normaizedData
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(4, data = $$props.data);
    		if ("disabled" in $$props) $$invalidate(0, disabled = $$props.disabled);
    		if ("normaizedData" in $$props) $$invalidate(1, normaizedData = $$props.normaizedData);
    	};

    	let normaizedData;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 16) {
    			 $$invalidate(1, normaizedData = normalizeData());
    		}
    	};

    	return [disabled, normaizedData, config, dashboard, data];
    }

    class Filter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, { data: 4, disabled: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Filter",
    			options,
    			id: create_fragment$D.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[4] === undefined && !("data" in props)) {
    			console.warn("<Filter> was created without expected prop 'data'");
    		}

    		if (/*disabled*/ ctx[0] === undefined && !("disabled" in props)) {
    			console.warn("<Filter> was created without expected prop 'disabled'");
    		}
    	}

    	get data() {
    		throw new Error("<Filter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Filter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get disabled() {
    		throw new Error("<Filter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set disabled(value) {
    		throw new Error("<Filter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/loader/Loader.svelte generated by Svelte v3.24.0 */
    const file$x = "src/js/components/loader/Loader.svelte";

    // (30:6) {#if message}
    function create_if_block$5(ctx) {
    	let div;
    	let int;
    	let current;

    	int = new Int({
    			props: { key: /*message*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(int.$$.fragment);
    			attr_dev(div, "class", "txcm-loaderMessage");
    			set_style(div, "top", /*shift*/ ctx[1] + "px");
    			add_location(div, file$x, 30, 8, 1161);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(int, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*message*/ 1) int_changes.key = /*message*/ ctx[0];
    			int.$set(int_changes);

    			if (!current || dirty & /*shift*/ 2) {
    				set_style(div, "top", /*shift*/ ctx[1] + "px");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(30:6) {#if message}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let div;
    	let svg;
    	let clipPath;
    	let path0;
    	let use;
    	let path1;
    	let t;
    	let current;
    	let if_block = /*message*/ ctx[0] && create_if_block$5(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			clipPath = svg_element("clipPath");
    			path0 = svg_element("path");
    			use = svg_element("use");
    			path1 = svg_element("path");
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(path0, "id", "txcm-loaderForm");
    			attr_dev(path0, "d", "M2.13 2.19A7.221 7.221 0 000 7.325v9.518l.652-.1C2.254 16.5 3.75 15 3.75 13.5v-6c0-.948.448-1.946 1.125-2.625C5.552 4.198 6.554 3.75 7.5 3.75H24V0H7.253C5.321 0 3.501.814 2.13 2.19zM21.87 21.81A7.221 7.221 0 0024 16.675V7.156l-.652.1C21.746 7.501 20.25 9 20.25 10.5v6c0 .948-.448 1.946-1.125 2.625-.677.677-1.679 1.125-2.625 1.125H0V24h16.747c1.932 0 3.752-.814 5.124-2.19z");
    			add_location(path0, file$x, 17, 10, 389);
    			attr_dev(clipPath, "id", "txcm-loaderClipPath");
    			add_location(clipPath, file$x, 16, 8, 343);
    			attr_dev(use, "class", "txcm-loaderForm");
    			xlink_attr(use, "xlink:href", "#txcm-loaderForm");
    			add_location(use, file$x, 21, 8, 849);
    			attr_dev(path1, "class", "txcm-loaderPath");
    			attr_dev(path1, "d", "M1.85 7v15.15H17c3.5 0 5.15-3.15 5.15-5.15V1.85H7C4.5 1.85 1.85 4.5 1.85 7z");
    			attr_dev(path1, "clip-path", "url(#txcm-loaderClipPath)");
    			add_location(path1, file$x, 24, 8, 939);
    			attr_dev(svg, "class", "txcm-loaderIcon");
    			set_style(svg, "top", /*shift*/ ctx[1] + "px");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$x, 9, 4, 175);
    			attr_dev(div, "class", "txcm-loader");
    			add_location(div, file$x, 7, 0, 143);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, clipPath);
    			append_dev(clipPath, path0);
    			append_dev(svg, use);
    			append_dev(svg, path1);
    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*shift*/ 2) {
    				set_style(svg, "top", /*shift*/ ctx[1] + "px");
    			}

    			if (/*message*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*message*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { message = null } = $$props;
    	let { shift = 0 } = $$props;
    	const writable_props = ["message", "shift"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Loader> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Loader", $$slots, []);

    	$$self.$set = $$props => {
    		if ("message" in $$props) $$invalidate(0, message = $$props.message);
    		if ("shift" in $$props) $$invalidate(1, shift = $$props.shift);
    	};

    	$$self.$capture_state = () => ({ Int, message, shift });

    	$$self.$inject_state = $$props => {
    		if ("message" in $$props) $$invalidate(0, message = $$props.message);
    		if ("shift" in $$props) $$invalidate(1, shift = $$props.shift);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [message, shift];
    }

    class Loader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, { message: 0, shift: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Loader",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get message() {
    		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set message(value) {
    		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shift() {
    		throw new Error("<Loader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shift(value) {
    		throw new Error("<Loader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/reload/Reload.svelte generated by Svelte v3.24.0 */
    const file$y = "src/js/components/reload/Reload.svelte";

    function create_fragment$F(ctx) {
    	let div3;
    	let div0;
    	let t0;
    	let div2;
    	let div1;
    	let int0;
    	let t1;
    	let button;
    	let int1;
    	let current;
    	let mounted;
    	let dispose;

    	int0 = new Int({
    			props: {
    				key: "Сессия разъединена, пожалуйста, обновите страницу"
    			},
    			$$inline: true
    		});

    	int1 = new Int({
    			props: { key: "Обновить" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = space();
    			div2 = element("div");
    			div1 = element("div");
    			create_component(int0.$$.fragment);
    			t1 = space();
    			button = element("button");
    			create_component(int1.$$.fragment);
    			attr_dev(div0, "class", "txcm-background");
    			add_location(div0, file$y, 11, 2, 187);
    			add_location(div1, file$y, 17, 4, 276);
    			attr_dev(button, "class", "txcm-messageButton");
    			add_location(button, file$y, 20, 4, 366);
    			attr_dev(div2, "class", "txcm-message");
    			add_location(div2, file$y, 15, 2, 236);
    			attr_dev(div3, "class", "txcm-reload");
    			add_location(div3, file$y, 9, 0, 155);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div3, t0);
    			append_dev(div3, div2);
    			append_dev(div2, div1);
    			mount_component(int0, div1, null);
    			append_dev(div2, t1);
    			append_dev(div2, button);
    			mount_component(int1, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", handleReload, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(int0);
    			destroy_component(int1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function handleReload() {
    	window.location.reload();
    }

    function instance$F($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Reload> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Reload", $$slots, []);
    	$$self.$capture_state = () => ({ Int, handleReload });
    	return [];
    }

    class Reload extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Reload",
    			options,
    			id: create_fragment$F.name
    		});
    	}
    }

    function isFocusElsewhere(elements) {
      return !elements.some(element => element === document.activeElement);
    }

    function isFocusChangeKey(keyCode) {
      return keyCode === 9;
    }

    function isFocusForwardKey(shiftKey) {
      return !shiftKey;
    }

    function isFocusBackKey(shiftKey) {
      return shiftKey;
    }

    function focusFirst() {
      return 0;
    }

    function findFocus(elements) {
      return elements.indexOf(document.activeElement);
    }


    function focusNext(index, elements, max) {
      return index === max ? 0 : index + 1;
    }

    function focusPrev(index, elements, max) {
      return index === 0 ? max : index - 1;
    }

    function focusTrap(node) {
      const elements = [].slice.call(node.querySelectorAll('a, input, button, textarea, [contenteditable], [tabindex="0"]'));
      const max = elements.length - 1;

      let index;

      function updateIndex(shiftKey) {
        if (isFocusElsewhere(elements)) index = focusFirst();
        else {
          if (isNaN(index)) index = findFocus(elements);
          if (isFocusForwardKey(shiftKey)) index = focusNext(index, elements, max);
          else if (isFocusBackKey(shiftKey)) index = focusPrev(index, elements, max);
        }
      }

      function updateFocus() {
        elements[index].focus();
      }

      function trapFocus(shiftKey) {
        updateIndex(shiftKey);
        updateFocus();
      }

      function onDocumentKeyDown(event) {
        const { keyCode, shiftKey } = event;
        if (isFocusChangeKey(keyCode)) {
          event.preventDefault();
          trapFocus(shiftKey);
        }
      }

      function init() {
        document.addEventListener('keydown', onDocumentKeyDown);
      }

      function destroy() {
        document.removeEventListener('keydown', onDocumentKeyDown);
      }

      init();

      return {
        destroy,
      };
    }

    /* src/js/components/core/overlay/Overlay.svelte generated by Svelte v3.24.0 */
    const file$z = "src/js/components/core/overlay/Overlay.svelte";

    function create_fragment$G(ctx) {
    	let div;
    	let focusTrap_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "txcm-overlay");
    			toggle_class(div, "txcm-overlay-is-visible", /*isActive*/ ctx[0]);
    			add_location(div, file$z, 42, 0, 868);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(focusTrap_action = focusTrap.call(null, div));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}

    			if (dirty & /*isActive*/ 1) {
    				toggle_class(div, "txcm-overlay-is-visible", /*isActive*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function isCloseKey$2(keyCode) {
    	return keyCode === 27;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { isActive } = $$props;
    	const dispatch = createEventDispatcher();

    	function hide() {
    		if (isActive) dispatch("overlayclose");
    	}

    	function onWindowClick() {
    		hide();
    	}

    	function onKeyUp({ keyCode }) {
    		if (isCloseKey$2(keyCode) && isActive) hide();
    	}

    	function subscribeWindow() {
    		window.addEventListener("click", onWindowClick);
    		window.addEventListener("keyup", onKeyUp);
    	}

    	function unsubscribeWindow() {
    		window.removeEventListener("click", onWindowClick);
    		window.removeEventListener("keyup", onKeyUp);
    	}

    	function updateEvents() {
    		if (isActive) subscribeWindow(); else unsubscribeWindow();
    	}

    	const writable_props = ["isActive"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Overlay> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Overlay", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		focusTrap,
    		isActive,
    		dispatch,
    		isCloseKey: isCloseKey$2,
    		hide,
    		onWindowClick,
    		onKeyUp,
    		subscribeWindow,
    		unsubscribeWindow,
    		updateEvents
    	});

    	$$self.$inject_state = $$props => {
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*isActive*/ 1) {
    			 updateEvents();
    		}
    	};

    	return [isActive, $$scope, $$slots];
    }

    class Overlay extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, { isActive: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Overlay",
    			options,
    			id: create_fragment$G.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*isActive*/ ctx[0] === undefined && !("isActive" in props)) {
    			console.warn("<Overlay> was created without expected prop 'isActive'");
    		}
    	}

    	get isActive() {
    		throw new Error("<Overlay>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isActive(value) {
    		throw new Error("<Overlay>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/drawer/Drawer.svelte generated by Svelte v3.24.0 */
    const file$A = "src/js/components/drawer/Drawer.svelte";

    // (25:0) <Overlay   {isActive}   on:overlayclose={onOverayClose}>
    function create_default_slot$9(ctx) {
    	let div;
    	let t;
    	let button;
    	let int;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	int = new Int({
    			props: { key: "Закрыть" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			t = space();
    			button = element("button");
    			create_component(int.$$.fragment);
    			attr_dev(button, "class", "txcm-drawerClose");
    			add_location(button, file$A, 32, 8, 612);
    			attr_dev(div, "class", "txcm-drawer");
    			toggle_class(div, "txcm-drawer-is-active", /*isActive*/ ctx[0]);
    			add_location(div, file$A, 27, 4, 479);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			append_dev(div, t);
    			append_dev(div, button);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*onCloseClick*/ ctx[2], false, false, false),
    					listen_dev(div, "click", stop_propagation(/*click_handler*/ ctx[6]), false, false, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			}

    			if (dirty & /*isActive*/ 1) {
    				toggle_class(div, "txcm-drawer-is-active", /*isActive*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			destroy_component(int);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(25:0) <Overlay   {isActive}   on:overlayclose={onOverayClose}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let overlay;
    	let current;

    	overlay = new Overlay({
    			props: {
    				isActive: /*isActive*/ ctx[0],
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	overlay.$on("overlayclose", /*onOverayClose*/ ctx[3]);

    	const block = {
    		c: function create() {
    			create_component(overlay.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(overlay, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const overlay_changes = {};
    			if (dirty & /*isActive*/ 1) overlay_changes.isActive = /*isActive*/ ctx[0];

    			if (dirty & /*$$scope, isActive*/ 129) {
    				overlay_changes.$$scope = { dirty, ctx };
    			}

    			overlay.$set(overlay_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(overlay.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(overlay.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(overlay, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let $drawer;
    	let { store } = $$props;
    	const drawer = getUIState(store);
    	validate_store(drawer, "drawer");
    	component_subscribe($$self, drawer, value => $$invalidate(8, $drawer = value));

    	function close() {
    		set_store_value(drawer, $drawer = false);
    	}

    	function onCloseClick() {
    		close();
    	}

    	function onOverayClose() {
    		close();
    	}

    	const writable_props = ["store"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Drawer> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Drawer", $$slots, ['default']);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("store" in $$props) $$invalidate(4, store = $$props.store);
    		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		getUIState,
    		Overlay,
    		store,
    		drawer,
    		close,
    		onCloseClick,
    		onOverayClose,
    		isActive,
    		$drawer
    	});

    	$$self.$inject_state = $$props => {
    		if ("store" in $$props) $$invalidate(4, store = $$props.store);
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    	};

    	let isActive;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$drawer*/ 256) {
    			 $$invalidate(0, isActive = $drawer);
    		}
    	};

    	return [
    		isActive,
    		drawer,
    		onCloseClick,
    		onOverayClose,
    		store,
    		$$slots,
    		click_handler,
    		$$scope
    	];
    }

    class Drawer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, { store: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Drawer",
    			options,
    			id: create_fragment$H.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*store*/ ctx[4] === undefined && !("store" in props)) {
    			console.warn("<Drawer> was created without expected prop 'store'");
    		}
    	}

    	get store() {
    		throw new Error("<Drawer>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set store(value) {
    		throw new Error("<Drawer>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function cubicInOut(t) {
        return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
    }

    function shiftVertical(node, { delay = 0, duration = 200, height }) {
      const opacity = +getComputedStyle(node).opacity;

      return {
        delay,
        duration,
        css: (ratio) => {
          const eased = cubicInOut(ratio);
          return `
        opacity: ${eased * opacity};
        margin-bottom: ${(1 - eased) * -height}px;
      `;
        },
      };
    }

    /* src/js/components/indicators/IndicatorsControl.svelte generated by Svelte v3.24.0 */
    const file$B = "src/js/components/indicators/IndicatorsControl.svelte";

    // (34:0) {#if !exclude || (exclude && !checked)}
    function create_if_block$6(ctx) {
    	let input;
    	let t0;
    	let label_1;
    	let int;
    	let t1;
    	let t2;
    	let svg;
    	let use;
    	let label_1_transition;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*label*/ ctx[0] },
    			$$inline: true
    		});

    	let if_block = /*note*/ ctx[1] && create_if_block_1$2(ctx);

    	const block = {
    		c: function create() {
    			input = element("input");
    			t0 = space();
    			label_1 = element("label");
    			create_component(int.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			svg = svg_element("svg");
    			use = svg_element("use");
    			attr_dev(input, "class", "txcm-indicatorsInput");
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "id", /*htmlID*/ ctx[5]);
    			input.__value = /*value*/ ctx[2];
    			input.value = input.__value;
    			add_location(input, file$B, 34, 2, 899);
    			xlink_attr(use, "xlink:href", "#txspt-icons-checkmark");
    			add_location(use, file$B, 56, 10, 1417);
    			attr_dev(svg, "class", "txcm-indicatorsControlIcon");
    			toggle_class(svg, "txcm-indicatorsControlIcon-is-visible", /*checked*/ ctx[4]);
    			add_location(svg, file$B, 53, 6, 1296);
    			attr_dev(label_1, "class", "txcm-indicatorsControl");
    			attr_dev(label_1, "for", /*htmlID*/ ctx[5]);
    			add_location(label_1, file$B, 40, 2, 1007);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = /*checked*/ ctx[4];
    			insert_dev(target, t0, anchor);
    			insert_dev(target, label_1, anchor);
    			mount_component(int, label_1, null);
    			append_dev(label_1, t1);
    			if (if_block) if_block.m(label_1, null);
    			append_dev(label_1, t2);
    			append_dev(label_1, svg);
    			append_dev(svg, use);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[8]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*value*/ 4) {
    				prop_dev(input, "__value", /*value*/ ctx[2]);
    				input.value = input.__value;
    			}

    			if (dirty & /*checked*/ 16) {
    				input.checked = /*checked*/ ctx[4];
    			}

    			const int_changes = {};
    			if (dirty & /*label*/ 1) int_changes.key = /*label*/ ctx[0];
    			int.$set(int_changes);

    			if (/*note*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*note*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(label_1, t2);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*checked*/ 16) {
    				toggle_class(svg, "txcm-indicatorsControlIcon-is-visible", /*checked*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			transition_in(if_block);

    			add_render_callback(() => {
    				if (!label_1_transition) label_1_transition = create_bidirectional_transition(label_1, shiftVertical, { height: 32 }, true);
    				label_1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			transition_out(if_block);
    			if (!label_1_transition) label_1_transition = create_bidirectional_transition(label_1, shiftVertical, { height: 32 }, false);
    			label_1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(label_1);
    			destroy_component(int);
    			if (if_block) if_block.d();
    			if (detaching && label_1_transition) label_1_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(34:0) {#if !exclude || (exclude && !checked)}",
    		ctx
    	});

    	return block;
    }

    // (47:6) {#if note}
    function create_if_block_1$2(ctx) {
    	let span;
    	let int;
    	let current;

    	int = new Int({
    			props: { key: /*note*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(int.$$.fragment);
    			attr_dev(span, "class", "txcm-indicatorsNote");
    			add_location(span, file$B, 47, 8, 1172);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(int, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*note*/ 2) int_changes.key = /*note*/ ctx[1];
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(47:6) {#if note}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = (!/*exclude*/ ctx[3] || /*exclude*/ ctx[3] && !/*checked*/ ctx[4]) && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*exclude*/ ctx[3] || /*exclude*/ ctx[3] && !/*checked*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*exclude, checked*/ 24) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { id } = $$props;
    	let { label } = $$props;
    	let { note = "" } = $$props;
    	let { status } = $$props;
    	let { value } = $$props;
    	let { exclude = false } = $$props;
    	const htmlID = renderID("indicatorToggle", id);
    	let checked = getIndicatorsData(id) || status;
    	const unsubscribeIndicator = subscribeIndicators(id, onIndicatorUpdate);
    	onDestroy(unsubscribeIndicator);

    	function onIndicatorUpdate(update) {
    		$$invalidate(4, checked = update);
    	}

    	function updateIndicatorValue() {
    		updateIndicators({ [id]: checked });
    	}

    	const writable_props = ["id", "label", "note", "status", "value", "exclude"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IndicatorsControl> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("IndicatorsControl", $$slots, []);

    	function input_change_handler() {
    		checked = this.checked;
    		$$invalidate(4, checked);
    	}

    	$$self.$set = $$props => {
    		if ("id" in $$props) $$invalidate(6, id = $$props.id);
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("note" in $$props) $$invalidate(1, note = $$props.note);
    		if ("status" in $$props) $$invalidate(7, status = $$props.status);
    		if ("value" in $$props) $$invalidate(2, value = $$props.value);
    		if ("exclude" in $$props) $$invalidate(3, exclude = $$props.exclude);
    	};

    	$$self.$capture_state = () => ({
    		onDestroy,
    		renderID,
    		shiftVertical,
    		updateIndicators,
    		subscribeIndicators,
    		getIndicatorsData,
    		Int,
    		id,
    		label,
    		note,
    		status,
    		value,
    		exclude,
    		htmlID,
    		checked,
    		unsubscribeIndicator,
    		onIndicatorUpdate,
    		updateIndicatorValue
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(6, id = $$props.id);
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("note" in $$props) $$invalidate(1, note = $$props.note);
    		if ("status" in $$props) $$invalidate(7, status = $$props.status);
    		if ("value" in $$props) $$invalidate(2, value = $$props.value);
    		if ("exclude" in $$props) $$invalidate(3, exclude = $$props.exclude);
    		if ("checked" in $$props) $$invalidate(4, checked = $$props.checked);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*checked*/ 16) {
    			 updateIndicatorValue();
    		}
    	};

    	return [label, note, value, exclude, checked, htmlID, id, status, input_change_handler];
    }

    class IndicatorsControl extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {
    			id: 6,
    			label: 0,
    			note: 1,
    			status: 7,
    			value: 2,
    			exclude: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IndicatorsControl",
    			options,
    			id: create_fragment$I.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[6] === undefined && !("id" in props)) {
    			console.warn("<IndicatorsControl> was created without expected prop 'id'");
    		}

    		if (/*label*/ ctx[0] === undefined && !("label" in props)) {
    			console.warn("<IndicatorsControl> was created without expected prop 'label'");
    		}

    		if (/*status*/ ctx[7] === undefined && !("status" in props)) {
    			console.warn("<IndicatorsControl> was created without expected prop 'status'");
    		}

    		if (/*value*/ ctx[2] === undefined && !("value" in props)) {
    			console.warn("<IndicatorsControl> was created without expected prop 'value'");
    		}
    	}

    	get id() {
    		throw new Error("<IndicatorsControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<IndicatorsControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<IndicatorsControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<IndicatorsControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get note() {
    		throw new Error("<IndicatorsControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set note(value) {
    		throw new Error("<IndicatorsControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get status() {
    		throw new Error("<IndicatorsControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set status(value) {
    		throw new Error("<IndicatorsControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<IndicatorsControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<IndicatorsControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get exclude() {
    		throw new Error("<IndicatorsControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set exclude(value) {
    		throw new Error("<IndicatorsControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/indicators/IndicatorsActiveList.svelte generated by Svelte v3.24.0 */
    const file$C = "src/js/components/indicators/IndicatorsActiveList.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (44:4) {#each active as indicator (indicator.id)}
    function create_each_block$d(key_1, ctx) {
    	let first;
    	let indicatorscontrol;
    	let current;

    	indicatorscontrol = new IndicatorsControl({
    			props: {
    				id: /*indicator*/ ctx[9].id,
    				label: /*indicator*/ ctx[9].label,
    				note: /*indicator*/ ctx[9].note,
    				status: /*indicator*/ ctx[9].status,
    				value: /*indicator*/ ctx[9].value
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(indicatorscontrol.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(indicatorscontrol, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const indicatorscontrol_changes = {};
    			if (dirty & /*active*/ 1) indicatorscontrol_changes.id = /*indicator*/ ctx[9].id;
    			if (dirty & /*active*/ 1) indicatorscontrol_changes.label = /*indicator*/ ctx[9].label;
    			if (dirty & /*active*/ 1) indicatorscontrol_changes.note = /*indicator*/ ctx[9].note;
    			if (dirty & /*active*/ 1) indicatorscontrol_changes.status = /*indicator*/ ctx[9].status;
    			if (dirty & /*active*/ 1) indicatorscontrol_changes.value = /*indicator*/ ctx[9].value;
    			indicatorscontrol.$set(indicatorscontrol_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(indicatorscontrol.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(indicatorscontrol.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(indicatorscontrol, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(44:4) {#each active as indicator (indicator.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value = /*active*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*indicator*/ ctx[9].id;
    	validate_each_keys(ctx, each_value, get_each_context$d, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$d(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$d(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-indicatorsActive");
    			toggle_class(div, "txcm-indicatorsActive-is-empty", /*isEmpty*/ ctx[1]);
    			add_location(div, file$C, 40, 0, 857);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*active*/ 1) {
    				const each_value = /*active*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$d, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$d, null, get_each_context$d);
    				check_outros();
    			}

    			if (dirty & /*isEmpty*/ 2) {
    				toggle_class(div, "txcm-indicatorsActive-is-empty", /*isEmpty*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function flattenOption(flat, group) {
    	return [...flat, ...group.indicators];
    }

    function sortOrder(option1, option2) {
    	return option1.order - option2.order;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let $activeIndicators;
    	let { config } = $$props;
    	const options = flattenOptions();
    	const activeIndicators = getActiveIndicatorsState();
    	validate_store(activeIndicators, "activeIndicators");
    	component_subscribe($$self, activeIndicators, value => $$invalidate(4, $activeIndicators = value));
    	let active = [];

    	function flattenOptions() {
    		return config.reduce(flattenOption, []).sort(sortOrder);
    	}

    	function findActiveIndicator(option) {
    		return $activeIndicators.find(id => `${option.id}` === `${id}`);
    	}

    	function updateActive() {
    		$$invalidate(0, active = options.filter(findActiveIndicator));
    	}

    	const writable_props = ["config"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IndicatorsActiveList> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("IndicatorsActiveList", $$slots, []);

    	$$self.$set = $$props => {
    		if ("config" in $$props) $$invalidate(3, config = $$props.config);
    	};

    	$$self.$capture_state = () => ({
    		getActiveIndicatorsState,
    		IndicatorsControl,
    		config,
    		options,
    		activeIndicators,
    		active,
    		flattenOption,
    		sortOrder,
    		flattenOptions,
    		findActiveIndicator,
    		updateActive,
    		$activeIndicators,
    		isEmpty
    	});

    	$$self.$inject_state = $$props => {
    		if ("config" in $$props) $$invalidate(3, config = $$props.config);
    		if ("active" in $$props) $$invalidate(0, active = $$props.active);
    		if ("isEmpty" in $$props) $$invalidate(1, isEmpty = $$props.isEmpty);
    	};

    	let isEmpty;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$activeIndicators*/ 16) {
    			 updateActive();
    		}

    		if ($$self.$$.dirty & /*active*/ 1) {
    			 $$invalidate(1, isEmpty = active.length === 0);
    		}
    	};

    	return [active, isEmpty, activeIndicators, config];
    }

    class IndicatorsActiveList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, { config: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IndicatorsActiveList",
    			options,
    			id: create_fragment$J.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*config*/ ctx[3] === undefined && !("config" in props)) {
    			console.warn("<IndicatorsActiveList> was created without expected prop 'config'");
    		}
    	}

    	get config() {
    		throw new Error("<IndicatorsActiveList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set config(value) {
    		throw new Error("<IndicatorsActiveList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/indicators/IndicatorsList.svelte generated by Svelte v3.24.0 */

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (18:6) {#each group.indicators as indicator (indicator.id)}
    function create_each_block_1$2(key_1, ctx) {
    	let first;
    	let indicatorscontrol;
    	let current;

    	indicatorscontrol = new IndicatorsControl({
    			props: {
    				id: /*indicator*/ ctx[6].id,
    				label: /*indicator*/ ctx[6].label,
    				note: /*indicator*/ ctx[6].note,
    				status: /*indicator*/ ctx[6].status,
    				value: /*indicator*/ ctx[6].value,
    				exclude: false
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(indicatorscontrol.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(indicatorscontrol, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const indicatorscontrol_changes = {};
    			if (dirty & /*filtered*/ 2) indicatorscontrol_changes.id = /*indicator*/ ctx[6].id;
    			if (dirty & /*filtered*/ 2) indicatorscontrol_changes.label = /*indicator*/ ctx[6].label;
    			if (dirty & /*filtered*/ 2) indicatorscontrol_changes.note = /*indicator*/ ctx[6].note;
    			if (dirty & /*filtered*/ 2) indicatorscontrol_changes.status = /*indicator*/ ctx[6].status;
    			if (dirty & /*filtered*/ 2) indicatorscontrol_changes.value = /*indicator*/ ctx[6].value;
    			indicatorscontrol.$set(indicatorscontrol_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(indicatorscontrol.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(indicatorscontrol.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(indicatorscontrol, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(18:6) {#each group.indicators as indicator (indicator.id)}",
    		ctx
    	});

    	return block;
    }

    // (13:2) <ListGroup     label={group.label}     count={filtered.length}     length={group.length}     {filter}>
    function create_default_slot$a(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t;
    	let current;
    	let each_value_1 = /*group*/ ctx[3].indicators;
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*indicator*/ ctx[6].id;
    	validate_each_keys(ctx, each_value_1, get_each_context_1$2, get_key);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$2(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$2(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*filtered*/ 2) {
    				const each_value_1 = /*group*/ ctx[3].indicators;
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$2, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, t.parentNode, outro_and_destroy_block, create_each_block_1$2, t, get_each_context_1$2);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(13:2) <ListGroup     label={group.label}     count={filtered.length}     length={group.length}     {filter}>",
    		ctx
    	});

    	return block;
    }

    // (12:0) {#each filtered as group}
    function create_each_block$e(ctx) {
    	let listgroup;
    	let current;

    	listgroup = new ListGroup({
    			props: {
    				label: /*group*/ ctx[3].label,
    				count: /*filtered*/ ctx[1].length,
    				length: /*group*/ ctx[3].length,
    				filter: /*filter*/ ctx[0],
    				$$slots: { default: [create_default_slot$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(listgroup.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(listgroup, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listgroup_changes = {};
    			if (dirty & /*filtered*/ 2) listgroup_changes.label = /*group*/ ctx[3].label;
    			if (dirty & /*filtered*/ 2) listgroup_changes.count = /*filtered*/ ctx[1].length;
    			if (dirty & /*filtered*/ 2) listgroup_changes.length = /*group*/ ctx[3].length;
    			if (dirty & /*filter*/ 1) listgroup_changes.filter = /*filter*/ ctx[0];

    			if (dirty & /*$$scope, filtered*/ 514) {
    				listgroup_changes.$$scope = { dirty, ctx };
    			}

    			listgroup.$set(listgroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listgroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listgroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(listgroup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(12:0) {#each filtered as group}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*filtered*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*filtered, filter*/ 3) {
    				each_value = /*filtered*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let { config } = $$props;
    	let { filter } = $$props;
    	const writable_props = ["config", "filter"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IndicatorsList> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("IndicatorsList", $$slots, []);

    	$$self.$set = $$props => {
    		if ("config" in $$props) $$invalidate(2, config = $$props.config);
    		if ("filter" in $$props) $$invalidate(0, filter = $$props.filter);
    	};

    	$$self.$capture_state = () => ({
    		ListGroup,
    		filterIndicatorCategories,
    		IndicatorsControl,
    		config,
    		filter,
    		filtered
    	});

    	$$self.$inject_state = $$props => {
    		if ("config" in $$props) $$invalidate(2, config = $$props.config);
    		if ("filter" in $$props) $$invalidate(0, filter = $$props.filter);
    		if ("filtered" in $$props) $$invalidate(1, filtered = $$props.filtered);
    	};

    	let filtered;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*config, filter*/ 5) {
    			 $$invalidate(1, filtered = filterIndicatorCategories(config, filter));
    		}
    	};

    	return [filter, filtered, config];
    }

    class IndicatorsList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, { config: 2, filter: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IndicatorsList",
    			options,
    			id: create_fragment$K.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*config*/ ctx[2] === undefined && !("config" in props)) {
    			console.warn("<IndicatorsList> was created without expected prop 'config'");
    		}

    		if (/*filter*/ ctx[0] === undefined && !("filter" in props)) {
    			console.warn("<IndicatorsList> was created without expected prop 'filter'");
    		}
    	}

    	get config() {
    		throw new Error("<IndicatorsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set config(value) {
    		throw new Error("<IndicatorsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filter() {
    		throw new Error("<IndicatorsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filter(value) {
    		throw new Error("<IndicatorsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/indicators/IndicatorsDrawer.svelte generated by Svelte v3.24.0 */
    const file$D = "src/js/components/indicators/IndicatorsDrawer.svelte";

    function create_fragment$L(ctx) {
    	let div0;
    	let int;
    	let t0;
    	let listfilter;
    	let updating_value;
    	let t1;
    	let div1;
    	let indicatorslist;
    	let current;

    	int = new Int({
    			props: { key: "Добавить показатели" },
    			$$inline: true
    		});

    	function listfilter_value_binding(value) {
    		/*listfilter_value_binding*/ ctx[2].call(null, value);
    	}

    	let listfilter_props = {};

    	if (/*filter*/ ctx[0] !== void 0) {
    		listfilter_props.value = /*filter*/ ctx[0];
    	}

    	listfilter = new ListFilter({ props: listfilter_props, $$inline: true });
    	binding_callbacks.push(() => bind(listfilter, "value", listfilter_value_binding));

    	indicatorslist = new IndicatorsList({
    			props: {
    				config: /*config*/ ctx[1],
    				filter: /*filter*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			create_component(int.$$.fragment);
    			t0 = space();
    			create_component(listfilter.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			create_component(indicatorslist.$$.fragment);
    			attr_dev(div0, "class", "txcm-indicatorsHeader");
    			add_location(div0, file$D, 12, 0, 396);
    			attr_dev(div1, "class", "txcm-indicatorsGroups");
    			add_location(div1, file$D, 19, 0, 522);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			mount_component(int, div0, null);
    			insert_dev(target, t0, anchor);
    			mount_component(listfilter, target, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(indicatorslist, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const listfilter_changes = {};

    			if (!updating_value && dirty & /*filter*/ 1) {
    				updating_value = true;
    				listfilter_changes.value = /*filter*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			listfilter.$set(listfilter_changes);
    			const indicatorslist_changes = {};
    			if (dirty & /*filter*/ 1) indicatorslist_changes.filter = /*filter*/ ctx[0];
    			indicatorslist.$set(indicatorslist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			transition_in(listfilter.$$.fragment, local);
    			transition_in(indicatorslist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			transition_out(listfilter.$$.fragment, local);
    			transition_out(indicatorslist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(int);
    			if (detaching) detach_dev(t0);
    			destroy_component(listfilter, detaching);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div1);
    			destroy_component(indicatorslist);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	const config = getContext("config").getIndicatorsConfig();
    	let filter = "";
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IndicatorsDrawer> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("IndicatorsDrawer", $$slots, []);

    	function listfilter_value_binding(value) {
    		filter = value;
    		$$invalidate(0, filter);
    	}

    	$$self.$capture_state = () => ({
    		getContext,
    		Int,
    		ListFilter,
    		IndicatorsActiveList,
    		IndicatorsList,
    		config,
    		filter
    	});

    	$$self.$inject_state = $$props => {
    		if ("filter" in $$props) $$invalidate(0, filter = $$props.filter);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [filter, config, listfilter_value_binding];
    }

    class IndicatorsDrawer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IndicatorsDrawer",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    /* src/js/components/indicators/IndicatorsMenu.svelte generated by Svelte v3.24.0 */

    // (6:0) <Drawer   store="indicators">
    function create_default_slot$b(ctx) {
    	let indicatorsdrawer;
    	let current;
    	indicatorsdrawer = new IndicatorsDrawer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(indicatorsdrawer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(indicatorsdrawer, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(indicatorsdrawer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(indicatorsdrawer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(indicatorsdrawer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(6:0) <Drawer   store=\\\"indicators\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let drawer;
    	let current;

    	drawer = new Drawer({
    			props: {
    				store: "indicators",
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(drawer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(drawer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const drawer_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				drawer_changes.$$scope = { dirty, ctx };
    			}

    			drawer.$set(drawer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(drawer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(drawer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(drawer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IndicatorsMenu> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("IndicatorsMenu", $$slots, []);
    	$$self.$capture_state = () => ({ Drawer, IndicatorsDrawer });
    	return [];
    }

    class IndicatorsMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IndicatorsMenu",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    /* src/js/components/indicators/IndicatorsToggle.svelte generated by Svelte v3.24.0 */
    const file$E = "src/js/components/indicators/IndicatorsToggle.svelte";

    function create_fragment$N(ctx) {
    	let button;
    	let svg;
    	let use;
    	let t;
    	let int;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: "Добавить показатели" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t = space();
    			create_component(int.$$.fragment);
    			xlink_attr(use, "xlink:href", "#txspt-icons-plus");
    			add_location(use, file$E, 20, 8, 452);
    			attr_dev(svg, "class", "txcm-indicatorsToggleIcon");
    			add_location(svg, file$E, 18, 4, 398);
    			attr_dev(button, "class", "txcm-indicatorsToggle");
    			add_location(button, file$E, 15, 0, 326);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, use);
    			append_dev(button, t);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onToggleClick*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let $indicators;
    	const indicators = getUIState("indicators");
    	validate_store(indicators, "indicators");
    	component_subscribe($$self, indicators, value => $$invalidate(2, $indicators = value));

    	function show() {
    		updateUI({ indicators: true });
    	}

    	function onToggleClick() {
    		if (!$indicators) setTimeout(show, 5);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<IndicatorsToggle> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("IndicatorsToggle", $$slots, []);

    	$$self.$capture_state = () => ({
    		getUIState,
    		updateUI,
    		Int,
    		indicators,
    		show,
    		onToggleClick,
    		$indicators
    	});

    	return [indicators, onToggleClick];
    }

    class IndicatorsToggle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IndicatorsToggle",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    /* src/js/components/indicators/Indicators.svelte generated by Svelte v3.24.0 */

    function create_fragment$O(ctx) {
    	let indicatorstoggle;
    	let t;
    	let indicatorsmenu;
    	let current;
    	indicatorstoggle = new IndicatorsToggle({ $$inline: true });
    	indicatorsmenu = new IndicatorsMenu({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(indicatorstoggle.$$.fragment);
    			t = space();
    			create_component(indicatorsmenu.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(indicatorstoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(indicatorsmenu, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(indicatorstoggle.$$.fragment, local);
    			transition_in(indicatorsmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(indicatorstoggle.$$.fragment, local);
    			transition_out(indicatorsmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(indicatorstoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(indicatorsmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Indicators> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Indicators", $$slots, []);
    	$$self.$capture_state = () => ({ IndicatorsMenu, IndicatorsToggle });
    	return [];
    }

    class Indicators extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Indicators",
    			options,
    			id: create_fragment$O.name
    		});
    	}
    }

    /* src/js/components/factorIndicators/FactorIndicatorsCell.svelte generated by Svelte v3.24.0 */

    const file$F = "src/js/components/factorIndicators/FactorIndicatorsCell.svelte";

    function create_fragment$P(ctx) {
    	let div1;
    	let div0;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "txcm-factorsTotalDiagramIndicator");
    			set_style(div0, "--shift", /*shift*/ ctx[0] + "%");
    			add_location(div0, file$F, 25, 4, 477);
    			attr_dev(div1, "class", "txcm-factorsTotalDiagramIndicatorHolder");
    			add_location(div1, file$F, 23, 0, 417);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*shift*/ 1) {
    				set_style(div0, "--shift", /*shift*/ ctx[0] + "%");
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let { base } = $$props;
    	let { comparison } = $$props;
    	let { bridge } = $$props;
    	let shift;

    	function calculateRatio() {
    		return comparison / base;
    	}

    	function calculateShift(ratio) {
    		return bridge < 0 ? 1 / ratio * 100 : 100;
    	}

    	function calculateValues() {
    		const ratio = calculateRatio();
    		$$invalidate(0, shift = calculateShift(ratio));
    	}

    	const writable_props = ["base", "comparison", "bridge"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorIndicatorsCell> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorIndicatorsCell", $$slots, []);

    	$$self.$set = $$props => {
    		if ("base" in $$props) $$invalidate(1, base = $$props.base);
    		if ("comparison" in $$props) $$invalidate(2, comparison = $$props.comparison);
    		if ("bridge" in $$props) $$invalidate(3, bridge = $$props.bridge);
    	};

    	$$self.$capture_state = () => ({
    		base,
    		comparison,
    		bridge,
    		shift,
    		calculateRatio,
    		calculateShift,
    		calculateValues
    	});

    	$$self.$inject_state = $$props => {
    		if ("base" in $$props) $$invalidate(1, base = $$props.base);
    		if ("comparison" in $$props) $$invalidate(2, comparison = $$props.comparison);
    		if ("bridge" in $$props) $$invalidate(3, bridge = $$props.bridge);
    		if ("shift" in $$props) $$invalidate(0, shift = $$props.shift);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*base, comparison*/ 6) {
    			 calculateValues();
    		}
    	};

    	return [shift, base, comparison, bridge];
    }

    class FactorIndicatorsCell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, { base: 1, comparison: 2, bridge: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorIndicatorsCell",
    			options,
    			id: create_fragment$P.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*base*/ ctx[1] === undefined && !("base" in props)) {
    			console.warn("<FactorIndicatorsCell> was created without expected prop 'base'");
    		}

    		if (/*comparison*/ ctx[2] === undefined && !("comparison" in props)) {
    			console.warn("<FactorIndicatorsCell> was created without expected prop 'comparison'");
    		}

    		if (/*bridge*/ ctx[3] === undefined && !("bridge" in props)) {
    			console.warn("<FactorIndicatorsCell> was created without expected prop 'bridge'");
    		}
    	}

    	get base() {
    		throw new Error("<FactorIndicatorsCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set base(value) {
    		throw new Error("<FactorIndicatorsCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get comparison() {
    		throw new Error("<FactorIndicatorsCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set comparison(value) {
    		throw new Error("<FactorIndicatorsCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bridge() {
    		throw new Error("<FactorIndicatorsCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bridge(value) {
    		throw new Error("<FactorIndicatorsCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factorIndicators/FactorIndicators.svelte generated by Svelte v3.24.0 */
    const file$G = "src/js/components/factorIndicators/FactorIndicators.svelte";

    function create_fragment$Q(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let factorindicatorscell0;
    	let t0;
    	let factorindicatorscell1;
    	let t1;
    	let div1;
    	let factorindicatorscell2;
    	let t2;
    	let factorindicatorscell3;
    	let current;

    	factorindicatorscell0 = new FactorIndicatorsCell({
    			props: {
    				base: /*data*/ ctx[0].column1.factCurrYearPercent.qNum,
    				comparison: /*data*/ ctx[0].column1.budgetPercent.qNum,
    				bridge: /*data*/ ctx[0].column1.bridgeResultBudgetPercent.qNum
    			},
    			$$inline: true
    		});

    	factorindicatorscell1 = new FactorIndicatorsCell({
    			props: {
    				base: /*data*/ ctx[0].column1.factCurrYearPercent.qNum,
    				comparison: /*data*/ ctx[0].column1.factPrevYearPrecent.qNum,
    				bridge: /*data*/ ctx[0].column1.bridgeResultPrevYearPercent.qNum
    			},
    			$$inline: true
    		});

    	factorindicatorscell2 = new FactorIndicatorsCell({
    			props: {
    				base: /*data*/ ctx[0].column2.factCurrYearPercent.qNum,
    				comparison: /*data*/ ctx[0].column2.budgetPercent.qNum,
    				bridge: /*data*/ ctx[0].column2.bridgeResultBudgetPercent.qNum
    			},
    			$$inline: true
    		});

    	factorindicatorscell3 = new FactorIndicatorsCell({
    			props: {
    				base: /*data*/ ctx[0].column2.factCurrYearPercent.qNum,
    				comparison: /*data*/ ctx[0].column2.factPrevYearPrecent.qNum,
    				bridge: /*data*/ ctx[0].column2.bridgeResultPrevYearPercent.qNum
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			create_component(factorindicatorscell0.$$.fragment);
    			t0 = space();
    			create_component(factorindicatorscell1.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			create_component(factorindicatorscell2.$$.fragment);
    			t2 = space();
    			create_component(factorindicatorscell3.$$.fragment);
    			attr_dev(div0, "class", "txcm-factorsTotalDiagramIndicatorCell");
    			add_location(div0, file$G, 23, 8, 532);
    			attr_dev(div1, "class", "txcm-factorsTotalDiagramIndicatorCell");
    			add_location(div1, file$G, 34, 8, 1069);
    			attr_dev(div2, "class", "txcm-factorsTotalDiagramIndicatorsRow");
    			add_location(div2, file$G, 21, 4, 466);
    			attr_dev(div3, "class", "txcm-factorsTotalDiagramIndicators");
    			add_location(div3, file$G, 18, 0, 392);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			mount_component(factorindicatorscell0, div0, null);
    			append_dev(div0, t0);
    			mount_component(factorindicatorscell1, div0, null);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			mount_component(factorindicatorscell2, div1, null);
    			append_dev(div1, t2);
    			mount_component(factorindicatorscell3, div1, null);
    			/*div3_binding*/ ctx[3](div3);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const factorindicatorscell0_changes = {};
    			if (dirty & /*data*/ 1) factorindicatorscell0_changes.base = /*data*/ ctx[0].column1.factCurrYearPercent.qNum;
    			if (dirty & /*data*/ 1) factorindicatorscell0_changes.comparison = /*data*/ ctx[0].column1.budgetPercent.qNum;
    			if (dirty & /*data*/ 1) factorindicatorscell0_changes.bridge = /*data*/ ctx[0].column1.bridgeResultBudgetPercent.qNum;
    			factorindicatorscell0.$set(factorindicatorscell0_changes);
    			const factorindicatorscell1_changes = {};
    			if (dirty & /*data*/ 1) factorindicatorscell1_changes.base = /*data*/ ctx[0].column1.factCurrYearPercent.qNum;
    			if (dirty & /*data*/ 1) factorindicatorscell1_changes.comparison = /*data*/ ctx[0].column1.factPrevYearPrecent.qNum;
    			if (dirty & /*data*/ 1) factorindicatorscell1_changes.bridge = /*data*/ ctx[0].column1.bridgeResultPrevYearPercent.qNum;
    			factorindicatorscell1.$set(factorindicatorscell1_changes);
    			const factorindicatorscell2_changes = {};
    			if (dirty & /*data*/ 1) factorindicatorscell2_changes.base = /*data*/ ctx[0].column2.factCurrYearPercent.qNum;
    			if (dirty & /*data*/ 1) factorindicatorscell2_changes.comparison = /*data*/ ctx[0].column2.budgetPercent.qNum;
    			if (dirty & /*data*/ 1) factorindicatorscell2_changes.bridge = /*data*/ ctx[0].column2.bridgeResultBudgetPercent.qNum;
    			factorindicatorscell2.$set(factorindicatorscell2_changes);
    			const factorindicatorscell3_changes = {};
    			if (dirty & /*data*/ 1) factorindicatorscell3_changes.base = /*data*/ ctx[0].column2.factCurrYearPercent.qNum;
    			if (dirty & /*data*/ 1) factorindicatorscell3_changes.comparison = /*data*/ ctx[0].column2.factPrevYearPrecent.qNum;
    			if (dirty & /*data*/ 1) factorindicatorscell3_changes.bridge = /*data*/ ctx[0].column2.bridgeResultPrevYearPercent.qNum;
    			factorindicatorscell3.$set(factorindicatorscell3_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorindicatorscell0.$$.fragment, local);
    			transition_in(factorindicatorscell1.$$.fragment, local);
    			transition_in(factorindicatorscell2.$$.fragment, local);
    			transition_in(factorindicatorscell3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorindicatorscell0.$$.fragment, local);
    			transition_out(factorindicatorscell1.$$.fragment, local);
    			transition_out(factorindicatorscell2.$$.fragment, local);
    			transition_out(factorindicatorscell3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(factorindicatorscell0);
    			destroy_component(factorindicatorscell1);
    			destroy_component(factorindicatorscell2);
    			destroy_component(factorindicatorscell3);
    			/*div3_binding*/ ctx[3](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let $sectionScrollX;
    	let { data } = $$props;
    	const sectionScrollX = getUIState("sectionScrollX");
    	validate_store(sectionScrollX, "sectionScrollX");
    	component_subscribe($$self, sectionScrollX, value => $$invalidate(4, $sectionScrollX = value));
    	let node;

    	function updateScroll() {
    		if (node) $$invalidate(1, node.scrollLeft = $sectionScrollX, node);
    	}

    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorIndicators> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorIndicators", $$slots, []);

    	function div3_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			node = $$value;
    			$$invalidate(1, node);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		getUIState,
    		getDashboardState,
    		FactorIndicatorsCell,
    		data,
    		sectionScrollX,
    		node,
    		updateScroll,
    		$sectionScrollX
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("node" in $$props) $$invalidate(1, node = $$props.node);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$sectionScrollX*/ 16) {
    			 updateScroll();
    		}
    	};

    	return [data, node, sectionScrollX, div3_binding];
    }

    class FactorIndicators extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, { data: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorIndicators",
    			options,
    			id: create_fragment$Q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<FactorIndicators> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<FactorIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<FactorIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factorsTotal/FactorsTotalRow.svelte generated by Svelte v3.24.0 */

    const file$H = "src/js/components/factorsTotal/FactorsTotalRow.svelte";

    function create_fragment$R(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "txcm-factorsTotalRow");
    			add_location(div, file$H, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsTotalRow> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsTotalRow", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, $$slots];
    }

    class FactorsTotalRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsTotalRow",
    			options,
    			id: create_fragment$R.name
    		});
    	}
    }

    /* src/js/components/factorsTotal/FactorsTotalLabel.svelte generated by Svelte v3.24.0 */
    const file$I = "src/js/components/factorsTotal/FactorsTotalLabel.svelte";

    function create_fragment$S(ctx) {
    	let div;
    	let int;
    	let current;

    	int = new Int({
    			props: { key: /*label*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(int.$$.fragment);
    			attr_dev(div, "class", "txcm-factorsTotalLabel");
    			add_location(div, file$I, 6, 0, 110);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(int, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const int_changes = {};
    			if (dirty & /*label*/ 1) int_changes.key = /*label*/ ctx[0];
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	const writable_props = ["label"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsTotalLabel> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsTotalLabel", $$slots, []);

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    	};

    	$$self.$capture_state = () => ({ Int, label });

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [label];
    }

    class FactorsTotalLabel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, { label: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsTotalLabel",
    			options,
    			id: create_fragment$S.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[0] === undefined && !("label" in props)) {
    			console.warn("<FactorsTotalLabel> was created without expected prop 'label'");
    		}
    	}

    	get label() {
    		throw new Error("<FactorsTotalLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<FactorsTotalLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factorsTotal/FactorsTotalValue.svelte generated by Svelte v3.24.0 */

    const file$J = "src/js/components/factorsTotal/FactorsTotalValue.svelte";

    function create_fragment$T(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "txcm-factorsTotalValue");
    			add_location(div, file$J, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsTotalValue> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsTotalValue", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, $$slots];
    }

    class FactorsTotalValue extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsTotalValue",
    			options,
    			id: create_fragment$T.name
    		});
    	}
    }

    function checkDynamics(value, threshold) {
      if (typeof threshold === 'number') {
        if (value < threshold) return -2;
        if (value < 0) return -1;
      }
      if (value < 0) return -2;
      if (value > 0) return 1;
      return 0;
    }

    function checkArrowDynamics(fact, value, arrow) {
      if (arrow === 0 || arrow === 1) {
        if (value < 0) return -2;
        if (value > 0) return 1;
      } else if (arrow === 2 || arrow === 3) {
        if (value > 0) return -2;
        if (value < 0) return 1;
      }
      
      return 0;
    }

    function compareDynamics(value1, value2) {
      const diff = Math.round(((value1 * 10000) - (value2 * 10000)));
      if (diff < 0) return -2;
      if (diff > 0) return 1;
      return 0;
    }

    function renderDynamicsClass(baseClass, dynamics) {
      if (dynamics === -2) return `${baseClass} ${baseClass}-is-decreasingCritically`;
      if (dynamics === -1) return `${baseClass} ${baseClass}-is-decreasing`;
      if (dynamics === 1) return `${baseClass} ${baseClass}-is-increasing`;
      return baseClass;
    }

    function renderArrowDynamicsClass(baseClass, dynamics) {
      if (dynamics === 0) return `${baseClass} ${baseClass}-is-decreasingCritically`;
      if (dynamics === 1) return `${baseClass} ${baseClass}-is-increasing`;
      if (dynamics === 2) return `${baseClass} ${baseClass}-is-decreasingCritically-inverted`;
      if (dynamics === 3) return `${baseClass} ${baseClass}-is-increasing-inverted`;
      

      return baseClass;
    }

    /* src/js/components/factorsTotal/FactorsTotalDiagram.svelte generated by Svelte v3.24.0 */
    const file$K = "src/js/components/factorsTotal/FactorsTotalDiagram.svelte";

    // (36:4) {#if value}
    function create_if_block_1$3(ctx) {
    	let div;
    	let factorstotalvalue;
    	let current;

    	factorstotalvalue = new FactorsTotalValue({
    			props: {
    				$$slots: { default: [create_default_slot$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(factorstotalvalue.$$.fragment);
    			set_style(div, "position", "absolute");
    			set_style(div, "right", "0px");
    			add_location(div, file$K, 36, 6, 798);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(factorstotalvalue, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorstotalvalue_changes = {};

    			if (dirty & /*$$scope, value*/ 2050) {
    				factorstotalvalue_changes.$$scope = { dirty, ctx };
    			}

    			factorstotalvalue.$set(factorstotalvalue_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorstotalvalue.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorstotalvalue.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(factorstotalvalue);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(36:4) {#if value}",
    		ctx
    	});

    	return block;
    }

    // (38:8) <FactorsTotalValue>
    function create_default_slot$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*value*/ ctx[1]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*value*/ 2) set_data_dev(t, /*value*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(38:8) <FactorsTotalValue>",
    		ctx
    	});

    	return block;
    }

    // (43:4) {#if data}
    function create_if_block$7(ctx) {
    	let svg;
    	let rect;
    	let rect_class_value;
    	let rect_x_value;
    	let rect_width_value;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			rect = svg_element("rect");
    			attr_dev(rect, "class", rect_class_value = `txcm-factorsTotalDiagramRectBase${/*renderDynamicsClass*/ ctx[4](/*data*/ ctx[0])}`);
    			attr_dev(rect, "x", rect_x_value = `${/*shift*/ ctx[3]}%`);
    			attr_dev(rect, "y", "0");
    			attr_dev(rect, "width", rect_width_value = `${/*width*/ ctx[2]}%`);
    			attr_dev(rect, "height", "100%");
    			attr_dev(rect, "rx", "3");
    			attr_dev(rect, "ry", "3");
    			add_location(rect, file$K, 47, 10, 1063);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "19");
    			attr_dev(svg, "class", "txcm-factorsTotalDiagramSVG");
    			add_location(svg, file$K, 43, 6, 962);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, rect);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && rect_class_value !== (rect_class_value = `txcm-factorsTotalDiagramRectBase${/*renderDynamicsClass*/ ctx[4](/*data*/ ctx[0])}`)) {
    				attr_dev(rect, "class", rect_class_value);
    			}

    			if (dirty & /*shift*/ 8 && rect_x_value !== (rect_x_value = `${/*shift*/ ctx[3]}%`)) {
    				attr_dev(rect, "x", rect_x_value);
    			}

    			if (dirty & /*width*/ 4 && rect_width_value !== (rect_width_value = `${/*width*/ ctx[2]}%`)) {
    				attr_dev(rect, "width", rect_width_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(43:4) {#if data}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$U(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block0 = /*value*/ ctx[1] && create_if_block_1$3(ctx);
    	let if_block1 = /*data*/ ctx[0] && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "txcm-factorsTotalDiagram");
    			add_location(div, file$K, 33, 0, 735);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*value*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*value*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*data*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$7(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { baseRatio } = $$props;
    	let { minRatio } = $$props;
    	let { value } = $$props;
    	let base;
    	let comparison;
    	let ratio;
    	let width;
    	let shift = 0;

    	function renderDynamicsClass() {
    		[base, comparison] = data;
    		const dynamics = checkDynamics(comparison);
    		if (dynamics === -2) return " txcm-factorsTotalDiagramRectBase-is-decreasing";
    		return "";
    	}

    	function updateValues() {
    		if (data) {
    			[base, comparison] = data;
    			$$invalidate(2, width = Math.abs(comparison * baseRatio) * 100);
    			$$invalidate(3, shift = minRatio * 100);
    		}
    	}

    	const writable_props = ["data", "baseRatio", "minRatio", "value"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsTotalDiagram> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsTotalDiagram", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("baseRatio" in $$props) $$invalidate(5, baseRatio = $$props.baseRatio);
    		if ("minRatio" in $$props) $$invalidate(6, minRatio = $$props.minRatio);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    	};

    	$$self.$capture_state = () => ({
    		checkDynamics,
    		FactorsTotalValue,
    		data,
    		baseRatio,
    		minRatio,
    		value,
    		base,
    		comparison,
    		ratio,
    		width,
    		shift,
    		renderDynamicsClass,
    		updateValues
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("baseRatio" in $$props) $$invalidate(5, baseRatio = $$props.baseRatio);
    		if ("minRatio" in $$props) $$invalidate(6, minRatio = $$props.minRatio);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("base" in $$props) base = $$props.base;
    		if ("comparison" in $$props) comparison = $$props.comparison;
    		if ("ratio" in $$props) ratio = $$props.ratio;
    		if ("width" in $$props) $$invalidate(2, width = $$props.width);
    		if ("shift" in $$props) $$invalidate(3, shift = $$props.shift);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data, baseRatio*/ 33) {
    			 updateValues();
    		}
    	};

    	return [data, value, width, shift, renderDynamicsClass, baseRatio, minRatio];
    }

    class FactorsTotalDiagram extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$U, create_fragment$U, safe_not_equal, {
    			data: 0,
    			baseRatio: 5,
    			minRatio: 6,
    			value: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsTotalDiagram",
    			options,
    			id: create_fragment$U.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<FactorsTotalDiagram> was created without expected prop 'data'");
    		}

    		if (/*baseRatio*/ ctx[5] === undefined && !("baseRatio" in props)) {
    			console.warn("<FactorsTotalDiagram> was created without expected prop 'baseRatio'");
    		}

    		if (/*minRatio*/ ctx[6] === undefined && !("minRatio" in props)) {
    			console.warn("<FactorsTotalDiagram> was created without expected prop 'minRatio'");
    		}

    		if (/*value*/ ctx[1] === undefined && !("value" in props)) {
    			console.warn("<FactorsTotalDiagram> was created without expected prop 'value'");
    		}
    	}

    	get data() {
    		throw new Error("<FactorsTotalDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<FactorsTotalDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseRatio() {
    		throw new Error("<FactorsTotalDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseRatio(value) {
    		throw new Error("<FactorsTotalDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minRatio() {
    		throw new Error("<FactorsTotalDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minRatio(value) {
    		throw new Error("<FactorsTotalDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<FactorsTotalDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<FactorsTotalDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var formatLabel = (value, units, suffix = '', base = 1000000.0) => {
      if (isNaN(value) || Math.abs(value) <= 0.00001)
        return '-';
      if (units === '%')
        return value = (value * 100.0).toFixed(2).toString() + suffix;
      else if (units === 'руб.')
        return value = (value / base).toFixed(0).toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1 ');
      else if (units === 'шт.' || units === "штук в чеке" || units === 'чел')
        return value.toFixed(0).toString().toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1 ');
      else if (units === 'дн.')
        return value.toFixed(0).toString()
      return value.toString();
    };

    /* src/js/components/factorsTotal/FactorsTotalCell.svelte generated by Svelte v3.24.0 */
    const file$L = "src/js/components/factorsTotal/FactorsTotalCell.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[6] = i;
    	return child_ctx;
    }

    // (16:4) <FactorsTotalValue>
    function create_default_slot$d(ctx) {
    	let t_value = formatLabel(/*value*/ ctx[0][0].qNum, /*value*/ ctx[0][0].units) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*value*/ 1 && t_value !== (t_value = formatLabel(/*value*/ ctx[0][0].qNum, /*value*/ ctx[0][0].units) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(16:4) <FactorsTotalValue>",
    		ctx
    	});

    	return block;
    }

    // (19:4) {#each diagrams as diagram, index}
    function create_each_block$f(ctx) {
    	let factorstotaldiagram;
    	let current;

    	factorstotaldiagram = new FactorsTotalDiagram({
    			props: {
    				value: /*index*/ ctx[6] === 1
    				? formatLabel(/*value*/ ctx[0][1].qNum, /*value*/ ctx[0][1].units)
    				: null,
    				data: /*diagrams*/ ctx[1][/*index*/ ctx[6]],
    				baseRatio: /*baseRatios*/ ctx[2][/*index*/ ctx[6]],
    				minRatio: /*minRatios*/ ctx[3][/*index*/ ctx[6]]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorstotaldiagram.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorstotaldiagram, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorstotaldiagram_changes = {};

    			if (dirty & /*value*/ 1) factorstotaldiagram_changes.value = /*index*/ ctx[6] === 1
    			? formatLabel(/*value*/ ctx[0][1].qNum, /*value*/ ctx[0][1].units)
    			: null;

    			if (dirty & /*diagrams*/ 2) factorstotaldiagram_changes.data = /*diagrams*/ ctx[1][/*index*/ ctx[6]];
    			if (dirty & /*baseRatios*/ 4) factorstotaldiagram_changes.baseRatio = /*baseRatios*/ ctx[2][/*index*/ ctx[6]];
    			if (dirty & /*minRatios*/ 8) factorstotaldiagram_changes.minRatio = /*minRatios*/ ctx[3][/*index*/ ctx[6]];
    			factorstotaldiagram.$set(factorstotaldiagram_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorstotaldiagram.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorstotaldiagram.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorstotaldiagram, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(19:4) {#each diagrams as diagram, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$V(ctx) {
    	let div;
    	let factorstotalvalue;
    	let t;
    	let current;

    	factorstotalvalue = new FactorsTotalValue({
    			props: {
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let each_value = /*diagrams*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(factorstotalvalue.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-factorsTotalCell");
    			add_location(div, file$L, 13, 0, 347);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(factorstotalvalue, div, null);
    			append_dev(div, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const factorstotalvalue_changes = {};

    			if (dirty & /*$$scope, value*/ 129) {
    				factorstotalvalue_changes.$$scope = { dirty, ctx };
    			}

    			factorstotalvalue.$set(factorstotalvalue_changes);

    			if (dirty & /*formatLabel, value, diagrams, baseRatios, minRatios*/ 15) {
    				each_value = /*diagrams*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorstotalvalue.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorstotalvalue.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(factorstotalvalue);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let { value } = $$props;
    	let { diagrams } = $$props;
    	let { baseRatios } = $$props;
    	let { minRatios } = $$props;
    	const writable_props = ["value", "diagrams", "baseRatios", "minRatios"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsTotalCell> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsTotalCell", $$slots, []);

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("diagrams" in $$props) $$invalidate(1, diagrams = $$props.diagrams);
    		if ("baseRatios" in $$props) $$invalidate(2, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(3, minRatios = $$props.minRatios);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		FactorsTotalValue,
    		FactorsTotalDiagram,
    		formatLabel,
    		value,
    		diagrams,
    		baseRatios,
    		minRatios
    	});

    	$$self.$inject_state = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("diagrams" in $$props) $$invalidate(1, diagrams = $$props.diagrams);
    		if ("baseRatios" in $$props) $$invalidate(2, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(3, minRatios = $$props.minRatios);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [value, diagrams, baseRatios, minRatios];
    }

    class FactorsTotalCell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$V, create_fragment$V, safe_not_equal, {
    			value: 0,
    			diagrams: 1,
    			baseRatios: 2,
    			minRatios: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsTotalCell",
    			options,
    			id: create_fragment$V.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[0] === undefined && !("value" in props)) {
    			console.warn("<FactorsTotalCell> was created without expected prop 'value'");
    		}

    		if (/*diagrams*/ ctx[1] === undefined && !("diagrams" in props)) {
    			console.warn("<FactorsTotalCell> was created without expected prop 'diagrams'");
    		}

    		if (/*baseRatios*/ ctx[2] === undefined && !("baseRatios" in props)) {
    			console.warn("<FactorsTotalCell> was created without expected prop 'baseRatios'");
    		}

    		if (/*minRatios*/ ctx[3] === undefined && !("minRatios" in props)) {
    			console.warn("<FactorsTotalCell> was created without expected prop 'minRatios'");
    		}
    	}

    	get value() {
    		throw new Error("<FactorsTotalCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<FactorsTotalCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get diagrams() {
    		throw new Error("<FactorsTotalCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set diagrams(value) {
    		throw new Error("<FactorsTotalCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseRatios() {
    		throw new Error("<FactorsTotalCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseRatios(value) {
    		throw new Error("<FactorsTotalCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minRatios() {
    		throw new Error("<FactorsTotalCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minRatios(value) {
    		throw new Error("<FactorsTotalCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factorsTotal/fact/FactorsTotalFact.svelte generated by Svelte v3.24.0 */

    // (30:2) {#if data}
    function create_if_block$8(ctx) {
    	let factorstotalcell0;
    	let t;
    	let factorstotalcell1;
    	let current;

    	factorstotalcell0 = new FactorsTotalCell({
    			props: {
    				indicator: /*indicator*/ ctx[3],
    				value: [
    					/*column1*/ ctx[5].factPrevYearPrecent,
    					/*column1*/ ctx[5].budgetPrevYearPercent
    				],
    				baseRatios: [/*baseRatios*/ ctx[1][0], /*baseRatios*/ ctx[1][1]],
    				minRatios: [/*minRatios*/ ctx[2][0], /*minRatios*/ ctx[2][1]],
    				diagrams: /*indicator*/ ctx[3].id == "20"
    				? [
    						[
    							/*column1*/ ctx[5].factCurrYearPercent.qNum,
    							/*column1*/ ctx[5].factPrevYearPrecent.qNum
    						],
    						[
    							/*column1*/ ctx[5].budgetPercent.qNum,
    							/*column1*/ ctx[5].budgetPrevYearPercent.qNum
    						]
    					]
    				: [
    						[
    							/*column1*/ ctx[5].factCurrYearPercent.qNum,
    							/*column1*/ ctx[5].factPrevYearPrecent.qNum
    						]
    					]
    			},
    			$$inline: true
    		});

    	factorstotalcell1 = new FactorsTotalCell({
    			props: {
    				indicator: /*indicator*/ ctx[3],
    				value: [
    					/*column2*/ ctx[6].factPrevYearPrecent,
    					/*column2*/ ctx[6].budgetPrevYearPercent
    				],
    				baseRatios: [/*baseRatios*/ ctx[1][2], /*baseRatios*/ ctx[1][3]],
    				minRatios: [/*minRatios*/ ctx[2][2], /*minRatios*/ ctx[2][3]],
    				diagrams: /*indicator*/ ctx[3].id == "20"
    				? [
    						[
    							/*column2*/ ctx[6].factCurrYearPercent.qNum,
    							/*column2*/ ctx[6].factPrevYearPrecent.qNum
    						],
    						[
    							/*column2*/ ctx[6].budgetPercent.qNum,
    							/*column2*/ ctx[6].budgetPrevYearPercent.qNum
    						]
    					]
    				: [
    						[
    							/*column2*/ ctx[6].factCurrYearPercent.qNum,
    							/*column2*/ ctx[6].factPrevYearPrecent.qNum
    						]
    					]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorstotalcell0.$$.fragment);
    			t = space();
    			create_component(factorstotalcell1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorstotalcell0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(factorstotalcell1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorstotalcell0_changes = {};
    			if (dirty & /*indicator*/ 8) factorstotalcell0_changes.indicator = /*indicator*/ ctx[3];

    			if (dirty & /*column1*/ 32) factorstotalcell0_changes.value = [
    				/*column1*/ ctx[5].factPrevYearPrecent,
    				/*column1*/ ctx[5].budgetPrevYearPercent
    			];

    			if (dirty & /*baseRatios*/ 2) factorstotalcell0_changes.baseRatios = [/*baseRatios*/ ctx[1][0], /*baseRatios*/ ctx[1][1]];
    			if (dirty & /*minRatios*/ 4) factorstotalcell0_changes.minRatios = [/*minRatios*/ ctx[2][0], /*minRatios*/ ctx[2][1]];

    			if (dirty & /*indicator, column1*/ 40) factorstotalcell0_changes.diagrams = /*indicator*/ ctx[3].id == "20"
    			? [
    					[
    						/*column1*/ ctx[5].factCurrYearPercent.qNum,
    						/*column1*/ ctx[5].factPrevYearPrecent.qNum
    					],
    					[
    						/*column1*/ ctx[5].budgetPercent.qNum,
    						/*column1*/ ctx[5].budgetPrevYearPercent.qNum
    					]
    				]
    			: [
    					[
    						/*column1*/ ctx[5].factCurrYearPercent.qNum,
    						/*column1*/ ctx[5].factPrevYearPrecent.qNum
    					]
    				];

    			factorstotalcell0.$set(factorstotalcell0_changes);
    			const factorstotalcell1_changes = {};
    			if (dirty & /*indicator*/ 8) factorstotalcell1_changes.indicator = /*indicator*/ ctx[3];

    			if (dirty & /*column2*/ 64) factorstotalcell1_changes.value = [
    				/*column2*/ ctx[6].factPrevYearPrecent,
    				/*column2*/ ctx[6].budgetPrevYearPercent
    			];

    			if (dirty & /*baseRatios*/ 2) factorstotalcell1_changes.baseRatios = [/*baseRatios*/ ctx[1][2], /*baseRatios*/ ctx[1][3]];
    			if (dirty & /*minRatios*/ 4) factorstotalcell1_changes.minRatios = [/*minRatios*/ ctx[2][2], /*minRatios*/ ctx[2][3]];

    			if (dirty & /*indicator, column2*/ 72) factorstotalcell1_changes.diagrams = /*indicator*/ ctx[3].id == "20"
    			? [
    					[
    						/*column2*/ ctx[6].factCurrYearPercent.qNum,
    						/*column2*/ ctx[6].factPrevYearPrecent.qNum
    					],
    					[
    						/*column2*/ ctx[6].budgetPercent.qNum,
    						/*column2*/ ctx[6].budgetPrevYearPercent.qNum
    					]
    				]
    			: [
    					[
    						/*column2*/ ctx[6].factCurrYearPercent.qNum,
    						/*column2*/ ctx[6].factPrevYearPrecent.qNum
    					]
    				];

    			factorstotalcell1.$set(factorstotalcell1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorstotalcell0.$$.fragment, local);
    			transition_in(factorstotalcell1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorstotalcell0.$$.fragment, local);
    			transition_out(factorstotalcell1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorstotalcell0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(factorstotalcell1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(30:2) {#if data}",
    		ctx
    	});

    	return block;
    }

    // (27:0) <FactorsTotalRow>
    function create_default_slot$e(ctx) {
    	let factorstotallabel;
    	let t;
    	let if_block_anchor;
    	let current;

    	factorstotallabel = new FactorsTotalLabel({
    			props: { label: /*label*/ ctx[4] },
    			$$inline: true
    		});

    	let if_block = /*data*/ ctx[0] && create_if_block$8(ctx);

    	const block = {
    		c: function create() {
    			create_component(factorstotallabel.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorstotallabel, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorstotallabel_changes = {};
    			if (dirty & /*label*/ 16) factorstotallabel_changes.label = /*label*/ ctx[4];
    			factorstotallabel.$set(factorstotallabel_changes);

    			if (/*data*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*data*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$8(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorstotallabel.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorstotallabel.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorstotallabel, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(27:0) <FactorsTotalRow>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$W(ctx) {
    	let factorstotalrow;
    	let current;

    	factorstotalrow = new FactorsTotalRow({
    			props: {
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorstotalrow.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorstotalrow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const factorstotalrow_changes = {};

    			if (dirty & /*$$scope, indicator, column2, baseRatios, minRatios, column1, data, label*/ 4223) {
    				factorstotalrow_changes.$$scope = { dirty, ctx };
    			}

    			factorstotalrow.$set(factorstotalrow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorstotalrow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorstotalrow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorstotalrow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let $datePoP;
    	let $locale;
    	let { data } = $$props;
    	let { baseRatios } = $$props;
    	let { minRatios } = $$props;
    	let { indicator } = $$props;
    	const datePoP = getDashboardState("datePoP");
    	validate_store(datePoP, "datePoP");
    	component_subscribe($$self, datePoP, value => $$invalidate(9, $datePoP = value));
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(10, $locale = value));

    	function renderLabel() {
    		const year = new Date($datePoP).getFullYear();
    		return `${translate("Факт", $locale)} ${year}`;
    	}

    	const writable_props = ["data", "baseRatios", "minRatios", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsTotalFact> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsTotalFact", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("baseRatios" in $$props) $$invalidate(1, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(2, minRatios = $$props.minRatios);
    		if ("indicator" in $$props) $$invalidate(3, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		FactorsTotalRow,
    		FactorsTotalLabel,
    		FactorsTotalCell,
    		translate,
    		getUIState,
    		data,
    		baseRatios,
    		minRatios,
    		indicator,
    		datePoP,
    		locale,
    		renderLabel,
    		label,
    		$datePoP,
    		$locale,
    		column1,
    		column2
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("baseRatios" in $$props) $$invalidate(1, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(2, minRatios = $$props.minRatios);
    		if ("indicator" in $$props) $$invalidate(3, indicator = $$props.indicator);
    		if ("label" in $$props) $$invalidate(4, label = $$props.label);
    		if ("column1" in $$props) $$invalidate(5, column1 = $$props.column1);
    		if ("column2" in $$props) $$invalidate(6, column2 = $$props.column2);
    	};

    	let label;
    	let column1;
    	let column2;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$datePoP, $locale*/ 1536) {
    			 $$invalidate(4, label = renderLabel());
    		}

    		if ($$self.$$.dirty & /*data*/ 1) {
    			 $$invalidate(5, column1 = data.column1);
    		}

    		if ($$self.$$.dirty & /*data*/ 1) {
    			 $$invalidate(6, column2 = data.column2);
    		}
    	};

    	return [
    		data,
    		baseRatios,
    		minRatios,
    		indicator,
    		label,
    		column1,
    		column2,
    		datePoP,
    		locale
    	];
    }

    class FactorsTotalFact extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$W, create_fragment$W, safe_not_equal, {
    			data: 0,
    			baseRatios: 1,
    			minRatios: 2,
    			indicator: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsTotalFact",
    			options,
    			id: create_fragment$W.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<FactorsTotalFact> was created without expected prop 'data'");
    		}

    		if (/*baseRatios*/ ctx[1] === undefined && !("baseRatios" in props)) {
    			console.warn("<FactorsTotalFact> was created without expected prop 'baseRatios'");
    		}

    		if (/*minRatios*/ ctx[2] === undefined && !("minRatios" in props)) {
    			console.warn("<FactorsTotalFact> was created without expected prop 'minRatios'");
    		}

    		if (/*indicator*/ ctx[3] === undefined && !("indicator" in props)) {
    			console.warn("<FactorsTotalFact> was created without expected prop 'indicator'");
    		}
    	}

    	get data() {
    		throw new Error("<FactorsTotalFact>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<FactorsTotalFact>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseRatios() {
    		throw new Error("<FactorsTotalFact>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseRatios(value) {
    		throw new Error("<FactorsTotalFact>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minRatios() {
    		throw new Error("<FactorsTotalFact>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minRatios(value) {
    		throw new Error("<FactorsTotalFact>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<FactorsTotalFact>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<FactorsTotalFact>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factorsTotal/budget/FactorsTotalBudget.svelte generated by Svelte v3.24.0 */

    // (30:2) {#if data}
    function create_if_block$9(ctx) {
    	let factorstotalcell0;
    	let t;
    	let factorstotalcell1;
    	let current;

    	factorstotalcell0 = new FactorsTotalCell({
    			props: {
    				indicator: /*indicator*/ ctx[3],
    				value: /*column1*/ ctx[5].budgetPercent,
    				baseRatio: /*baseRatios*/ ctx[1][1],
    				minRatio: /*minRatios*/ ctx[2][1],
    				diagrams: [
    					[
    						/*column1*/ ctx[5].factCurrYearPercent.qNum,
    						/*column1*/ ctx[5].budgetPercent.qNum
    					],
    					[
    						/*column1*/ ctx[5].factCurrYearPercent.qNum,
    						/*column1*/ ctx[5].budgetPercent.qNum
    					]
    				]
    			},
    			$$inline: true
    		});

    	factorstotalcell1 = new FactorsTotalCell({
    			props: {
    				indicator: /*indicator*/ ctx[3],
    				value: /*column2*/ ctx[6].budgetPercent,
    				baseRatio: /*baseRatios*/ ctx[1][3],
    				minRatio: /*minRatios*/ ctx[2][3],
    				diagrams: [
    					[
    						/*column2*/ ctx[6].factCurrYearPercent.qNum,
    						/*column2*/ ctx[6].budgetPercent.qNum
    					],
    					[
    						/*column2*/ ctx[6].factCurrYearPercent.qNum,
    						/*column2*/ ctx[6].budgetPercent.qNum
    					]
    				]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorstotalcell0.$$.fragment);
    			t = space();
    			create_component(factorstotalcell1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorstotalcell0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(factorstotalcell1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorstotalcell0_changes = {};
    			if (dirty & /*indicator*/ 8) factorstotalcell0_changes.indicator = /*indicator*/ ctx[3];
    			if (dirty & /*column1*/ 32) factorstotalcell0_changes.value = /*column1*/ ctx[5].budgetPercent;
    			if (dirty & /*baseRatios*/ 2) factorstotalcell0_changes.baseRatio = /*baseRatios*/ ctx[1][1];
    			if (dirty & /*minRatios*/ 4) factorstotalcell0_changes.minRatio = /*minRatios*/ ctx[2][1];

    			if (dirty & /*column1*/ 32) factorstotalcell0_changes.diagrams = [
    				[
    					/*column1*/ ctx[5].factCurrYearPercent.qNum,
    					/*column1*/ ctx[5].budgetPercent.qNum
    				],
    				[
    					/*column1*/ ctx[5].factCurrYearPercent.qNum,
    					/*column1*/ ctx[5].budgetPercent.qNum
    				]
    			];

    			factorstotalcell0.$set(factorstotalcell0_changes);
    			const factorstotalcell1_changes = {};
    			if (dirty & /*indicator*/ 8) factorstotalcell1_changes.indicator = /*indicator*/ ctx[3];
    			if (dirty & /*column2*/ 64) factorstotalcell1_changes.value = /*column2*/ ctx[6].budgetPercent;
    			if (dirty & /*baseRatios*/ 2) factorstotalcell1_changes.baseRatio = /*baseRatios*/ ctx[1][3];
    			if (dirty & /*minRatios*/ 4) factorstotalcell1_changes.minRatio = /*minRatios*/ ctx[2][3];

    			if (dirty & /*column2*/ 64) factorstotalcell1_changes.diagrams = [
    				[
    					/*column2*/ ctx[6].factCurrYearPercent.qNum,
    					/*column2*/ ctx[6].budgetPercent.qNum
    				],
    				[
    					/*column2*/ ctx[6].factCurrYearPercent.qNum,
    					/*column2*/ ctx[6].budgetPercent.qNum
    				]
    			];

    			factorstotalcell1.$set(factorstotalcell1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorstotalcell0.$$.fragment, local);
    			transition_in(factorstotalcell1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorstotalcell0.$$.fragment, local);
    			transition_out(factorstotalcell1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorstotalcell0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(factorstotalcell1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(30:2) {#if data}",
    		ctx
    	});

    	return block;
    }

    // (27:0) <FactorsTotalRow>
    function create_default_slot$f(ctx) {
    	let factorstotallabel;
    	let t;
    	let if_block_anchor;
    	let current;

    	factorstotallabel = new FactorsTotalLabel({
    			props: { label: /*label*/ ctx[4] },
    			$$inline: true
    		});

    	let if_block = /*data*/ ctx[0] && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			create_component(factorstotallabel.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorstotallabel, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorstotallabel_changes = {};
    			if (dirty & /*label*/ 16) factorstotallabel_changes.label = /*label*/ ctx[4];
    			factorstotallabel.$set(factorstotallabel_changes);

    			if (/*data*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*data*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorstotallabel.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorstotallabel.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorstotallabel, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(27:0) <FactorsTotalRow>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$X(ctx) {
    	let factorstotalrow;
    	let current;

    	factorstotalrow = new FactorsTotalRow({
    			props: {
    				$$slots: { default: [create_default_slot$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorstotalrow.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorstotalrow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const factorstotalrow_changes = {};

    			if (dirty & /*$$scope, indicator, column2, baseRatios, minRatios, column1, data, label*/ 4223) {
    				factorstotalrow_changes.$$scope = { dirty, ctx };
    			}

    			factorstotalrow.$set(factorstotalrow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorstotalrow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorstotalrow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorstotalrow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let $date;
    	let $locale;
    	let { data } = $$props;
    	let { baseRatios } = $$props;
    	let { minRatios } = $$props;
    	let { indicator } = $$props;
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(9, $date = value));
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(10, $locale = value));

    	function renderLabel() {
    		const year = new Date($date).getFullYear();
    		return `${translate("Бюджет", $locale)} ${year}`;
    	}

    	const writable_props = ["data", "baseRatios", "minRatios", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsTotalBudget> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsTotalBudget", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("baseRatios" in $$props) $$invalidate(1, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(2, minRatios = $$props.minRatios);
    		if ("indicator" in $$props) $$invalidate(3, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		FactorsTotalRow,
    		FactorsTotalLabel,
    		FactorsTotalCell,
    		translate,
    		getUIState,
    		data,
    		baseRatios,
    		minRatios,
    		indicator,
    		date,
    		locale,
    		renderLabel,
    		label,
    		$date,
    		$locale,
    		column1,
    		column2
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("baseRatios" in $$props) $$invalidate(1, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(2, minRatios = $$props.minRatios);
    		if ("indicator" in $$props) $$invalidate(3, indicator = $$props.indicator);
    		if ("label" in $$props) $$invalidate(4, label = $$props.label);
    		if ("column1" in $$props) $$invalidate(5, column1 = $$props.column1);
    		if ("column2" in $$props) $$invalidate(6, column2 = $$props.column2);
    	};

    	let label;
    	let column1;
    	let column2;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$date, $locale*/ 1536) {
    			 $$invalidate(4, label = renderLabel());
    		}

    		if ($$self.$$.dirty & /*data*/ 1) {
    			 $$invalidate(5, column1 = data.column1);
    		}

    		if ($$self.$$.dirty & /*data*/ 1) {
    			 $$invalidate(6, column2 = data.column2);
    		}
    	};

    	return [data, baseRatios, minRatios, indicator, label, column1, column2, date, locale];
    }

    class FactorsTotalBudget extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$X, create_fragment$X, safe_not_equal, {
    			data: 0,
    			baseRatios: 1,
    			minRatios: 2,
    			indicator: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsTotalBudget",
    			options,
    			id: create_fragment$X.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<FactorsTotalBudget> was created without expected prop 'data'");
    		}

    		if (/*baseRatios*/ ctx[1] === undefined && !("baseRatios" in props)) {
    			console.warn("<FactorsTotalBudget> was created without expected prop 'baseRatios'");
    		}

    		if (/*minRatios*/ ctx[2] === undefined && !("minRatios" in props)) {
    			console.warn("<FactorsTotalBudget> was created without expected prop 'minRatios'");
    		}

    		if (/*indicator*/ ctx[3] === undefined && !("indicator" in props)) {
    			console.warn("<FactorsTotalBudget> was created without expected prop 'indicator'");
    		}
    	}

    	get data() {
    		throw new Error("<FactorsTotalBudget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<FactorsTotalBudget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseRatios() {
    		throw new Error("<FactorsTotalBudget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseRatios(value) {
    		throw new Error("<FactorsTotalBudget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minRatios() {
    		throw new Error("<FactorsTotalBudget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minRatios(value) {
    		throw new Error("<FactorsTotalBudget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<FactorsTotalBudget>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<FactorsTotalBudget>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factors/FactorsSectionHeader.svelte generated by Svelte v3.24.0 */
    const file$M = "src/js/components/factors/FactorsSectionHeader.svelte";

    function create_fragment$Y(ctx) {
    	let div;
    	let factorstotalfact;
    	let current;

    	factorstotalfact = new FactorsTotalFact({
    			props: {
    				data: /*data*/ ctx[0],
    				baseRatios: /*baseRatios*/ ctx[1],
    				minRatios: /*minRatios*/ ctx[2],
    				indicator: /*indicator*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(factorstotalfact.$$.fragment);
    			attr_dev(div, "class", "txcm-factorsSectionHeader");
    			add_location(div, file$M, 21, 0, 522);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(factorstotalfact, div, null);
    			/*div_binding*/ ctx[6](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const factorstotalfact_changes = {};
    			if (dirty & /*data*/ 1) factorstotalfact_changes.data = /*data*/ ctx[0];
    			if (dirty & /*baseRatios*/ 2) factorstotalfact_changes.baseRatios = /*baseRatios*/ ctx[1];
    			if (dirty & /*minRatios*/ 4) factorstotalfact_changes.minRatios = /*minRatios*/ ctx[2];
    			if (dirty & /*indicator*/ 8) factorstotalfact_changes.indicator = /*indicator*/ ctx[3];
    			factorstotalfact.$set(factorstotalfact_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorstotalfact.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorstotalfact.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(factorstotalfact);
    			/*div_binding*/ ctx[6](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let $sectionScrollX;
    	let { data } = $$props;
    	let { baseRatios } = $$props;
    	let { minRatios } = $$props;
    	let { indicator } = $$props;
    	const sectionScrollX = getUIState("sectionScrollX");
    	validate_store(sectionScrollX, "sectionScrollX");
    	component_subscribe($$self, sectionScrollX, value => $$invalidate(7, $sectionScrollX = value));
    	let node;

    	function updateScroll() {
    		if (node) $$invalidate(4, node.scrollLeft = $sectionScrollX, node);
    	}

    	const writable_props = ["data", "baseRatios", "minRatios", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsSectionHeader> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsSectionHeader", $$slots, []);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			node = $$value;
    			$$invalidate(4, node);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("baseRatios" in $$props) $$invalidate(1, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(2, minRatios = $$props.minRatios);
    		if ("indicator" in $$props) $$invalidate(3, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getUIState,
    		FactorsTotalFact,
    		FactorsTotalBudget,
    		data,
    		baseRatios,
    		minRatios,
    		indicator,
    		sectionScrollX,
    		node,
    		updateScroll,
    		$sectionScrollX
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("baseRatios" in $$props) $$invalidate(1, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(2, minRatios = $$props.minRatios);
    		if ("indicator" in $$props) $$invalidate(3, indicator = $$props.indicator);
    		if ("node" in $$props) $$invalidate(4, node = $$props.node);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$sectionScrollX*/ 128) {
    			 updateScroll();
    		}
    	};

    	return [data, baseRatios, minRatios, indicator, node, sectionScrollX, div_binding];
    }

    class FactorsSectionHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {
    			data: 0,
    			baseRatios: 1,
    			minRatios: 2,
    			indicator: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsSectionHeader",
    			options,
    			id: create_fragment$Y.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<FactorsSectionHeader> was created without expected prop 'data'");
    		}

    		if (/*baseRatios*/ ctx[1] === undefined && !("baseRatios" in props)) {
    			console.warn("<FactorsSectionHeader> was created without expected prop 'baseRatios'");
    		}

    		if (/*minRatios*/ ctx[2] === undefined && !("minRatios" in props)) {
    			console.warn("<FactorsSectionHeader> was created without expected prop 'minRatios'");
    		}

    		if (/*indicator*/ ctx[3] === undefined && !("indicator" in props)) {
    			console.warn("<FactorsSectionHeader> was created without expected prop 'indicator'");
    		}
    	}

    	get data() {
    		throw new Error("<FactorsSectionHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<FactorsSectionHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseRatios() {
    		throw new Error("<FactorsSectionHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseRatios(value) {
    		throw new Error("<FactorsSectionHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minRatios() {
    		throw new Error("<FactorsSectionHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minRatios(value) {
    		throw new Error("<FactorsSectionHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<FactorsSectionHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<FactorsSectionHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factorsComparison/FactorsComparisonValue.svelte generated by Svelte v3.24.0 */
    const file$N = "src/js/components/factorsComparison/FactorsComparisonValue.svelte";

    function create_fragment$Z(ctx) {
    	let div;
    	let svg;
    	let use;
    	let svg_class_value;
    	let t;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t = space();
    			if (default_slot) default_slot.c();
    			xlink_attr(use, "xlink:href", "#txspt-icons-fatArrow");
    			add_location(use, file$N, 10, 8, 236);
    			attr_dev(svg, "class", svg_class_value = renderDynamicsClass("txcm-factorsTotalValueIcon", /*dynamics*/ ctx[0]));
    			add_location(svg, file$N, 8, 4, 148);
    			attr_dev(div, "class", "txcm-factorsTotalValue");
    			add_location(div, file$N, 6, 0, 105);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, use);
    			append_dev(div, t);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*dynamics*/ 1 && svg_class_value !== (svg_class_value = renderDynamicsClass("txcm-factorsTotalValueIcon", /*dynamics*/ ctx[0]))) {
    				attr_dev(svg, "class", svg_class_value);
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let { dynamics } = $$props;
    	const writable_props = ["dynamics"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsComparisonValue> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsComparisonValue", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("dynamics" in $$props) $$invalidate(0, dynamics = $$props.dynamics);
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ renderDynamicsClass, dynamics });

    	$$self.$inject_state = $$props => {
    		if ("dynamics" in $$props) $$invalidate(0, dynamics = $$props.dynamics);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dynamics, $$scope, $$slots];
    }

    class FactorsComparisonValue extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, { dynamics: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsComparisonValue",
    			options,
    			id: create_fragment$Z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dynamics*/ ctx[0] === undefined && !("dynamics" in props)) {
    			console.warn("<FactorsComparisonValue> was created without expected prop 'dynamics'");
    		}
    	}

    	get dynamics() {
    		throw new Error("<FactorsComparisonValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dynamics(value) {
    		throw new Error("<FactorsComparisonValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factorsComparison/FactorsComparisonDiagram.svelte generated by Svelte v3.24.0 */
    const file$O = "src/js/components/factorsComparison/FactorsComparisonDiagram.svelte";

    // (65:4) {#if value}
    function create_if_block_2$1(ctx) {
    	let div;
    	let factorscomparisonvalue;
    	let current;

    	factorscomparisonvalue = new FactorsComparisonValue({
    			props: {
    				dynamics: /*dynamics*/ ctx[4],
    				$$slots: { default: [create_default_slot$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(factorscomparisonvalue.$$.fragment);
    			set_style(div, "position", "absolute");
    			set_style(div, "right", "0px");
    			add_location(div, file$O, 65, 6, 1738);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(factorscomparisonvalue, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorscomparisonvalue_changes = {};
    			if (dirty & /*dynamics*/ 16) factorscomparisonvalue_changes.dynamics = /*dynamics*/ ctx[4];

    			if (dirty & /*$$scope, value*/ 16392) {
    				factorscomparisonvalue_changes.$$scope = { dirty, ctx };
    			}

    			factorscomparisonvalue.$set(factorscomparisonvalue_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorscomparisonvalue.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorscomparisonvalue.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(factorscomparisonvalue);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(65:4) {#if value}",
    		ctx
    	});

    	return block;
    }

    // (67:8) <FactorsComparisonValue {dynamics}>
    function create_default_slot$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*value*/ ctx[3]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*value*/ 8) set_data_dev(t, /*value*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(67:8) <FactorsComparisonValue {dynamics}>",
    		ctx
    	});

    	return block;
    }

    // (72:4) {#if data}
    function create_if_block$a(ctx) {
    	let svg;
    	let rect;
    	let rect_x_value;
    	let rect_width_value;
    	let t0;
    	let div;
    	let t1_value = formatLabel(/*bridge*/ ctx[1].qNum, /*bridge*/ ctx[1].units) + "";
    	let t1;

    	let rect_levels = [
    		{
    			class: "txcm-factorsTotalDiagramRectBase"
    		},
    		{
    			x: rect_x_value = `${/*minRatio*/ ctx[2] * 100 + /*baseShift*/ ctx[6]}%`
    		},
    		{
    			width: rect_width_value = `${/*baseWidth*/ ctx[5]}%`
    		},
    		/*RECT*/ ctx[9]
    	];

    	let rect_data = {};

    	for (let i = 0; i < rect_levels.length; i += 1) {
    		rect_data = assign(rect_data, rect_levels[i]);
    	}

    	let if_block = /*bridge*/ ctx[1].qNum !== 0 && create_if_block_1$4(ctx);

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			rect = svg_element("rect");
    			if (if_block) if_block.c();
    			t0 = space();
    			div = element("div");
    			t1 = text(t1_value);
    			set_svg_attributes(rect, rect_data);
    			add_location(rect, file$O, 76, 10, 2024);
    			attr_dev(svg, "class", "txcm-factorsTotalDiagramSVG");
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "19");
    			add_location(svg, file$O, 72, 6, 1923);
    			attr_dev(div, "class", "txcm-factorsTotalDiagramDiff");
    			add_location(div, file$O, 89, 6, 2509);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, rect);
    			if (if_block) if_block.m(svg, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(rect, rect_data = get_spread_update(rect_levels, [
    				{
    					class: "txcm-factorsTotalDiagramRectBase"
    				},
    				dirty & /*minRatio, baseShift*/ 68 && rect_x_value !== (rect_x_value = `${/*minRatio*/ ctx[2] * 100 + /*baseShift*/ ctx[6]}%`) && { x: rect_x_value },
    				dirty & /*baseWidth*/ 32 && rect_width_value !== (rect_width_value = `${/*baseWidth*/ ctx[5]}%`) && { width: rect_width_value },
    				/*RECT*/ ctx[9]
    			]));

    			if (/*bridge*/ ctx[1].qNum !== 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_1$4(ctx);
    					if_block.c();
    					if_block.m(svg, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*bridge*/ 2 && t1_value !== (t1_value = formatLabel(/*bridge*/ ctx[1].qNum, /*bridge*/ ctx[1].units) + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(72:4) {#if data}",
    		ctx
    	});

    	return block;
    }

    // (82:12) {#if bridge.qNum !== 0}
    function create_if_block_1$4(ctx) {
    	let rect;
    	let rect_class_value;
    	let rect_x_value;
    	let rect_width_value;

    	let rect_levels = [
    		{
    			class: rect_class_value = renderDynamicsClass("txcm-factorsTotalDiagramRectBase", checkDynamics(/*bridge*/ ctx[1].qNum))
    		},
    		/*RECT*/ ctx[9],
    		{
    			x: rect_x_value = `${/*minRatio*/ ctx[2] * 100 + /*shift*/ ctx[8]}%`
    		},
    		{
    			width: rect_width_value = `${/*width*/ ctx[7]}%`
    		}
    	];

    	let rect_data = {};

    	for (let i = 0; i < rect_levels.length; i += 1) {
    		rect_data = assign(rect_data, rect_levels[i]);
    	}

    	const block = {
    		c: function create() {
    			rect = svg_element("rect");
    			set_svg_attributes(rect, rect_data);
    			add_location(rect, file$O, 82, 14, 2244);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, rect, anchor);
    		},
    		p: function update(ctx, dirty) {
    			set_svg_attributes(rect, rect_data = get_spread_update(rect_levels, [
    				dirty & /*bridge*/ 2 && rect_class_value !== (rect_class_value = renderDynamicsClass("txcm-factorsTotalDiagramRectBase", checkDynamics(/*bridge*/ ctx[1].qNum))) && { class: rect_class_value },
    				/*RECT*/ ctx[9],
    				dirty & /*minRatio, shift*/ 260 && rect_x_value !== (rect_x_value = `${/*minRatio*/ ctx[2] * 100 + /*shift*/ ctx[8]}%`) && { x: rect_x_value },
    				dirty & /*width*/ 128 && rect_width_value !== (rect_width_value = `${/*width*/ ctx[7]}%`) && { width: rect_width_value }
    			]));
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(rect);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(82:12) {#if bridge.qNum !== 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$_(ctx) {
    	let div;
    	let t;
    	let current;
    	let if_block0 = /*value*/ ctx[3] && create_if_block_2$1(ctx);
    	let if_block1 = /*data*/ ctx[0] && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "txcm-factorsTotalDiagram");
    			add_location(div, file$O, 62, 0, 1675);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*value*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*value*/ 8) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*data*/ ctx[0]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$a(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { bridge } = $$props;
    	let { baseRatio } = $$props;
    	let { minRatio } = $$props;
    	let { value } = $$props;
    	let { dynamics } = $$props;
    	const RECT = { y: 0, height: "100%", rx: 3, ry: 3 };
    	let base;
    	let comparison;
    	let baseWidth;
    	let baseShift = 0;
    	let width;
    	let shift = 0;

    	function calculateValues() {
    		if (data) {
    			[base, comparison] = data;
    			const value = base - comparison;

    			if (comparison >= 0) {
    				if (value >= 0) {
    					$$invalidate(6, baseShift = 0);
    					$$invalidate(5, baseWidth = Math.abs(base) * baseRatio * 100);
    					$$invalidate(8, shift = Math.abs(comparison) * baseRatio * 100);
    					$$invalidate(7, width = Math.abs(base - comparison) * baseRatio * 100);
    				} else {
    					$$invalidate(7, width = Math.abs(base - comparison) * baseRatio * 100);
    					$$invalidate(5, baseWidth = Math.abs(comparison) * baseRatio * 100);
    					$$invalidate(8, shift = baseWidth - width);
    				}
    			} else {
    				if (value >= 0) {
    					$$invalidate(6, baseShift = 0);
    					$$invalidate(5, baseWidth = Math.abs(base) * baseRatio * 100);
    					$$invalidate(7, width = Math.abs(base - comparison) * baseRatio * 100);
    				} else {
    					$$invalidate(7, width = Math.abs(base - comparison) * baseRatio * 100);
    					$$invalidate(5, baseWidth = Math.abs(base) * baseRatio * 100);
    					$$invalidate(6, baseShift = -baseWidth + Math.abs(comparison) * baseRatio * 100);
    					$$invalidate(8, shift = baseShift);
    				}
    			}
    		}
    	}

    	const writable_props = ["data", "bridge", "baseRatio", "minRatio", "value", "dynamics"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsComparisonDiagram> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsComparisonDiagram", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("bridge" in $$props) $$invalidate(1, bridge = $$props.bridge);
    		if ("baseRatio" in $$props) $$invalidate(10, baseRatio = $$props.baseRatio);
    		if ("minRatio" in $$props) $$invalidate(2, minRatio = $$props.minRatio);
    		if ("value" in $$props) $$invalidate(3, value = $$props.value);
    		if ("dynamics" in $$props) $$invalidate(4, dynamics = $$props.dynamics);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		checkDynamics,
    		renderDynamicsClass,
    		FactorsComparisonValue,
    		formatLabel,
    		data,
    		bridge,
    		baseRatio,
    		minRatio,
    		value,
    		dynamics,
    		RECT,
    		base,
    		comparison,
    		baseWidth,
    		baseShift,
    		width,
    		shift,
    		calculateValues
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("bridge" in $$props) $$invalidate(1, bridge = $$props.bridge);
    		if ("baseRatio" in $$props) $$invalidate(10, baseRatio = $$props.baseRatio);
    		if ("minRatio" in $$props) $$invalidate(2, minRatio = $$props.minRatio);
    		if ("value" in $$props) $$invalidate(3, value = $$props.value);
    		if ("dynamics" in $$props) $$invalidate(4, dynamics = $$props.dynamics);
    		if ("base" in $$props) base = $$props.base;
    		if ("comparison" in $$props) comparison = $$props.comparison;
    		if ("baseWidth" in $$props) $$invalidate(5, baseWidth = $$props.baseWidth);
    		if ("baseShift" in $$props) $$invalidate(6, baseShift = $$props.baseShift);
    		if ("width" in $$props) $$invalidate(7, width = $$props.width);
    		if ("shift" in $$props) $$invalidate(8, shift = $$props.shift);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data, bridge, baseRatio*/ 1027) {
    			 calculateValues();
    		}
    	};

    	return [
    		data,
    		bridge,
    		minRatio,
    		value,
    		dynamics,
    		baseWidth,
    		baseShift,
    		width,
    		shift,
    		RECT,
    		baseRatio
    	];
    }

    class FactorsComparisonDiagram extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$_, create_fragment$_, safe_not_equal, {
    			data: 0,
    			bridge: 1,
    			baseRatio: 10,
    			minRatio: 2,
    			value: 3,
    			dynamics: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsComparisonDiagram",
    			options,
    			id: create_fragment$_.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<FactorsComparisonDiagram> was created without expected prop 'data'");
    		}

    		if (/*bridge*/ ctx[1] === undefined && !("bridge" in props)) {
    			console.warn("<FactorsComparisonDiagram> was created without expected prop 'bridge'");
    		}

    		if (/*baseRatio*/ ctx[10] === undefined && !("baseRatio" in props)) {
    			console.warn("<FactorsComparisonDiagram> was created without expected prop 'baseRatio'");
    		}

    		if (/*minRatio*/ ctx[2] === undefined && !("minRatio" in props)) {
    			console.warn("<FactorsComparisonDiagram> was created without expected prop 'minRatio'");
    		}

    		if (/*value*/ ctx[3] === undefined && !("value" in props)) {
    			console.warn("<FactorsComparisonDiagram> was created without expected prop 'value'");
    		}

    		if (/*dynamics*/ ctx[4] === undefined && !("dynamics" in props)) {
    			console.warn("<FactorsComparisonDiagram> was created without expected prop 'dynamics'");
    		}
    	}

    	get data() {
    		throw new Error("<FactorsComparisonDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<FactorsComparisonDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bridge() {
    		throw new Error("<FactorsComparisonDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bridge(value) {
    		throw new Error("<FactorsComparisonDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseRatio() {
    		throw new Error("<FactorsComparisonDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseRatio(value) {
    		throw new Error("<FactorsComparisonDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minRatio() {
    		throw new Error("<FactorsComparisonDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minRatio(value) {
    		throw new Error("<FactorsComparisonDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<FactorsComparisonDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<FactorsComparisonDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dynamics() {
    		throw new Error("<FactorsComparisonDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dynamics(value) {
    		throw new Error("<FactorsComparisonDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factorsComparison/FactorsComparisonCell.svelte generated by Svelte v3.24.0 */
    const file$P = "src/js/components/factorsComparison/FactorsComparisonCell.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (19:4) <FactorsComparisonValue       dynamics={compareDynamics(value[0].qNum, comparison[0].qNum)}>
    function create_default_slot$h(ctx) {
    	let t_value = formatLabel(/*value*/ ctx[0][0].qNum, /*value*/ ctx[0][0].units) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*value*/ 1 && t_value !== (t_value = formatLabel(/*value*/ ctx[0][0].qNum, /*value*/ ctx[0][0].units) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(19:4) <FactorsComparisonValue       dynamics={compareDynamics(value[0].qNum, comparison[0].qNum)}>",
    		ctx
    	});

    	return block;
    }

    // (34:4) {:else}
    function create_else_block$1(ctx) {
    	let factorscomparisondiagram;
    	let current;

    	factorscomparisondiagram = new FactorsComparisonDiagram({
    			props: {
    				data: /*diagrams*/ ctx[3][0],
    				bridge: /*bridges*/ ctx[2][0],
    				baseRatio: /*baseRatios*/ ctx[4][0],
    				minRatio: /*minRatios*/ ctx[5][0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorscomparisondiagram.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorscomparisondiagram, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorscomparisondiagram_changes = {};
    			if (dirty & /*diagrams*/ 8) factorscomparisondiagram_changes.data = /*diagrams*/ ctx[3][0];
    			if (dirty & /*bridges*/ 4) factorscomparisondiagram_changes.bridge = /*bridges*/ ctx[2][0];
    			if (dirty & /*baseRatios*/ 16) factorscomparisondiagram_changes.baseRatio = /*baseRatios*/ ctx[4][0];
    			if (dirty & /*minRatios*/ 32) factorscomparisondiagram_changes.minRatio = /*minRatios*/ ctx[5][0];
    			factorscomparisondiagram.$set(factorscomparisondiagram_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorscomparisondiagram.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorscomparisondiagram.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorscomparisondiagram, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(34:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (23:4) {#if indicator.id === '20'}
    function create_if_block$b(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*diagrams*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*formatLabel, value, compareDynamics, comparison, diagrams, bridges, baseRatios, minRatios*/ 63) {
    				each_value = /*diagrams*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$g(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$g(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(23:4) {#if indicator.id === '20'}",
    		ctx
    	});

    	return block;
    }

    // (24:6) {#each diagrams as diagram, index}
    function create_each_block$g(ctx) {
    	let factorscomparisondiagram;
    	let current;

    	factorscomparisondiagram = new FactorsComparisonDiagram({
    			props: {
    				value: /*index*/ ctx[9] === 1
    				? formatLabel(/*value*/ ctx[0][1].qNum, /*value*/ ctx[0][1].units)
    				: null,
    				dynamics: /*index*/ ctx[9] === 1
    				? compareDynamics(/*value*/ ctx[0][1].qNum, /*comparison*/ ctx[1][1].qNum)
    				: null,
    				data: /*diagrams*/ ctx[3][/*index*/ ctx[9]],
    				bridge: /*bridges*/ ctx[2][/*index*/ ctx[9]],
    				baseRatio: /*baseRatios*/ ctx[4][/*index*/ ctx[9]],
    				minRatio: /*minRatios*/ ctx[5][/*index*/ ctx[9]]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorscomparisondiagram.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorscomparisondiagram, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorscomparisondiagram_changes = {};

    			if (dirty & /*value*/ 1) factorscomparisondiagram_changes.value = /*index*/ ctx[9] === 1
    			? formatLabel(/*value*/ ctx[0][1].qNum, /*value*/ ctx[0][1].units)
    			: null;

    			if (dirty & /*value, comparison*/ 3) factorscomparisondiagram_changes.dynamics = /*index*/ ctx[9] === 1
    			? compareDynamics(/*value*/ ctx[0][1].qNum, /*comparison*/ ctx[1][1].qNum)
    			: null;

    			if (dirty & /*diagrams*/ 8) factorscomparisondiagram_changes.data = /*diagrams*/ ctx[3][/*index*/ ctx[9]];
    			if (dirty & /*bridges*/ 4) factorscomparisondiagram_changes.bridge = /*bridges*/ ctx[2][/*index*/ ctx[9]];
    			if (dirty & /*baseRatios*/ 16) factorscomparisondiagram_changes.baseRatio = /*baseRatios*/ ctx[4][/*index*/ ctx[9]];
    			if (dirty & /*minRatios*/ 32) factorscomparisondiagram_changes.minRatio = /*minRatios*/ ctx[5][/*index*/ ctx[9]];
    			factorscomparisondiagram.$set(factorscomparisondiagram_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorscomparisondiagram.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorscomparisondiagram.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorscomparisondiagram, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$g.name,
    		type: "each",
    		source: "(24:6) {#each diagrams as diagram, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$$(ctx) {
    	let div;
    	let factorscomparisonvalue;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let current;

    	factorscomparisonvalue = new FactorsComparisonValue({
    			props: {
    				dynamics: compareDynamics(/*value*/ ctx[0][0].qNum, /*comparison*/ ctx[1][0].qNum),
    				$$slots: { default: [create_default_slot$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block$b, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*indicator*/ ctx[6].id === "20") return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(factorscomparisonvalue.$$.fragment);
    			t = space();
    			if_block.c();
    			attr_dev(div, "class", "txcm-factorsTotalCell");
    			add_location(div, file$P, 16, 0, 440);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(factorscomparisonvalue, div, null);
    			append_dev(div, t);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const factorscomparisonvalue_changes = {};
    			if (dirty & /*value, comparison*/ 3) factorscomparisonvalue_changes.dynamics = compareDynamics(/*value*/ ctx[0][0].qNum, /*comparison*/ ctx[1][0].qNum);

    			if (dirty & /*$$scope, value*/ 1025) {
    				factorscomparisonvalue_changes.$$scope = { dirty, ctx };
    			}

    			factorscomparisonvalue.$set(factorscomparisonvalue_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorscomparisonvalue.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorscomparisonvalue.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(factorscomparisonvalue);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let { value } = $$props;
    	let { comparison } = $$props;
    	let { bridges } = $$props;
    	let { diagrams } = $$props;
    	let { baseRatios } = $$props;
    	let { minRatios } = $$props;
    	let { indicator } = $$props;

    	const writable_props = [
    		"value",
    		"comparison",
    		"bridges",
    		"diagrams",
    		"baseRatios",
    		"minRatios",
    		"indicator"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsComparisonCell> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsComparisonCell", $$slots, []);

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("comparison" in $$props) $$invalidate(1, comparison = $$props.comparison);
    		if ("bridges" in $$props) $$invalidate(2, bridges = $$props.bridges);
    		if ("diagrams" in $$props) $$invalidate(3, diagrams = $$props.diagrams);
    		if ("baseRatios" in $$props) $$invalidate(4, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(5, minRatios = $$props.minRatios);
    		if ("indicator" in $$props) $$invalidate(6, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		compareDynamics,
    		FactorsComparisonValue,
    		FactorsComparisonDiagram,
    		formatLabel,
    		value,
    		comparison,
    		bridges,
    		diagrams,
    		baseRatios,
    		minRatios,
    		indicator
    	});

    	$$self.$inject_state = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    		if ("comparison" in $$props) $$invalidate(1, comparison = $$props.comparison);
    		if ("bridges" in $$props) $$invalidate(2, bridges = $$props.bridges);
    		if ("diagrams" in $$props) $$invalidate(3, diagrams = $$props.diagrams);
    		if ("baseRatios" in $$props) $$invalidate(4, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(5, minRatios = $$props.minRatios);
    		if ("indicator" in $$props) $$invalidate(6, indicator = $$props.indicator);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [value, comparison, bridges, diagrams, baseRatios, minRatios, indicator];
    }

    class FactorsComparisonCell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$$, create_fragment$$, safe_not_equal, {
    			value: 0,
    			comparison: 1,
    			bridges: 2,
    			diagrams: 3,
    			baseRatios: 4,
    			minRatios: 5,
    			indicator: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsComparisonCell",
    			options,
    			id: create_fragment$$.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[0] === undefined && !("value" in props)) {
    			console.warn("<FactorsComparisonCell> was created without expected prop 'value'");
    		}

    		if (/*comparison*/ ctx[1] === undefined && !("comparison" in props)) {
    			console.warn("<FactorsComparisonCell> was created without expected prop 'comparison'");
    		}

    		if (/*bridges*/ ctx[2] === undefined && !("bridges" in props)) {
    			console.warn("<FactorsComparisonCell> was created without expected prop 'bridges'");
    		}

    		if (/*diagrams*/ ctx[3] === undefined && !("diagrams" in props)) {
    			console.warn("<FactorsComparisonCell> was created without expected prop 'diagrams'");
    		}

    		if (/*baseRatios*/ ctx[4] === undefined && !("baseRatios" in props)) {
    			console.warn("<FactorsComparisonCell> was created without expected prop 'baseRatios'");
    		}

    		if (/*minRatios*/ ctx[5] === undefined && !("minRatios" in props)) {
    			console.warn("<FactorsComparisonCell> was created without expected prop 'minRatios'");
    		}

    		if (/*indicator*/ ctx[6] === undefined && !("indicator" in props)) {
    			console.warn("<FactorsComparisonCell> was created without expected prop 'indicator'");
    		}
    	}

    	get value() {
    		throw new Error("<FactorsComparisonCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<FactorsComparisonCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get comparison() {
    		throw new Error("<FactorsComparisonCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set comparison(value) {
    		throw new Error("<FactorsComparisonCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bridges() {
    		throw new Error("<FactorsComparisonCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bridges(value) {
    		throw new Error("<FactorsComparisonCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get diagrams() {
    		throw new Error("<FactorsComparisonCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set diagrams(value) {
    		throw new Error("<FactorsComparisonCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseRatios() {
    		throw new Error("<FactorsComparisonCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseRatios(value) {
    		throw new Error("<FactorsComparisonCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minRatios() {
    		throw new Error("<FactorsComparisonCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minRatios(value) {
    		throw new Error("<FactorsComparisonCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<FactorsComparisonCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<FactorsComparisonCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factorsComparison/FactorsComparison.svelte generated by Svelte v3.24.0 */

    // (28:4) {#if data}
    function create_if_block$c(ctx) {
    	let factorscomparisoncell0;
    	let t;
    	let factorscomparisoncell1;
    	let current;

    	factorscomparisoncell0 = new FactorsComparisonCell({
    			props: {
    				indicator: /*indicator*/ ctx[3],
    				value: [
    					/*data*/ ctx[0].column1.factCurrYearPercent,
    					/*data*/ ctx[0].column1.budgetPercent
    				],
    				comparison: [
    					/*data*/ ctx[0].column1.factPrevYearPrecent,
    					/*data*/ ctx[0].column1.budgetPrevYearPercent.qNum
    				],
    				baseRatios: [/*baseRatios*/ ctx[1][0], /*baseRatios*/ ctx[1][1]],
    				minRatios: [/*minRatios*/ ctx[2][0], /*minRatios*/ ctx[2][1]],
    				bridges: [
    					/*data*/ ctx[0].column1.bridgeResultPrevYearPercent,
    					/*data*/ ctx[0].column1.bridgeResultBudgetPercent
    				],
    				diagrams: [
    					[
    						/*data*/ ctx[0].column1.factCurrYearPercent.qNum,
    						/*data*/ ctx[0].column1.factPrevYearPrecent.qNum
    					],
    					[
    						/*data*/ ctx[0].column1.budgetPrevYearPercent.qNum,
    						/*data*/ ctx[0].column1.budgetPercent.qNum
    					]
    				]
    			},
    			$$inline: true
    		});

    	factorscomparisoncell1 = new FactorsComparisonCell({
    			props: {
    				indicator: /*indicator*/ ctx[3],
    				value: [
    					/*data*/ ctx[0].column2.factCurrYearPercent,
    					/*data*/ ctx[0].column2.budgetPercent
    				],
    				comparison: [
    					/*data*/ ctx[0].column2.factPrevYearPrecent,
    					/*data*/ ctx[0].column2.budgetPrevYearPercent.qNum
    				],
    				baseRatios: [/*baseRatios*/ ctx[1][2], /*baseRatios*/ ctx[1][3]],
    				minRatios: [/*minRatios*/ ctx[2][2], /*minRatios*/ ctx[2][3]],
    				bridges: [
    					/*data*/ ctx[0].column2.bridgeResultPrevYearPercent,
    					/*data*/ ctx[0].column2.bridgeResultBudgetPercent
    				],
    				diagrams: [
    					[
    						/*data*/ ctx[0].column2.factCurrYearPercent.qNum,
    						/*data*/ ctx[0].column2.factPrevYearPrecent.qNum
    					],
    					[
    						/*data*/ ctx[0].column2.budgetPrevYearPercent.qNum,
    						/*data*/ ctx[0].column2.budgetPercent.qNum
    					]
    				]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorscomparisoncell0.$$.fragment);
    			t = space();
    			create_component(factorscomparisoncell1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorscomparisoncell0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(factorscomparisoncell1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorscomparisoncell0_changes = {};
    			if (dirty & /*indicator*/ 8) factorscomparisoncell0_changes.indicator = /*indicator*/ ctx[3];

    			if (dirty & /*data*/ 1) factorscomparisoncell0_changes.value = [
    				/*data*/ ctx[0].column1.factCurrYearPercent,
    				/*data*/ ctx[0].column1.budgetPercent
    			];

    			if (dirty & /*data*/ 1) factorscomparisoncell0_changes.comparison = [
    				/*data*/ ctx[0].column1.factPrevYearPrecent,
    				/*data*/ ctx[0].column1.budgetPrevYearPercent.qNum
    			];

    			if (dirty & /*baseRatios*/ 2) factorscomparisoncell0_changes.baseRatios = [/*baseRatios*/ ctx[1][0], /*baseRatios*/ ctx[1][1]];
    			if (dirty & /*minRatios*/ 4) factorscomparisoncell0_changes.minRatios = [/*minRatios*/ ctx[2][0], /*minRatios*/ ctx[2][1]];

    			if (dirty & /*data*/ 1) factorscomparisoncell0_changes.bridges = [
    				/*data*/ ctx[0].column1.bridgeResultPrevYearPercent,
    				/*data*/ ctx[0].column1.bridgeResultBudgetPercent
    			];

    			if (dirty & /*data*/ 1) factorscomparisoncell0_changes.diagrams = [
    				[
    					/*data*/ ctx[0].column1.factCurrYearPercent.qNum,
    					/*data*/ ctx[0].column1.factPrevYearPrecent.qNum
    				],
    				[
    					/*data*/ ctx[0].column1.budgetPrevYearPercent.qNum,
    					/*data*/ ctx[0].column1.budgetPercent.qNum
    				]
    			];

    			factorscomparisoncell0.$set(factorscomparisoncell0_changes);
    			const factorscomparisoncell1_changes = {};
    			if (dirty & /*indicator*/ 8) factorscomparisoncell1_changes.indicator = /*indicator*/ ctx[3];

    			if (dirty & /*data*/ 1) factorscomparisoncell1_changes.value = [
    				/*data*/ ctx[0].column2.factCurrYearPercent,
    				/*data*/ ctx[0].column2.budgetPercent
    			];

    			if (dirty & /*data*/ 1) factorscomparisoncell1_changes.comparison = [
    				/*data*/ ctx[0].column2.factPrevYearPrecent,
    				/*data*/ ctx[0].column2.budgetPrevYearPercent.qNum
    			];

    			if (dirty & /*baseRatios*/ 2) factorscomparisoncell1_changes.baseRatios = [/*baseRatios*/ ctx[1][2], /*baseRatios*/ ctx[1][3]];
    			if (dirty & /*minRatios*/ 4) factorscomparisoncell1_changes.minRatios = [/*minRatios*/ ctx[2][2], /*minRatios*/ ctx[2][3]];

    			if (dirty & /*data*/ 1) factorscomparisoncell1_changes.bridges = [
    				/*data*/ ctx[0].column2.bridgeResultPrevYearPercent,
    				/*data*/ ctx[0].column2.bridgeResultBudgetPercent
    			];

    			if (dirty & /*data*/ 1) factorscomparisoncell1_changes.diagrams = [
    				[
    					/*data*/ ctx[0].column2.factCurrYearPercent.qNum,
    					/*data*/ ctx[0].column2.factPrevYearPrecent.qNum
    				],
    				[
    					/*data*/ ctx[0].column2.budgetPrevYearPercent.qNum,
    					/*data*/ ctx[0].column2.budgetPercent.qNum
    				]
    			];

    			factorscomparisoncell1.$set(factorscomparisoncell1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorscomparisoncell0.$$.fragment, local);
    			transition_in(factorscomparisoncell1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorscomparisoncell0.$$.fragment, local);
    			transition_out(factorscomparisoncell1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorscomparisoncell0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(factorscomparisoncell1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(28:4) {#if data}",
    		ctx
    	});

    	return block;
    }

    // (25:0) <FactorsTotalRow>
    function create_default_slot$i(ctx) {
    	let factorstotallabel;
    	let t;
    	let if_block_anchor;
    	let current;

    	factorstotallabel = new FactorsTotalLabel({
    			props: { label: /*label*/ ctx[4] },
    			$$inline: true
    		});

    	let if_block = /*data*/ ctx[0] && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			create_component(factorstotallabel.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorstotallabel, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorstotallabel_changes = {};
    			if (dirty & /*label*/ 16) factorstotallabel_changes.label = /*label*/ ctx[4];
    			factorstotallabel.$set(factorstotallabel_changes);

    			if (/*data*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*data*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorstotallabel.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorstotallabel.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorstotallabel, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(25:0) <FactorsTotalRow>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$10(ctx) {
    	let factorstotalrow;
    	let current;

    	factorstotalrow = new FactorsTotalRow({
    			props: {
    				$$slots: { default: [create_default_slot$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorstotalrow.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorstotalrow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const factorstotalrow_changes = {};

    			if (dirty & /*$$scope, indicator, data, baseRatios, minRatios, label*/ 1055) {
    				factorstotalrow_changes.$$scope = { dirty, ctx };
    			}

    			factorstotalrow.$set(factorstotalrow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorstotalrow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorstotalrow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorstotalrow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let $date;
    	let $locale;
    	let { data } = $$props;
    	let { baseRatios } = $$props;
    	let { minRatios } = $$props;
    	let { indicator } = $$props;
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(7, $date = value));
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(8, $locale = value));

    	function renderLabel() {
    		const year = new Date($date).getFullYear();
    		return `${translate("Факт", $locale)} ${year}`;
    	}

    	const writable_props = ["data", "baseRatios", "minRatios", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsComparison> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsComparison", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("baseRatios" in $$props) $$invalidate(1, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(2, minRatios = $$props.minRatios);
    		if ("indicator" in $$props) $$invalidate(3, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		FactorsTotalRow,
    		FactorsTotalLabel,
    		FactorsComparisonCell,
    		translate,
    		getUIState,
    		data,
    		baseRatios,
    		minRatios,
    		indicator,
    		date,
    		locale,
    		renderLabel,
    		label,
    		$date,
    		$locale
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("baseRatios" in $$props) $$invalidate(1, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(2, minRatios = $$props.minRatios);
    		if ("indicator" in $$props) $$invalidate(3, indicator = $$props.indicator);
    		if ("label" in $$props) $$invalidate(4, label = $$props.label);
    	};

    	let label;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$date, $locale*/ 384) {
    			 $$invalidate(4, label = renderLabel());
    		}
    	};

    	return [data, baseRatios, minRatios, indicator, label, date, locale];
    }

    class FactorsComparison extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$10, create_fragment$10, safe_not_equal, {
    			data: 0,
    			baseRatios: 1,
    			minRatios: 2,
    			indicator: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsComparison",
    			options,
    			id: create_fragment$10.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<FactorsComparison> was created without expected prop 'data'");
    		}

    		if (/*baseRatios*/ ctx[1] === undefined && !("baseRatios" in props)) {
    			console.warn("<FactorsComparison> was created without expected prop 'baseRatios'");
    		}

    		if (/*minRatios*/ ctx[2] === undefined && !("minRatios" in props)) {
    			console.warn("<FactorsComparison> was created without expected prop 'minRatios'");
    		}

    		if (/*indicator*/ ctx[3] === undefined && !("indicator" in props)) {
    			console.warn("<FactorsComparison> was created without expected prop 'indicator'");
    		}
    	}

    	get data() {
    		throw new Error("<FactorsComparison>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<FactorsComparison>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseRatios() {
    		throw new Error("<FactorsComparison>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseRatios(value) {
    		throw new Error("<FactorsComparison>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minRatios() {
    		throw new Error("<FactorsComparison>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minRatios(value) {
    		throw new Error("<FactorsComparison>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<FactorsComparison>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<FactorsComparison>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factors/FactorsSectionFooter.svelte generated by Svelte v3.24.0 */
    const file$Q = "src/js/components/factors/FactorsSectionFooter.svelte";

    function create_fragment$11(ctx) {
    	let div;
    	let factorscomparison;
    	let current;

    	factorscomparison = new FactorsComparison({
    			props: {
    				data: /*data*/ ctx[0],
    				baseRatios: /*baseRatios*/ ctx[1],
    				minRatios: /*minRatios*/ ctx[2],
    				indicator: /*indicator*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(factorscomparison.$$.fragment);
    			attr_dev(div, "class", "txcm-factorsSectionFooter");
    			add_location(div, file$Q, 20, 0, 431);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(factorscomparison, div, null);
    			/*div_binding*/ ctx[6](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const factorscomparison_changes = {};
    			if (dirty & /*data*/ 1) factorscomparison_changes.data = /*data*/ ctx[0];
    			if (dirty & /*baseRatios*/ 2) factorscomparison_changes.baseRatios = /*baseRatios*/ ctx[1];
    			if (dirty & /*minRatios*/ 4) factorscomparison_changes.minRatios = /*minRatios*/ ctx[2];
    			if (dirty & /*indicator*/ 8) factorscomparison_changes.indicator = /*indicator*/ ctx[3];
    			factorscomparison.$set(factorscomparison_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorscomparison.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorscomparison.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(factorscomparison);
    			/*div_binding*/ ctx[6](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let $sectionScrollX;
    	let { data } = $$props;
    	let { baseRatios } = $$props;
    	let { minRatios } = $$props;
    	let { indicator } = $$props;
    	const sectionScrollX = getUIState("sectionScrollX");
    	validate_store(sectionScrollX, "sectionScrollX");
    	component_subscribe($$self, sectionScrollX, value => $$invalidate(7, $sectionScrollX = value));
    	let node;

    	function updateScroll() {
    		if (node) $$invalidate(4, node.scrollLeft = $sectionScrollX, node);
    	}

    	const writable_props = ["data", "baseRatios", "minRatios", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsSectionFooter> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsSectionFooter", $$slots, []);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			node = $$value;
    			$$invalidate(4, node);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("baseRatios" in $$props) $$invalidate(1, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(2, minRatios = $$props.minRatios);
    		if ("indicator" in $$props) $$invalidate(3, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getUIState,
    		FactorsComparison,
    		data,
    		baseRatios,
    		minRatios,
    		indicator,
    		sectionScrollX,
    		node,
    		updateScroll,
    		$sectionScrollX
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("baseRatios" in $$props) $$invalidate(1, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(2, minRatios = $$props.minRatios);
    		if ("indicator" in $$props) $$invalidate(3, indicator = $$props.indicator);
    		if ("node" in $$props) $$invalidate(4, node = $$props.node);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$sectionScrollX*/ 128) {
    			 updateScroll();
    		}
    	};

    	return [data, baseRatios, minRatios, indicator, node, sectionScrollX, div_binding];
    }

    class FactorsSectionFooter extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$11, create_fragment$11, safe_not_equal, {
    			data: 0,
    			baseRatios: 1,
    			minRatios: 2,
    			indicator: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsSectionFooter",
    			options,
    			id: create_fragment$11.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<FactorsSectionFooter> was created without expected prop 'data'");
    		}

    		if (/*baseRatios*/ ctx[1] === undefined && !("baseRatios" in props)) {
    			console.warn("<FactorsSectionFooter> was created without expected prop 'baseRatios'");
    		}

    		if (/*minRatios*/ ctx[2] === undefined && !("minRatios" in props)) {
    			console.warn("<FactorsSectionFooter> was created without expected prop 'minRatios'");
    		}

    		if (/*indicator*/ ctx[3] === undefined && !("indicator" in props)) {
    			console.warn("<FactorsSectionFooter> was created without expected prop 'indicator'");
    		}
    	}

    	get data() {
    		throw new Error("<FactorsSectionFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<FactorsSectionFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseRatios() {
    		throw new Error("<FactorsSectionFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseRatios(value) {
    		throw new Error("<FactorsSectionFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minRatios() {
    		throw new Error("<FactorsSectionFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minRatios(value) {
    		throw new Error("<FactorsSectionFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<FactorsSectionFooter>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<FactorsSectionFooter>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factor/FactorColumn.svelte generated by Svelte v3.24.0 */

    const file$R = "src/js/components/factor/FactorColumn.svelte";

    function create_fragment$12(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "txcm-factorColumn");
    			add_location(div, file$R, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorColumn> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorColumn", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, $$slots];
    }

    class FactorColumn extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$12, create_fragment$12, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorColumn",
    			options,
    			id: create_fragment$12.name
    		});
    	}
    }

    /* src/js/components/factor/FactorDiagram.svelte generated by Svelte v3.24.0 */
    const file$S = "src/js/components/factor/FactorDiagram.svelte";

    // (16:4) {#if data}
    function create_if_block$d(ctx) {
    	let svg;
    	let rect;
    	let rect_class_value;
    	let rect_x_value;
    	let rect_width_value;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			rect = svg_element("rect");
    			attr_dev(rect, "class", rect_class_value = `txcm-factorDiagramRectBase${/*renderDynamicsClass*/ ctx[2](/*data*/ ctx[0])}`);
    			attr_dev(rect, "x", rect_x_value = `${(/*graph*/ ctx[1].min + /*graph*/ ctx[1].shift) * 100}%`);
    			attr_dev(rect, "y", "0.5");
    			attr_dev(rect, "width", rect_width_value = `${/*graph*/ ctx[1].width * 100}%`);
    			attr_dev(rect, "height", "19px");
    			attr_dev(rect, "rx", "3");
    			attr_dev(rect, "ry", "3");
    			attr_dev(rect, "transform", "translate(0.5 0)");
    			add_location(rect, file$S, 20, 10, 440);
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", "20");
    			attr_dev(svg, "class", "txcm-factorDiagramSVG");
    			add_location(svg, file$S, 16, 6, 345);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, rect);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && rect_class_value !== (rect_class_value = `txcm-factorDiagramRectBase${/*renderDynamicsClass*/ ctx[2](/*data*/ ctx[0])}`)) {
    				attr_dev(rect, "class", rect_class_value);
    			}

    			if (dirty & /*graph*/ 2 && rect_x_value !== (rect_x_value = `${(/*graph*/ ctx[1].min + /*graph*/ ctx[1].shift) * 100}%`)) {
    				attr_dev(rect, "x", rect_x_value);
    			}

    			if (dirty & /*graph*/ 2 && rect_width_value !== (rect_width_value = `${/*graph*/ ctx[1].width * 100}%`)) {
    				attr_dev(rect, "width", rect_width_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(16:4) {#if data}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$13(ctx) {
    	let div;
    	let if_block = /*data*/ ctx[0] && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "txcm-factorDiagram");
    			add_location(div, file$S, 13, 0, 289);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*data*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$13($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { graph } = $$props;

    	function renderDynamicsClass() {
    		const dynamics = checkDynamics(data);
    		if (dynamics === -2) return " txcm-factorDiagramRectBase-is-decreasing";
    		return "";
    	}

    	const writable_props = ["data", "graph"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorDiagram> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorDiagram", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("graph" in $$props) $$invalidate(1, graph = $$props.graph);
    	};

    	$$self.$capture_state = () => ({
    		checkDynamics,
    		data,
    		graph,
    		renderDynamicsClass
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("graph" in $$props) $$invalidate(1, graph = $$props.graph);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [data, graph, renderDynamicsClass];
    }

    class FactorDiagram extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$13, create_fragment$13, safe_not_equal, { data: 0, graph: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorDiagram",
    			options,
    			id: create_fragment$13.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<FactorDiagram> was created without expected prop 'data'");
    		}

    		if (/*graph*/ ctx[1] === undefined && !("graph" in props)) {
    			console.warn("<FactorDiagram> was created without expected prop 'graph'");
    		}
    	}

    	get data() {
    		throw new Error("<FactorDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<FactorDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get graph() {
    		throw new Error("<FactorDiagram>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set graph(value) {
    		throw new Error("<FactorDiagram>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factor/FactorValue.svelte generated by Svelte v3.24.0 */

    const file$T = "src/js/components/factor/FactorValue.svelte";

    function create_fragment$14(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*data*/ ctx[0]);
    			attr_dev(div, "class", "txcm-factorValue");
    			add_location(div, file$T, 4, 0, 39);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*data*/ 1) set_data_dev(t, /*data*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorValue> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorValue", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({ data });

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [data];
    }

    class FactorValue extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$14, safe_not_equal, { data: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorValue",
    			options,
    			id: create_fragment$14.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<FactorValue> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<FactorValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<FactorValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factor/FactorCell.svelte generated by Svelte v3.24.0 */
    const file$U = "src/js/components/factor/FactorCell.svelte";

    // (16:2) <FactorColumn>
    function create_default_slot_1$3(ctx) {
    	let factorvalue;
    	let t;
    	let factordiagram;
    	let current;

    	factorvalue = new FactorValue({
    			props: {
    				data: formatLabel(/*data*/ ctx[0].vsFactPercent.qNum, /*data*/ ctx[0].vsFactPercent.units)
    			},
    			$$inline: true
    		});

    	factordiagram = new FactorDiagram({
    			props: {
    				graph: /*graph*/ ctx[1].vsFactPercent,
    				data: /*data*/ ctx[0].vsFactPercent.qNum
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorvalue.$$.fragment);
    			t = space();
    			create_component(factordiagram.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorvalue, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(factordiagram, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorvalue_changes = {};
    			if (dirty & /*data*/ 1) factorvalue_changes.data = formatLabel(/*data*/ ctx[0].vsFactPercent.qNum, /*data*/ ctx[0].vsFactPercent.units);
    			factorvalue.$set(factorvalue_changes);
    			const factordiagram_changes = {};
    			if (dirty & /*graph*/ 2) factordiagram_changes.graph = /*graph*/ ctx[1].vsFactPercent;
    			if (dirty & /*data*/ 1) factordiagram_changes.data = /*data*/ ctx[0].vsFactPercent.qNum;
    			factordiagram.$set(factordiagram_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorvalue.$$.fragment, local);
    			transition_in(factordiagram.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorvalue.$$.fragment, local);
    			transition_out(factordiagram.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorvalue, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(factordiagram, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(16:2) <FactorColumn>",
    		ctx
    	});

    	return block;
    }

    // (23:4) {#if indicator.id === '20'}
    function create_if_block$e(ctx) {
    	let factorcolumn;
    	let current;

    	factorcolumn = new FactorColumn({
    			props: {
    				$$slots: { default: [create_default_slot$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorcolumn.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorcolumn, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorcolumn_changes = {};

    			if (dirty & /*$$scope, graph, data*/ 11) {
    				factorcolumn_changes.$$scope = { dirty, ctx };
    			}

    			factorcolumn.$set(factorcolumn_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorcolumn.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorcolumn.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorcolumn, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(23:4) {#if indicator.id === '20'}",
    		ctx
    	});

    	return block;
    }

    // (24:6) <FactorColumn>
    function create_default_slot$j(ctx) {
    	let factorvalue;
    	let t;
    	let factordiagram;
    	let current;

    	factorvalue = new FactorValue({
    			props: {
    				data: formatLabel(/*data*/ ctx[0].vsBudgetPercent.qNum, /*data*/ ctx[0].vsBudgetPercent.units)
    			},
    			$$inline: true
    		});

    	factordiagram = new FactorDiagram({
    			props: {
    				graph: /*graph*/ ctx[1].vsBudgetPercent,
    				data: /*data*/ ctx[0].vsBudgetPercent.qNum
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorvalue.$$.fragment);
    			t = space();
    			create_component(factordiagram.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorvalue, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(factordiagram, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorvalue_changes = {};
    			if (dirty & /*data*/ 1) factorvalue_changes.data = formatLabel(/*data*/ ctx[0].vsBudgetPercent.qNum, /*data*/ ctx[0].vsBudgetPercent.units);
    			factorvalue.$set(factorvalue_changes);
    			const factordiagram_changes = {};
    			if (dirty & /*graph*/ 2) factordiagram_changes.graph = /*graph*/ ctx[1].vsBudgetPercent;
    			if (dirty & /*data*/ 1) factordiagram_changes.data = /*data*/ ctx[0].vsBudgetPercent.qNum;
    			factordiagram.$set(factordiagram_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorvalue.$$.fragment, local);
    			transition_in(factordiagram.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorvalue.$$.fragment, local);
    			transition_out(factordiagram.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorvalue, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(factordiagram, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(24:6) <FactorColumn>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$15(ctx) {
    	let div;
    	let factorcolumn;
    	let t;
    	let current;

    	factorcolumn = new FactorColumn({
    			props: {
    				$$slots: { default: [create_default_slot_1$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*indicator*/ ctx[2].id === "20" && create_if_block$e(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(factorcolumn.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "txcm-factorCell");
    			add_location(div, file$U, 13, 0, 346);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(factorcolumn, div, null);
    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const factorcolumn_changes = {};

    			if (dirty & /*$$scope, graph, data*/ 11) {
    				factorcolumn_changes.$$scope = { dirty, ctx };
    			}

    			factorcolumn.$set(factorcolumn_changes);

    			if (/*indicator*/ ctx[2].id === "20") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*indicator*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$e(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorcolumn.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorcolumn.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(factorcolumn);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { graph } = $$props;
    	let { indicator } = $$props;
    	const writable_props = ["data", "graph", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorCell> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorCell", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("graph" in $$props) $$invalidate(1, graph = $$props.graph);
    		if ("indicator" in $$props) $$invalidate(2, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		FactorColumn,
    		FactorDiagram,
    		FactorValue,
    		formatLabel,
    		data,
    		graph,
    		indicator
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("graph" in $$props) $$invalidate(1, graph = $$props.graph);
    		if ("indicator" in $$props) $$invalidate(2, indicator = $$props.indicator);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [data, graph, indicator];
    }

    class FactorCell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$15, create_fragment$15, safe_not_equal, { data: 0, graph: 1, indicator: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorCell",
    			options,
    			id: create_fragment$15.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<FactorCell> was created without expected prop 'data'");
    		}

    		if (/*graph*/ ctx[1] === undefined && !("graph" in props)) {
    			console.warn("<FactorCell> was created without expected prop 'graph'");
    		}

    		if (/*indicator*/ ctx[2] === undefined && !("indicator" in props)) {
    			console.warn("<FactorCell> was created without expected prop 'indicator'");
    		}
    	}

    	get data() {
    		throw new Error("<FactorCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<FactorCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get graph() {
    		throw new Error("<FactorCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set graph(value) {
    		throw new Error("<FactorCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<FactorCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<FactorCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factor/FactorLabel.svelte generated by Svelte v3.24.0 */
    const file$V = "src/js/components/factor/FactorLabel.svelte";

    function create_fragment$16(ctx) {
    	let div;
    	let int;
    	let current;

    	int = new Int({
    			props: { key: /*label*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(int.$$.fragment);
    			attr_dev(div, "class", "txcm-factorLabel");
    			add_location(div, file$V, 6, 0, 110);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(int, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const int_changes = {};
    			if (dirty & /*label*/ 1) int_changes.key = /*label*/ ctx[0];
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	const writable_props = ["label"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorLabel> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorLabel", $$slots, []);

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    	};

    	$$self.$capture_state = () => ({ Int, label });

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [label];
    }

    class FactorLabel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$16, safe_not_equal, { label: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorLabel",
    			options,
    			id: create_fragment$16.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[0] === undefined && !("label" in props)) {
    			console.warn("<FactorLabel> was created without expected prop 'label'");
    		}
    	}

    	get label() {
    		throw new Error("<FactorLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<FactorLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factor/FactorRow.svelte generated by Svelte v3.24.0 */

    const file$W = "src/js/components/factor/FactorRow.svelte";

    function create_fragment$17(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "txcm-factorRow");
    			add_location(div, file$W, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$17($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorRow> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorRow", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, $$slots];
    }

    class FactorRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$17, create_fragment$17, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorRow",
    			options,
    			id: create_fragment$17.name
    		});
    	}
    }

    /* src/js/components/factors/FactorsBridge.svelte generated by Svelte v3.24.0 */

    // (13:0) <FactorRow>
    function create_default_slot$k(ctx) {
    	let factorlabel;
    	let t0;
    	let factorcell0;
    	let t1;
    	let factorcell1;
    	let current;

    	factorlabel = new FactorLabel({
    			props: { label: /*bridge*/ ctx[0].name },
    			$$inline: true
    		});

    	factorcell0 = new FactorCell({
    			props: {
    				graph: /*graph*/ ctx[1].column1,
    				data: /*bridge*/ ctx[0].column1,
    				indicator: /*indicator*/ ctx[2]
    			},
    			$$inline: true
    		});

    	factorcell1 = new FactorCell({
    			props: {
    				graph: /*graph*/ ctx[1].column2,
    				data: /*bridge*/ ctx[0].column2,
    				indicator: /*indicator*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorlabel.$$.fragment);
    			t0 = space();
    			create_component(factorcell0.$$.fragment);
    			t1 = space();
    			create_component(factorcell1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorlabel, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(factorcell0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(factorcell1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorlabel_changes = {};
    			if (dirty & /*bridge*/ 1) factorlabel_changes.label = /*bridge*/ ctx[0].name;
    			factorlabel.$set(factorlabel_changes);
    			const factorcell0_changes = {};
    			if (dirty & /*graph*/ 2) factorcell0_changes.graph = /*graph*/ ctx[1].column1;
    			if (dirty & /*bridge*/ 1) factorcell0_changes.data = /*bridge*/ ctx[0].column1;
    			if (dirty & /*indicator*/ 4) factorcell0_changes.indicator = /*indicator*/ ctx[2];
    			factorcell0.$set(factorcell0_changes);
    			const factorcell1_changes = {};
    			if (dirty & /*graph*/ 2) factorcell1_changes.graph = /*graph*/ ctx[1].column2;
    			if (dirty & /*bridge*/ 1) factorcell1_changes.data = /*bridge*/ ctx[0].column2;
    			if (dirty & /*indicator*/ 4) factorcell1_changes.indicator = /*indicator*/ ctx[2];
    			factorcell1.$set(factorcell1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorlabel.$$.fragment, local);
    			transition_in(factorcell0.$$.fragment, local);
    			transition_in(factorcell1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorlabel.$$.fragment, local);
    			transition_out(factorcell0.$$.fragment, local);
    			transition_out(factorcell1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorlabel, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(factorcell0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(factorcell1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(13:0) <FactorRow>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$18(ctx) {
    	let factorrow;
    	let current;

    	factorrow = new FactorRow({
    			props: {
    				$$slots: { default: [create_default_slot$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorrow.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorrow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const factorrow_changes = {};

    			if (dirty & /*$$scope, graph, bridge, indicator*/ 15) {
    				factorrow_changes.$$scope = { dirty, ctx };
    			}

    			factorrow.$set(factorrow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorrow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorrow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorrow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$18($$self, $$props, $$invalidate) {
    	let { bridge } = $$props;
    	let { graph } = $$props;
    	let { indicator } = $$props;
    	const writable_props = ["bridge", "graph", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsBridge> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsBridge", $$slots, []);

    	$$self.$set = $$props => {
    		if ("bridge" in $$props) $$invalidate(0, bridge = $$props.bridge);
    		if ("graph" in $$props) $$invalidate(1, graph = $$props.graph);
    		if ("indicator" in $$props) $$invalidate(2, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		FactorCell,
    		FactorLabel,
    		FactorRow,
    		bridge,
    		graph,
    		indicator
    	});

    	$$self.$inject_state = $$props => {
    		if ("bridge" in $$props) $$invalidate(0, bridge = $$props.bridge);
    		if ("graph" in $$props) $$invalidate(1, graph = $$props.graph);
    		if ("indicator" in $$props) $$invalidate(2, indicator = $$props.indicator);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [bridge, graph, indicator];
    }

    class FactorsBridge extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$18, safe_not_equal, { bridge: 0, graph: 1, indicator: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsBridge",
    			options,
    			id: create_fragment$18.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*bridge*/ ctx[0] === undefined && !("bridge" in props)) {
    			console.warn("<FactorsBridge> was created without expected prop 'bridge'");
    		}

    		if (/*graph*/ ctx[1] === undefined && !("graph" in props)) {
    			console.warn("<FactorsBridge> was created without expected prop 'graph'");
    		}

    		if (/*indicator*/ ctx[2] === undefined && !("indicator" in props)) {
    			console.warn("<FactorsBridge> was created without expected prop 'indicator'");
    		}
    	}

    	get bridge() {
    		throw new Error("<FactorsBridge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bridge(value) {
    		throw new Error("<FactorsBridge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get graph() {
    		throw new Error("<FactorsBridge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set graph(value) {
    		throw new Error("<FactorsBridge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<FactorsBridge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<FactorsBridge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factors/FactorsBridges.svelte generated by Svelte v3.24.0 */
    const file$X = "src/js/components/factors/FactorsBridges.svelte";

    function get_each_context$h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (78:0) {#if bridges}
    function create_if_block$f(ctx) {
    	let div;
    	let sectionScroll_action;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*bridges*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-factorsRows");
    			add_location(div, file$X, 78, 2, 2828);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(sectionScroll_action = sectionScroll.call(null, div, true));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bridges, indicator, graphs*/ 7) {
    				each_value = /*bridges*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$h(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$h(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(78:0) {#if bridges}",
    		ctx
    	});

    	return block;
    }

    // (82:6) {#each bridges as bridge, index}
    function create_each_block$h(ctx) {
    	let factorsbridge;
    	let current;

    	factorsbridge = new FactorsBridge({
    			props: {
    				bridge: /*bridge*/ ctx[8],
    				indicator: /*indicator*/ ctx[1],
    				graph: /*graphs*/ ctx[2][/*index*/ ctx[10]]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorsbridge.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorsbridge, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorsbridge_changes = {};
    			if (dirty & /*bridges*/ 1) factorsbridge_changes.bridge = /*bridge*/ ctx[8];
    			if (dirty & /*indicator*/ 2) factorsbridge_changes.indicator = /*indicator*/ ctx[1];
    			if (dirty & /*graphs*/ 4) factorsbridge_changes.graph = /*graphs*/ ctx[2][/*index*/ ctx[10]];
    			factorsbridge.$set(factorsbridge_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorsbridge.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorsbridge.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorsbridge, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$h.name,
    		type: "each",
    		source: "(82:6) {#each bridges as bridge, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$19(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*bridges*/ ctx[0] && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*bridges*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*bridges*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function calulateGraphShift(current, previous, currentRatio, previousRatio, previousShift) {
    	if (previous < 0 && current < 0) return previousShift - currentRatio;
    	if (previous >= 0 && current >= 0) return previousShift + previousRatio;
    	if (previous < 0 && current >= 0) return previousShift;
    	if (previous >= 0 && current < 0) return previousShift + previousRatio - currentRatio;
    	return 0;
    }

    function calculateGraphValue(current, previous, baseRatio, minRatio) {
    	const currentNum = !isNaN(current.qNum) ? current.qNum : 0;
    	const previousNum = !isNaN(previous.qNum) ? previous.qNum : 0;
    	const currentRatio = Math.abs(currentNum * baseRatio);
    	const previousRatio = Math.abs(previousNum * baseRatio);
    	const previousShift = previous.shift ? previous.shift : 0;
    	let shift = calulateGraphShift(currentNum, previousNum, currentRatio, previousRatio, previousShift);

    	return {
    		...current,
    		width: currentRatio,
    		shift,
    		min: minRatio,
    		baseRatio,
    		currentNum,
    		previousNum
    	};
    }

    function instance$19($$self, $$props, $$invalidate) {
    	let { results } = $$props;
    	let { bridges } = $$props;
    	let { baseRatios } = $$props;
    	let { minRatios } = $$props;
    	let { indicator } = $$props;

    	function calculateGraphRow(data, row, index) {
    		const prevColumn1VSFactPercent = index !== 0
    		? data[index - 1].column1.vsFactPercent
    		: results.column1.factPrevYearPrecent;

    		const prevColumn1VSBudgetPercent = index !== 0
    		? data[index - 1].column1.vsBudgetPercent
    		: results.column1.budgetPercent;

    		const prevColumn2VSFactPercent = index !== 0
    		? data[index - 1].column2.vsFactPercent
    		: results.column2.factPrevYearPrecent;

    		const prevColumn2VSBudgetPercent = index !== 0
    		? data[index - 1].column2.vsBudgetPercent
    		: results.column2.budgetPercent;

    		data.push({
    			column1: {
    				vsFactPercent: calculateGraphValue(row.column1.vsFactPercent, prevColumn1VSFactPercent, baseRatios[0], minRatios[0]),
    				vsBudgetPercent: calculateGraphValue(row.column1.vsBudgetPercent, prevColumn1VSBudgetPercent, baseRatios[1], minRatios[1])
    			},
    			column2: {
    				vsFactPercent: calculateGraphValue(row.column2.vsFactPercent, prevColumn2VSFactPercent, baseRatios[2], minRatios[2]),
    				vsBudgetPercent: calculateGraphValue(row.column2.vsBudgetPercent, prevColumn2VSBudgetPercent, baseRatios[3], minRatios[3])
    			}
    		});

    		return data;
    	}

    	function calculateGraphs() {
    		const data = bridges.reduce(calculateGraphRow, []);
    		return data;
    	}

    	const writable_props = ["results", "bridges", "baseRatios", "minRatios", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsBridges> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsBridges", $$slots, []);

    	$$self.$set = $$props => {
    		if ("results" in $$props) $$invalidate(3, results = $$props.results);
    		if ("bridges" in $$props) $$invalidate(0, bridges = $$props.bridges);
    		if ("baseRatios" in $$props) $$invalidate(4, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(5, minRatios = $$props.minRatios);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		sectionScroll,
    		FactorsBridge,
    		results,
    		bridges,
    		baseRatios,
    		minRatios,
    		indicator,
    		calulateGraphShift,
    		calculateGraphValue,
    		calculateGraphRow,
    		calculateGraphs,
    		graphs
    	});

    	$$self.$inject_state = $$props => {
    		if ("results" in $$props) $$invalidate(3, results = $$props.results);
    		if ("bridges" in $$props) $$invalidate(0, bridges = $$props.bridges);
    		if ("baseRatios" in $$props) $$invalidate(4, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(5, minRatios = $$props.minRatios);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("graphs" in $$props) $$invalidate(2, graphs = $$props.graphs);
    	};

    	let graphs;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*results, bridges, baseRatios, minRatios*/ 57) {
    			 $$invalidate(2, graphs = calculateGraphs());
    		}
    	};

    	return [bridges, indicator, graphs, results, baseRatios, minRatios];
    }

    class FactorsBridges extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$19, create_fragment$19, safe_not_equal, {
    			results: 3,
    			bridges: 0,
    			baseRatios: 4,
    			minRatios: 5,
    			indicator: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsBridges",
    			options,
    			id: create_fragment$19.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*results*/ ctx[3] === undefined && !("results" in props)) {
    			console.warn("<FactorsBridges> was created without expected prop 'results'");
    		}

    		if (/*bridges*/ ctx[0] === undefined && !("bridges" in props)) {
    			console.warn("<FactorsBridges> was created without expected prop 'bridges'");
    		}

    		if (/*baseRatios*/ ctx[4] === undefined && !("baseRatios" in props)) {
    			console.warn("<FactorsBridges> was created without expected prop 'baseRatios'");
    		}

    		if (/*minRatios*/ ctx[5] === undefined && !("minRatios" in props)) {
    			console.warn("<FactorsBridges> was created without expected prop 'minRatios'");
    		}

    		if (/*indicator*/ ctx[1] === undefined && !("indicator" in props)) {
    			console.warn("<FactorsBridges> was created without expected prop 'indicator'");
    		}
    	}

    	get results() {
    		throw new Error("<FactorsBridges>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set results(value) {
    		throw new Error("<FactorsBridges>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get bridges() {
    		throw new Error("<FactorsBridges>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set bridges(value) {
    		throw new Error("<FactorsBridges>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get baseRatios() {
    		throw new Error("<FactorsBridges>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set baseRatios(value) {
    		throw new Error("<FactorsBridges>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get minRatios() {
    		throw new Error("<FactorsBridges>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set minRatios(value) {
    		throw new Error("<FactorsBridges>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<FactorsBridges>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<FactorsBridges>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/columnOptions/ColumnOption.svelte generated by Svelte v3.24.0 */
    const file$Y = "src/js/components/columnOptions/ColumnOption.svelte";

    function create_fragment$1a(ctx) {
    	let input;
    	let t0;
    	let label_1;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			t0 = space();
    			label_1 = element("label");
    			t1 = text(/*label*/ ctx[1]);
    			attr_dev(input, "class", "txcm-columnOptionInput");
    			attr_dev(input, "type", "radio");
    			attr_dev(input, "id", /*htmlID*/ ctx[3]);
    			input.__value = /*value*/ ctx[2];
    			input.value = input.__value;
    			/*$$binding_groups*/ ctx[5][0].push(input);
    			add_location(input, file$Y, 12, 0, 224);
    			attr_dev(label_1, "class", "txcm-columnOptionControl");
    			attr_dev(label_1, "for", /*htmlID*/ ctx[3]);
    			add_location(label_1, file$Y, 18, 0, 328);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = input.__value === /*selected*/ ctx[0];
    			insert_dev(target, t0, anchor);
    			insert_dev(target, label_1, anchor);
    			append_dev(label_1, t1);

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[4]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*value*/ 4) {
    				prop_dev(input, "__value", /*value*/ ctx[2]);
    				input.value = input.__value;
    			}

    			if (dirty & /*selected*/ 1) {
    				input.checked = input.__value === /*selected*/ ctx[0];
    			}

    			if (dirty & /*label*/ 2) set_data_dev(t1, /*label*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*$$binding_groups*/ ctx[5][0].splice(/*$$binding_groups*/ ctx[5][0].indexOf(input), 1);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(label_1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	let { value } = $$props;
    	let { selected } = $$props;
    	const htmlID = renderID("columnOptionToggle", value);
    	const writable_props = ["label", "value", "selected"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ColumnOption> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ColumnOption", $$slots, []);
    	const $$binding_groups = [[]];

    	function input_change_handler() {
    		selected = this.__value;
    		$$invalidate(0, selected);
    	}

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("value" in $$props) $$invalidate(2, value = $$props.value);
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    	};

    	$$self.$capture_state = () => ({
    		renderID,
    		label,
    		value,
    		selected,
    		htmlID,
    		checked
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("value" in $$props) $$invalidate(2, value = $$props.value);
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    		if ("checked" in $$props) checked = $$props.checked;
    	};

    	let checked;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*selected, value*/ 5) {
    			 checked = selected === value;
    		}
    	};

    	return [selected, label, value, htmlID, input_change_handler, $$binding_groups];
    }

    class ColumnOption extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, { label: 1, value: 2, selected: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ColumnOption",
    			options,
    			id: create_fragment$1a.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[1] === undefined && !("label" in props)) {
    			console.warn("<ColumnOption> was created without expected prop 'label'");
    		}

    		if (/*value*/ ctx[2] === undefined && !("value" in props)) {
    			console.warn("<ColumnOption> was created without expected prop 'value'");
    		}

    		if (/*selected*/ ctx[0] === undefined && !("selected" in props)) {
    			console.warn("<ColumnOption> was created without expected prop 'selected'");
    		}
    	}

    	get label() {
    		throw new Error("<ColumnOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<ColumnOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<ColumnOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<ColumnOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<ColumnOption>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<ColumnOption>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/columnOptions/ColumnOptions.svelte generated by Svelte v3.24.0 */
    const file$Z = "src/js/components/columnOptions/ColumnOptions.svelte";

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	return child_ctx;
    }

    function get_each_context$i(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[20] = list[i];
    	child_ctx[22] = i;
    	return child_ctx;
    }

    // (73:16) {#if indicator.value > $datePrecision || indicator.value == 4}
    function create_if_block$g(ctx) {
    	let columnoption;
    	let updating_selected;
    	let current;

    	function columnoption_selected_binding(value) {
    		/*columnoption_selected_binding*/ ctx[11].call(null, value);
    	}

    	let columnoption_props = {
    		label: /*indicator*/ ctx[23].label,
    		value: /*indicator*/ ctx[23].value
    	};

    	if (/*selected*/ ctx[0] !== void 0) {
    		columnoption_props.selected = /*selected*/ ctx[0];
    	}

    	columnoption = new ColumnOption({
    			props: columnoption_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(columnoption, "selected", columnoption_selected_binding));

    	const block = {
    		c: function create() {
    			create_component(columnoption.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(columnoption, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const columnoption_changes = {};
    			if (dirty & /*filtered*/ 4) columnoption_changes.label = /*indicator*/ ctx[23].label;
    			if (dirty & /*filtered*/ 4) columnoption_changes.value = /*indicator*/ ctx[23].value;

    			if (!updating_selected && dirty & /*selected*/ 1) {
    				updating_selected = true;
    				columnoption_changes.selected = /*selected*/ ctx[0];
    				add_flush_callback(() => updating_selected = false);
    			}

    			columnoption.$set(columnoption_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(columnoption.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(columnoption.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(columnoption, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(73:16) {#if indicator.value > $datePrecision || indicator.value == 4}",
    		ctx
    	});

    	return block;
    }

    // (72:14) {#each group.indicators as indicator (indicator.value)}
    function create_each_block_1$3(key_1, ctx) {
    	let first;
    	let if_block_anchor;
    	let current;
    	let if_block = (/*indicator*/ ctx[23].value > /*$datePrecision*/ ctx[4] || /*indicator*/ ctx[23].value == 4) && create_if_block$g(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*indicator*/ ctx[23].value > /*$datePrecision*/ ctx[4] || /*indicator*/ ctx[23].value == 4) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*filtered, $datePrecision*/ 20) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$g(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(72:14) {#each group.indicators as indicator (indicator.value)}",
    		ctx
    	});

    	return block;
    }

    // (71:12) {#each filtered as group, index}
    function create_each_block$i(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*group*/ ctx[20].indicators;
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*indicator*/ ctx[23].value;
    	validate_each_keys(ctx, each_value_1, get_each_context_1$3, get_key);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$3(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$3(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*filtered, selected, $datePrecision*/ 21) {
    				const each_value_1 = /*group*/ ctx[20].indicators;
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$3, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1$3, each_1_anchor, get_each_context_1$3);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$i.name,
    		type: "each",
    		source: "(71:12) {#each filtered as group, index}",
    		ctx
    	});

    	return block;
    }

    // (64:4) <Dropdown       {isActive}       on:dropdownclose={onDropdownClose}>
    function create_default_slot$l(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*filtered*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$i(get_each_context$i(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-graphDetailOptions");
    			toggle_class(div, "txcm-graphDetailOptions-is-active", /*isActive*/ ctx[1]);
    			add_location(div, file$Z, 66, 8, 1754);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", stop_propagation(/*click_handler*/ ctx[10]), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*filtered, selected, $datePrecision*/ 21) {
    				each_value = /*filtered*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$i(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$i(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*isActive*/ 2) {
    				toggle_class(div, "txcm-graphDetailOptions-is-active", /*isActive*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(64:4) <Dropdown       {isActive}       on:dropdownclose={onDropdownClose}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1b(ctx) {
    	let div;
    	let button;
    	let svg;
    	let use;
    	let t0;
    	let int;
    	let t1;
    	let dropdown;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*label*/ ctx[3] },
    			$$inline: true
    		});

    	dropdown = new Dropdown({
    			props: {
    				isActive: /*isActive*/ ctx[1],
    				$$slots: { default: [create_default_slot$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown.$on("dropdownclose", /*onDropdownClose*/ ctx[8]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t0 = space();
    			create_component(int.$$.fragment);
    			t1 = space();
    			create_component(dropdown.$$.fragment);
    			xlink_attr(use, "xlink:href", "#txspt-icons-fatArrow");
    			add_location(use, file$Z, 57, 12, 1549);
    			attr_dev(svg, "class", "txcm-columnOptionPickerToggleIcon");
    			add_location(svg, file$Z, 55, 8, 1479);
    			attr_dev(button, "class", "txcm-columnOptionPickerToggle");
    			add_location(button, file$Z, 52, 4, 1371);
    			attr_dev(div, "class", "txcm-columnOptionPicker");
    			add_location(div, file$Z, 50, 0, 1327);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			append_dev(button, svg);
    			append_dev(svg, use);
    			append_dev(button, t0);
    			mount_component(int, button, null);
    			append_dev(div, t1);
    			mount_component(dropdown, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", stop_propagation(/*onToggleClick*/ ctx[9]), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const int_changes = {};
    			if (dirty & /*label*/ 8) int_changes.key = /*label*/ ctx[3];
    			int.$set(int_changes);
    			const dropdown_changes = {};
    			if (dirty & /*isActive*/ 2) dropdown_changes.isActive = /*isActive*/ ctx[1];

    			if (dirty & /*$$scope, isActive, filtered, selected, $datePrecision*/ 67108887) {
    				dropdown_changes.$$scope = { dirty, ctx };
    			}

    			dropdown.$set(dropdown_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			transition_in(dropdown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			transition_out(dropdown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    			destroy_component(dropdown);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	let $columnPrecision;
    	let $date;
    	let $datePrecision;
    	const config = getContext("config").getColumnConfig();
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(13, $date = value));
    	const columnPrecision = getDashboardState("columnPrecision");
    	validate_store(columnPrecision, "columnPrecision");
    	component_subscribe($$self, columnPrecision, value => $$invalidate(12, $columnPrecision = value));
    	const datePrecision = getDashboardState("datePrecision");
    	validate_store(datePrecision, "datePrecision");
    	component_subscribe($$self, datePrecision, value => $$invalidate(4, $datePrecision = value));
    	let selected = $columnPrecision;
    	let filter = "";
    	let isActive = false;

    	function updateColumnPrecision() {
    		set_store_value(columnPrecision, $columnPrecision = selected);
    	}

    	function renderLabel() {
    		if ($columnPrecision === 0) return "DTD";
    		if ($columnPrecision === 1) return "WTD";
    		if ($columnPrecision === 2) return "MTD";
    		if ($columnPrecision === 3) return "QTD";
    		return "YTD";
    	}

    	function toggle() {
    		$$invalidate(1, isActive = !isActive);
    	}

    	function hide() {
    		$$invalidate(1, isActive = false);
    	}

    	function onDropdownClose() {
    		hide();
    	}

    	function onToggleClick() {
    		toggle();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ColumnOptions> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ColumnOptions", $$slots, []);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function columnoption_selected_binding(value) {
    		selected = value;
    		$$invalidate(0, selected);
    	}

    	$$self.$capture_state = () => ({
    		getContext,
    		filterIndicatorCategories,
    		getDashboardState,
    		Int,
    		Dropdown,
    		ColumnOption,
    		config,
    		date,
    		columnPrecision,
    		datePrecision,
    		selected,
    		filter,
    		isActive,
    		updateColumnPrecision,
    		renderLabel,
    		toggle,
    		hide,
    		onDropdownClose,
    		onToggleClick,
    		$columnPrecision,
    		filtered,
    		label,
    		$date,
    		$datePrecision
    	});

    	$$self.$inject_state = $$props => {
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    		if ("filter" in $$props) $$invalidate(15, filter = $$props.filter);
    		if ("isActive" in $$props) $$invalidate(1, isActive = $$props.isActive);
    		if ("filtered" in $$props) $$invalidate(2, filtered = $$props.filtered);
    		if ("label" in $$props) $$invalidate(3, label = $$props.label);
    	};

    	let filtered;
    	let label;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*selected*/ 1) {
    			 updateColumnPrecision();
    		}

    		if ($$self.$$.dirty & /*$date, $columnPrecision*/ 12288) {
    			 $$invalidate(3, label = renderLabel());
    		}
    	};

    	 $$invalidate(2, filtered = filterIndicatorCategories(config, filter));

    	return [
    		selected,
    		isActive,
    		filtered,
    		label,
    		$datePrecision,
    		date,
    		columnPrecision,
    		datePrecision,
    		onDropdownClose,
    		onToggleClick,
    		click_handler,
    		columnoption_selected_binding
    	];
    }

    class ColumnOptions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ColumnOptions",
    			options,
    			id: create_fragment$1b.name
    		});
    	}
    }

    /* src/js/components/tableHeader/TableHeader.svelte generated by Svelte v3.24.0 */

    const file$_ = "src/js/components/tableHeader/TableHeader.svelte";

    function create_fragment$1c(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", div_class_value = `txcm-tableHeader${/*renderDetailClass*/ ctx[1](/*detail*/ ctx[0])}`);
    			add_location(div, file$_, 9, 0, 155);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*detail*/ 1 && div_class_value !== (div_class_value = `txcm-tableHeader${/*renderDetailClass*/ ctx[1](/*detail*/ ctx[0])}`)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	let { detail = null } = $$props;

    	function renderDetailClass() {
    		if (detail) return ` txcm-tableHeader-${detail}`;
    		return "";
    	}

    	const writable_props = ["detail"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TableHeader> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TableHeader", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("detail" in $$props) $$invalidate(0, detail = $$props.detail);
    		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ detail, renderDetailClass });

    	$$self.$inject_state = $$props => {
    		if ("detail" in $$props) $$invalidate(0, detail = $$props.detail);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [detail, renderDetailClass, $$scope, $$slots];
    }

    class TableHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, { detail: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableHeader",
    			options,
    			id: create_fragment$1c.name
    		});
    	}

    	get detail() {
    		throw new Error("<TableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set detail(value) {
    		throw new Error("<TableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/tableHeader/TableHeaderCell.svelte generated by Svelte v3.24.0 */

    const file$$ = "src/js/components/tableHeader/TableHeaderCell.svelte";

    function create_fragment$1d(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "txcm-tableHeaderCell");
    			add_location(div, file$$, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TableHeaderCell> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TableHeaderCell", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, $$slots];
    }

    class TableHeaderCell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableHeaderCell",
    			options,
    			id: create_fragment$1d.name
    		});
    	}
    }

    /* src/js/components/tableHeader/operational/factors/TableHeaderCellOpFactors.svelte generated by Svelte v3.24.0 */
    const file$10 = "src/js/components/tableHeader/operational/factors/TableHeaderCellOpFactors.svelte";

    // (30:2) {#if indicator.id === '20'}
    function create_if_block$h(ctx) {
    	let div;
    	let int;
    	let br;
    	let current;

    	int = new Int({
    			props: { key: /*inflationText*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(int.$$.fragment);
    			br = element("br");
    			add_location(br, file$10, 32, 34, 937);
    			attr_dev(div, "class", "txcm-tableHeaderCellWideColumn");
    			add_location(div, file$10, 30, 4, 852);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(int, div, null);
    			append_dev(div, br);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*inflationText*/ 2) int_changes.key = /*inflationText*/ ctx[1];
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(30:2) {#if indicator.id === '20'}",
    		ctx
    	});

    	return block;
    }

    // (19:0) <TableHeaderCell>
    function create_default_slot$m(ctx) {
    	let t0;
    	let div;
    	let span0;
    	let int;
    	let t1;
    	let span1;
    	let t2;
    	let t3;
    	let if_block_anchor;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[6].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[7], null);

    	int = new Int({
    			props: { key: "∆ (ppt)" },
    			$$inline: true
    		});

    	let if_block = /*indicator*/ ctx[0].id === "20" && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    			t0 = space();
    			div = element("div");
    			span0 = element("span");
    			create_component(int.$$.fragment);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*label*/ ctx[2]);
    			t3 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(span0, file$10, 22, 6, 682);
    			set_style(span1, "margin-top", "-4px");
    			add_location(span1, file$10, 25, 6, 738);
    			attr_dev(div, "class", "txcm-tableHeaderCellWideColumn");
    			add_location(div, file$10, 20, 2, 627);
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, span0);
    			mount_component(int, span0, null);
    			append_dev(div, t1);
    			append_dev(div, span1);
    			append_dev(span1, t2);
    			insert_dev(target, t3, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 128) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[7], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*label*/ 4) set_data_dev(t2, /*label*/ ctx[2]);

    			if (/*indicator*/ ctx[0].id === "20") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*indicator*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(int.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(int.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    			if (detaching) detach_dev(t3);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(19:0) <TableHeaderCell>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1e(ctx) {
    	let tableheadercell;
    	let current;

    	tableheadercell = new TableHeaderCell({
    			props: {
    				$$slots: { default: [create_default_slot$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tableheadercell.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tableheadercell, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tableheadercell_changes = {};

    			if (dirty & /*$$scope, inflationText, indicator, label*/ 135) {
    				tableheadercell_changes.$$scope = { dirty, ctx };
    			}

    			tableheadercell.$set(tableheadercell_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tableheadercell.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tableheadercell.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tableheadercell, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1e($$self, $$props, $$invalidate) {
    	let $datePoP;
    	let $datePrecision;
    	let $locale;
    	let { indicator } = $$props;
    	let { inflationText } = $$props;
    	const datePoP = getDashboardState("datePoP");
    	validate_store(datePoP, "datePoP");
    	component_subscribe($$self, datePoP, value => $$invalidate(8, $datePoP = value));
    	const datePrecision = getDashboardState("datePrecision");
    	validate_store(datePrecision, "datePrecision");
    	component_subscribe($$self, datePrecision, value => $$invalidate(9, $datePrecision = value));
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(10, $locale = value));
    	const writable_props = ["indicator", "inflationText"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TableHeaderCellOpFactors> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TableHeaderCellOpFactors", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("inflationText" in $$props) $$invalidate(1, inflationText = $$props.inflationText);
    		if ("$$scope" in $$props) $$invalidate(7, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		renderPreciseCellDate,
    		getUIState,
    		TableHeaderCell,
    		Int,
    		indicator,
    		inflationText,
    		datePoP,
    		datePrecision,
    		locale,
    		label,
    		$datePoP,
    		$datePrecision,
    		$locale
    	});

    	$$self.$inject_state = $$props => {
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("inflationText" in $$props) $$invalidate(1, inflationText = $$props.inflationText);
    		if ("label" in $$props) $$invalidate(2, label = $$props.label);
    	};

    	let label;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$datePoP, $datePrecision, $locale*/ 1792) {
    			 $$invalidate(2, label = renderPreciseCellDate($datePoP, $datePrecision, $locale));
    		}
    	};

    	return [
    		indicator,
    		inflationText,
    		label,
    		datePoP,
    		datePrecision,
    		locale,
    		$$slots,
    		$$scope
    	];
    }

    class TableHeaderCellOpFactors extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, { indicator: 0, inflationText: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableHeaderCellOpFactors",
    			options,
    			id: create_fragment$1e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*indicator*/ ctx[0] === undefined && !("indicator" in props)) {
    			console.warn("<TableHeaderCellOpFactors> was created without expected prop 'indicator'");
    		}

    		if (/*inflationText*/ ctx[1] === undefined && !("inflationText" in props)) {
    			console.warn("<TableHeaderCellOpFactors> was created without expected prop 'inflationText'");
    		}
    	}

    	get indicator() {
    		throw new Error("<TableHeaderCellOpFactors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<TableHeaderCellOpFactors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get inflationText() {
    		throw new Error("<TableHeaderCellOpFactors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set inflationText(value) {
    		throw new Error("<TableHeaderCellOpFactors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/tableHeader/operational/factors/TableHeaderOpFactors.svelte generated by Svelte v3.24.0 */
    const file$11 = "src/js/components/tableHeader/operational/factors/TableHeaderOpFactors.svelte";

    // (21:4) <TableHeaderCellOperationalFactors {indicator} inflationText={'Вклад за счет маржинальности'}>
    function create_default_slot_2(ctx) {
    	let div1;
    	let t0;
    	let t1;
    	let div0;
    	let int;
    	let current;
    	int = new Int({ props: { key: "" }, $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			t0 = text(/*label*/ ctx[1]);
    			t1 = space();
    			div0 = element("div");
    			create_component(int.$$.fragment);
    			attr_dev(div0, "class", "txcm-tableHeaderCellLabelNote");
    			add_location(div0, file$11, 24, 10, 928);
    			attr_dev(div1, "class", "txcm-tableHeaderCellLabel");
    			add_location(div1, file$11, 21, 6, 852);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t0);
    			append_dev(div1, t1);
    			append_dev(div1, div0);
    			mount_component(int, div0, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*label*/ 2) set_data_dev(t0, /*label*/ ctx[1]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(21:4) <TableHeaderCellOperationalFactors {indicator} inflationText={'Вклад за счет маржинальности'}>",
    		ctx
    	});

    	return block;
    }

    // (31:4) <TableHeaderCellOperationalFactors {indicator} inflationText={'Вклад за счет маржинальности'}>
    function create_default_slot_1$4(ctx) {
    	let div1;
    	let columnoptions;
    	let t;
    	let div0;
    	let int;
    	let current;
    	columnoptions = new ColumnOptions({ $$inline: true });
    	int = new Int({ props: { key: "" }, $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(columnoptions.$$.fragment);
    			t = space();
    			div0 = element("div");
    			create_component(int.$$.fragment);
    			attr_dev(div0, "class", "txcm-tableHeaderCellLabelNote");
    			add_location(div0, file$11, 34, 10, 1274);
    			attr_dev(div1, "class", "txcm-tableHeaderCellLabel");
    			add_location(div1, file$11, 31, 6, 1188);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(columnoptions, div1, null);
    			append_dev(div1, t);
    			append_dev(div1, div0);
    			mount_component(int, div0, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(columnoptions.$$.fragment, local);
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(columnoptions.$$.fragment, local);
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(columnoptions);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(31:4) <TableHeaderCellOperationalFactors {indicator} inflationText={'Вклад за счет маржинальности'}>",
    		ctx
    	});

    	return block;
    }

    // (19:0) <TableHeader   detail="factors">
    function create_default_slot$n(ctx) {
    	let tableheadercelloperationalfactors0;
    	let t;
    	let tableheadercelloperationalfactors1;
    	let current;

    	tableheadercelloperationalfactors0 = new TableHeaderCellOpFactors({
    			props: {
    				indicator: /*indicator*/ ctx[0],
    				inflationText: "Вклад за счет маржинальности",
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tableheadercelloperationalfactors1 = new TableHeaderCellOpFactors({
    			props: {
    				indicator: /*indicator*/ ctx[0],
    				inflationText: "Вклад за счет маржинальности",
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tableheadercelloperationalfactors0.$$.fragment);
    			t = space();
    			create_component(tableheadercelloperationalfactors1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tableheadercelloperationalfactors0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(tableheadercelloperationalfactors1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tableheadercelloperationalfactors0_changes = {};
    			if (dirty & /*indicator*/ 1) tableheadercelloperationalfactors0_changes.indicator = /*indicator*/ ctx[0];

    			if (dirty & /*$$scope, label*/ 258) {
    				tableheadercelloperationalfactors0_changes.$$scope = { dirty, ctx };
    			}

    			tableheadercelloperationalfactors0.$set(tableheadercelloperationalfactors0_changes);
    			const tableheadercelloperationalfactors1_changes = {};
    			if (dirty & /*indicator*/ 1) tableheadercelloperationalfactors1_changes.indicator = /*indicator*/ ctx[0];

    			if (dirty & /*$$scope*/ 256) {
    				tableheadercelloperationalfactors1_changes.$$scope = { dirty, ctx };
    			}

    			tableheadercelloperationalfactors1.$set(tableheadercelloperationalfactors1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tableheadercelloperationalfactors0.$$.fragment, local);
    			transition_in(tableheadercelloperationalfactors1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tableheadercelloperationalfactors0.$$.fragment, local);
    			transition_out(tableheadercelloperationalfactors1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tableheadercelloperationalfactors0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(tableheadercelloperationalfactors1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(19:0) <TableHeader   detail=\\\"factors\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1f(ctx) {
    	let tableheader;
    	let current;

    	tableheader = new TableHeader({
    			props: {
    				detail: "factors",
    				$$slots: { default: [create_default_slot$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tableheader.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tableheader, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tableheader_changes = {};

    			if (dirty & /*$$scope, indicator, label*/ 259) {
    				tableheader_changes.$$scope = { dirty, ctx };
    			}

    			tableheader.$set(tableheader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tableheader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tableheader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tableheader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	let $date;
    	let $datePrecision;
    	let $locale;
    	let { indicator } = $$props;
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(7, $locale = value));
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(5, $date = value));
    	const datePrecision = getDashboardState("datePrecision");
    	validate_store(datePrecision, "datePrecision");
    	component_subscribe($$self, datePrecision, value => $$invalidate(6, $datePrecision = value));
    	const writable_props = ["indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TableHeaderOpFactors> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TableHeaderOpFactors", $$slots, []);

    	$$self.$set = $$props => {
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		renderPreciseTableDate,
    		ColumnOptions,
    		TableHeader,
    		TableHeaderCellOperationalFactors: TableHeaderCellOpFactors,
    		Int,
    		getUIState,
    		indicator,
    		locale,
    		date,
    		datePrecision,
    		label,
    		$date,
    		$datePrecision,
    		$locale
    	});

    	$$self.$inject_state = $$props => {
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    	};

    	let label;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$date, $datePrecision, $locale*/ 224) {
    			 $$invalidate(1, label = renderPreciseTableDate($date, $datePrecision, $locale));
    		}
    	};

    	return [indicator, label, locale, date, datePrecision];
    }

    class TableHeaderOpFactors extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, { indicator: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableHeaderOpFactors",
    			options,
    			id: create_fragment$1f.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*indicator*/ ctx[0] === undefined && !("indicator" in props)) {
    			console.warn("<TableHeaderOpFactors> was created without expected prop 'indicator'");
    		}
    	}

    	get indicator() {
    		throw new Error("<TableHeaderOpFactors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<TableHeaderOpFactors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factors/FactorsLabel.svelte generated by Svelte v3.24.0 */
    const file$12 = "src/js/components/factors/FactorsLabel.svelte";

    function create_fragment$1g(ctx) {
    	let div;
    	let int;
    	let current;

    	int = new Int({
    			props: { key: /*indicator*/ ctx[0].label },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(int.$$.fragment);
    			attr_dev(div, "class", "txcm-factorsLabel");
    			add_location(div, file$12, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(int, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const int_changes = {};
    			if (dirty & /*indicator*/ 1) int_changes.key = /*indicator*/ ctx[0].label;
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	let { indicator } = $$props;
    	const writable_props = ["indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsLabel> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsLabel", $$slots, []);

    	$$self.$set = $$props => {
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({ Int, indicator });

    	$$self.$inject_state = $$props => {
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [indicator];
    }

    class FactorsLabel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, { indicator: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsLabel",
    			options,
    			id: create_fragment$1g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*indicator*/ ctx[0] === undefined && !("indicator" in props)) {
    			console.warn("<FactorsLabel> was created without expected prop 'indicator'");
    		}
    	}

    	get indicator() {
    		throw new Error("<FactorsLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<FactorsLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factors/FactorsTableHeader.svelte generated by Svelte v3.24.0 */
    const file$13 = "src/js/components/factors/FactorsTableHeader.svelte";

    function create_fragment$1h(ctx) {
    	let div;
    	let factorslabel;
    	let t;
    	let tableheaderoperationalfactors;
    	let current;

    	factorslabel = new FactorsLabel({
    			props: { indicator: /*indicator*/ ctx[0] },
    			$$inline: true
    		});

    	tableheaderoperationalfactors = new TableHeaderOpFactors({
    			props: { indicator: /*indicator*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(factorslabel.$$.fragment);
    			t = space();
    			create_component(tableheaderoperationalfactors.$$.fragment);
    			attr_dev(div, "class", "txcm-factorsHeader");
    			add_location(div, file$13, 19, 0, 467);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(factorslabel, div, null);
    			append_dev(div, t);
    			mount_component(tableheaderoperationalfactors, div, null);
    			/*div_binding*/ ctx[4](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const factorslabel_changes = {};
    			if (dirty & /*indicator*/ 1) factorslabel_changes.indicator = /*indicator*/ ctx[0];
    			factorslabel.$set(factorslabel_changes);
    			const tableheaderoperationalfactors_changes = {};
    			if (dirty & /*indicator*/ 1) tableheaderoperationalfactors_changes.indicator = /*indicator*/ ctx[0];
    			tableheaderoperationalfactors.$set(tableheaderoperationalfactors_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorslabel.$$.fragment, local);
    			transition_in(tableheaderoperationalfactors.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorslabel.$$.fragment, local);
    			transition_out(tableheaderoperationalfactors.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(factorslabel);
    			destroy_component(tableheaderoperationalfactors);
    			/*div_binding*/ ctx[4](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	let $sectionScrollX;
    	let { dashboard } = $$props;
    	let { indicator } = $$props;
    	const sectionScrollX = getUIState("sectionScrollX");
    	validate_store(sectionScrollX, "sectionScrollX");
    	component_subscribe($$self, sectionScrollX, value => $$invalidate(5, $sectionScrollX = value));
    	let node;

    	function updateScroll() {
    		if (node) $$invalidate(1, node.scrollLeft = $sectionScrollX, node);
    	}

    	const writable_props = ["dashboard", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<FactorsTableHeader> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("FactorsTableHeader", $$slots, []);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			node = $$value;
    			$$invalidate(1, node);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(3, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getUIState,
    		TableHeaderOperationalFactors: TableHeaderOpFactors,
    		FactorsLabel,
    		dashboard,
    		indicator,
    		sectionScrollX,
    		node,
    		updateScroll,
    		$sectionScrollX
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(3, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("node" in $$props) $$invalidate(1, node = $$props.node);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$sectionScrollX*/ 32) {
    			 updateScroll();
    		}
    	};

    	return [indicator, node, sectionScrollX, dashboard, div_binding];
    }

    class FactorsTableHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, { dashboard: 3, indicator: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FactorsTableHeader",
    			options,
    			id: create_fragment$1h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[3] === undefined && !("dashboard" in props)) {
    			console.warn("<FactorsTableHeader> was created without expected prop 'dashboard'");
    		}

    		if (/*indicator*/ ctx[0] === undefined && !("indicator" in props)) {
    			console.warn("<FactorsTableHeader> was created without expected prop 'indicator'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<FactorsTableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<FactorsTableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<FactorsTableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<FactorsTableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/factors/Factors.svelte generated by Svelte v3.24.0 */

    const { Object: Object_1$1 } = globals;
    const file$14 = "src/js/components/factors/Factors.svelte";

    // (132:4) {#if data && results}
    function create_if_block$i(ctx) {
    	let factorssectionheader;
    	let t0;
    	let factorsbridges;
    	let t1;
    	let factorssectionfooter;
    	let current;

    	factorssectionheader = new FactorsSectionHeader({
    			props: {
    				data: /*results*/ ctx[5],
    				baseRatios: /*baseRatios*/ ctx[2],
    				minRatios: /*minRatios*/ ctx[3],
    				indicator: /*indicatorId*/ ctx[6]
    			},
    			$$inline: true
    		});

    	factorsbridges = new FactorsBridges({
    			props: {
    				results: /*results*/ ctx[5],
    				bridges: /*bridges*/ ctx[4],
    				baseRatios: /*baseRatios*/ ctx[2],
    				minRatios: /*minRatios*/ ctx[3],
    				indicator: /*indicatorId*/ ctx[6]
    			},
    			$$inline: true
    		});

    	factorssectionfooter = new FactorsSectionFooter({
    			props: {
    				data: /*results*/ ctx[5],
    				baseRatios: /*baseRatios*/ ctx[2],
    				minRatios: /*minRatios*/ ctx[3],
    				indicator: /*indicatorId*/ ctx[6]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factorssectionheader.$$.fragment);
    			t0 = space();
    			create_component(factorsbridges.$$.fragment);
    			t1 = space();
    			create_component(factorssectionfooter.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(factorssectionheader, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(factorsbridges, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(factorssectionfooter, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factorssectionheader_changes = {};
    			if (dirty & /*results*/ 32) factorssectionheader_changes.data = /*results*/ ctx[5];
    			if (dirty & /*baseRatios*/ 4) factorssectionheader_changes.baseRatios = /*baseRatios*/ ctx[2];
    			if (dirty & /*minRatios*/ 8) factorssectionheader_changes.minRatios = /*minRatios*/ ctx[3];
    			if (dirty & /*indicatorId*/ 64) factorssectionheader_changes.indicator = /*indicatorId*/ ctx[6];
    			factorssectionheader.$set(factorssectionheader_changes);
    			const factorsbridges_changes = {};
    			if (dirty & /*results*/ 32) factorsbridges_changes.results = /*results*/ ctx[5];
    			if (dirty & /*bridges*/ 16) factorsbridges_changes.bridges = /*bridges*/ ctx[4];
    			if (dirty & /*baseRatios*/ 4) factorsbridges_changes.baseRatios = /*baseRatios*/ ctx[2];
    			if (dirty & /*minRatios*/ 8) factorsbridges_changes.minRatios = /*minRatios*/ ctx[3];
    			if (dirty & /*indicatorId*/ 64) factorsbridges_changes.indicator = /*indicatorId*/ ctx[6];
    			factorsbridges.$set(factorsbridges_changes);
    			const factorssectionfooter_changes = {};
    			if (dirty & /*results*/ 32) factorssectionfooter_changes.data = /*results*/ ctx[5];
    			if (dirty & /*baseRatios*/ 4) factorssectionfooter_changes.baseRatios = /*baseRatios*/ ctx[2];
    			if (dirty & /*minRatios*/ 8) factorssectionfooter_changes.minRatios = /*minRatios*/ ctx[3];
    			if (dirty & /*indicatorId*/ 64) factorssectionfooter_changes.indicator = /*indicatorId*/ ctx[6];
    			factorssectionfooter.$set(factorssectionfooter_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorssectionheader.$$.fragment, local);
    			transition_in(factorsbridges.$$.fragment, local);
    			transition_in(factorssectionfooter.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorssectionheader.$$.fragment, local);
    			transition_out(factorsbridges.$$.fragment, local);
    			transition_out(factorssectionfooter.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factorssectionheader, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(factorsbridges, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(factorssectionfooter, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(132:4) {#if data && results}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1i(ctx) {
    	let section;
    	let factorstableheader;
    	let t;
    	let current;

    	factorstableheader = new FactorsTableHeader({
    			props: {
    				indicator: /*indicatorId*/ ctx[6],
    				dashboard: /*dashboard*/ ctx[1]
    			},
    			$$inline: true
    		});

    	let if_block = /*data*/ ctx[0] && /*results*/ ctx[5] && create_if_block$i(ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			create_component(factorstableheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(section, "class", "txcm-factorsSection");
    			add_location(section, file$14, 126, 0, 5138);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			mount_component(factorstableheader, section, null);
    			append_dev(section, t);
    			if (if_block) if_block.m(section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const factorstableheader_changes = {};
    			if (dirty & /*indicatorId*/ 64) factorstableheader_changes.indicator = /*indicatorId*/ ctx[6];
    			if (dirty & /*dashboard*/ 2) factorstableheader_changes.dashboard = /*dashboard*/ ctx[1];
    			factorstableheader.$set(factorstableheader_changes);

    			if (/*data*/ ctx[0] && /*results*/ ctx[5]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*data, results*/ 33) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$i(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(section, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factorstableheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factorstableheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(factorstableheader);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function coerceMinRatio(min, comparison, baseRatio) {
    	if (comparison >= 0) {
    		return -1 * min * baseRatio;
    	} else {
    		return -1 * (min - comparison) * baseRatio;
    	}
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	let { data = null } = $$props;
    	let { dashboard } = $$props;
    	let { indicator } = $$props;
    	const config = getContext("config").getIndicatorsConfig();
    	const indicators = Object.values(config).reduce(flattenCategories, {});
    	let baseRatios = [0, 0, 0, 0];
    	let minRatios = [0, 0, 0, 0];

    	function sortedBridges() {
    		if (!data.results) return [];

    		if (data.results[0].column1.factPrevYearPrecent.qNum >= 0) {
    			return data.bridges.sort((a, b) => {
    				return a.column1.vsFactPercent.qNum - b.column1.vsFactPercent.qNum;
    			});
    		} else {
    			return data.bridges.sort((a, b) => {
    				return b.column1.vsFactPercent.qNum - a.column1.vsFactPercent.qNum;
    			});
    		}
    	}

    	function flattenIndicators(results, option) {
    		return { ...results, [option.id]: option };
    	}

    	function flattenCategories(results, group) {
    		return {
    			...results,
    			...group.indicators.reduce(flattenIndicators, {})
    		};
    	}

    	function findIndicator() {
    		return Object.values(indicators).find(option => option.url === indicator);
    	}

    	function calculateRange() {
    		const arr = [
    			[
    				results.column1.factPrevYearPrecent && !isNaN(results.column1.factPrevYearPrecent.qNum)
    				? results.column1.factPrevYearPrecent.qNum
    				: 0
    			],
    			[
    				results.column1.budgetPercent && !isNaN(results.column1.budgetPercent.qNum)
    				? results.column1.budgetPercent.qNum
    				: 0
    			],
    			[
    				results.column2.factPrevYearPrecent && !isNaN(results.column2.factPrevYearPrecent.qNum)
    				? results.column2.factPrevYearPrecent.qNum
    				: 0
    			],
    			[
    				results.column2.budgetPercent && !isNaN(results.column2.budgetPercent.qNum)
    				? results.column2.budgetPercent.qNum
    				: 0
    			]
    		];

    		bridges.reduce(
    			(prev, curr) => {
    				prev[0] += curr.column1.vsFactPercent && !isNaN(curr.column1.vsFactPercent.qNum)
    				? curr.column1.vsFactPercent.qNum
    				: 0;

    				prev[1] += curr.column1.vsBudgetPercent && !isNaN(curr.column1.vsBudgetPercent.qNum)
    				? curr.column1.vsBudgetPercent.qNum
    				: 0;

    				prev[2] += curr.column2.vsFactPercent && !isNaN(curr.column2.vsFactPercent.qNum)
    				? curr.column2.vsFactPercent.qNum
    				: 0;

    				prev[3] += curr.column2.vsBudgetPercent && !isNaN(curr.column2.vsBudgetPercent.qNum)
    				? curr.column2.vsBudgetPercent.qNum
    				: 0;

    				arr[0].push(prev[0]);
    				arr[1].push(prev[1]);
    				arr[2].push(prev[2]);
    				arr[3].push(prev[3]);
    				return prev;
    			},
    			[
    				results.column1.factPrevYearPrecent && !isNaN(results.column1.factPrevYearPrecent.qNum)
    				? results.column1.factPrevYearPrecent.qNum
    				: 0,
    				results.column1.budgetPercent && !isNaN(results.column1.budgetPercent.qNum)
    				? results.column1.budgetPercent.qNum
    				: 0,
    				results.column2.factPrevYearPrecent && !isNaN(results.column2.factPrevYearPrecent.qNum)
    				? results.column2.factPrevYearPrecent.qNum
    				: 0,
    				results.column2.budgetPercent && !isNaN(results.column2.budgetPercent.qNum)
    				? results.column2.budgetPercent.qNum
    				: 0
    			]
    		);

    		const min = [
    			Math.min(...arr[0]),
    			Math.min(...arr[1]),
    			Math.min(...arr[2]),
    			Math.min(...arr[3])
    		];

    		const max = [
    			Math.max(...arr[0]),
    			Math.max(...arr[1]),
    			Math.max(...arr[2]),
    			Math.max(...arr[3])
    		];

    		return [
    			[
    				min[0] - Math.abs(max[0] - min[0]) * 0.3,
    				min[1] - Math.abs(max[1] - min[1]) * 0.3,
    				min[2] - Math.abs(max[2] - min[2]) * 0.3,
    				min[3] - Math.abs(max[3] - min[3]) * 0.3
    			],
    			max
    		];
    	}

    	function updateBaseRatios() {
    		if (!results) return;
    		const [min, max] = calculateRange();
    		$$invalidate(2, baseRatios[0] = 1 / Math.abs(max[0] - min[0]), baseRatios);
    		$$invalidate(2, baseRatios[1] = 1 / Math.abs(max[1] - min[1]), baseRatios);
    		$$invalidate(2, baseRatios[2] = 1 / Math.abs(max[2] - min[2]), baseRatios);
    		$$invalidate(2, baseRatios[3] = 1 / Math.abs(max[3] - min[3]), baseRatios);

    		$$invalidate(
    			3,
    			minRatios[0] = coerceMinRatio(
    				min[0],
    				results.column1.factPrevYearPrecent
    				? results.column1.factPrevYearPrecent.qNum
    				: 0,
    				baseRatios[0]
    			),
    			minRatios
    		);

    		$$invalidate(
    			3,
    			minRatios[1] = coerceMinRatio(
    				min[1],
    				results.column1.budgetPercent
    				? results.column1.budgetPercent.qNum
    				: 0,
    				baseRatios[1]
    			),
    			minRatios
    		);

    		$$invalidate(
    			3,
    			minRatios[2] = coerceMinRatio(
    				min[2],
    				results.column2.factPrevYearPrecent
    				? results.column2.factPrevYearPrecent.qNum
    				: 0,
    				baseRatios[2]
    			),
    			minRatios
    		);

    		$$invalidate(
    			3,
    			minRatios[3] = coerceMinRatio(
    				min[3],
    				results.column2.budgetPercent
    				? results.column2.budgetPercent.qNum
    				: 0,
    				baseRatios[3]
    			),
    			minRatios
    		);
    	}

    	const writable_props = ["data", "dashboard", "indicator"];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Factors> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Factors", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("dashboard" in $$props) $$invalidate(1, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(7, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		getDashboardState,
    		FactorIndicators,
    		FactorsSectionHeader,
    		FactorsSectionFooter,
    		FactorsBridges,
    		FactorsTableHeader,
    		data,
    		dashboard,
    		indicator,
    		config,
    		indicators,
    		baseRatios,
    		minRatios,
    		sortedBridges,
    		flattenIndicators,
    		flattenCategories,
    		findIndicator,
    		calculateRange,
    		coerceMinRatio,
    		updateBaseRatios,
    		bridges,
    		results,
    		indicatorId
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("dashboard" in $$props) $$invalidate(1, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(7, indicator = $$props.indicator);
    		if ("baseRatios" in $$props) $$invalidate(2, baseRatios = $$props.baseRatios);
    		if ("minRatios" in $$props) $$invalidate(3, minRatios = $$props.minRatios);
    		if ("bridges" in $$props) $$invalidate(4, bridges = $$props.bridges);
    		if ("results" in $$props) $$invalidate(5, results = $$props.results);
    		if ("indicatorId" in $$props) $$invalidate(6, indicatorId = $$props.indicatorId);
    	};

    	let bridges;
    	let results;
    	let indicatorId;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 1) {
    			 $$invalidate(4, bridges = sortedBridges());
    		}

    		if ($$self.$$.dirty & /*data*/ 1) {
    			 $$invalidate(5, results = data.results && data.results.length
    			? data.results[0]
    			: null);
    		}

    		if ($$self.$$.dirty & /*bridges*/ 16) {
    			 updateBaseRatios();
    		}

    		if ($$self.$$.dirty & /*indicator*/ 128) {
    			 $$invalidate(6, indicatorId = findIndicator());
    		}
    	};

    	return [
    		data,
    		dashboard,
    		baseRatios,
    		minRatios,
    		bridges,
    		results,
    		indicatorId,
    		indicator
    	];
    }

    class Factors extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, { data: 0, dashboard: 1, indicator: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Factors",
    			options,
    			id: create_fragment$1i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[1] === undefined && !("dashboard" in props)) {
    			console.warn("<Factors> was created without expected prop 'dashboard'");
    		}

    		if (/*indicator*/ ctx[7] === undefined && !("indicator" in props)) {
    			console.warn("<Factors> was created without expected prop 'indicator'");
    		}
    	}

    	get data() {
    		throw new Error("<Factors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Factors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dashboard() {
    		throw new Error("<Factors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<Factors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<Factors>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<Factors>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* eslint max-lines-per-function: 'off' */

    function show(content, side, position, theme) {
      updateUI({ tooltip: { content, side, position, theme } });
    }

    function hide() {
      updateUI({ tooltip: null });
    }

    function calculateVerticalPosition(vertical, left, right, shift = 0) {
      return {
        x: left + ((right - left) / 2),
        y: vertical + shift,
      };
    }

    function calculateHorizontalPosition(horizontal, top, bottom, shift = 0) {
      return {
        x: horizontal + shift,
        y: top + ((bottom - top) / 2),
      };
    }

    function calculatePosition(node, side) {
      const rect = node.getBoundingClientRect();
      const { top, right, bottom, left } = rect;
      if (side === 'bottom') return calculateVerticalPosition(bottom, left, right, -18);
      else if (side === 'right') return calculateHorizontalPosition(right, top, bottom, -18);
      else if (side === 'left') return calculateHorizontalPosition(left, top, bottom, 18);
      return calculateVerticalPosition(top, left, right, 18);
    }

    function tooltip(node, data) {
      let { content, side, theme } = data;

      function onNodeMouseOver() {
        const position = calculatePosition(node, side);
        show(content, side, position, theme);
      }

      function onNodeMouseOut() {
        if (!document.activeElement || document.activeElement !== node) hide();
      }

      function onNodeFocus() {
        const position = calculatePosition(node);
        show(content, side, position, theme);
      }

      function onNodeBlur() {
        hide();
      }

      function subscribe() {
        node.addEventListener('mouseenter', onNodeMouseOver);
        node.addEventListener('mouseleave', onNodeMouseOut);
        node.addEventListener('focus', onNodeFocus);
        node.addEventListener('blur', onNodeBlur);
      }

      function unsubscribe() {
        node.removeEventListener('mouseenter', onNodeMouseOver);
        node.removeEventListener('mouseleave', onNodeMouseOut);
        node.removeEventListener('focus', onNodeFocus);
        node.removeEventListener('blur', onNodeBlur);
      }

      function init() {
        if (content.data && content.component) subscribe();
      }

      function destroy() {
        unsubscribe();
      }

      function update(newData) {
        ({ content, side, theme } = newData);
        if (content.data && content.component) subscribe();
        else unsubscribe();
      }

      init();

      return {
        update,
        destroy,
      };
    }

    /* src/js/components/graphOptions/GraphOptionsDetailTooltip.svelte generated by Svelte v3.24.0 */

    const file$15 = "src/js/components/graphOptions/GraphOptionsDetailTooltip.svelte";

    function create_fragment$1j(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*data*/ ctx[0]);
    			attr_dev(div, "class", "txcm-txcm-graphDetailTooltip");
    			add_location(div, file$15, 4, 0, 39);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*data*/ 1) set_data_dev(t, /*data*/ ctx[0]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1j($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GraphOptionsDetailTooltip> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("GraphOptionsDetailTooltip", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({ data });

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [data];
    }

    class GraphOptionsDetailTooltip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, { data: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GraphOptionsDetailTooltip",
    			options,
    			id: create_fragment$1j.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<GraphOptionsDetailTooltip> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<GraphOptionsDetailTooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<GraphOptionsDetailTooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/graphOptions/GraphOptionsDetail.svelte generated by Svelte v3.24.0 */
    const file$16 = "src/js/components/graphOptions/GraphOptionsDetail.svelte";

    function create_fragment$1k(ctx) {
    	let input;
    	let t;
    	let label_1;
    	let int;
    	let tooltip_action;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*label*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			input = element("input");
    			t = space();
    			label_1 = element("label");
    			create_component(int.$$.fragment);
    			attr_dev(input, "class", "txcm-graphDetailInput");
    			attr_dev(input, "type", "radio");
    			attr_dev(input, "id", /*htmlID*/ ctx[3]);
    			input.__value = /*value*/ ctx[2];
    			input.value = input.__value;
    			/*$$binding_groups*/ ctx[7][0].push(input);
    			add_location(input, file$16, 22, 0, 577);
    			attr_dev(label_1, "class", "txcm-graphDetailControl");
    			attr_dev(label_1, "for", /*htmlID*/ ctx[3]);
    			add_location(label_1, file$16, 28, 0, 680);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = input.__value === /*selected*/ ctx[0];
    			insert_dev(target, t, anchor);
    			insert_dev(target, label_1, anchor);
    			mount_component(int, label_1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*input_change_handler*/ ctx[6]),
    					action_destroyer(tooltip_action = tooltip.call(null, label_1, /*tooltipOptions*/ ctx[4]))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*value*/ 4) {
    				prop_dev(input, "__value", /*value*/ ctx[2]);
    				input.value = input.__value;
    			}

    			if (dirty & /*selected*/ 1) {
    				input.checked = input.__value === /*selected*/ ctx[0];
    			}

    			const int_changes = {};
    			if (dirty & /*label*/ 2) int_changes.key = /*label*/ ctx[1];
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*$$binding_groups*/ ctx[7][0].splice(/*$$binding_groups*/ ctx[7][0].indexOf(input), 1);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(label_1);
    			destroy_component(int);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1k($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	let { subLabel } = $$props;
    	let { value } = $$props;
    	let { selected } = $$props;
    	const htmlID = renderID("graphDetail", value);

    	const tooltipOptions = {
    		content: {
    			component: GraphOptionsDetailTooltip,
    			data: subLabel
    		},
    		side: "bottom",
    		theme: "txcm-tooltip-graphDetail"
    	};

    	const writable_props = ["label", "subLabel", "value", "selected"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GraphOptionsDetail> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("GraphOptionsDetail", $$slots, []);
    	const $$binding_groups = [[]];

    	function input_change_handler() {
    		selected = this.__value;
    		$$invalidate(0, selected);
    	}

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("subLabel" in $$props) $$invalidate(5, subLabel = $$props.subLabel);
    		if ("value" in $$props) $$invalidate(2, value = $$props.value);
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    	};

    	$$self.$capture_state = () => ({
    		renderID,
    		tooltip,
    		Int,
    		GraphOptionsDetailTooltip,
    		label,
    		subLabel,
    		value,
    		selected,
    		htmlID,
    		tooltipOptions
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("subLabel" in $$props) $$invalidate(5, subLabel = $$props.subLabel);
    		if ("value" in $$props) $$invalidate(2, value = $$props.value);
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		selected,
    		label,
    		value,
    		htmlID,
    		tooltipOptions,
    		subLabel,
    		input_change_handler,
    		$$binding_groups
    	];
    }

    class GraphOptionsDetail extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, {
    			label: 1,
    			subLabel: 5,
    			value: 2,
    			selected: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GraphOptionsDetail",
    			options,
    			id: create_fragment$1k.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[1] === undefined && !("label" in props)) {
    			console.warn("<GraphOptionsDetail> was created without expected prop 'label'");
    		}

    		if (/*subLabel*/ ctx[5] === undefined && !("subLabel" in props)) {
    			console.warn("<GraphOptionsDetail> was created without expected prop 'subLabel'");
    		}

    		if (/*value*/ ctx[2] === undefined && !("value" in props)) {
    			console.warn("<GraphOptionsDetail> was created without expected prop 'value'");
    		}

    		if (/*selected*/ ctx[0] === undefined && !("selected" in props)) {
    			console.warn("<GraphOptionsDetail> was created without expected prop 'selected'");
    		}
    	}

    	get label() {
    		throw new Error("<GraphOptionsDetail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<GraphOptionsDetail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get subLabel() {
    		throw new Error("<GraphOptionsDetail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set subLabel(value) {
    		throw new Error("<GraphOptionsDetail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<GraphOptionsDetail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<GraphOptionsDetail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<GraphOptionsDetail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<GraphOptionsDetail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/graphOptions/GraphKindOptionsDetail.svelte generated by Svelte v3.24.0 */
    const file$17 = "src/js/components/graphOptions/GraphKindOptionsDetail.svelte";

    function create_fragment$1l(ctx) {
    	let input;
    	let t0;
    	let label_1;
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			t0 = space();
    			label_1 = element("label");
    			t1 = text(/*label*/ ctx[1]);
    			attr_dev(input, "class", "txcm-columnOptionInput");
    			attr_dev(input, "type", "radio");
    			attr_dev(input, "id", /*htmlID*/ ctx[3]);
    			input.__value = /*value*/ ctx[2];
    			input.value = input.__value;
    			/*$$binding_groups*/ ctx[5][0].push(input);
    			add_location(input, file$17, 12, 0, 228);
    			attr_dev(label_1, "class", "txcm-columnOptionControl");
    			attr_dev(label_1, "for", /*htmlID*/ ctx[3]);
    			add_location(label_1, file$17, 18, 0, 332);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = input.__value === /*selected*/ ctx[0];
    			insert_dev(target, t0, anchor);
    			insert_dev(target, label_1, anchor);
    			append_dev(label_1, t1);

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[4]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*value*/ 4) {
    				prop_dev(input, "__value", /*value*/ ctx[2]);
    				input.value = input.__value;
    			}

    			if (dirty & /*selected*/ 1) {
    				input.checked = input.__value === /*selected*/ ctx[0];
    			}

    			if (dirty & /*label*/ 2) set_data_dev(t1, /*label*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*$$binding_groups*/ ctx[5][0].splice(/*$$binding_groups*/ ctx[5][0].indexOf(input), 1);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(label_1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1l($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	let { value } = $$props;
    	let { selected } = $$props;
    	const htmlID = renderID("graphKindOptionsDetail", value);
    	const writable_props = ["label", "value", "selected"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GraphKindOptionsDetail> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("GraphKindOptionsDetail", $$slots, []);
    	const $$binding_groups = [[]];

    	function input_change_handler() {
    		selected = this.__value;
    		$$invalidate(0, selected);
    	}

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("value" in $$props) $$invalidate(2, value = $$props.value);
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    	};

    	$$self.$capture_state = () => ({
    		renderID,
    		label,
    		value,
    		selected,
    		htmlID,
    		checked
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    		if ("value" in $$props) $$invalidate(2, value = $$props.value);
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    		if ("checked" in $$props) checked = $$props.checked;
    	};

    	let checked;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*selected, value*/ 5) {
    			 checked = selected === value;
    		}
    	};

    	return [selected, label, value, htmlID, input_change_handler, $$binding_groups];
    }

    class GraphKindOptionsDetail extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, { label: 1, value: 2, selected: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GraphKindOptionsDetail",
    			options,
    			id: create_fragment$1l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[1] === undefined && !("label" in props)) {
    			console.warn("<GraphKindOptionsDetail> was created without expected prop 'label'");
    		}

    		if (/*value*/ ctx[2] === undefined && !("value" in props)) {
    			console.warn("<GraphKindOptionsDetail> was created without expected prop 'value'");
    		}

    		if (/*selected*/ ctx[0] === undefined && !("selected" in props)) {
    			console.warn("<GraphKindOptionsDetail> was created without expected prop 'selected'");
    		}
    	}

    	get label() {
    		throw new Error("<GraphKindOptionsDetail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<GraphKindOptionsDetail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<GraphKindOptionsDetail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<GraphKindOptionsDetail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get selected() {
    		throw new Error("<GraphKindOptionsDetail>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set selected(value) {
    		throw new Error("<GraphKindOptionsDetail>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/graphOptions/GraphKindOptionsDetails.svelte generated by Svelte v3.24.0 */
    const file$18 = "src/js/components/graphOptions/GraphKindOptionsDetails.svelte";

    function get_each_context$j(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	child_ctx[21] = i;
    	return child_ctx;
    }

    // (71:10) {#each kinds as option, index}
    function create_each_block$j(ctx) {
    	let graphkindoptionsdetail;
    	let updating_selected;
    	let current;

    	function graphkindoptionsdetail_selected_binding(value) {
    		/*graphkindoptionsdetail_selected_binding*/ ctx[11].call(null, value);
    	}

    	let graphkindoptionsdetail_props = {
    		value: /*index*/ ctx[21],
    		label: /*option*/ ctx[19]
    	};

    	if (/*selected*/ ctx[0] !== void 0) {
    		graphkindoptionsdetail_props.selected = /*selected*/ ctx[0];
    	}

    	graphkindoptionsdetail = new GraphKindOptionsDetail({
    			props: graphkindoptionsdetail_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(graphkindoptionsdetail, "selected", graphkindoptionsdetail_selected_binding));

    	const block = {
    		c: function create() {
    			create_component(graphkindoptionsdetail.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphkindoptionsdetail, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const graphkindoptionsdetail_changes = {};

    			if (!updating_selected && dirty & /*selected*/ 1) {
    				updating_selected = true;
    				graphkindoptionsdetail_changes.selected = /*selected*/ ctx[0];
    				add_flush_callback(() => updating_selected = false);
    			}

    			graphkindoptionsdetail.$set(graphkindoptionsdetail_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphkindoptionsdetail.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphkindoptionsdetail.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphkindoptionsdetail, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$j.name,
    		type: "each",
    		source: "(71:10) {#each kinds as option, index}",
    		ctx
    	});

    	return block;
    }

    // (64:2) <Dropdown     {isActive}     on:dropdownclose={onDropdownClose}>
    function create_default_slot$o(ctx) {
    	let div;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*kinds*/ ctx[6];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-graphDetailOptions");
    			toggle_class(div, "txcm-graphDetailOptions-is-active", /*isActive*/ ctx[1]);
    			add_location(div, file$18, 66, 6, 1630);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", stop_propagation(/*click_handler*/ ctx[10]), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*kinds, selected*/ 65) {
    				each_value = /*kinds*/ ctx[6];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$j(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$j(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*isActive*/ 2) {
    				toggle_class(div, "txcm-graphDetailOptions-is-active", /*isActive*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$o.name,
    		type: "slot",
    		source: "(64:2) <Dropdown     {isActive}     on:dropdownclose={onDropdownClose}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1m(ctx) {
    	let div1;
    	let button;
    	let svg;
    	let use;
    	let t0;
    	let div0;
    	let int;
    	let t1;
    	let dropdown;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*label*/ ctx[2] },
    			$$inline: true
    		});

    	dropdown = new Dropdown({
    			props: {
    				isActive: /*isActive*/ ctx[1],
    				$$slots: { default: [create_default_slot$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown.$on("dropdownclose", /*onDropdownClose*/ ctx[8]);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t0 = space();
    			div0 = element("div");
    			create_component(int.$$.fragment);
    			t1 = space();
    			create_component(dropdown.$$.fragment);
    			xlink_attr(use, "xlink:href", "#txspt-icons-fatArrow");
    			add_location(use, file$18, 53, 10, 1312);
    			attr_dev(svg, "class", "txcm-graphDetailPickerToggleIcon");
    			add_location(svg, file$18, 51, 6, 1247);
    			attr_dev(div0, "class", "txcm-tableHeaderCellLabel");
    			toggle_class(div0, "txcm-tableHeaderCellLabel-is-kind", true);
    			add_location(div0, file$18, 56, 6, 1386);
    			button.disabled = /*disabled*/ ctx[3];
    			attr_dev(button, "class", "txcm-graphDetailPickerToggle");
    			add_location(button, file$18, 47, 2, 1131);
    			attr_dev(div1, "class", "txcm-graphDetailPicker");
    			add_location(div1, file$18, 46, 0, 1092);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button);
    			append_dev(button, svg);
    			append_dev(svg, use);
    			append_dev(button, t0);
    			append_dev(button, div0);
    			mount_component(int, div0, null);
    			append_dev(div1, t1);
    			mount_component(dropdown, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", stop_propagation(/*onToggleClick*/ ctx[7]), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const int_changes = {};
    			if (dirty & /*label*/ 4) int_changes.key = /*label*/ ctx[2];
    			int.$set(int_changes);

    			if (!current || dirty & /*disabled*/ 8) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[3]);
    			}

    			const dropdown_changes = {};
    			if (dirty & /*isActive*/ 2) dropdown_changes.isActive = /*isActive*/ ctx[1];

    			if (dirty & /*$$scope, isActive, selected*/ 4194307) {
    				dropdown_changes.$$scope = { dirty, ctx };
    			}

    			dropdown.$set(dropdown_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			transition_in(dropdown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			transition_out(dropdown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(int);
    			destroy_component(dropdown);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1m($$self, $$props, $$invalidate) {
    	let $kind;
    	let $updating;
    	let { indicator } = $$props;
    	const { graphs: graphConfig } = getContext("app").getAppConfig();
    	const dashboard = getContext("config").getDashboard();
    	const kind = getGraphsState("kind");
    	validate_store(kind, "kind");
    	component_subscribe($$self, kind, value => $$invalidate(12, $kind = value));
    	const updating = getUIState("updating");
    	validate_store(updating, "updating");
    	component_subscribe($$self, updating, value => $$invalidate(13, $updating = value));
    	let selected = $kind;
    	let isActive = false;
    	let kinds = ["Дин."]; // [ 'Дин.', 'Стр.']

    	function renderLabel() {
    		return kinds[$kind];
    	}

    	function toggle() {
    		$$invalidate(1, isActive = !isActive);
    	}

    	function hide() {
    		$$invalidate(1, isActive = false);
    	}

    	function onToggleClick() {
    		toggle();
    	}

    	function onDropdownClose() {
    		hide();
    	}

    	const writable_props = ["indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GraphKindOptionsDetails> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("GraphKindOptionsDetails", $$slots, []);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function graphkindoptionsdetail_selected_binding(value) {
    		selected = value;
    		$$invalidate(0, selected);
    	}

    	$$self.$set = $$props => {
    		if ("indicator" in $$props) $$invalidate(9, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		getGraphsState,
    		Int,
    		Dropdown,
    		GraphOptionsDetail,
    		getUIState,
    		GraphKindOptionsDetail,
    		indicator,
    		graphConfig,
    		dashboard,
    		kind,
    		updating,
    		selected,
    		isActive,
    		kinds,
    		renderLabel,
    		toggle,
    		hide,
    		onToggleClick,
    		onDropdownClose,
    		$kind,
    		label,
    		disabled,
    		$updating
    	});

    	$$self.$inject_state = $$props => {
    		if ("indicator" in $$props) $$invalidate(9, indicator = $$props.indicator);
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    		if ("isActive" in $$props) $$invalidate(1, isActive = $$props.isActive);
    		if ("kinds" in $$props) $$invalidate(6, kinds = $$props.kinds);
    		if ("label" in $$props) $$invalidate(2, label = $$props.label);
    		if ("disabled" in $$props) $$invalidate(3, disabled = $$props.disabled);
    	};

    	let label;
    	let disabled;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*selected*/ 1) {
    			 set_store_value(kind, $kind = selected);
    		}

    		if ($$self.$$.dirty & /*$kind*/ 4096) {
    			 $$invalidate(2, label = renderLabel());
    		}

    		if ($$self.$$.dirty & /*$updating*/ 8192) {
    			 $$invalidate(3, disabled = $updating > 0);
    		}
    	};

    	return [
    		selected,
    		isActive,
    		label,
    		disabled,
    		kind,
    		updating,
    		kinds,
    		onToggleClick,
    		onDropdownClose,
    		indicator,
    		click_handler,
    		graphkindoptionsdetail_selected_binding
    	];
    }

    class GraphKindOptionsDetails extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1m, create_fragment$1m, safe_not_equal, { indicator: 9 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GraphKindOptionsDetails",
    			options,
    			id: create_fragment$1m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*indicator*/ ctx[9] === undefined && !("indicator" in props)) {
    			console.warn("<GraphKindOptionsDetails> was created without expected prop 'indicator'");
    		}
    	}

    	get indicator() {
    		throw new Error("<GraphKindOptionsDetails>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<GraphKindOptionsDetails>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/graphOptions/GraphOptionsDetails.svelte generated by Svelte v3.24.0 */
    const file$19 = "src/js/components/graphOptions/GraphOptionsDetails.svelte";

    function get_each_context$k(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[29] = list[i];
    	child_ctx[31] = i;
    	return child_ctx;
    }

    // (120:4) {:else}
    function create_else_block$2(ctx) {
    	let int;
    	let current;

    	int = new Int({
    			props: { key: /*label*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(int.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(int, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty[0] & /*label*/ 4) int_changes.key = /*label*/ ctx[2];
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(int, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(120:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (87:4) {#if isDynamicsMode($mode)}
    function create_if_block$j(ctx) {
    	let button;
    	let svg;
    	let use;
    	let t0;
    	let int;
    	let t1;
    	let dropdown;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*label*/ ctx[2] },
    			$$inline: true
    		});

    	dropdown = new Dropdown({
    			props: {
    				isActive: /*isActive*/ ctx[1],
    				$$slots: { default: [create_default_slot$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dropdown.$on("dropdownclose", /*onDropdownClose*/ ctx[13]);

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t0 = space();
    			create_component(int.$$.fragment);
    			t1 = space();
    			create_component(dropdown.$$.fragment);
    			xlink_attr(use, "xlink:href", "#txspt-icons-fatArrow");
    			add_location(use, file$19, 93, 14, 2422);
    			attr_dev(svg, "class", "txcm-graphDetailPickerToggleIcon");
    			add_location(svg, file$19, 91, 10, 2349);
    			button.disabled = /*disabled*/ ctx[4];
    			attr_dev(button, "class", "txcm-graphDetailPickerToggle");
    			add_location(button, file$19, 87, 6, 2217);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, use);
    			append_dev(button, t0);
    			mount_component(int, button, null);
    			insert_dev(target, t1, anchor);
    			mount_component(dropdown, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", stop_propagation(/*onToggleClick*/ ctx[12]), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty[0] & /*label*/ 4) int_changes.key = /*label*/ ctx[2];
    			int.$set(int_changes);

    			if (!current || dirty[0] & /*disabled*/ 16) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[4]);
    			}

    			const dropdown_changes = {};
    			if (dirty[0] & /*isActive*/ 2) dropdown_changes.isActive = /*isActive*/ ctx[1];

    			if (dirty[0] & /*isActive, selected, $datePrecision*/ 35 | dirty[1] & /*$$scope*/ 2) {
    				dropdown_changes.$$scope = { dirty, ctx };
    			}

    			dropdown.$set(dropdown_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			transition_in(dropdown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			transition_out(dropdown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(int);
    			if (detaching) detach_dev(t1);
    			destroy_component(dropdown, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(87:4) {#if isDynamicsMode($mode)}",
    		ctx
    	});

    	return block;
    }

    // (110:16) {#if $datePrecision < 3 || ($datePrecision >= 3 && index >= 2)}
    function create_if_block_1$5(ctx) {
    	let graphoptionsdetail;
    	let updating_selected;
    	let current;

    	function graphoptionsdetail_selected_binding(value) {
    		/*graphoptionsdetail_selected_binding*/ ctx[16].call(null, value);
    	}

    	let graphoptionsdetail_props = {
    		value: /*option*/ ctx[29].value,
    		label: /*option*/ ctx[29].label,
    		subLabel: /*option*/ ctx[29].subLabel
    	};

    	if (/*selected*/ ctx[0] !== void 0) {
    		graphoptionsdetail_props.selected = /*selected*/ ctx[0];
    	}

    	graphoptionsdetail = new GraphOptionsDetail({
    			props: graphoptionsdetail_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(graphoptionsdetail, "selected", graphoptionsdetail_selected_binding));

    	const block = {
    		c: function create() {
    			create_component(graphoptionsdetail.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphoptionsdetail, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const graphoptionsdetail_changes = {};

    			if (!updating_selected && dirty[0] & /*selected*/ 1) {
    				updating_selected = true;
    				graphoptionsdetail_changes.selected = /*selected*/ ctx[0];
    				add_flush_callback(() => updating_selected = false);
    			}

    			graphoptionsdetail.$set(graphoptionsdetail_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphoptionsdetail.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphoptionsdetail.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphoptionsdetail, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(110:16) {#if $datePrecision < 3 || ($datePrecision >= 3 && index >= 2)}",
    		ctx
    	});

    	return block;
    }

    // (109:14) {#each dynamicsOptions as option, index}
    function create_each_block$k(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = (/*$datePrecision*/ ctx[5] < 3 || /*$datePrecision*/ ctx[5] >= 3 && /*index*/ ctx[31] >= 2) && create_if_block_1$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$datePrecision*/ ctx[5] < 3 || /*$datePrecision*/ ctx[5] >= 3 && /*index*/ ctx[31] >= 2) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$datePrecision*/ 32) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$k.name,
    		type: "each",
    		source: "(109:14) {#each dynamicsOptions as option, index}",
    		ctx
    	});

    	return block;
    }

    // (100:6) <Dropdown         {isActive}         on:dropdownclose={onDropdownClose}>
    function create_default_slot$p(ctx) {
    	let div;
    	let int;
    	let t;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: "Грануляция" },
    			$$inline: true
    		});

    	let each_value = /*dynamicsOptions*/ ctx[8];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$k(get_each_context$k(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(int.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-graphDetailOptions");
    			toggle_class(div, "txcm-graphDetailOptions-is-active", /*isActive*/ ctx[1]);
    			add_location(div, file$19, 102, 10, 2645);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(int, div, null);
    			append_dev(div, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", stop_propagation(/*click_handler*/ ctx[15]), false, false, true);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*dynamicsOptions, selected, $datePrecision*/ 289) {
    				each_value = /*dynamicsOptions*/ ctx[8];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$k(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$k(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty[0] & /*isActive*/ 2) {
    				toggle_class(div, "txcm-graphDetailOptions-is-active", /*isActive*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$p.name,
    		type: "slot",
    		source: "(100:6) <Dropdown         {isActive}         on:dropdownclose={onDropdownClose}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1n(ctx) {
    	let div;
    	let show_if;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$j, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty[0] & /*$mode*/ 8) show_if = !!/*isDynamicsMode*/ ctx[11](/*$mode*/ ctx[3]);
    		if (show_if) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, [-1]);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block.c();
    			attr_dev(div, "class", "txcm-graphDetailPicker");
    			add_location(div, file$19, 84, 0, 2140);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function fattenDynamicsLabel(result, option) {
    	return {
    		...result,
    		[option.value]: option.subLabel
    	};
    }

    function fattenSliceLabel(result, option) {
    	if (!option.subLabel) return result;

    	return {
    		...result,
    		[option.value]: option.subLabel
    	};
    }

    function instance$1n($$self, $$props, $$invalidate) {
    	let $dynamics;
    	let $mode;
    	let $updating;
    	let $datePrecision;
    	let { indicator } = $$props;
    	const { graphs: graphConfig } = getContext("app").getAppConfig();
    	const dashboard = getContext("config").getDashboard();
    	const mode = getGraphsState("mode");
    	validate_store(mode, "mode");
    	component_subscribe($$self, mode, value => $$invalidate(3, $mode = value));
    	const dynamics = getGraphsState("dynamics");
    	validate_store(dynamics, "dynamics");
    	component_subscribe($$self, dynamics, value => $$invalidate(17, $dynamics = value));
    	const sliceLabels = flattenSliceLabels();
    	const dynamicsLabels = flattenDynamicsLabels();
    	const dynamicsOptions = updateDynamicOptions();
    	const updating = getUIState("updating");
    	validate_store(updating, "updating");
    	component_subscribe($$self, updating, value => $$invalidate(18, $updating = value));
    	const datePrecision = getDashboardState("datePrecision");
    	validate_store(datePrecision, "datePrecision");
    	component_subscribe($$self, datePrecision, value => $$invalidate(5, $datePrecision = value));
    	let selected = $dynamics;
    	let isActive = false;

    	function isDynamicsMode() {
    		return $mode === "graphModeDynamics";
    	}

    	function updateDynamicOptions() {
    		const dynamics = graphConfig.dynamics.slice();
    		if (dashboard === "financial") return dynamics.slice(2);
    		return dynamics;
    	}

    	function flattenDynamicsLabels() {
    		return graphConfig.dynamics.reduce(fattenDynamicsLabel, {});
    	}

    	function flattenSliceLabels() {
    		return graphConfig.modes.reduce(fattenSliceLabel, {});
    	}

    	function renderLabel() {
    		if (isDynamicsMode()) return dynamicsLabels[$dynamics];
    		return sliceLabels[$mode];
    	}

    	function toggle() {
    		$$invalidate(1, isActive = !isActive);
    	}

    	function hide() {
    		$$invalidate(1, isActive = false);
    	}

    	function onToggleClick() {
    		toggle();
    	}

    	function onDropdownClose() {
    		hide();
    	}

    	const writable_props = ["indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GraphOptionsDetails> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("GraphOptionsDetails", $$slots, []);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function graphoptionsdetail_selected_binding(value) {
    		selected = value;
    		$$invalidate(0, selected);
    	}

    	$$self.$set = $$props => {
    		if ("indicator" in $$props) $$invalidate(14, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		getGraphsState,
    		getDashboardState,
    		Int,
    		Dropdown,
    		GraphOptionsDetail,
    		getUIState,
    		indicator,
    		graphConfig,
    		dashboard,
    		mode,
    		dynamics,
    		sliceLabels,
    		dynamicsLabels,
    		dynamicsOptions,
    		updating,
    		datePrecision,
    		selected,
    		isActive,
    		isDynamicsMode,
    		updateDynamicOptions,
    		fattenDynamicsLabel,
    		flattenDynamicsLabels,
    		fattenSliceLabel,
    		flattenSliceLabels,
    		renderLabel,
    		toggle,
    		hide,
    		onToggleClick,
    		onDropdownClose,
    		$dynamics,
    		label,
    		$mode,
    		disabled,
    		$updating,
    		$datePrecision
    	});

    	$$self.$inject_state = $$props => {
    		if ("indicator" in $$props) $$invalidate(14, indicator = $$props.indicator);
    		if ("selected" in $$props) $$invalidate(0, selected = $$props.selected);
    		if ("isActive" in $$props) $$invalidate(1, isActive = $$props.isActive);
    		if ("label" in $$props) $$invalidate(2, label = $$props.label);
    		if ("disabled" in $$props) $$invalidate(4, disabled = $$props.disabled);
    	};

    	let label;
    	let disabled;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*selected*/ 1) {
    			 set_store_value(dynamics, $dynamics = selected);
    		}

    		if ($$self.$$.dirty[0] & /*$mode, $dynamics*/ 131080) {
    			 $$invalidate(2, label = renderLabel());
    		}

    		if ($$self.$$.dirty[0] & /*$updating*/ 262144) {
    			 $$invalidate(4, disabled = $updating > 0);
    		}
    	};

    	return [
    		selected,
    		isActive,
    		label,
    		$mode,
    		disabled,
    		$datePrecision,
    		mode,
    		dynamics,
    		dynamicsOptions,
    		updating,
    		datePrecision,
    		isDynamicsMode,
    		onToggleClick,
    		onDropdownClose,
    		indicator,
    		click_handler,
    		graphoptionsdetail_selected_binding
    	];
    }

    class GraphOptionsDetails extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1n, create_fragment$1n, safe_not_equal, { indicator: 14 }, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GraphOptionsDetails",
    			options,
    			id: create_fragment$1n.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*indicator*/ ctx[14] === undefined && !("indicator" in props)) {
    			console.warn("<GraphOptionsDetails> was created without expected prop 'indicator'");
    		}
    	}

    	get indicator() {
    		throw new Error("<GraphOptionsDetails>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<GraphOptionsDetails>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/graphOptions/GraphOptions.svelte generated by Svelte v3.24.0 */
    const file$1a = "src/js/components/graphOptions/GraphOptions.svelte";

    // (15:4) {#if !indicator || indicator.id != '5'}
    function create_if_block_1$6(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "YoY";
    			attr_dev(div, "class", "txcm-tableHeaderCellLabel");
    			add_location(div, file$1a, 15, 6, 452);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(15:4) {#if !indicator || indicator.id != '5'}",
    		ctx
    	});

    	return block;
    }

    // (18:4) {#if indicator && indicator.id == '5'}
    function create_if_block$k(ctx) {
    	let graphkindoptionsdetails;
    	let current;

    	graphkindoptionsdetails = new GraphKindOptionsDetails({
    			props: { indicator: /*indicator*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphkindoptionsdetails.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphkindoptionsdetails, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const graphkindoptionsdetails_changes = {};
    			if (dirty & /*indicator*/ 1) graphkindoptionsdetails_changes.indicator = /*indicator*/ ctx[0];
    			graphkindoptionsdetails.$set(graphkindoptionsdetails_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphkindoptionsdetails.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphkindoptionsdetails.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphkindoptionsdetails, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(18:4) {#if indicator && indicator.id == '5'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1o(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let graphoptionsdetails;
    	let current;
    	let if_block0 = (!/*indicator*/ ctx[0] || /*indicator*/ ctx[0].id != "5") && create_if_block_1$6(ctx);
    	let if_block1 = /*indicator*/ ctx[0] && /*indicator*/ ctx[0].id == "5" && create_if_block$k(ctx);

    	graphoptionsdetails = new GraphOptionsDetails({
    			props: { indicator: /*indicator*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			create_component(graphoptionsdetails.$$.fragment);
    			attr_dev(div, "class", "txcm-graphOptions");
    			toggle_class(div, "txcm-graphOptions-is-kind", /*indicator*/ ctx[0] && /*indicator*/ ctx[0].id == "5");
    			add_location(div, file$1a, 10, 0, 296);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			mount_component(graphoptionsdetails, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*indicator*/ ctx[0] || /*indicator*/ ctx[0].id != "5") {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_1$6(ctx);
    					if_block0.c();
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*indicator*/ ctx[0] && /*indicator*/ ctx[0].id == "5") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*indicator*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$k(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const graphoptionsdetails_changes = {};
    			if (dirty & /*indicator*/ 1) graphoptionsdetails_changes.indicator = /*indicator*/ ctx[0];
    			graphoptionsdetails.$set(graphoptionsdetails_changes);

    			if (dirty & /*indicator*/ 1) {
    				toggle_class(div, "txcm-graphOptions-is-kind", /*indicator*/ ctx[0] && /*indicator*/ ctx[0].id == "5");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(graphoptionsdetails.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(graphoptionsdetails.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_component(graphoptionsdetails);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1o($$self, $$props, $$invalidate) {
    	let { indicator } = $$props;
    	const writable_props = ["indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GraphOptions> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("GraphOptions", $$slots, []);

    	$$self.$set = $$props => {
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		GraphKindOptionsDetails,
    		GraphOptionsDetails,
    		getGraphsState,
    		indicator
    	});

    	$$self.$inject_state = $$props => {
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [indicator];
    }

    class GraphOptions extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1o, create_fragment$1o, safe_not_equal, { indicator: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GraphOptions",
    			options,
    			id: create_fragment$1o.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*indicator*/ ctx[0] === undefined && !("indicator" in props)) {
    			console.warn("<GraphOptions> was created without expected prop 'indicator'");
    		}
    	}

    	get indicator() {
    		throw new Error("<GraphOptions>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<GraphOptions>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/graphScale/GraphScaleDate.svelte generated by Svelte v3.24.0 */
    const file$1b = "src/js/components/graphScale/GraphScaleDate.svelte";

    function get_each_context$l(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (33:0) {#if fragment}
    function create_if_block$l(ctx) {
    	let div;
    	let current;
    	let each_value = /*fragment*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$l(get_each_context$l(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-graphScale");
    			set_style(div, "--dummyWidth", 100 / /*$count*/ ctx[2] + "%");
    			set_style(div, "transform", "translateX(" + /*$shift*/ ctx[3] + "px)");
    			attr_dev(div, "data-dummy", /*dummy*/ ctx[1]);
    			add_location(div, file$1b, 33, 2, 738);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fragment*/ 1) {
    				each_value = /*fragment*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$l(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$l(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*$count*/ 4) {
    				set_style(div, "--dummyWidth", 100 / /*$count*/ ctx[2] + "%");
    			}

    			if (!current || dirty & /*$shift*/ 8) {
    				set_style(div, "transform", "translateX(" + /*$shift*/ ctx[3] + "px)");
    			}

    			if (!current || dirty & /*dummy*/ 2) {
    				attr_dev(div, "data-dummy", /*dummy*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(33:0) {#if fragment}",
    		ctx
    	});

    	return block;
    }

    // (38:6) {#each fragment as option}
    function create_each_block$l(ctx) {
    	let div1;
    	let div0;
    	let int;
    	let t;
    	let current;

    	int = new Int({
    			props: { key: /*option*/ ctx[11].label },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(int.$$.fragment);
    			t = space();
    			attr_dev(div0, "class", "txcm-graphScaleDateOptionText");
    			add_location(div0, file$1b, 40, 12, 975);
    			attr_dev(div1, "class", "txcm-graphScaleDateOption");
    			add_location(div1, file$1b, 38, 8, 913);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(int, div0, null);
    			append_dev(div1, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*fragment*/ 1) int_changes.key = /*option*/ ctx[11].label;
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$l.name,
    		type: "each",
    		source: "(38:6) {#each fragment as option}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1p(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*fragment*/ ctx[0] && create_if_block$l(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*fragment*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*fragment*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$l(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function updateFragments(values) {
    	return values.slice(0, -1);
    }

    function instance$1p($$self, $$props, $$invalidate) {
    	let $count;
    	let $step;
    	let $shift;
    	const count = getGraphsState("count");
    	validate_store(count, "count");
    	component_subscribe($$self, count, value => $$invalidate(2, $count = value));
    	const step = getGraphsState("step");
    	validate_store(step, "step");
    	component_subscribe($$self, step, value => $$invalidate(8, $step = value));
    	const shift = getGraphsState("shift");
    	validate_store(shift, "shift");
    	component_subscribe($$self, shift, value => $$invalidate(3, $shift = value));
    	let { generator } = $$props;
    	let fragment;
    	let dummy;

    	function updateDummy(values) {
    		return values[$count] ? values[$count].label : "";
    	}

    	async function updateScale() {
    		const values = generator();
    		await tick();
    		$$invalidate(1, dummy = updateDummy(values));
    		$$invalidate(0, fragment = updateFragments(values));
    	}

    	const writable_props = ["generator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GraphScaleDate> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("GraphScaleDate", $$slots, []);

    	$$self.$set = $$props => {
    		if ("generator" in $$props) $$invalidate(7, generator = $$props.generator);
    	};

    	$$self.$capture_state = () => ({
    		tick,
    		getGraphsState,
    		Int,
    		count,
    		step,
    		shift,
    		generator,
    		fragment,
    		dummy,
    		updateDummy,
    		updateFragments,
    		updateScale,
    		$count,
    		$step,
    		$shift
    	});

    	$$self.$inject_state = $$props => {
    		if ("generator" in $$props) $$invalidate(7, generator = $$props.generator);
    		if ("fragment" in $$props) $$invalidate(0, fragment = $$props.fragment);
    		if ("dummy" in $$props) $$invalidate(1, dummy = $$props.dummy);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$count, $step, generator*/ 388) {
    			 updateScale();
    		}
    	};

    	return [fragment, dummy, $count, $shift, count, step, shift, generator];
    }

    class GraphScaleDate extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1p, create_fragment$1p, safe_not_equal, { generator: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GraphScaleDate",
    			options,
    			id: create_fragment$1p.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*generator*/ ctx[7] === undefined && !("generator" in props)) {
    			console.warn("<GraphScaleDate> was created without expected prop 'generator'");
    		}
    	}

    	get generator() {
    		throw new Error("<GraphScaleDate>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set generator(value) {
    		throw new Error("<GraphScaleDate>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/graphScale/GraphScaleFixed.svelte generated by Svelte v3.24.0 */
    const file$1c = "src/js/components/graphScale/GraphScaleFixed.svelte";

    function get_each_context$m(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    // (35:0) {#if fragment}
    function create_if_block$m(ctx) {
    	let div;
    	let current;
    	let each_value = /*fragment*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$m(get_each_context$m(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-graphScale");
    			set_style(div, "--dummyWidth", 100 / /*$count*/ ctx[2] + "%");
    			set_style(div, "transform", "translateX(" + /*$shift*/ ctx[3] + "px)");
    			attr_dev(div, "data-dummy", /*dummy*/ ctx[1]);
    			add_location(div, file$1c, 35, 2, 794);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fragment*/ 1) {
    				each_value = /*fragment*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$m(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$m(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*$count*/ 4) {
    				set_style(div, "--dummyWidth", 100 / /*$count*/ ctx[2] + "%");
    			}

    			if (!current || dirty & /*$shift*/ 8) {
    				set_style(div, "transform", "translateX(" + /*$shift*/ ctx[3] + "px)");
    			}

    			if (!current || dirty & /*dummy*/ 2) {
    				attr_dev(div, "data-dummy", /*dummy*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(35:0) {#if fragment}",
    		ctx
    	});

    	return block;
    }

    // (40:6) {#each fragment as option}
    function create_each_block$m(ctx) {
    	let div1;
    	let div0;
    	let int;
    	let t;
    	let current;

    	int = new Int({
    			props: { key: /*option*/ ctx[12].label },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(int.$$.fragment);
    			t = space();
    			attr_dev(div0, "class", "txcm-graphScaleFixedOptionText");
    			add_location(div0, file$1c, 42, 12, 1032);
    			attr_dev(div1, "class", "txcm-graphScaleFixedOption");
    			add_location(div1, file$1c, 40, 8, 969);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(int, div0, null);
    			append_dev(div1, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*fragment*/ 1) int_changes.key = /*option*/ ctx[12].label;
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$m.name,
    		type: "each",
    		source: "(40:6) {#each fragment as option}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1q(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*fragment*/ ctx[0] && create_if_block$m(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*fragment*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*fragment*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$m(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1q($$self, $$props, $$invalidate) {
    	let $count;
    	let $step;
    	let $shift;
    	const count = getGraphsState("count");
    	validate_store(count, "count");
    	component_subscribe($$self, count, value => $$invalidate(2, $count = value));
    	const step = getGraphsState("step");
    	validate_store(step, "step");
    	component_subscribe($$self, step, value => $$invalidate(8, $step = value));
    	const shift = getGraphsState("shift");
    	validate_store(shift, "shift");
    	component_subscribe($$self, shift, value => $$invalidate(3, $shift = value));
    	let { options } = $$props;
    	let fragment;
    	let dummy;

    	function updateDummy() {
    		const index = $count + $step;
    		if (options[index]) return options[index].label;
    		return "";
    	}

    	function updateFragments() {
    		if ($count >= options.length) return options;
    		return options.slice($step, $step + $count);
    	}

    	async function updateScale() {
    		await tick();
    		$$invalidate(0, fragment = updateFragments());
    		$$invalidate(1, dummy = updateDummy());
    	}

    	const writable_props = ["options"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GraphScaleFixed> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("GraphScaleFixed", $$slots, []);

    	$$self.$set = $$props => {
    		if ("options" in $$props) $$invalidate(7, options = $$props.options);
    	};

    	$$self.$capture_state = () => ({
    		tick,
    		getGraphsState,
    		Int,
    		count,
    		step,
    		shift,
    		options,
    		fragment,
    		dummy,
    		updateDummy,
    		updateFragments,
    		updateScale,
    		$count,
    		$step,
    		$shift
    	});

    	$$self.$inject_state = $$props => {
    		if ("options" in $$props) $$invalidate(7, options = $$props.options);
    		if ("fragment" in $$props) $$invalidate(0, fragment = $$props.fragment);
    		if ("dummy" in $$props) $$invalidate(1, dummy = $$props.dummy);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$count, $step, options*/ 388) {
    			 updateScale();
    		}
    	};

    	return [fragment, dummy, $count, $shift, count, step, shift, options];
    }

    class GraphScaleFixed extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1q, create_fragment$1q, safe_not_equal, { options: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GraphScaleFixed",
    			options,
    			id: create_fragment$1q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*options*/ ctx[7] === undefined && !("options" in props)) {
    			console.warn("<GraphScaleFixed> was created without expected prop 'options'");
    		}
    	}

    	get options() {
    		throw new Error("<GraphScaleFixed>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<GraphScaleFixed>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/graphStickers/GraphsSticker.svelte generated by Svelte v3.24.0 */
    const file$1d = "src/js/components/graphStickers/GraphsSticker.svelte";

    function create_fragment$1r(ctx) {
    	let div;
    	let int;
    	let current;

    	int = new Int({
    			props: { key: /*sticker*/ ctx[0].label },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(int.$$.fragment);
    			attr_dev(div, "class", "txcm-graphScaleDateSticker");
    			set_style(div, "left", 100 / /*count*/ ctx[1] * /*stepStart*/ ctx[2] + "%");
    			set_style(div, "width", 100 / /*count*/ ctx[1] + "%");
    			set_style(div, "transform", "translateX(" + /*relativeShift*/ ctx[3] + "px)");
    			add_location(div, file$1d, 49, 0, 960);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(int, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const int_changes = {};
    			if (dirty & /*sticker*/ 1) int_changes.key = /*sticker*/ ctx[0].label;
    			int.$set(int_changes);

    			if (!current || dirty & /*count, stepStart*/ 6) {
    				set_style(div, "left", 100 / /*count*/ ctx[1] * /*stepStart*/ ctx[2] + "%");
    			}

    			if (!current || dirty & /*count*/ 2) {
    				set_style(div, "width", 100 / /*count*/ ctx[1] + "%");
    			}

    			if (!current || dirty & /*relativeShift*/ 8) {
    				set_style(div, "transform", "translateX(" + /*relativeShift*/ ctx[3] + "px)");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1r($$self, $$props, $$invalidate) {
    	let { sticker } = $$props;
    	let { scroll } = $$props;
    	let { shift } = $$props;
    	let { count } = $$props;
    	let { step } = $$props;
    	let { stepWidth } = $$props;
    	let stepStart;
    	let stepFinish;
    	let stepsSpace;

    	function updateSticker() {
    		$$invalidate(2, { stepStart, stepFinish } = sticker, stepStart);
    		stepsSpace = stepFinish - stepStart;
    	}

    	function shouldShow() {
    		return step < stepStart;
    	}

    	function shouldStick() {
    		return step >= stepStart && step < stepFinish;
    	}

    	function show() {
    		return -scroll;
    	}

    	function stick() {
    		return stepWidth * (step - stepStart) - scroll - shift;
    	}

    	function hide() {
    		return stepWidth * stepsSpace - scroll;
    	}

    	function updateRelativeShift() {
    		if (shouldShow()) return show(); else if (shouldStick()) return stick();
    		return hide();
    	}

    	const writable_props = ["sticker", "scroll", "shift", "count", "step", "stepWidth"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GraphsSticker> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("GraphsSticker", $$slots, []);

    	$$self.$set = $$props => {
    		if ("sticker" in $$props) $$invalidate(0, sticker = $$props.sticker);
    		if ("scroll" in $$props) $$invalidate(4, scroll = $$props.scroll);
    		if ("shift" in $$props) $$invalidate(5, shift = $$props.shift);
    		if ("count" in $$props) $$invalidate(1, count = $$props.count);
    		if ("step" in $$props) $$invalidate(6, step = $$props.step);
    		if ("stepWidth" in $$props) $$invalidate(7, stepWidth = $$props.stepWidth);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		sticker,
    		scroll,
    		shift,
    		count,
    		step,
    		stepWidth,
    		stepStart,
    		stepFinish,
    		stepsSpace,
    		updateSticker,
    		shouldShow,
    		shouldStick,
    		show,
    		stick,
    		hide,
    		updateRelativeShift,
    		relativeShift
    	});

    	$$self.$inject_state = $$props => {
    		if ("sticker" in $$props) $$invalidate(0, sticker = $$props.sticker);
    		if ("scroll" in $$props) $$invalidate(4, scroll = $$props.scroll);
    		if ("shift" in $$props) $$invalidate(5, shift = $$props.shift);
    		if ("count" in $$props) $$invalidate(1, count = $$props.count);
    		if ("step" in $$props) $$invalidate(6, step = $$props.step);
    		if ("stepWidth" in $$props) $$invalidate(7, stepWidth = $$props.stepWidth);
    		if ("stepStart" in $$props) $$invalidate(2, stepStart = $$props.stepStart);
    		if ("stepFinish" in $$props) stepFinish = $$props.stepFinish;
    		if ("stepsSpace" in $$props) stepsSpace = $$props.stepsSpace;
    		if ("relativeShift" in $$props) $$invalidate(3, relativeShift = $$props.relativeShift);
    	};

    	let relativeShift;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*sticker*/ 1) {
    			 updateSticker();
    		}

    		if ($$self.$$.dirty & /*step, shift*/ 96) {
    			 $$invalidate(3, relativeShift = updateRelativeShift());
    		}
    	};

    	return [sticker, count, stepStart, relativeShift, scroll, shift, step, stepWidth];
    }

    class GraphsSticker extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1r, create_fragment$1r, safe_not_equal, {
    			sticker: 0,
    			scroll: 4,
    			shift: 5,
    			count: 1,
    			step: 6,
    			stepWidth: 7
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GraphsSticker",
    			options,
    			id: create_fragment$1r.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*sticker*/ ctx[0] === undefined && !("sticker" in props)) {
    			console.warn("<GraphsSticker> was created without expected prop 'sticker'");
    		}

    		if (/*scroll*/ ctx[4] === undefined && !("scroll" in props)) {
    			console.warn("<GraphsSticker> was created without expected prop 'scroll'");
    		}

    		if (/*shift*/ ctx[5] === undefined && !("shift" in props)) {
    			console.warn("<GraphsSticker> was created without expected prop 'shift'");
    		}

    		if (/*count*/ ctx[1] === undefined && !("count" in props)) {
    			console.warn("<GraphsSticker> was created without expected prop 'count'");
    		}

    		if (/*step*/ ctx[6] === undefined && !("step" in props)) {
    			console.warn("<GraphsSticker> was created without expected prop 'step'");
    		}

    		if (/*stepWidth*/ ctx[7] === undefined && !("stepWidth" in props)) {
    			console.warn("<GraphsSticker> was created without expected prop 'stepWidth'");
    		}
    	}

    	get sticker() {
    		throw new Error("<GraphsSticker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sticker(value) {
    		throw new Error("<GraphsSticker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scroll() {
    		throw new Error("<GraphsSticker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scroll(value) {
    		throw new Error("<GraphsSticker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shift() {
    		throw new Error("<GraphsSticker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shift(value) {
    		throw new Error("<GraphsSticker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<GraphsSticker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<GraphsSticker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get step() {
    		throw new Error("<GraphsSticker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set step(value) {
    		throw new Error("<GraphsSticker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stepWidth() {
    		throw new Error("<GraphsSticker>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stepWidth(value) {
    		throw new Error("<GraphsSticker>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/graphStickers/GraphStickers.svelte generated by Svelte v3.24.0 */

    function get_each_context$n(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    // (30:0) {#if fragment}
    function create_if_block$n(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*fragment*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$n(get_each_context$n(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fragment, scroll, stepWidth, $count, $step, $shift*/ 63) {
    				each_value = /*fragment*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$n(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$n(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(30:0) {#if fragment}",
    		ctx
    	});

    	return block;
    }

    // (31:2) {#each fragment as sticker}
    function create_each_block$n(ctx) {
    	let graphssticker;
    	let current;

    	graphssticker = new GraphsSticker({
    			props: {
    				sticker: /*sticker*/ ctx[12],
    				scroll: /*scroll*/ ctx[0],
    				stepWidth: /*stepWidth*/ ctx[1],
    				count: /*$count*/ ctx[3],
    				step: /*$step*/ ctx[4],
    				shift: /*$shift*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphssticker.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphssticker, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const graphssticker_changes = {};
    			if (dirty & /*fragment*/ 4) graphssticker_changes.sticker = /*sticker*/ ctx[12];
    			if (dirty & /*scroll*/ 1) graphssticker_changes.scroll = /*scroll*/ ctx[0];
    			if (dirty & /*stepWidth*/ 2) graphssticker_changes.stepWidth = /*stepWidth*/ ctx[1];
    			if (dirty & /*$count*/ 8) graphssticker_changes.count = /*$count*/ ctx[3];
    			if (dirty & /*$step*/ 16) graphssticker_changes.step = /*$step*/ ctx[4];
    			if (dirty & /*$shift*/ 32) graphssticker_changes.shift = /*$shift*/ ctx[5];
    			graphssticker.$set(graphssticker_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphssticker.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphssticker.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphssticker, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$n.name,
    		type: "each",
    		source: "(31:2) {#each fragment as sticker}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1s(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*fragment*/ ctx[2] && create_if_block$n(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*fragment*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*fragment*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$n(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1s($$self, $$props, $$invalidate) {
    	let $count;
    	let $step;
    	let $shift;
    	const count = getGraphsState("count");
    	validate_store(count, "count");
    	component_subscribe($$self, count, value => $$invalidate(3, $count = value));
    	const step = getGraphsState("step");
    	validate_store(step, "step");
    	component_subscribe($$self, step, value => $$invalidate(4, $step = value));
    	const shift = getGraphsState("shift");
    	validate_store(shift, "shift");
    	component_subscribe($$self, shift, value => $$invalidate(5, $shift = value));
    	let { stickers } = $$props;
    	let { scroll } = $$props;
    	let { stepWidth } = $$props;
    	let fragment;

    	function filterSticker(sticker) {
    		const { stepStart, stepFinish } = sticker;
    		const stepSpace = $count;
    		return $step > stepStart - stepSpace && $step < stepFinish + stepSpace;
    	}

    	async function updateStickers() {
    		await tick();
    		$$invalidate(2, fragment = stickers.filter(filterSticker));
    	}

    	const writable_props = ["stickers", "scroll", "stepWidth"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GraphStickers> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("GraphStickers", $$slots, []);

    	$$self.$set = $$props => {
    		if ("stickers" in $$props) $$invalidate(9, stickers = $$props.stickers);
    		if ("scroll" in $$props) $$invalidate(0, scroll = $$props.scroll);
    		if ("stepWidth" in $$props) $$invalidate(1, stepWidth = $$props.stepWidth);
    	};

    	$$self.$capture_state = () => ({
    		tick,
    		getGraphsState,
    		GraphsSticker,
    		count,
    		step,
    		shift,
    		stickers,
    		scroll,
    		stepWidth,
    		fragment,
    		filterSticker,
    		updateStickers,
    		$count,
    		$step,
    		$shift
    	});

    	$$self.$inject_state = $$props => {
    		if ("stickers" in $$props) $$invalidate(9, stickers = $$props.stickers);
    		if ("scroll" in $$props) $$invalidate(0, scroll = $$props.scroll);
    		if ("stepWidth" in $$props) $$invalidate(1, stepWidth = $$props.stepWidth);
    		if ("fragment" in $$props) $$invalidate(2, fragment = $$props.fragment);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$count, $step, stickers*/ 536) {
    			 updateStickers();
    		}
    	};

    	return [
    		scroll,
    		stepWidth,
    		fragment,
    		$count,
    		$step,
    		$shift,
    		count,
    		step,
    		shift,
    		stickers
    	];
    }

    class GraphStickers extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1s, create_fragment$1s, safe_not_equal, { stickers: 9, scroll: 0, stepWidth: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GraphStickers",
    			options,
    			id: create_fragment$1s.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*stickers*/ ctx[9] === undefined && !("stickers" in props)) {
    			console.warn("<GraphStickers> was created without expected prop 'stickers'");
    		}

    		if (/*scroll*/ ctx[0] === undefined && !("scroll" in props)) {
    			console.warn("<GraphStickers> was created without expected prop 'scroll'");
    		}

    		if (/*stepWidth*/ ctx[1] === undefined && !("stepWidth" in props)) {
    			console.warn("<GraphStickers> was created without expected prop 'stepWidth'");
    		}
    	}

    	get stickers() {
    		throw new Error("<GraphStickers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stickers(value) {
    		throw new Error("<GraphStickers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get scroll() {
    		throw new Error("<GraphStickers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set scroll(value) {
    		throw new Error("<GraphStickers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get stepWidth() {
    		throw new Error("<GraphStickers>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set stepWidth(value) {
    		throw new Error("<GraphStickers>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/graphHeader/GraphHeaderScrollTrack.svelte generated by Svelte v3.24.0 */
    const file$1e = "src/js/components/graphHeader/GraphHeaderScrollTrack.svelte";

    function create_fragment$1t(ctx) {
    	let div1;
    	let div0;
    	let div1_resize_listener;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			attr_dev(div0, "class", "txcm-graphScrollThumb");
    			set_style(div0, "transform", "translateX(" + /*thumbPosition*/ ctx[1] + "px)");
    			add_location(div0, file$1e, 87, 4, 2673);
    			attr_dev(div1, "class", "txcm-graphScroll");
    			add_render_callback(() => /*div1_elementresize_handler*/ ctx[9].call(div1));
    			add_location(div1, file$1e, 81, 0, 2453);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			div1_resize_listener = add_resize_listener(div1, /*div1_elementresize_handler*/ ctx[9].bind(div1));

    			if (!mounted) {
    				dispose = [
    					listen_dev(div0, "click", stop_propagation(prevent_default(/*click_handler*/ ctx[8])), false, true, true),
    					listen_dev(div0, "mousedown", prevent_default(/*onThumbPointerDown*/ ctx[5]), false, true, false),
    					listen_dev(div0, "touchstart", prevent_default(/*onThumbPointerDown*/ ctx[5]), false, true, false),
    					listen_dev(div1, "click", stop_propagation(prevent_default(/*onScrollClick*/ ctx[4])), false, true, true),
    					listen_dev(div1, "mousedown", stop_propagation(prevent_default(/*mousedown_handler*/ ctx[6])), false, true, true),
    					listen_dev(div1, "touchstart", stop_propagation(prevent_default(/*touchstart_handler*/ ctx[7])), false, true, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*thumbPosition*/ 2) {
    				set_style(div0, "transform", "translateX(" + /*thumbPosition*/ ctx[1] + "px)");
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			div1_resize_listener();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const THUMB_WIDTH = 80;
    const CLICK_SHIFT = 50;

    function instance$1t($$self, $$props, $$invalidate) {
    	let $scroll;
    	let $scrollMax;
    	let trackWidth;
    	let scrollStart;
    	let thumbPositionStart;
    	const scroll = getGraphsState("scroll");
    	validate_store(scroll, "scroll");
    	component_subscribe($$self, scroll, value => $$invalidate(13, $scroll = value));
    	const scrollMax = getGraphsState("scrollMax");
    	validate_store(scrollMax, "scrollMax");
    	component_subscribe($$self, scrollMax, value => $$invalidate(14, $scrollMax = value));

    	function calculateThumbPosition() {
    		const ratio = $scroll / $scrollMax;
    		return (trackWidth - THUMB_WIDTH) * ratio;
    	}

    	function calculateThumbDistance() {
    		return trackWidth - THUMB_WIDTH;
    	}

    	function updateDragScroll(clientX) {
    		const thumbPositionDiff = clientX - thumbPositionStart;
    		const ratio = thumbPositionDiff / thumbDistance;
    		const scrollDelta = $scrollMax * ratio;
    		if (scrollStart + scrollDelta <= 0) set_store_value(scroll, $scroll = 0); else if (scrollStart + scrollDelta >= $scrollMax) set_store_value(scroll, $scroll = $scrollMax); else set_store_value(scroll, $scroll = scrollStart + scrollDelta);
    	}

    	function updateClickSroll(offsetX) {
    		const diff = offsetX - thumbPosition;

    		if (diff > 0) {
    			const direction = Math.abs(diff) / diff;
    			const scrollDelta = CLICK_SHIFT * direction;
    			if ($scroll + scrollDelta <= 0) set_store_value(scroll, $scroll = 0); else if ($scroll + scrollDelta >= $scrollMax) set_store_value(scroll, $scroll = $scrollMax); else set_store_value(scroll, $scroll += scrollDelta);
    		}
    	}

    	function onScrollClick({ offsetX }) {
    		updateClickSroll(offsetX);
    	}

    	function onThumbPointerMove(event) {
    		const { clientX } = event.touches ? event.touches[0] : event;
    		updateDragScroll(clientX);
    	}

    	function onThumbPointerUp(event) {
    		event.preventDefault();
    		unsubscribeWindow();
    	}

    	function onThumbPointerDown(event) {
    		const { clientX } = event.touches ? event.touches[0] : event;
    		scrollStart = $scroll;
    		thumbPositionStart = clientX;
    		subscribeWindow();
    	}

    	function subscribeWindow() {
    		window.addEventListener("mousemove", onThumbPointerMove);
    		window.addEventListener("touchmove", onThumbPointerMove);
    		window.addEventListener("mouseup", onThumbPointerUp);
    		window.addEventListener("touchend", onThumbPointerUp);
    	}

    	function unsubscribeWindow() {
    		window.removeEventListener("mousemove", onThumbPointerMove);
    		window.removeEventListener("touchmove", onThumbPointerMove);
    		window.removeEventListener("mouseup", onThumbPointerUp);
    		window.removeEventListener("touchend", onThumbPointerUp);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GraphHeaderScrollTrack> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("GraphHeaderScrollTrack", $$slots, []);

    	function mousedown_handler(event) {
    		bubble($$self, event);
    	}

    	function touchstart_handler(event) {
    		bubble($$self, event);
    	}

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function div1_elementresize_handler() {
    		trackWidth = this.clientWidth;
    		$$invalidate(0, trackWidth);
    	}

    	$$self.$capture_state = () => ({
    		getGraphsState,
    		THUMB_WIDTH,
    		CLICK_SHIFT,
    		trackWidth,
    		scrollStart,
    		thumbPositionStart,
    		scroll,
    		scrollMax,
    		calculateThumbPosition,
    		calculateThumbDistance,
    		updateDragScroll,
    		updateClickSroll,
    		onScrollClick,
    		onThumbPointerMove,
    		onThumbPointerUp,
    		onThumbPointerDown,
    		subscribeWindow,
    		unsubscribeWindow,
    		thumbDistance,
    		thumbPosition,
    		$scroll,
    		$scrollMax
    	});

    	$$self.$inject_state = $$props => {
    		if ("trackWidth" in $$props) $$invalidate(0, trackWidth = $$props.trackWidth);
    		if ("scrollStart" in $$props) scrollStart = $$props.scrollStart;
    		if ("thumbPositionStart" in $$props) thumbPositionStart = $$props.thumbPositionStart;
    		if ("thumbDistance" in $$props) thumbDistance = $$props.thumbDistance;
    		if ("thumbPosition" in $$props) $$invalidate(1, thumbPosition = $$props.thumbPosition);
    	};

    	let thumbDistance;
    	let thumbPosition;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*trackWidth*/ 1) {
    			 thumbDistance = calculateThumbDistance();
    		}

    		if ($$self.$$.dirty & /*trackWidth, $scroll, $scrollMax*/ 24577) {
    			 $$invalidate(1, thumbPosition = calculateThumbPosition());
    		}
    	};

    	return [
    		trackWidth,
    		thumbPosition,
    		scroll,
    		scrollMax,
    		onScrollClick,
    		onThumbPointerDown,
    		mousedown_handler,
    		touchstart_handler,
    		click_handler,
    		div1_elementresize_handler
    	];
    }

    class GraphHeaderScrollTrack extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1t, create_fragment$1t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GraphHeaderScrollTrack",
    			options,
    			id: create_fragment$1t.name
    		});
    	}
    }

    /* src/js/components/graphHeader/GraphHeader.svelte generated by Svelte v3.24.0 */

    const { window: window_1 } = globals;
    const file$1f = "src/js/components/graphHeader/GraphHeader.svelte";

    // (495:4) {:else}
    function create_else_block$3(ctx) {
    	let graphscaledate;
    	let t;
    	let if_block_anchor;
    	let current;

    	graphscaledate = new GraphScaleDate({
    			props: { generator: /*generator*/ ctx[3] },
    			$$inline: true
    		});

    	let if_block = /*stickers*/ ctx[4] && create_if_block_2$2(ctx);

    	const block = {
    		c: function create() {
    			create_component(graphscaledate.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphscaledate, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const graphscaledate_changes = {};
    			if (dirty[0] & /*generator*/ 8) graphscaledate_changes.generator = /*generator*/ ctx[3];
    			graphscaledate.$set(graphscaledate_changes);

    			if (/*stickers*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*stickers*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphscaledate.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphscaledate.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphscaledate, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(495:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (492:4) {#if isFixedScale($mode)}
    function create_if_block_1$7(ctx) {
    	let graphscalefixed;
    	let current;

    	graphscalefixed = new GraphScaleFixed({
    			props: { options: /*options*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphscalefixed.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphscalefixed, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const graphscalefixed_changes = {};
    			if (dirty[0] & /*options*/ 4) graphscalefixed_changes.options = /*options*/ ctx[2];
    			graphscalefixed.$set(graphscalefixed_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphscalefixed.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphscalefixed.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphscalefixed, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(492:4) {#if isFixedScale($mode)}",
    		ctx
    	});

    	return block;
    }

    // (498:6) {#if stickers}
    function create_if_block_2$2(ctx) {
    	let graphstickers;
    	let current;

    	graphstickers = new GraphStickers({
    			props: {
    				scroll: /*$scroll*/ ctx[7],
    				stickers: /*stickers*/ ctx[4],
    				stepWidth: /*$optionWidthMax*/ ctx[9]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(graphstickers.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphstickers, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const graphstickers_changes = {};
    			if (dirty[0] & /*$scroll*/ 128) graphstickers_changes.scroll = /*$scroll*/ ctx[7];
    			if (dirty[0] & /*stickers*/ 16) graphstickers_changes.stickers = /*stickers*/ ctx[4];
    			if (dirty[0] & /*$optionWidthMax*/ 512) graphstickers_changes.stepWidth = /*$optionWidthMax*/ ctx[9];
    			graphstickers.$set(graphstickers_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphstickers.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphstickers.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphstickers, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(498:6) {#if stickers}",
    		ctx
    	});

    	return block;
    }

    // (505:4) {#if isHaveScroll($count, stepMax)}
    function create_if_block$o(ctx) {
    	let graphheaderscrolltrack;
    	let current;
    	graphheaderscrolltrack = new GraphHeaderScrollTrack({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(graphheaderscrolltrack.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphheaderscrolltrack, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphheaderscrolltrack.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphheaderscrolltrack.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphheaderscrolltrack, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(505:4) {#if isHaveScroll($count, stepMax)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1u(ctx) {
    	let div;
    	let show_if_1;
    	let current_block_type_index;
    	let if_block0;
    	let t;
    	let show_if = /*isHaveScroll*/ ctx[23](/*$count*/ ctx[5], /*stepMax*/ ctx[8]);
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1$7, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (dirty[0] & /*$mode*/ 2) show_if_1 = !!/*isFixedScale*/ ctx[24](/*$mode*/ ctx[1]);
    		if (show_if_1) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx, [-1]);
    	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block1 = show_if && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", div_class_value = `txcm-graphHeader${/*renderStatusClass*/ ctx[25](/*$status*/ ctx[6])}`);
    			add_location(div, file$1f, 485, 0, 15529);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);
    			/*div_binding*/ ctx[30](div);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window_1, "resize", /*onResize*/ ctx[28], false, false, false),
    					listen_dev(window_1, "mousemove", /*onMouseMove*/ ctx[26], false, false, false),
    					listen_dev(div, "wheel", /*onWheel*/ ctx[27], false, false, false),
    					listen_dev(div, "mousedown", stop_propagation(prevent_default(/*onPointerDown*/ ctx[29])), false, true, true),
    					listen_dev(div, "touchstart", stop_propagation(prevent_default(/*onPointerDown*/ ctx[29])), false, true, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx, dirty);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block0 = if_blocks[current_block_type_index];

    				if (!if_block0) {
    					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block0.c();
    				}

    				transition_in(if_block0, 1);
    				if_block0.m(div, t);
    			}

    			if (dirty[0] & /*$count, stepMax*/ 288) show_if = /*isHaveScroll*/ ctx[23](/*$count*/ ctx[5], /*stepMax*/ ctx[8]);

    			if (show_if) {
    				if (if_block1) {
    					if (dirty[0] & /*$count, stepMax*/ 288) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$o(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*$status*/ 64 && div_class_value !== (div_class_value = `txcm-graphHeader${/*renderStatusClass*/ ctx[25](/*$status*/ ctx[6])}`)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			if (if_block1) if_block1.d();
    			/*div_binding*/ ctx[30](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const SCALE_DAYS_COUNT = 30;
    const SCALE_WEEKS_COUNT = 11;

    function generateDayOptions$1() {
    	return { length: SCALE_DAYS_COUNT + 1 };
    }

    function generateWeekOptions() {
    	return { length: SCALE_WEEKS_COUNT };
    }

    function shouldScroll(deltaX) {
    	return Math.abs(deltaX) > 0;
    }

    function instance$1u($$self, $$props, $$invalidate) {
    	let $date;
    	let $dynamics;
    	let $mode;
    	let $locale;
    	let $count;
    	let $status;
    	let $scroll;
    	let $scrollMax;
    	let $optionWidthMax;
    	let $sectionScrollX;
    	let $step;
    	let $highlighted;
    	let $shift;
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(43, $locale = value));
    	const SCALE_FIXED_VALUES = ["graphModeCounty", "graphModeFormat", "graphModeCategory"];

    	const SCALE_FIXED_OPTION_WIDTHS = {
    		graphModeCounty: 90,
    		graphModeFormat: 50,
    		graphModeCategory: 90
    	};

    	const SCALE_DATE_OPTION_WIDTHS = {
    		graphDetailDay: 40,
    		graphDetailAvgCheck: 40,
    		graphDetailWeek: 40,
    		graphDetailMonth: 50,
    		graphDetailQuarter: 70,
    		graphDetailYear: 40
    	};

    	const sectionScrollX = getUIState("sectionScrollX");
    	validate_store(sectionScrollX, "sectionScrollX");
    	component_subscribe($$self, sectionScrollX, value => $$invalidate(45, $sectionScrollX = value));
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(40, $date = value));
    	const appConfig = getContext("app").getAppConfig();
    	const graphConfig = appConfig.graphs;
    	const { dateMin, dateMax } = appConfig;
    	const fixedOptions = flattenFixedOptions();
    	const mode = getGraphsState("mode");
    	validate_store(mode, "mode");
    	component_subscribe($$self, mode, value => $$invalidate(1, $mode = value));
    	const dynamics = getGraphsState("dynamics");
    	validate_store(dynamics, "dynamics");
    	component_subscribe($$self, dynamics, value => $$invalidate(41, $dynamics = value));
    	const count = getGraphsState("count");
    	validate_store(count, "count");
    	component_subscribe($$self, count, value => $$invalidate(5, $count = value));
    	const step = getGraphsState("step");
    	validate_store(step, "step");
    	component_subscribe($$self, step, value => $$invalidate(46, $step = value));
    	const highlighted = getGraphsState("highlighted");
    	validate_store(highlighted, "highlighted");
    	component_subscribe($$self, highlighted, value => $$invalidate(47, $highlighted = value));
    	const shift = getGraphsState("shift");
    	validate_store(shift, "shift");
    	component_subscribe($$self, shift, value => $$invalidate(48, $shift = value));
    	const status = getGraphsState("status");
    	validate_store(status, "status");
    	component_subscribe($$self, status, value => $$invalidate(6, $status = value));
    	const weeksCache = generateYearsWeekCache(dateMin, dateMax);
    	const weekRangesCache = generateYearsWeekRangeCache(dateMin, dateMax, weeksCache);
    	const optionWidthMax = getGraphsState("optionWidthMax");
    	validate_store(optionWidthMax, "optionWidthMax");
    	component_subscribe($$self, optionWidthMax, value => $$invalidate(9, $optionWidthMax = value));
    	const scroll = getGraphsState("scroll");
    	validate_store(scroll, "scroll");
    	component_subscribe($$self, scroll, value => $$invalidate(7, $scroll = value));
    	const scrollMax = getGraphsState("scrollMax");
    	validate_store(scrollMax, "scrollMax");
    	component_subscribe($$self, scrollMax, value => $$invalidate(44, $scrollMax = value));
    	let node;
    	let width;
    	let top;
    	let left;
    	let pointer = null;
    	let pointerPositionStart;
    	let pointerScrollStart;
    	let pointerPositionCurrent;
    	let isPointDown = false;
    	onMount(measureComponent);

    	function isHaveScroll() {
    		return stepMax > 0;
    	}

    	function isFixedScale() {
    		return SCALE_FIXED_VALUES.includes($mode);
    	}

    	function isDaysOption() {
    		return $dynamics === graphConfig.dynamics[0].value;
    	}

    	function isWeeksOption() {
    		return $dynamics === graphConfig.dynamics[1].value;
    	}

    	function isMonthsOption() {
    		return $dynamics === graphConfig.dynamics[2].value;
    	}

    	function isQuartersDaysOption() {
    		return $dynamics === graphConfig.dynamics[3].value;
    	}

    	function measureComponent() {
    		if (node) {
    			const rect = node.getBoundingClientRect();
    			$$invalidate(31, { left, top, width } = rect, width);
    		}
    	}

    	function fattenFixedOption(result, option) {
    		if (option.options) {
    			return {
    				...result,
    				[option.value]: appConfig[option.options]
    			};
    		}

    		return result;
    	}

    	function flattenFixedOptions() {
    		return graphConfig.modes.reduce(fattenFixedOption, {});
    	}

    	function pickOptionWidthBase() {
    		if (isFixedScale()) return SCALE_FIXED_OPTION_WIDTHS[$mode];
    		return SCALE_DATE_OPTION_WIDTHS[$dynamics];
    	}

    	function generateMonthOptions() {
    		return {
    			length: calculateDatesMonthsCount(datePoP, $date)
    		};
    	}

    	function generateQuarterOptions() {
    		return {
    			length: calculateDatesQuartersCount(datePoP, $date)
    		};
    	}

    	function generateYearOptions() {
    		return {
    			length: calculateDatesYearsCount(datePoP, $date)
    		};
    	}

    	function generateDateOptions() {
    		if (isDaysOption()) return generateDayOptions$1(); else if (isWeeksOption()) return generateWeekOptions(); else if (isMonthsOption()) return generateMonthOptions(); else if (isQuartersDaysOption()) return generateQuarterOptions();
    		return generateYearOptions();
    	}

    	function pickOptions() {
    		if (isFixedScale()) return fixedOptions[$mode];
    		return generateDateOptions();
    	}

    	function generateDayFragment() {
    		const daysDateMin = new Date(datePoP).getTime();
    		const startOption = daysDateMin + DAY * $step;
    		const result = [];

    		for (let index = 0; index <= $count; ++index) {
    			const timestamp = startOption + index * DAY;
    			const label = new Date(timestamp).getDate();
    			result.push({ label });
    		}

    		return result;
    	}

    	function generateWeekFragment() {
    		const weeksDateObjectMin = new Date(datePoP);
    		const yearMin = weeksDateObjectMin.getFullYear();
    		const monthMin = weeksDateObjectMin.getMonth();
    		const dayMin = weeksDateObjectMin.getDate();
    		const weekStart = calculateWeekNumber(dayMin, monthMin, yearMin);
    		let weekCount = calculateWeekNumber(31, 11, yearMin);
    		weekCount = weekCount === 1 ? 52 : weekCount;
    		const result = [];

    		for (let index = 0; index <= $count; index += 1) {
    			const week = (weekStart + $step + index - 1) % weekCount + 1;
    			const label = `${week}`;
    			result.push({ label });
    		}

    		return result;
    	}

    	function generateMonthFragment() {
    		const monthsDateObjectMin = new Date(datePoP);
    		const monthStart = monthsDateObjectMin.getMonth();
    		const result = [];

    		for (let index = 0; index <= $count; index += 1) {
    			const month = (monthStart + $step + index) % 12;
    			const label = renderMonthShort(Date.UTC(2000, month, 1), $locale);
    			result.push({ label });
    		}

    		return result;
    	}

    	function generateQuarterFragment() {
    		const quarterStart = 4 - calculateQuartersRestCount(datePoP);
    		const result = [];

    		for (let index = 0; index <= $count; index += 1) {
    			const quarter = (quarterStart + $step + index) % 4 + 1;
    			const label = `${quarter} ${translate("квартал", $locale)}`;
    			result.push({ label });
    		}

    		return result;
    	}

    	function generateYearFragment() {
    		const yearMin = new Date(datePoP).getFullYear();
    		const result = [];

    		for (let index = 0; index <= $count; index += 1) {
    			const year = yearMin + $step + index;
    			const label = year;
    			result.push({ label });
    		}

    		return result;
    	}

    	function pickGenerator() {
    		if (isDaysOption()) return generateDayFragment; else if (isWeeksOption()) return generateWeekFragment; else if (isMonthsOption()) return generateMonthFragment; else if (isQuartersDaysOption()) return generateQuarterFragment;
    		return generateYearFragment;
    	}

    	function generateDayStickers() {
    		const daysDateMin = new Date(datePoP).getTime();
    		const daysDatObjectMin = new Date(daysDateMin);
    		const yearMin = daysDatObjectMin.getFullYear();
    		const monthMin = daysDatObjectMin.getMonth();
    		const dayMin = daysDatObjectMin.getDate();
    		const daysDatObjectMax = new Date($date);
    		const yearMax = daysDatObjectMax.getFullYear();
    		const monthMax = daysDatObjectMax.getMonth();
    		const yearsCount = calculateDatesYearsCount(daysDateMin, $date);
    		const result = [];

    		for (let yearShift = 0; yearShift < yearsCount; yearShift += 1) {
    			const year = yearMin + yearShift;
    			const monthStart = year !== yearMin ? 0 : monthMin;
    			const monthLimit = year !== yearMax ? 12 : monthMax + 1;

    			for (let month = monthStart; month < monthLimit; month += 1) {
    				const timestamp = Date.UTC(year, month + 1, 0);
    				const label = `${renderMonthLong(timestamp, $locale)} ${year}`;
    				const days = calcuateMonthDayCount(timestamp);
    				const index = yearShift * 12 + month - monthMin;
    				const stepStart = index !== 0 ? result[index - 1].stepFinish + 1 : 0;

    				const stepFinish = index !== 0
    				? stepStart + days - 1
    				: stepStart + (days - dayMin);

    				result.push({ label, stepStart, stepFinish });
    			}
    		}

    		return result;
    	}

    	function generateWeekStickers() {
    		const weeksDateMin = subtractWeeks($date, SCALE_WEEKS_COUNT);
    		const weeksDateObjectMin = new Date(weeksDateMin);
    		const yearMin = weeksDateObjectMin.getFullYear();
    		const monthMin = weeksDateObjectMin.getMonth();
    		const dayMin = weeksDateObjectMin.getDate();
    		const weeksMin = calculateWeekNumber(dayMin, monthMin, yearMin);
    		const yearsCount = calculateDatesYearsCount(weeksDateMin, $date);
    		const result = [];

    		for (let yearShift = 0; yearShift < yearsCount; yearShift += 1) {
    			const year = yearMin + yearShift;
    			const label = year;
    			const weeks = calculateYearWeekCount(year);

    			const stepStart = yearShift !== 0
    			? result[yearShift - 1].stepFinish + 1
    			: 0;

    			const stepFinish = yearShift !== 0
    			? stepStart + weeks - 1
    			: stepStart + (weeks - weeksMin);

    			result.push({ label, stepStart, stepFinish });
    		}

    		return result;
    	}

    	function generateMonthStickers() {
    		const monthsDateObjectMin = new Date(datePoP);
    		const yearMin = monthsDateObjectMin.getFullYear();
    		const monthMin = monthsDateObjectMin.getMonth();
    		const yearsCount = calculateDatesYearsCount(datePoP, $date);
    		const result = [];

    		for (let yearShift = 0; yearShift < yearsCount; yearShift += 1) {
    			const label = yearMin + yearShift;

    			const stepStart = yearShift !== 0
    			? result[yearShift - 1].stepFinish + 1
    			: 0;

    			const stepFinish = yearShift !== 0
    			? stepStart + 12 - 1
    			: stepStart + 12 - (monthMin + 1);

    			result.push({ label, stepStart, stepFinish });
    		}

    		return result;
    	}

    	function generateQuarterStickers() {
    		const yearMin = new Date(datePoP).getFullYear();
    		const diff = calculateDatesYearsCount(datePoP, $date);
    		const quarterMin = calculateQuartersRestCount(datePoP);
    		const result = [];

    		for (let yearShift = 0; yearShift <= diff; yearShift += 1) {
    			const label = yearMin + yearShift;

    			const stepStart = yearShift !== 0
    			? result[yearShift - 1].stepFinish + 1
    			: 0;

    			const stepFinish = yearShift !== 0
    			? stepStart + 4 - 1
    			: stepStart + (quarterMin - 1);

    			result.push({ label, stepStart, stepFinish });
    		}

    		return result;
    	}

    	function generateStickers() {
    		if (isDaysOption()) return generateDayStickers(); else if (isWeeksOption()) return generateWeekStickers(); else if (isMonthsOption()) return generateMonthStickers(); else if (isQuartersDaysOption()) return generateQuarterStickers();
    		return null;
    	}

    	function renderStatusClass() {
    		if ($status === 1) return " txcm-graphHeader-has-leftShade"; else if ($status === 2) return " txcm-graphHeader-has-rightShade"; else if ($status === 3) return " txcm-graphHeader-has-leftShade txcm-graphHeader-has-rightShade";
    		return "";
    	}

    	function calculateOptionWidthMax(newCount) {
    		if (newCount === 0) return 0;
    		return width / newCount;
    	}

    	function calculateScrollMax() {
    		return (options.length - $count) * $optionWidthMax;
    	}

    	function updateScrollLimits() {
    		set_store_value(optionWidthMax, $optionWidthMax = calculateOptionWidthMax($count));
    		set_store_value(scrollMax, $scrollMax = calculateScrollMax());
    	}

    	function calculateFixedOptionsCount() {
    		const { length } = options;
    		const widthCount = Math.floor(width / optionWidthBase);
    		if (widthCount < length) return widthCount;
    		return length;
    	}

    	function calculateCount() {
    		return calculateFixedOptionsCount();
    	}

    	async function updateHighighted() {
    		await tick();

    		set_store_value(highlighted, $highlighted = pointer === null
    		? null
    		: Math.floor(pointer / $optionWidthMax));
    	}

    	function updateStatus() {
    		if ($scroll) {
    			if ($scroll === $scrollMax) return 1;
    			return 3;
    		} else if ($scrollMax > 0) return 2;

    		return 0;
    	}

    	function updateStepMax() {
    		return options.length - $count;
    	}

    	async function resetStep() {
    		await tick();
    		set_store_value(step, $step = isFixedScale() ? 0 : stepMax);
    		set_store_value(shift, $shift = 0);
    	}

    	function updateStep() {
    		if ($optionWidthMax) {
    			const newStep = Math.floor($scroll / $optionWidthMax);
    			set_store_value(step, $step = newStep);
    			set_store_value(shift, $shift = newStep * $optionWidthMax - $scroll);
    		}
    	}

    	function shouldHighlight(pageX, pageY) {
    		return pageY >= top && pageX > left;
    	}

    	function onMouseMove({ pageX, pageY }) {
    		if (shouldHighlight(pageX, pageY)) $$invalidate(34, pointer = pageX - left - $shift); else $$invalidate(34, pointer = null);
    	}

    	function updateScroll(deltaX) {
    		if ($scroll + deltaX <= 0) set_store_value(scroll, $scroll = 0); else if ($scroll + deltaX >= $scrollMax) set_store_value(scroll, $scroll = $scrollMax); else set_store_value(scroll, $scroll += deltaX);
    	}

    	function changeScroll(deltaX) {
    		if (pointerScrollStart + deltaX <= 0) set_store_value(scroll, $scroll = 0); else if (pointerScrollStart + deltaX >= $scrollMax) set_store_value(scroll, $scroll = $scrollMax); else set_store_value(scroll, $scroll = pointerScrollStart + deltaX);
    	}

    	async function resetScroll() {
    		await tick();
    		set_store_value(scroll, $scroll = isFixedScale() ? 0 : $scrollMax);
    	}

    	function onWheel(event) {
    		const { deltaX } = event;

    		if (shouldScroll(deltaX)) {
    			event.preventDefault();
    			updateScroll(deltaX);
    		}
    	}

    	function onResize() {
    		measureComponent();
    	}

    	function onPointerMove(event) {
    		if (isPointDown) {
    			pointerPositionCurrent = event.touches ? event.touches[0].clientX : event.clientX;
    			const diff = pointerPositionStart - pointerPositionCurrent;
    			changeScroll(diff);
    		}
    	}

    	function onPointerUp(event) {
    		isPointDown = false;
    		event.preventDefault();
    		event.stopPropagation();
    		unsubscribeWindow();
    	}

    	function subscribeWindow() {
    		window.addEventListener("mousemove", onPointerMove);
    		window.addEventListener("touchmove", onPointerMove);
    		window.addEventListener("mouseup", onPointerUp);
    		window.addEventListener("touchend", onPointerUp);
    	}

    	function unsubscribeWindow() {
    		window.removeEventListener("mousemove", onPointerMove);
    		window.removeEventListener("touchmove", onPointerMove);
    		window.removeEventListener("mouseup", onPointerUp);
    		window.removeEventListener("touchend", onPointerUp);
    	}

    	function onPointerDown(event) {
    		isPointDown = true;
    		pointerPositionStart = event.touches ? event.touches[0].clientX : event.clientX;
    		pointerScrollStart = $scroll;
    		subscribeWindow();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<GraphHeader> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("GraphHeader", $$slots, []);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			node = $$value;
    			$$invalidate(0, node);
    		});
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		getContext,
    		tick,
    		getUIState,
    		getDashboardState,
    		getGraphsState,
    		calculateDatePoP,
    		calculateWeekNumber,
    		calculateYearWeekCount,
    		calculateDatesMonthsCount,
    		calculateDatesQuartersCount,
    		calculateQuartersRestCount,
    		calculateDatesYearsCount,
    		calcuateMonthDayCount,
    		generateYearsWeekCache,
    		generateYearsWeekRangeCache,
    		renderMonthShort,
    		renderMonthLong,
    		subtractDays,
    		subtractWeeks,
    		DAY,
    		GraphScaleDate,
    		GraphScaleFixed,
    		GraphStickers,
    		GraphHeaderScrollTrack,
    		translate,
    		locale,
    		SCALE_FIXED_VALUES,
    		SCALE_FIXED_OPTION_WIDTHS,
    		SCALE_DATE_OPTION_WIDTHS,
    		SCALE_DAYS_COUNT,
    		SCALE_WEEKS_COUNT,
    		sectionScrollX,
    		date,
    		appConfig,
    		graphConfig,
    		dateMin,
    		dateMax,
    		fixedOptions,
    		mode,
    		dynamics,
    		count,
    		step,
    		highlighted,
    		shift,
    		status,
    		weeksCache,
    		weekRangesCache,
    		optionWidthMax,
    		scroll,
    		scrollMax,
    		node,
    		width,
    		top,
    		left,
    		pointer,
    		pointerPositionStart,
    		pointerScrollStart,
    		pointerPositionCurrent,
    		isPointDown,
    		isHaveScroll,
    		isFixedScale,
    		isDaysOption,
    		isWeeksOption,
    		isMonthsOption,
    		isQuartersDaysOption,
    		measureComponent,
    		fattenFixedOption,
    		flattenFixedOptions,
    		pickOptionWidthBase,
    		generateDayOptions: generateDayOptions$1,
    		generateWeekOptions,
    		generateMonthOptions,
    		generateQuarterOptions,
    		generateYearOptions,
    		generateDateOptions,
    		pickOptions,
    		generateDayFragment,
    		generateWeekFragment,
    		generateMonthFragment,
    		generateQuarterFragment,
    		generateYearFragment,
    		pickGenerator,
    		generateDayStickers,
    		generateWeekStickers,
    		generateMonthStickers,
    		generateQuarterStickers,
    		generateStickers,
    		renderStatusClass,
    		calculateOptionWidthMax,
    		calculateScrollMax,
    		updateScrollLimits,
    		calculateFixedOptionsCount,
    		calculateCount,
    		updateHighighted,
    		updateStatus,
    		updateStepMax,
    		resetStep,
    		updateStep,
    		shouldHighlight,
    		onMouseMove,
    		updateScroll,
    		changeScroll,
    		resetScroll,
    		shouldScroll,
    		onWheel,
    		onResize,
    		onPointerMove,
    		onPointerUp,
    		subscribeWindow,
    		unsubscribeWindow,
    		onPointerDown,
    		datePoP,
    		$date,
    		$dynamics,
    		optionWidthBase,
    		$mode,
    		options,
    		$locale,
    		generator,
    		stickers,
    		$count,
    		$status,
    		$scroll,
    		$scrollMax,
    		stepMax,
    		$optionWidthMax,
    		$sectionScrollX,
    		$step,
    		$highlighted,
    		$shift
    	});

    	$$self.$inject_state = $$props => {
    		if ("node" in $$props) $$invalidate(0, node = $$props.node);
    		if ("width" in $$props) $$invalidate(31, width = $$props.width);
    		if ("top" in $$props) top = $$props.top;
    		if ("left" in $$props) left = $$props.left;
    		if ("pointer" in $$props) $$invalidate(34, pointer = $$props.pointer);
    		if ("pointerPositionStart" in $$props) pointerPositionStart = $$props.pointerPositionStart;
    		if ("pointerScrollStart" in $$props) pointerScrollStart = $$props.pointerScrollStart;
    		if ("pointerPositionCurrent" in $$props) pointerPositionCurrent = $$props.pointerPositionCurrent;
    		if ("isPointDown" in $$props) isPointDown = $$props.isPointDown;
    		if ("datePoP" in $$props) $$invalidate(39, datePoP = $$props.datePoP);
    		if ("optionWidthBase" in $$props) optionWidthBase = $$props.optionWidthBase;
    		if ("options" in $$props) $$invalidate(2, options = $$props.options);
    		if ("generator" in $$props) $$invalidate(3, generator = $$props.generator);
    		if ("stickers" in $$props) $$invalidate(4, stickers = $$props.stickers);
    		if ("stepMax" in $$props) $$invalidate(8, stepMax = $$props.stepMax);
    	};

    	let datePoP;
    	let optionWidthBase;
    	let options;
    	let generator;
    	let stickers;
    	let stepMax;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[1] & /*$date, $dynamics*/ 1536) {
    			 $$invalidate(39, datePoP = calculateDatePoP($date, $dynamics));
    		}

    		if ($$self.$$.dirty[0] & /*$mode*/ 2 | $$self.$$.dirty[1] & /*$dynamics, $date, datePoP*/ 1792) {
    			 optionWidthBase = pickOptionWidthBase();
    		}

    		if ($$self.$$.dirty[0] & /*$mode*/ 2 | $$self.$$.dirty[1] & /*$dynamics, $date, datePoP, $locale*/ 5888) {
    			 $$invalidate(2, options = pickOptions());
    		}

    		if ($$self.$$.dirty[1] & /*$dynamics, $locale*/ 5120) {
    			 $$invalidate(3, generator = pickGenerator());
    		}

    		if ($$self.$$.dirty[1] & /*$dynamics, $date, datePoP, $locale*/ 5888) {
    			 $$invalidate(4, stickers = generateStickers());
    		}

    		if ($$self.$$.dirty[0] & /*options*/ 4 | $$self.$$.dirty[1] & /*$dynamics, width, $date, datePoP*/ 1793) {
    			 set_store_value(count, $count = calculateCount());
    		}

    		if ($$self.$$.dirty[0] & /*$scroll*/ 128 | $$self.$$.dirty[1] & /*$scrollMax*/ 8192) {
    			 set_store_value(status, $status = updateStatus());
    		}

    		if ($$self.$$.dirty[0] & /*$count, options*/ 36) {
    			 $$invalidate(8, stepMax = updateStepMax());
    		}

    		if ($$self.$$.dirty[0] & /*$count, options*/ 36 | $$self.$$.dirty[1] & /*width*/ 1) {
    			 updateScrollLimits();
    		}

    		if ($$self.$$.dirty[0] & /*$mode*/ 2 | $$self.$$.dirty[1] & /*$dynamics, $date, datePoP*/ 1792) {
    			 resetStep();
    		}

    		if ($$self.$$.dirty[0] & /*$scroll*/ 128) {
    			 updateStep();
    		}

    		if ($$self.$$.dirty[0] & /*$optionWidthMax*/ 512 | $$self.$$.dirty[1] & /*pointer*/ 8) {
    			 updateHighighted();
    		}

    		if ($$self.$$.dirty[0] & /*$mode*/ 2 | $$self.$$.dirty[1] & /*$dynamics, $date, datePoP*/ 1792) {
    			 resetScroll();
    		}

    		if ($$self.$$.dirty[1] & /*$sectionScrollX*/ 16384) {
    			 measureComponent();
    		}
    	};

    	return [
    		node,
    		$mode,
    		options,
    		generator,
    		stickers,
    		$count,
    		$status,
    		$scroll,
    		stepMax,
    		$optionWidthMax,
    		locale,
    		sectionScrollX,
    		date,
    		mode,
    		dynamics,
    		count,
    		step,
    		highlighted,
    		shift,
    		status,
    		optionWidthMax,
    		scroll,
    		scrollMax,
    		isHaveScroll,
    		isFixedScale,
    		renderStatusClass,
    		onMouseMove,
    		onWheel,
    		onResize,
    		onPointerDown,
    		div_binding
    	];
    }

    class GraphHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1u, create_fragment$1u, safe_not_equal, {}, [-1, -1, -1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GraphHeader",
    			options,
    			id: create_fragment$1u.name
    		});
    	}
    }

    /* src/js/components/tableHeader/TableHeaderGraph.svelte generated by Svelte v3.24.0 */

    const file$1g = "src/js/components/tableHeader/TableHeaderGraph.svelte";

    function create_fragment$1v(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "txcm-tableHeaderGraph");
    			add_location(div, file$1g, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1v($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TableHeaderGraph> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TableHeaderGraph", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, $$slots];
    }

    class TableHeaderGraph extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1v, create_fragment$1v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableHeaderGraph",
    			options,
    			id: create_fragment$1v.name
    		});
    	}
    }

    /* src/js/components/tableHeader/financial/overview/TableHeaderCellFinOverview.svelte generated by Svelte v3.24.0 */
    const file$1h = "src/js/components/tableHeader/financial/overview/TableHeaderCellFinOverview.svelte";

    // (7:0) <TableHeaderCell>
    function create_default_slot$q(ctx) {
    	let t0;
    	let div0;
    	let t1;
    	let br0;
    	let t2;
    	let t3;
    	let div1;
    	let t4;
    	let br1;
    	let t5;
    	let t6;
    	let t7;
    	let div2;
    	let t8;
    	let br2;
    	let t9;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    			t0 = space();
    			div0 = element("div");
    			t1 = text("% от выр.");
    			br0 = element("br");
    			t2 = text("\n      млн. руб");
    			t3 = space();
    			div1 = element("div");
    			t4 = text("∆ (ppt)");
    			br1 = element("br");
    			t5 = space();
    			t6 = text(/*date*/ ctx[0]);
    			t7 = space();
    			div2 = element("div");
    			t8 = text("∆ (ppt)");
    			br2 = element("br");
    			t9 = text("\n      от план");
    			add_location(br0, file$1h, 10, 15, 210);
    			attr_dev(div0, "class", "txcm-tableHeaderCellColumn");
    			add_location(div0, file$1h, 8, 2, 150);
    			add_location(br1, file$1h, 15, 13, 299);
    			attr_dev(div1, "class", "txcm-tableHeaderCellColumn");
    			add_location(div1, file$1h, 13, 2, 241);
    			add_location(br2, file$1h, 20, 13, 386);
    			attr_dev(div2, "class", "txcm-tableHeaderCellColumn");
    			add_location(div2, file$1h, 18, 2, 328);
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			append_dev(div0, t1);
    			append_dev(div0, br0);
    			append_dev(div0, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, t4);
    			append_dev(div1, br1);
    			append_dev(div1, t5);
    			append_dev(div1, t6);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, t8);
    			append_dev(div2, br2);
    			append_dev(div2, t9);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*date*/ 1) set_data_dev(t6, /*date*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$q.name,
    		type: "slot",
    		source: "(7:0) <TableHeaderCell>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1w(ctx) {
    	let tableheadercell;
    	let current;

    	tableheadercell = new TableHeaderCell({
    			props: {
    				$$slots: { default: [create_default_slot$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tableheadercell.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tableheadercell, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tableheadercell_changes = {};

    			if (dirty & /*$$scope, date*/ 5) {
    				tableheadercell_changes.$$scope = { dirty, ctx };
    			}

    			tableheadercell.$set(tableheadercell_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tableheadercell.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tableheadercell.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tableheadercell, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1w($$self, $$props, $$invalidate) {
    	let { date } = $$props;
    	const writable_props = ["date"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TableHeaderCellFinOverview> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TableHeaderCellFinOverview", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("date" in $$props) $$invalidate(0, date = $$props.date);
    		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ TableHeaderCell, date });

    	$$self.$inject_state = $$props => {
    		if ("date" in $$props) $$invalidate(0, date = $$props.date);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [date, $$slots, $$scope];
    }

    class TableHeaderCellFinOverview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1w, create_fragment$1w, safe_not_equal, { date: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableHeaderCellFinOverview",
    			options,
    			id: create_fragment$1w.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*date*/ ctx[0] === undefined && !("date" in props)) {
    			console.warn("<TableHeaderCellFinOverview> was created without expected prop 'date'");
    		}
    	}

    	get date() {
    		throw new Error("<TableHeaderCellFinOverview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set date(value) {
    		throw new Error("<TableHeaderCellFinOverview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/tableHeader/financial/overview/TableHeaderFinOverview.svelte generated by Svelte v3.24.0 */
    const file$1i = "src/js/components/tableHeader/financial/overview/TableHeaderFinOverview.svelte";

    // (24:2) <TableHeaderCellFinancialOverview     date={column1Date}>
    function create_default_slot_3(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*label*/ ctx[0]);
    			attr_dev(div, "class", "txcm-tableHeaderCellLabel");
    			add_location(div, file$1i, 25, 6, 1225);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 1) set_data_dev(t, /*label*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(24:2) <TableHeaderCellFinancialOverview     date={column1Date}>",
    		ctx
    	});

    	return block;
    }

    // (31:2) <TableHeaderCellFinancialOverview     date={column2Date}>
    function create_default_slot_2$1(ctx) {
    	let div;
    	let columnoptions;
    	let current;
    	columnoptions = new ColumnOptions({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(columnoptions.$$.fragment);
    			attr_dev(div, "class", "txcm-tableHeaderCellLabel");
    			add_location(div, file$1i, 32, 6, 1408);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(columnoptions, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(columnoptions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(columnoptions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(columnoptions);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(31:2) <TableHeaderCellFinancialOverview     date={column2Date}>",
    		ctx
    	});

    	return block;
    }

    // (38:2) <TableHeaderGraph>
    function create_default_slot_1$5(ctx) {
    	let graphoptions;
    	let t;
    	let graphheader;
    	let current;
    	graphoptions = new GraphOptions({ $$inline: true });
    	graphheader = new GraphHeader({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(graphoptions.$$.fragment);
    			t = space();
    			create_component(graphheader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphoptions, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(graphheader, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphoptions.$$.fragment, local);
    			transition_in(graphheader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphoptions.$$.fragment, local);
    			transition_out(graphheader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphoptions, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(graphheader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(38:2) <TableHeaderGraph>",
    		ctx
    	});

    	return block;
    }

    // (23:0) <TableHeader>
    function create_default_slot$r(ctx) {
    	let tableheadercellfinancialoverview0;
    	let t0;
    	let tableheadercellfinancialoverview1;
    	let t1;
    	let tableheadergraph;
    	let current;

    	tableheadercellfinancialoverview0 = new TableHeaderCellFinOverview({
    			props: {
    				date: /*column1Date*/ ctx[1],
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tableheadercellfinancialoverview1 = new TableHeaderCellFinOverview({
    			props: {
    				date: /*column2Date*/ ctx[2],
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tableheadergraph = new TableHeaderGraph({
    			props: {
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tableheadercellfinancialoverview0.$$.fragment);
    			t0 = space();
    			create_component(tableheadercellfinancialoverview1.$$.fragment);
    			t1 = space();
    			create_component(tableheadergraph.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tableheadercellfinancialoverview0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tableheadercellfinancialoverview1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tableheadergraph, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tableheadercellfinancialoverview0_changes = {};
    			if (dirty & /*column1Date*/ 2) tableheadercellfinancialoverview0_changes.date = /*column1Date*/ ctx[1];

    			if (dirty & /*$$scope, label*/ 2049) {
    				tableheadercellfinancialoverview0_changes.$$scope = { dirty, ctx };
    			}

    			tableheadercellfinancialoverview0.$set(tableheadercellfinancialoverview0_changes);
    			const tableheadercellfinancialoverview1_changes = {};
    			if (dirty & /*column2Date*/ 4) tableheadercellfinancialoverview1_changes.date = /*column2Date*/ ctx[2];

    			if (dirty & /*$$scope*/ 2048) {
    				tableheadercellfinancialoverview1_changes.$$scope = { dirty, ctx };
    			}

    			tableheadercellfinancialoverview1.$set(tableheadercellfinancialoverview1_changes);
    			const tableheadergraph_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				tableheadergraph_changes.$$scope = { dirty, ctx };
    			}

    			tableheadergraph.$set(tableheadergraph_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tableheadercellfinancialoverview0.$$.fragment, local);
    			transition_in(tableheadercellfinancialoverview1.$$.fragment, local);
    			transition_in(tableheadergraph.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tableheadercellfinancialoverview0.$$.fragment, local);
    			transition_out(tableheadercellfinancialoverview1.$$.fragment, local);
    			transition_out(tableheadergraph.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tableheadercellfinancialoverview0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tableheadercellfinancialoverview1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tableheadergraph, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$r.name,
    		type: "slot",
    		source: "(23:0) <TableHeader>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1x(ctx) {
    	let tableheader;
    	let current;

    	tableheader = new TableHeader({
    			props: {
    				$$slots: { default: [create_default_slot$r] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tableheader.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tableheader, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tableheader_changes = {};

    			if (dirty & /*$$scope, column2Date, column1Date, label*/ 2055) {
    				tableheader_changes.$$scope = { dirty, ctx };
    			}

    			tableheader.$set(tableheader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tableheader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tableheader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tableheader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1x($$self, $$props, $$invalidate) {
    	let $date;
    	let $datePrecision;
    	let $datePoP;
    	const appConfig = getContext("app").getAppConfig();
    	const { dateMax } = appConfig;
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(6, $date = value));
    	const datePoP = getDashboardState("datePoP");
    	validate_store(datePoP, "datePoP");
    	component_subscribe($$self, datePoP, value => $$invalidate(8, $datePoP = value));
    	const datePrecision = getDashboardState("datePrecision");
    	validate_store(datePrecision, "datePrecision");
    	component_subscribe($$self, datePrecision, value => $$invalidate(7, $datePrecision = value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TableHeaderFinOverview> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TableHeaderFinOverview", $$slots, []);

    	$$self.$capture_state = () => ({
    		getContext,
    		getDashboardState,
    		renderPreciseTableMonth,
    		renderPreciseCellDate,
    		renderPreciseCellMonth,
    		ColumnOptions,
    		GraphOptions,
    		GraphHeader,
    		TableHeader,
    		TableHeaderGraph,
    		TableHeaderCellFinancialOverview: TableHeaderCellFinOverview,
    		appConfig,
    		dateMax,
    		date,
    		datePoP,
    		datePrecision,
    		label,
    		$date,
    		$datePrecision,
    		column1Date,
    		$datePoP,
    		column2Date
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("column1Date" in $$props) $$invalidate(1, column1Date = $$props.column1Date);
    		if ("column2Date" in $$props) $$invalidate(2, column2Date = $$props.column2Date);
    	};

    	let label;
    	let column1Date;
    	let column2Date;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$date, $datePrecision*/ 192) {
    			 $$invalidate(0, label = renderPreciseTableMonth($date, $datePrecision, dateMax));
    		}

    		if ($$self.$$.dirty & /*$datePoP, $datePrecision*/ 384) {
    			 $$invalidate(1, column1Date = renderPreciseCellMonth($datePoP, $datePrecision, dateMax));
    		}

    		if ($$self.$$.dirty & /*$datePoP, $datePrecision*/ 384) {
    			 $$invalidate(2, column2Date = renderPreciseCellDate($datePoP, $datePrecision, dateMax));
    		}
    	};

    	return [label, column1Date, column2Date, date, datePoP, datePrecision];
    }

    class TableHeaderFinOverview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1x, create_fragment$1x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableHeaderFinOverview",
    			options,
    			id: create_fragment$1x.name
    		});
    	}
    }

    /* src/js/components/tableHeader/operational/overview/TableHeaderCellOpOverview.svelte generated by Svelte v3.24.0 */
    const file$1j = "src/js/components/tableHeader/operational/overview/TableHeaderCellOpOverview.svelte";

    // (15:0) <TableHeaderCell>
    function create_default_slot$s(ctx) {
    	let t0;
    	let div0;
    	let span0;
    	let int0;
    	let t1;
    	let span1;
    	let t2;
    	let t3;
    	let div1;
    	let span2;
    	let int1;
    	let t4;
    	let span3;
    	let int2;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);
    	int0 = new Int({ props: { key: "∆ от" }, $$inline: true });
    	int1 = new Int({ props: { key: "∆ от" }, $$inline: true });
    	int2 = new Int({ props: { key: "плана" }, $$inline: true });

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    			t0 = space();
    			div0 = element("div");
    			span0 = element("span");
    			create_component(int0.$$.fragment);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*label*/ ctx[0]);
    			t3 = space();
    			div1 = element("div");
    			span2 = element("span");
    			create_component(int1.$$.fragment);
    			t4 = space();
    			span3 = element("span");
    			create_component(int2.$$.fragment);
    			add_location(span0, file$1j, 18, 6, 624);
    			set_style(span1, "margin-top", "-4px");
    			add_location(span1, file$1j, 21, 6, 677);
    			attr_dev(div0, "class", "txcm-tableHeaderCellColumn");
    			add_location(div0, file$1j, 16, 2, 573);
    			add_location(span2, file$1j, 27, 6, 808);
    			set_style(span3, "margin-top", "-4px");
    			add_location(span3, file$1j, 30, 6, 867);
    			attr_dev(div1, "class", "txcm-tableHeaderCellColumn");
    			add_location(div1, file$1j, 25, 2, 757);
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			append_dev(div0, span0);
    			mount_component(int0, span0, null);
    			append_dev(div0, t1);
    			append_dev(div0, span1);
    			append_dev(span1, t2);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, span2);
    			mount_component(int1, span2, null);
    			append_dev(div1, t4);
    			append_dev(div1, span3);
    			mount_component(int2, span3, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*label*/ 1) set_data_dev(t2, /*label*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			transition_in(int2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			transition_out(int2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			destroy_component(int0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(div1);
    			destroy_component(int1);
    			destroy_component(int2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$s.name,
    		type: "slot",
    		source: "(15:0) <TableHeaderCell>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1y(ctx) {
    	let tableheadercell;
    	let current;

    	tableheadercell = new TableHeaderCell({
    			props: {
    				$$slots: { default: [create_default_slot$s] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tableheadercell.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tableheadercell, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tableheadercell_changes = {};

    			if (dirty & /*$$scope, label*/ 33) {
    				tableheadercell_changes.$$scope = { dirty, ctx };
    			}

    			tableheadercell.$set(tableheadercell_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tableheadercell.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tableheadercell.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tableheadercell, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1y($$self, $$props, $$invalidate) {
    	let $datePoP;
    	let $datePrecision;
    	let $locale;
    	const datePoP = getDashboardState("datePoP");
    	validate_store(datePoP, "datePoP");
    	component_subscribe($$self, datePoP, value => $$invalidate(6, $datePoP = value));
    	const datePrecision = getDashboardState("datePrecision");
    	validate_store(datePrecision, "datePrecision");
    	component_subscribe($$self, datePrecision, value => $$invalidate(7, $datePrecision = value));
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(8, $locale = value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TableHeaderCellOpOverview> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TableHeaderCellOpOverview", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		renderPreciseCellDate,
    		getUIState,
    		TableHeaderCell,
    		Int,
    		datePoP,
    		datePrecision,
    		locale,
    		label,
    		$datePoP,
    		$datePrecision,
    		$locale
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    	};

    	let label;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$datePoP, $datePrecision, $locale*/ 448) {
    			 $$invalidate(0, label = renderPreciseCellDate($datePoP, $datePrecision, $locale));
    		}
    	};

    	return [label, datePoP, datePrecision, locale, $$slots, $$scope];
    }

    class TableHeaderCellOpOverview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1y, create_fragment$1y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableHeaderCellOpOverview",
    			options,
    			id: create_fragment$1y.name
    		});
    	}
    }

    /* src/js/components/tableHeader/operational/overview/TableHeaderOpOverview.svelte generated by Svelte v3.24.0 */
    const file$1k = "src/js/components/tableHeader/operational/overview/TableHeaderOpOverview.svelte";

    // (22:2) <TableHeaderCellOpOverview>
    function create_default_slot_3$1(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*label*/ ctx[1]);
    			attr_dev(div, "class", "txcm-tableHeaderCellLabel");
    			add_location(div, file$1k, 22, 4, 912);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 2) set_data_dev(t, /*label*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(22:2) <TableHeaderCellOpOverview>",
    		ctx
    	});

    	return block;
    }

    // (28:2) <TableHeaderCellOpOverview>
    function create_default_slot_2$2(ctx) {
    	let div;
    	let columnoptions;
    	let current;
    	columnoptions = new ColumnOptions({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(columnoptions.$$.fragment);
    			attr_dev(div, "class", "txcm-tableHeaderCellLabel");
    			add_location(div, file$1k, 28, 4, 1050);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(columnoptions, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(columnoptions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(columnoptions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(columnoptions);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(28:2) <TableHeaderCellOpOverview>",
    		ctx
    	});

    	return block;
    }

    // (34:2) <TableHeaderGraph>
    function create_default_slot_1$6(ctx) {
    	let graphoptions;
    	let t;
    	let graphheader;
    	let current;

    	graphoptions = new GraphOptions({
    			props: { indicator: /*indicator*/ ctx[0] },
    			$$inline: true
    		});

    	graphheader = new GraphHeader({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(graphoptions.$$.fragment);
    			t = space();
    			create_component(graphheader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphoptions, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(graphheader, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const graphoptions_changes = {};
    			if (dirty & /*indicator*/ 1) graphoptions_changes.indicator = /*indicator*/ ctx[0];
    			graphoptions.$set(graphoptions_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphoptions.$$.fragment, local);
    			transition_in(graphheader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphoptions.$$.fragment, local);
    			transition_out(graphheader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphoptions, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(graphheader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(34:2) <TableHeaderGraph>",
    		ctx
    	});

    	return block;
    }

    // (21:0) <TableHeader>
    function create_default_slot$t(ctx) {
    	let tableheadercellopoverview0;
    	let t0;
    	let tableheadercellopoverview1;
    	let t1;
    	let tableheadergraph;
    	let current;

    	tableheadercellopoverview0 = new TableHeaderCellOpOverview({
    			props: {
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tableheadercellopoverview1 = new TableHeaderCellOpOverview({
    			props: {
    				$$slots: { default: [create_default_slot_2$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tableheadergraph = new TableHeaderGraph({
    			props: {
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tableheadercellopoverview0.$$.fragment);
    			t0 = space();
    			create_component(tableheadercellopoverview1.$$.fragment);
    			t1 = space();
    			create_component(tableheadergraph.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tableheadercellopoverview0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tableheadercellopoverview1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tableheadergraph, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tableheadercellopoverview0_changes = {};

    			if (dirty & /*$$scope, label*/ 258) {
    				tableheadercellopoverview0_changes.$$scope = { dirty, ctx };
    			}

    			tableheadercellopoverview0.$set(tableheadercellopoverview0_changes);
    			const tableheadercellopoverview1_changes = {};

    			if (dirty & /*$$scope*/ 256) {
    				tableheadercellopoverview1_changes.$$scope = { dirty, ctx };
    			}

    			tableheadercellopoverview1.$set(tableheadercellopoverview1_changes);
    			const tableheadergraph_changes = {};

    			if (dirty & /*$$scope, indicator*/ 257) {
    				tableheadergraph_changes.$$scope = { dirty, ctx };
    			}

    			tableheadergraph.$set(tableheadergraph_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tableheadercellopoverview0.$$.fragment, local);
    			transition_in(tableheadercellopoverview1.$$.fragment, local);
    			transition_in(tableheadergraph.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tableheadercellopoverview0.$$.fragment, local);
    			transition_out(tableheadercellopoverview1.$$.fragment, local);
    			transition_out(tableheadergraph.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tableheadercellopoverview0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tableheadercellopoverview1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tableheadergraph, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$t.name,
    		type: "slot",
    		source: "(21:0) <TableHeader>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1z(ctx) {
    	let tableheader;
    	let current;

    	tableheader = new TableHeader({
    			props: {
    				$$slots: { default: [create_default_slot$t] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tableheader.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tableheader, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tableheader_changes = {};

    			if (dirty & /*$$scope, indicator, label*/ 259) {
    				tableheader_changes.$$scope = { dirty, ctx };
    			}

    			tableheader.$set(tableheader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tableheader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tableheader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tableheader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1z($$self, $$props, $$invalidate) {
    	let $date;
    	let $datePrecision;
    	let $locale;
    	let { indicator } = $$props;
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(7, $locale = value));
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(5, $date = value));
    	const datePrecision = getDashboardState("datePrecision");
    	validate_store(datePrecision, "datePrecision");
    	component_subscribe($$self, datePrecision, value => $$invalidate(6, $datePrecision = value));
    	const writable_props = ["indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TableHeaderOpOverview> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TableHeaderOpOverview", $$slots, []);

    	$$self.$set = $$props => {
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		renderPreciseTableDate,
    		ColumnOptions,
    		GraphOptions,
    		GraphHeader,
    		TableHeader,
    		TableHeaderGraph,
    		TableHeaderCellOpOverview,
    		getUIState,
    		indicator,
    		locale,
    		date,
    		datePrecision,
    		label,
    		$date,
    		$datePrecision,
    		$locale
    	});

    	$$self.$inject_state = $$props => {
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("label" in $$props) $$invalidate(1, label = $$props.label);
    	};

    	let label;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$date, $datePrecision, $locale*/ 224) {
    			 $$invalidate(1, label = renderPreciseTableDate($date, $datePrecision, $locale));
    		}
    	};

    	return [indicator, label, locale, date, datePrecision];
    }

    class TableHeaderOpOverview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1z, create_fragment$1z, safe_not_equal, { indicator: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableHeaderOpOverview",
    			options,
    			id: create_fragment$1z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*indicator*/ ctx[0] === undefined && !("indicator" in props)) {
    			console.warn("<TableHeaderOpOverview> was created without expected prop 'indicator'");
    		}
    	}

    	get indicator() {
    		throw new Error("<TableHeaderOpOverview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<TableHeaderOpOverview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/overview/OverviewTableHeader.svelte generated by Svelte v3.24.0 */
    const file$1l = "src/js/components/overview/OverviewTableHeader.svelte";

    function create_fragment$1A(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	var switch_value = /*pickHeader*/ ctx[3](/*dashboard*/ ctx[0]);

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "txcm-overviewHeader");
    			add_location(div, file$1l, 28, 0, 773);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			/*div_binding*/ ctx[4](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (switch_value !== (switch_value = /*pickHeader*/ ctx[3](/*dashboard*/ ctx[0]))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			/*div_binding*/ ctx[4](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1A($$self, $$props, $$invalidate) {
    	let $sectionScrollX;

    	const TABLE_HEADERS = {
    		financial: TableHeaderFinOverview,
    		operational: TableHeaderOpOverview
    	};

    	let { dashboard } = $$props;
    	const sectionScrollX = getUIState("sectionScrollX");
    	validate_store(sectionScrollX, "sectionScrollX");
    	component_subscribe($$self, sectionScrollX, value => $$invalidate(5, $sectionScrollX = value));
    	let node;

    	function pickHeader() {
    		if (TABLE_HEADERS[dashboard]) return TABLE_HEADERS[dashboard];
    		return TABLE_HEADERS.financial;
    	}

    	function updateScroll() {
    		if (node) $$invalidate(1, node.scrollLeft = $sectionScrollX, node);
    	}

    	const writable_props = ["dashboard"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<OverviewTableHeader> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("OverviewTableHeader", $$slots, []);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			node = $$value;
    			$$invalidate(1, node);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    	};

    	$$self.$capture_state = () => ({
    		getUIState,
    		TableHeaderFinancialOverview: TableHeaderFinOverview,
    		TableHeaderOperationalOverview: TableHeaderOpOverview,
    		TABLE_HEADERS,
    		dashboard,
    		sectionScrollX,
    		node,
    		pickHeader,
    		updateScroll,
    		$sectionScrollX
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("node" in $$props) $$invalidate(1, node = $$props.node);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$sectionScrollX*/ 32) {
    			 updateScroll();
    		}
    	};

    	return [dashboard, node, sectionScrollX, pickHeader, div_binding];
    }

    class OverviewTableHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1A, create_fragment$1A, safe_not_equal, { dashboard: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OverviewTableHeader",
    			options,
    			id: create_fragment$1A.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[0] === undefined && !("dashboard" in props)) {
    			console.warn("<OverviewTableHeader> was created without expected prop 'dashboard'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<OverviewTableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<OverviewTableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // List of nodes to update
    const nodes = [];

    // Current location
    let location$1;

    // Function that updates all nodes marking the active ones
    function checkActive(el) {
        const matchesLocation = el.pattern.test(location$1);
        toggleClasses(el, el.className, matchesLocation);
        toggleClasses(el, el.inactiveClassName, !matchesLocation);
    }

    function toggleClasses(el, className, shouldAdd) {
        (className || '').split(' ').forEach((cls) => {
            if (!cls) {
                return
            }
            // Remove the class firsts
            el.node.classList.remove(cls);

            // If the pattern doesn't match, then set the class
            if (shouldAdd) {
                el.node.classList.add(cls);
            }
        });
    }

    // Listen to changes in the location
    loc.subscribe((value) => {
        // Update the location
        location$1 = value.location + (value.querystring ? '?' + value.querystring : '');

        // Update all nodes
        nodes.map(checkActive);
    });

    /**
     * @typedef {Object} ActiveOptions
     * @property {string|RegExp} [path] - Path expression that makes the link active when matched (must start with '/' or '*'); default is the link's href
     * @property {string} [className] - CSS class to apply to the element when active; default value is "active"
     */

    /**
     * Svelte Action for automatically adding the "active" class to elements (links, or any other DOM element) when the current location matches a certain path.
     * 
     * @param {HTMLElement} node - The target node (automatically set by Svelte)
     * @param {ActiveOptions|string|RegExp} [opts] - Can be an object of type ActiveOptions, or a string (or regular expressions) representing ActiveOptions.path.
     * @returns {{destroy: function(): void}} Destroy function
     */
    function active$1(node, opts) {
        // Check options
        if (opts && (typeof opts == 'string' || (typeof opts == 'object' && opts instanceof RegExp))) {
            // Interpret strings and regular expressions as opts.path
            opts = {
                path: opts
            };
        }
        else {
            // Ensure opts is a dictionary
            opts = opts || {};
        }

        // Path defaults to link target
        if (!opts.path && node.hasAttribute('href')) {
            opts.path = node.getAttribute('href');
            if (opts.path && opts.path.length > 1 && opts.path.charAt(0) == '#') {
                opts.path = opts.path.substring(1);
            }
        }

        // Default class name
        if (!opts.className) {
            opts.className = 'active';
        }

        // If path is a string, it must start with '/' or '*'
        if (!opts.path || 
            typeof opts.path == 'string' && (opts.path.length < 1 || (opts.path.charAt(0) != '/' && opts.path.charAt(0) != '*'))
        ) {
            throw Error('Invalid value for "path" argument')
        }

        // If path is not a regular expression already, make it
        const {pattern} = typeof opts.path == 'string' ?
            regexparam(opts.path) :
            {pattern: opts.path};

        // Add the node to the list
        const el = {
            node,
            className: opts.className,
            inactiveClassName: opts.inactiveClassName,
            pattern
        };
        nodes.push(el);

        // Trigger the action right away
        checkActive(el);

        return {
            // When the element is destroyed, remove it from the list
            destroy() {
                nodes.splice(nodes.indexOf(el), 1);
            }
        }
    }

    /* src/js/components/core/navLink/NavLink.svelte generated by Svelte v3.24.0 */
    const file$1m = "src/js/components/core/navLink/NavLink.svelte";

    function create_fragment$1B(ctx) {
    	let a;
    	let a_class_value;
    	let link_action;
    	let active_action;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

    	const block = {
    		c: function create() {
    			a = element("a");
    			if (default_slot) default_slot.c();

    			attr_dev(a, "class", a_class_value = !/*disabled*/ ctx[2]
    			? `${/*linkClass*/ ctx[1]}`
    			: `${/*linkClass*/ ctx[1]}-is-disabled`);

    			attr_dev(a, "href", /*to*/ ctx[0]);
    			add_location(a, file$1m, 31, 0, 777);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);

    			if (default_slot) {
    				default_slot.m(a, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*handleClick*/ ctx[4], false, false, false),
    					action_destroyer(link_action = link.call(null, a)),
    					action_destroyer(active_action = active$1.call(null, a, {
    						className: `${/*linkClass*/ ctx[1]} ${/*linkClass*/ ctx[1]}-is-active`,
    						inactiveClassName: `${/*linkClass*/ ctx[1]}`
    					}))
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 64) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[6], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*disabled, linkClass*/ 6 && a_class_value !== (a_class_value = !/*disabled*/ ctx[2]
    			? `${/*linkClass*/ ctx[1]}`
    			: `${/*linkClass*/ ctx[1]}-is-disabled`)) {
    				attr_dev(a, "class", a_class_value);
    			}

    			if (!current || dirty & /*to*/ 1) {
    				attr_dev(a, "href", /*to*/ ctx[0]);
    			}

    			if (active_action && is_function(active_action.update) && dirty & /*linkClass*/ 2) active_action.update.call(null, {
    				className: `${/*linkClass*/ ctx[1]} ${/*linkClass*/ ctx[1]}-is-active`,
    				inactiveClassName: `${/*linkClass*/ ctx[1]}`
    			});
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1B($$self, $$props, $$invalidate) {
    	let $updating;
    	const dispatch = createEventDispatcher();
    	const updating = getUIState("updating");
    	validate_store(updating, "updating");
    	component_subscribe($$self, updating, value => $$invalidate(8, $updating = value));
    	let { to } = $$props;
    	let { partial = false } = $$props;
    	let { linkClass } = $$props;

    	function isCurrentLink(isCurrent, isPartiallyCurrent) {
    		return isCurrent || partial && isPartiallyCurrent;
    	}

    	function getProps({ isCurrent, isPartiallyCurrent }) {
    		if (isCurrentLink(isCurrent, isPartiallyCurrent)) return {
    			class: `${linkClass} ${linkClass}-is-active`
    		};

    		return { class: linkClass };
    	}

    	function handleClick() {
    		dispatch("click");
    	}

    	const writable_props = ["to", "partial", "linkClass"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NavLink> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("NavLink", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("to" in $$props) $$invalidate(0, to = $$props.to);
    		if ("partial" in $$props) $$invalidate(5, partial = $$props.partial);
    		if ("linkClass" in $$props) $$invalidate(1, linkClass = $$props.linkClass);
    		if ("$$scope" in $$props) $$invalidate(6, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		link,
    		active: active$1,
    		createEventDispatcher,
    		getUIState,
    		dispatch,
    		updating,
    		to,
    		partial,
    		linkClass,
    		isCurrentLink,
    		getProps,
    		handleClick,
    		disabled,
    		$updating
    	});

    	$$self.$inject_state = $$props => {
    		if ("to" in $$props) $$invalidate(0, to = $$props.to);
    		if ("partial" in $$props) $$invalidate(5, partial = $$props.partial);
    		if ("linkClass" in $$props) $$invalidate(1, linkClass = $$props.linkClass);
    		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
    	};

    	let disabled;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$updating*/ 256) {
    			 $$invalidate(2, disabled = $updating > 0);
    		}
    	};

    	return [to, linkClass, disabled, updating, handleClick, partial, $$scope, $$slots];
    }

    class NavLink extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1B, create_fragment$1B, safe_not_equal, { to: 0, partial: 5, linkClass: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavLink",
    			options,
    			id: create_fragment$1B.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*to*/ ctx[0] === undefined && !("to" in props)) {
    			console.warn("<NavLink> was created without expected prop 'to'");
    		}

    		if (/*linkClass*/ ctx[1] === undefined && !("linkClass" in props)) {
    			console.warn("<NavLink> was created without expected prop 'linkClass'");
    		}
    	}

    	get to() {
    		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set to(value) {
    		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get partial() {
    		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set partial(value) {
    		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get linkClass() {
    		throw new Error("<NavLink>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set linkClass(value) {
    		throw new Error("<NavLink>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/kpi/KPILabel.svelte generated by Svelte v3.24.0 */

    const { Object: Object_1$2 } = globals;
    const file$1n = "src/js/components/kpi/KPILabel.svelte";

    // (68:12) {#if indicator.labelUnit}
    function create_if_block$p(ctx) {
    	let span;
    	let t_value = /*indicator*/ ctx[0].labelUnit + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "txcm-kpiUnit");
    			add_location(span, file$1n, 68, 14, 1809);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*indicator*/ 1 && t_value !== (t_value = /*indicator*/ ctx[0].labelUnit + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(68:12) {#if indicator.labelUnit}",
    		ctx
    	});

    	return block;
    }

    // (61:4) <NavLink       linkClass="txcm-kpiLabelLink"       to={renderURL(dashboard, indicator.url)}>
    function create_default_slot$u(ctx) {
    	let span0;
    	let int0;
    	let t0;
    	let t1;
    	let span2;
    	let int1;
    	let t2;
    	let span1;
    	let int2;
    	let current;

    	int0 = new Int({
    			props: { key: /*indicator*/ ctx[0].label },
    			$$inline: true
    		});

    	let if_block = /*indicator*/ ctx[0].labelUnit && create_if_block$p(ctx);

    	int1 = new Int({
    			props: { key: /*indicator*/ ctx[0].subLabel },
    			$$inline: true
    		});

    	int2 = new Int({
    			props: { key: /*indicator*/ ctx[0].subLabelUnit },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span0 = element("span");
    			create_component(int0.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			span2 = element("span");
    			create_component(int1.$$.fragment);
    			t2 = space();
    			span1 = element("span");
    			create_component(int2.$$.fragment);
    			attr_dev(span0, "class", "txcm-kpiText");
    			add_location(span0, file$1n, 63, 8, 1663);
    			attr_dev(span1, "class", "txcm-kpiSubUnit");
    			add_location(span1, file$1n, 78, 14, 2071);
    			attr_dev(span2, "class", "txcm-kpiSubText");
    			add_location(span2, file$1n, 74, 8, 1957);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span0, anchor);
    			mount_component(int0, span0, null);
    			append_dev(span0, t0);
    			if (if_block) if_block.m(span0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, span2, anchor);
    			mount_component(int1, span2, null);
    			append_dev(span2, t2);
    			append_dev(span2, span1);
    			mount_component(int2, span1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const int0_changes = {};
    			if (dirty & /*indicator*/ 1) int0_changes.key = /*indicator*/ ctx[0].label;
    			int0.$set(int0_changes);

    			if (/*indicator*/ ctx[0].labelUnit) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$p(ctx);
    					if_block.c();
    					if_block.m(span0, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const int1_changes = {};
    			if (dirty & /*indicator*/ 1) int1_changes.key = /*indicator*/ ctx[0].subLabel;
    			int1.$set(int1_changes);
    			const int2_changes = {};
    			if (dirty & /*indicator*/ 1) int2_changes.key = /*indicator*/ ctx[0].subLabelUnit;
    			int2.$set(int2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			transition_in(int2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			transition_out(int2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span0);
    			destroy_component(int0);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(span2);
    			destroy_component(int1);
    			destroy_component(int2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$u.name,
    		type: "slot",
    		source: "(61:4) <NavLink       linkClass=\\\"txcm-kpiLabelLink\\\"       to={renderURL(dashboard, indicator.url)}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1C(ctx) {
    	let div;
    	let navlink;
    	let t;
    	let button;
    	let int;
    	let div_class_value;
    	let current;
    	let mounted;
    	let dispose;

    	navlink = new NavLink({
    			props: {
    				linkClass: "txcm-kpiLabelLink",
    				to: renderURL(/*dashboard*/ ctx[1], /*indicator*/ ctx[0].url),
    				$$slots: { default: [create_default_slot$u] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	int = new Int({
    			props: { key: "Убрать показатель" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(navlink.$$.fragment);
    			t = space();
    			button = element("button");
    			create_component(int.$$.fragment);
    			attr_dev(button, "class", "txcm-kpiCancel");
    			add_location(button, file$1n, 85, 4, 2250);
    			attr_dev(div, "class", div_class_value = `txcm-kpiLabel${renderLayoutClass(/*indicator*/ ctx[0])}${renderSizeClass(/*indicator*/ ctx[0])}`);
    			add_location(div, file$1n, 58, 0, 1466);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(navlink, div, null);
    			append_dev(div, t);
    			append_dev(div, button);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onCancelClick*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const navlink_changes = {};
    			if (dirty & /*indicator*/ 1) navlink_changes.to = renderURL(/*dashboard*/ ctx[1], /*indicator*/ ctx[0].url);

    			if (dirty & /*$$scope, indicator*/ 17) {
    				navlink_changes.$$scope = { dirty, ctx };
    			}

    			navlink.$set(navlink_changes);

    			if (!current || dirty & /*indicator*/ 1 && div_class_value !== (div_class_value = `txcm-kpiLabel${renderLayoutClass(/*indicator*/ ctx[0])}${renderSizeClass(/*indicator*/ ctx[0])}`)) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navlink.$$.fragment, local);
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navlink.$$.fragment, local);
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(navlink);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const SIZES = {
    	10: "txcm-kpiLabel-is-smaller",
    	15: "txcm-kpiLabel-is-small",
    	20: "txcm-kpiLabel-is-tiny"
    };

    function checkSizeName(count, name, index, options, length) {
    	if (options[index + 1]) return length === count || length > count && length < options[index + 1][0];
    	return true;
    }

    function findSizeClass(length) {
    	let name = SIZES[20];

    	Object.entries(SIZES).some(([count, className]) => {
    		if (length <= count) {
    			name = className;
    			return true;
    		} else {
    			return false;
    		}
    	});

    	return name;
    }

    function renderSizeClass({ label, subLabel }) {
    	const { length } = label;
    	if (subLabel) return ` ${SIZES[20]}`;
    	if (length < 10) return "";
    	return ` ${findSizeClass(length)}`;
    }

    function renderLayoutClass({ subLabel }) {
    	if (subLabel) return " txcm-kpiLabel-has-subLabel";
    	return "";
    }

    function instance$1C($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { indicator } = $$props;
    	const dashboard = getContext("config").getDashboard();

    	function onCancelClick() {
    		updateIndicators({ [data.id]: false });
    	}

    	const writable_props = ["data", "indicator"];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<KPILabel> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("KPILabel", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		SIZES,
    		checkSizeName,
    		findSizeClass,
    		renderSizeClass,
    		renderLayoutClass,
    		getContext,
    		renderURL,
    		updateIndicators,
    		Int,
    		NavLink,
    		data,
    		indicator,
    		dashboard,
    		onCancelClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [indicator, dashboard, onCancelClick, data];
    }

    class KPILabel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1C, create_fragment$1C, safe_not_equal, { data: 3, indicator: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KPILabel",
    			options,
    			id: create_fragment$1C.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[3] === undefined && !("data" in props)) {
    			console.warn("<KPILabel> was created without expected prop 'data'");
    		}

    		if (/*indicator*/ ctx[0] === undefined && !("indicator" in props)) {
    			console.warn("<KPILabel> was created without expected prop 'indicator'");
    		}
    	}

    	get data() {
    		throw new Error("<KPILabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<KPILabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<KPILabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<KPILabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/kpi/KPIColumn.svelte generated by Svelte v3.24.0 */

    const file$1o = "src/js/components/kpi/KPIColumn.svelte";

    function create_fragment$1D(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "txcm-kpiColumn");
    			add_location(div, file$1o, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1D($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<KPIColumn> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("KPIColumn", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, $$slots];
    }

    class KPIColumn extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1D, create_fragment$1D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KPIColumn",
    			options,
    			id: create_fragment$1D.name
    		});
    	}
    }

    /* src/js/components/deviation/DeviationHint.svelte generated by Svelte v3.24.0 */
    const file$1p = "src/js/components/deviation/DeviationHint.svelte";

    function create_fragment$1E(ctx) {
    	let span;
    	let int;
    	let current;

    	int = new Int({
    			props: { key: /*data*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(int.$$.fragment);
    			attr_dev(span, "class", "txcm-deviationHint");
    			add_location(span, file$1p, 6, 0, 111);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(int, span, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const int_changes = {};
    			if (dirty & /*data*/ 1) int_changes.key = /*data*/ ctx[0];
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1E($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DeviationHint> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DeviationHint", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({ Int, data });

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [data];
    }

    class DeviationHint extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1E, create_fragment$1E, safe_not_equal, { data: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DeviationHint",
    			options,
    			id: create_fragment$1E.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<DeviationHint> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<DeviationHint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<DeviationHint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/kpi/KPIValueMain.svelte generated by Svelte v3.24.0 */
    const file$1q = "src/js/components/kpi/KPIValueMain.svelte";

    function create_fragment$1F(ctx) {
    	let div;
    	let svg;
    	let use;
    	let svg_class_value;
    	let tooltip_action;
    	let t;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*$$slots*/ ctx[5].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t = space();
    			if (default_slot) default_slot.c();
    			xlink_attr(use, "xlink:href", "#txspt-icons-fatArrow");
    			add_location(use, file$1q, 33, 8, 856);
    			attr_dev(svg, "class", svg_class_value = renderArrowDynamicsClass("txcm-kpiValueIcon", /*dynamics*/ ctx[2]));
    			add_location(svg, file$1q, 30, 4, 737);
    			attr_dev(div, "class", "txcm-kpiValue");
    			toggle_class(div, "txcm-kpiValue-is-highlighted", isHighlighted(/*units*/ ctx[0], /*valueUnits*/ ctx[1]));
    			add_location(div, file$1q, 27, 0, 631);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, use);
    			append_dev(div, t);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(tooltip_action = tooltip.call(null, svg, /*tooltipOptions*/ ctx[3]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*dynamics*/ 4 && svg_class_value !== (svg_class_value = renderArrowDynamicsClass("txcm-kpiValueIcon", /*dynamics*/ ctx[2]))) {
    				attr_dev(svg, "class", svg_class_value);
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}

    			if (dirty & /*isHighlighted, units, valueUnits*/ 3) {
    				toggle_class(div, "txcm-kpiValue-is-highlighted", isHighlighted(/*units*/ ctx[0], /*valueUnits*/ ctx[1]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function isHighlighted(units, valueUnits) {
    	return units === valueUnits;
    }

    function instance$1F($$self, $$props, $$invalidate) {
    	const tooltipOptions = {
    		content: {
    			component: DeviationHint,
    			data: "Тренд относительно прошлого периода"
    		},
    		side: "right",
    		theme: "txcm-tooltip-deviationHint"
    	};

    	let { units } = $$props;
    	let { valueUnits } = $$props;
    	let { dynamics } = $$props;
    	const writable_props = ["units", "valueUnits", "dynamics"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<KPIValueMain> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("KPIValueMain", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("valueUnits" in $$props) $$invalidate(1, valueUnits = $$props.valueUnits);
    		if ("dynamics" in $$props) $$invalidate(2, dynamics = $$props.dynamics);
    		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		isHighlighted,
    		renderArrowDynamicsClass,
    		DeviationHint,
    		tooltip,
    		tooltipOptions,
    		units,
    		valueUnits,
    		dynamics
    	});

    	$$self.$inject_state = $$props => {
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("valueUnits" in $$props) $$invalidate(1, valueUnits = $$props.valueUnits);
    		if ("dynamics" in $$props) $$invalidate(2, dynamics = $$props.dynamics);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [units, valueUnits, dynamics, tooltipOptions, $$scope, $$slots];
    }

    class KPIValueMain extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1F, create_fragment$1F, safe_not_equal, { units: 0, valueUnits: 1, dynamics: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KPIValueMain",
    			options,
    			id: create_fragment$1F.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*units*/ ctx[0] === undefined && !("units" in props)) {
    			console.warn("<KPIValueMain> was created without expected prop 'units'");
    		}

    		if (/*valueUnits*/ ctx[1] === undefined && !("valueUnits" in props)) {
    			console.warn("<KPIValueMain> was created without expected prop 'valueUnits'");
    		}

    		if (/*dynamics*/ ctx[2] === undefined && !("dynamics" in props)) {
    			console.warn("<KPIValueMain> was created without expected prop 'dynamics'");
    		}
    	}

    	get units() {
    		throw new Error("<KPIValueMain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<KPIValueMain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valueUnits() {
    		throw new Error("<KPIValueMain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valueUnits(value) {
    		throw new Error("<KPIValueMain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dynamics() {
    		throw new Error("<KPIValueMain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dynamics(value) {
    		throw new Error("<KPIValueMain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/kpi/KPIValueAdd.svelte generated by Svelte v3.24.0 */
    const file$1r = "src/js/components/kpi/KPIValueAdd.svelte";

    function create_fragment$1G(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", div_class_value = renderDynamicsClass("txcm-kpiValueAdd", /*dynamics*/ ctx[0]));
    			add_location(div, file$1r, 8, 0, 151);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*dynamics*/ 1 && div_class_value !== (div_class_value = renderDynamicsClass("txcm-kpiValueAdd", /*dynamics*/ ctx[0]))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1G($$self, $$props, $$invalidate) {
    	let { dynamics } = $$props;
    	const writable_props = ["dynamics"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<KPIValueAdd> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("KPIValueAdd", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("dynamics" in $$props) $$invalidate(0, dynamics = $$props.dynamics);
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ renderDynamicsClass, dynamics });

    	$$self.$inject_state = $$props => {
    		if ("dynamics" in $$props) $$invalidate(0, dynamics = $$props.dynamics);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dynamics, $$scope, $$slots];
    }

    class KPIValueAdd extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1G, create_fragment$1G, safe_not_equal, { dynamics: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KPIValueAdd",
    			options,
    			id: create_fragment$1G.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dynamics*/ ctx[0] === undefined && !("dynamics" in props)) {
    			console.warn("<KPIValueAdd> was created without expected prop 'dynamics'");
    		}
    	}

    	get dynamics() {
    		throw new Error("<KPIValueAdd>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dynamics(value) {
    		throw new Error("<KPIValueAdd>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/kpi/KPIValue.svelte generated by Svelte v3.24.0 */

    // (20:0) {:else}
    function create_else_block$4(ctx) {
    	let kpivalueadd;
    	let current;

    	kpivalueadd = new KPIValueAdd({
    			props: {
    				dynamics: /*dynamics*/ ctx[2],
    				$$slots: { default: [create_default_slot_1$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(kpivalueadd.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(kpivalueadd, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const kpivalueadd_changes = {};
    			if (dirty & /*dynamics*/ 4) kpivalueadd_changes.dynamics = /*dynamics*/ ctx[2];

    			if (dirty & /*$$scope*/ 32) {
    				kpivalueadd_changes.$$scope = { dirty, ctx };
    			}

    			kpivalueadd.$set(kpivalueadd_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(kpivalueadd.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(kpivalueadd.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(kpivalueadd, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(20:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (13:0) {#if status}
    function create_if_block$q(ctx) {
    	let kpivaluemain;
    	let current;

    	kpivaluemain = new KPIValueMain({
    			props: {
    				units: /*units*/ ctx[0],
    				valueUnits: /*valueUnits*/ ctx[1],
    				dynamics: /*dynamics*/ ctx[2],
    				$$slots: { default: [create_default_slot$v] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(kpivaluemain.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(kpivaluemain, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const kpivaluemain_changes = {};
    			if (dirty & /*units*/ 1) kpivaluemain_changes.units = /*units*/ ctx[0];
    			if (dirty & /*valueUnits*/ 2) kpivaluemain_changes.valueUnits = /*valueUnits*/ ctx[1];
    			if (dirty & /*dynamics*/ 4) kpivaluemain_changes.dynamics = /*dynamics*/ ctx[2];

    			if (dirty & /*$$scope*/ 32) {
    				kpivaluemain_changes.$$scope = { dirty, ctx };
    			}

    			kpivaluemain.$set(kpivaluemain_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(kpivaluemain.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(kpivaluemain.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(kpivaluemain, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(13:0) {#if status}",
    		ctx
    	});

    	return block;
    }

    // (21:2) <KPIValueAdd     {dynamics}>
    function create_default_slot_1$7(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(21:2) <KPIValueAdd     {dynamics}>",
    		ctx
    	});

    	return block;
    }

    // (14:2) <KPIValueMain     {units}     {valueUnits}     {dynamics}>
    function create_default_slot$v(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$v.name,
    		type: "slot",
    		source: "(14:2) <KPIValueMain     {units}     {valueUnits}     {dynamics}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1H(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$q, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*status*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1H($$self, $$props, $$invalidate) {
    	let { units } = $$props;
    	let { valueUnits = 0 } = $$props;
    	let { dynamics = 0 } = $$props;
    	let { status = false } = $$props;
    	const writable_props = ["units", "valueUnits", "dynamics", "status"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<KPIValue> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("KPIValue", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("valueUnits" in $$props) $$invalidate(1, valueUnits = $$props.valueUnits);
    		if ("dynamics" in $$props) $$invalidate(2, dynamics = $$props.dynamics);
    		if ("status" in $$props) $$invalidate(3, status = $$props.status);
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		KPIValueMain,
    		KPIValueAdd,
    		units,
    		valueUnits,
    		dynamics,
    		status
    	});

    	$$self.$inject_state = $$props => {
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("valueUnits" in $$props) $$invalidate(1, valueUnits = $$props.valueUnits);
    		if ("dynamics" in $$props) $$invalidate(2, dynamics = $$props.dynamics);
    		if ("status" in $$props) $$invalidate(3, status = $$props.status);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [units, valueUnits, dynamics, status, $$slots, $$scope];
    }

    class KPIValue extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1H, create_fragment$1H, safe_not_equal, {
    			units: 0,
    			valueUnits: 1,
    			dynamics: 2,
    			status: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KPIValue",
    			options,
    			id: create_fragment$1H.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*units*/ ctx[0] === undefined && !("units" in props)) {
    			console.warn("<KPIValue> was created without expected prop 'units'");
    		}
    	}

    	get units() {
    		throw new Error("<KPIValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<KPIValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valueUnits() {
    		throw new Error("<KPIValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valueUnits(value) {
    		throw new Error("<KPIValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dynamics() {
    		throw new Error("<KPIValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dynamics(value) {
    		throw new Error("<KPIValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get status() {
    		throw new Error("<KPIValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set status(value) {
    		throw new Error("<KPIValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/kpi/KPITooltip.svelte generated by Svelte v3.24.0 */
    const file$1s = "src/js/components/kpi/KPITooltip.svelte";

    // (40:0) {#if data}
    function create_if_block$r(ctx) {
    	let table;
    	let tr0;
    	let th0;
    	let t0;
    	let th1;
    	let int0;
    	let t1;
    	let th2;
    	let int1;
    	let t2;
    	let tr1;
    	let th3;
    	let int2;
    	let t3;
    	let t4;
    	let t5;
    	let td0;
    	let t7;
    	let td1;

    	let t8_value = (/*fact*/ ctx[3]
    	? formatLabel(/*fact*/ ctx[3].qNum, /*units*/ ctx[11], "", 1)
    	: "-") + "";

    	let t8;
    	let t9;
    	let tr2;
    	let th4;
    	let int3;
    	let t10;
    	let t11;
    	let t12;
    	let td2;
    	let t14;
    	let td3;

    	let t15_value = (/*factPp*/ ctx[4]
    	? formatLabel(/*factPp*/ ctx[4].qNum, /*units*/ ctx[11], "", 1)
    	: "-") + "";

    	let t15;
    	let t16;
    	let tr3;
    	let th5;
    	let int4;
    	let t17;
    	let t18;
    	let t19;
    	let td4;

    	let t20_value = (/*factVsPpPercent*/ ctx[6]
    	? formatLabel(/*factVsPpPercent*/ ctx[6].qNum, "%", "%")
    	: "-") + "";

    	let t20;
    	let t21;
    	let td5;

    	let t22_value = (/*factVsPp*/ ctx[5]
    	? formatLabel(/*factVsPp*/ ctx[5].qNum, /*units*/ ctx[11], "", 1)
    	: "-") + "";

    	let t22;
    	let t23;
    	let tr4;
    	let th6;
    	let int5;
    	let t24;
    	let t25;
    	let t26;
    	let td6;
    	let t28;
    	let td7;

    	let t29_value = (/*budget*/ ctx[9]
    	? formatLabel(/*budget*/ ctx[9].qNum, /*units*/ ctx[11], "", 1)
    	: "-") + "";

    	let t29;
    	let t30;
    	let tr5;
    	let th7;
    	let int6;
    	let t31;
    	let td8;

    	let t32_value = (/*factVsBudgetPercent*/ ctx[8]
    	? formatLabel(/*factVsBudgetPercent*/ ctx[8].qNum, "%", "%")
    	: "-") + "";

    	let t32;
    	let t33;
    	let td9;

    	let t34_value = (/*factVsBudget*/ ctx[7]
    	? formatLabel(/*factVsBudget*/ ctx[7].qNum, /*units*/ ctx[11], "", 1)
    	: "-") + "";

    	let t34;
    	let current;

    	int0 = new Int({
    			props: { key: "в %/п.п." },
    			$$inline: true
    		});

    	int1 = new Int({
    			props: { key: "абсолют" },
    			$$inline: true
    		});

    	int2 = new Int({ props: { key: "Факт" }, $$inline: true });
    	int3 = new Int({ props: { key: "Факт" }, $$inline: true });
    	int4 = new Int({ props: { key: "∆ от" }, $$inline: true });
    	int5 = new Int({ props: { key: "План" }, $$inline: true });

    	int6 = new Int({
    			props: { key: "∆ от плана" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			table = element("table");
    			tr0 = element("tr");
    			th0 = element("th");
    			t0 = space();
    			th1 = element("th");
    			create_component(int0.$$.fragment);
    			t1 = space();
    			th2 = element("th");
    			create_component(int1.$$.fragment);
    			t2 = space();
    			tr1 = element("tr");
    			th3 = element("th");
    			create_component(int2.$$.fragment);
    			t3 = space();
    			t4 = text(/*factLabel*/ ctx[1]);
    			t5 = space();
    			td0 = element("td");
    			td0.textContent = `${"-"}`;
    			t7 = space();
    			td1 = element("td");
    			t8 = text(t8_value);
    			t9 = space();
    			tr2 = element("tr");
    			th4 = element("th");
    			create_component(int3.$$.fragment);
    			t10 = space();
    			t11 = text(/*factPoPlabel*/ ctx[2]);
    			t12 = space();
    			td2 = element("td");
    			td2.textContent = `${"-"}`;
    			t14 = space();
    			td3 = element("td");
    			t15 = text(t15_value);
    			t16 = space();
    			tr3 = element("tr");
    			th5 = element("th");
    			create_component(int4.$$.fragment);
    			t17 = space();
    			t18 = text(/*factPoPlabel*/ ctx[2]);
    			t19 = space();
    			td4 = element("td");
    			t20 = text(t20_value);
    			t21 = space();
    			td5 = element("td");
    			t22 = text(t22_value);
    			t23 = space();
    			tr4 = element("tr");
    			th6 = element("th");
    			create_component(int5.$$.fragment);
    			t24 = space();
    			t25 = text(/*year*/ ctx[10]);
    			t26 = space();
    			td6 = element("td");
    			td6.textContent = `${"-"}`;
    			t28 = space();
    			td7 = element("td");
    			t29 = text(t29_value);
    			t30 = space();
    			tr5 = element("tr");
    			th7 = element("th");
    			create_component(int6.$$.fragment);
    			t31 = space();
    			td8 = element("td");
    			t32 = text(t32_value);
    			t33 = space();
    			td9 = element("td");
    			t34 = text(t34_value);
    			attr_dev(th0, "class", "txcm-kpiDataTooltipCollumnHeader");
    			attr_dev(th0, "scope", "row");
    			add_location(th0, file$1s, 44, 10, 1427);
    			attr_dev(th1, "class", "txcm-kpiDataTooltipCollumnHeader");
    			attr_dev(th1, "scope", "row");
    			add_location(th1, file$1s, 47, 10, 1521);
    			attr_dev(th2, "class", "txcm-kpiDataTooltipCollumnHeader");
    			attr_dev(th2, "scope", "row");
    			add_location(th2, file$1s, 52, 10, 1665);
    			attr_dev(tr0, "class", "txcm-kpiDataTooltipRow");
    			add_location(tr0, file$1s, 42, 6, 1373);
    			attr_dev(th3, "class", "txcm-kpiDataTooltipRowHeader");
    			add_location(th3, file$1s, 60, 8, 1868);
    			attr_dev(td0, "class", "txcm-kpiDataTooltipRowCell");
    			add_location(td0, file$1s, 64, 8, 1984);
    			attr_dev(td1, "class", "txcm-kpiDataTooltipRowCell");
    			add_location(td1, file$1s, 68, 8, 2074);
    			attr_dev(tr1, "class", "txcm-kpiDataTooltipRow");
    			add_location(tr1, file$1s, 58, 6, 1816);
    			attr_dev(th4, "class", "txcm-kpiDataTooltipRowHeader");
    			add_location(th4, file$1s, 75, 8, 2274);
    			attr_dev(td2, "class", "txcm-kpiDataTooltipRowCell");
    			add_location(td2, file$1s, 79, 8, 2393);
    			attr_dev(td3, "class", "txcm-kpiDataTooltipRowCell");
    			add_location(td3, file$1s, 83, 8, 2483);
    			attr_dev(tr2, "class", "txcm-kpiDataTooltipRow");
    			add_location(tr2, file$1s, 73, 6, 2222);
    			attr_dev(th5, "class", "txcm-kpiDataTooltipRowHeader");
    			add_location(th5, file$1s, 90, 8, 2689);
    			attr_dev(td4, "class", "txcm-kpiDataTooltipRowCell");
    			add_location(td4, file$1s, 94, 8, 2808);
    			attr_dev(td5, "class", "txcm-kpiDataTooltipRowCell");
    			add_location(td5, file$1s, 98, 8, 2962);
    			attr_dev(tr3, "class", "txcm-kpiDataTooltipRow");
    			add_location(tr3, file$1s, 88, 6, 2637);
    			attr_dev(th6, "class", "txcm-kpiDataTooltipRowHeader");
    			add_location(th6, file$1s, 105, 8, 3170);
    			attr_dev(td6, "class", "txcm-kpiDataTooltipRowCell");
    			add_location(td6, file$1s, 109, 8, 3281);
    			attr_dev(td7, "class", "txcm-kpiDataTooltipRowCell");
    			add_location(td7, file$1s, 113, 8, 3371);
    			attr_dev(tr4, "class", "txcm-kpiDataTooltipRow");
    			add_location(tr4, file$1s, 103, 6, 3118);
    			attr_dev(th7, "class", "txcm-kpiDataTooltipRowHeader");
    			add_location(th7, file$1s, 120, 8, 3575);
    			attr_dev(td8, "class", "txcm-kpiDataTooltipRowCell");
    			add_location(td8, file$1s, 124, 8, 3685);
    			attr_dev(td9, "class", "txcm-kpiDataTooltipRowCell");
    			add_location(td9, file$1s, 128, 8, 3847);
    			attr_dev(tr5, "class", "txcm-kpiDataTooltipRow");
    			add_location(tr5, file$1s, 118, 6, 3523);
    			attr_dev(table, "class", "txcm-kpiDataTooltip");
    			add_location(table, file$1s, 40, 2, 1327);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, tr0);
    			append_dev(tr0, th0);
    			append_dev(tr0, t0);
    			append_dev(tr0, th1);
    			mount_component(int0, th1, null);
    			append_dev(tr0, t1);
    			append_dev(tr0, th2);
    			mount_component(int1, th2, null);
    			append_dev(table, t2);
    			append_dev(table, tr1);
    			append_dev(tr1, th3);
    			mount_component(int2, th3, null);
    			append_dev(th3, t3);
    			append_dev(th3, t4);
    			append_dev(tr1, t5);
    			append_dev(tr1, td0);
    			append_dev(tr1, t7);
    			append_dev(tr1, td1);
    			append_dev(td1, t8);
    			append_dev(table, t9);
    			append_dev(table, tr2);
    			append_dev(tr2, th4);
    			mount_component(int3, th4, null);
    			append_dev(th4, t10);
    			append_dev(th4, t11);
    			append_dev(tr2, t12);
    			append_dev(tr2, td2);
    			append_dev(tr2, t14);
    			append_dev(tr2, td3);
    			append_dev(td3, t15);
    			append_dev(table, t16);
    			append_dev(table, tr3);
    			append_dev(tr3, th5);
    			mount_component(int4, th5, null);
    			append_dev(th5, t17);
    			append_dev(th5, t18);
    			append_dev(tr3, t19);
    			append_dev(tr3, td4);
    			append_dev(td4, t20);
    			append_dev(tr3, t21);
    			append_dev(tr3, td5);
    			append_dev(td5, t22);
    			append_dev(table, t23);
    			append_dev(table, tr4);
    			append_dev(tr4, th6);
    			mount_component(int5, th6, null);
    			append_dev(th6, t24);
    			append_dev(th6, t25);
    			append_dev(tr4, t26);
    			append_dev(tr4, td6);
    			append_dev(tr4, t28);
    			append_dev(tr4, td7);
    			append_dev(td7, t29);
    			append_dev(table, t30);
    			append_dev(table, tr5);
    			append_dev(tr5, th7);
    			mount_component(int6, th7, null);
    			append_dev(tr5, t31);
    			append_dev(tr5, td8);
    			append_dev(td8, t32);
    			append_dev(tr5, t33);
    			append_dev(tr5, td9);
    			append_dev(td9, t34);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*factLabel*/ 2) set_data_dev(t4, /*factLabel*/ ctx[1]);

    			if ((!current || dirty & /*fact, units*/ 2056) && t8_value !== (t8_value = (/*fact*/ ctx[3]
    			? formatLabel(/*fact*/ ctx[3].qNum, /*units*/ ctx[11], "", 1)
    			: "-") + "")) set_data_dev(t8, t8_value);

    			if (!current || dirty & /*factPoPlabel*/ 4) set_data_dev(t11, /*factPoPlabel*/ ctx[2]);

    			if ((!current || dirty & /*factPp, units*/ 2064) && t15_value !== (t15_value = (/*factPp*/ ctx[4]
    			? formatLabel(/*factPp*/ ctx[4].qNum, /*units*/ ctx[11], "", 1)
    			: "-") + "")) set_data_dev(t15, t15_value);

    			if (!current || dirty & /*factPoPlabel*/ 4) set_data_dev(t18, /*factPoPlabel*/ ctx[2]);

    			if ((!current || dirty & /*factVsPpPercent*/ 64) && t20_value !== (t20_value = (/*factVsPpPercent*/ ctx[6]
    			? formatLabel(/*factVsPpPercent*/ ctx[6].qNum, "%", "%")
    			: "-") + "")) set_data_dev(t20, t20_value);

    			if ((!current || dirty & /*factVsPp, units*/ 2080) && t22_value !== (t22_value = (/*factVsPp*/ ctx[5]
    			? formatLabel(/*factVsPp*/ ctx[5].qNum, /*units*/ ctx[11], "", 1)
    			: "-") + "")) set_data_dev(t22, t22_value);

    			if (!current || dirty & /*year*/ 1024) set_data_dev(t25, /*year*/ ctx[10]);

    			if ((!current || dirty & /*budget, units*/ 2560) && t29_value !== (t29_value = (/*budget*/ ctx[9]
    			? formatLabel(/*budget*/ ctx[9].qNum, /*units*/ ctx[11], "", 1)
    			: "-") + "")) set_data_dev(t29, t29_value);

    			if ((!current || dirty & /*factVsBudgetPercent*/ 256) && t32_value !== (t32_value = (/*factVsBudgetPercent*/ ctx[8]
    			? formatLabel(/*factVsBudgetPercent*/ ctx[8].qNum, "%", "%")
    			: "-") + "")) set_data_dev(t32, t32_value);

    			if ((!current || dirty & /*factVsBudget, units*/ 2176) && t34_value !== (t34_value = (/*factVsBudget*/ ctx[7]
    			? formatLabel(/*factVsBudget*/ ctx[7].qNum, /*units*/ ctx[11], "", 1)
    			: "-") + "")) set_data_dev(t34, t34_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			transition_in(int2.$$.fragment, local);
    			transition_in(int3.$$.fragment, local);
    			transition_in(int4.$$.fragment, local);
    			transition_in(int5.$$.fragment, local);
    			transition_in(int6.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			transition_out(int2.$$.fragment, local);
    			transition_out(int3.$$.fragment, local);
    			transition_out(int4.$$.fragment, local);
    			transition_out(int5.$$.fragment, local);
    			transition_out(int6.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_component(int0);
    			destroy_component(int1);
    			destroy_component(int2);
    			destroy_component(int3);
    			destroy_component(int4);
    			destroy_component(int5);
    			destroy_component(int6);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(40:0) {#if data}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1I(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*data*/ ctx[0] && create_if_block$r(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*data*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*data*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$r(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1I($$self, $$props, $$invalidate) {
    	let $date;
    	let $datePoP;
    	let $datePrecision;
    	let $locale;
    	let { data } = $$props;
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(16, $date = value));
    	const datePoP = getDashboardState("datePoP");
    	validate_store(datePoP, "datePoP");
    	component_subscribe($$self, datePoP, value => $$invalidate(17, $datePoP = value));
    	const datePrecision = getDashboardState("datePrecision");
    	validate_store(datePrecision, "datePrecision");
    	component_subscribe($$self, datePrecision, value => $$invalidate(18, $datePrecision = value));
    	let factLabel;
    	let factPoPlabel;
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(19, $locale = value));

    	function updateLabels() {
    		if ($datePrecision === 0) {
    			$$invalidate(1, factLabel = `${renderDateShort($date, $locale)} ${renderYear($date)}`);
    			$$invalidate(2, factPoPlabel = `${renderDateShort($datePoP, $locale)} ${renderYear($datePoP)}`);
    		} else {
    			$$invalidate(1, factLabel = renderPreciseDate($date, $datePrecision, $locale));
    			$$invalidate(2, factPoPlabel = renderPreciseDate($datePoP, $datePrecision, $locale));
    		}
    	}

    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<KPITooltip> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("KPITooltip", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		renderYear,
    		renderDateShort,
    		formatLabel,
    		translate,
    		getUIState,
    		Int,
    		renderPreciseDate,
    		data,
    		date,
    		datePoP,
    		datePrecision,
    		factLabel,
    		factPoPlabel,
    		locale,
    		updateLabels,
    		fact,
    		factPp,
    		factVsPp,
    		factVsPpPercent,
    		factVsBudget,
    		factVsBudgetPercent,
    		budget,
    		year,
    		$date,
    		units,
    		$datePoP,
    		$datePrecision,
    		$locale
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("factLabel" in $$props) $$invalidate(1, factLabel = $$props.factLabel);
    		if ("factPoPlabel" in $$props) $$invalidate(2, factPoPlabel = $$props.factPoPlabel);
    		if ("fact" in $$props) $$invalidate(3, fact = $$props.fact);
    		if ("factPp" in $$props) $$invalidate(4, factPp = $$props.factPp);
    		if ("factVsPp" in $$props) $$invalidate(5, factVsPp = $$props.factVsPp);
    		if ("factVsPpPercent" in $$props) $$invalidate(6, factVsPpPercent = $$props.factVsPpPercent);
    		if ("factVsBudget" in $$props) $$invalidate(7, factVsBudget = $$props.factVsBudget);
    		if ("factVsBudgetPercent" in $$props) $$invalidate(8, factVsBudgetPercent = $$props.factVsBudgetPercent);
    		if ("budget" in $$props) $$invalidate(9, budget = $$props.budget);
    		if ("year" in $$props) $$invalidate(10, year = $$props.year);
    		if ("units" in $$props) $$invalidate(11, units = $$props.units);
    	};

    	let fact;
    	let factPp;
    	let factVsPp;
    	let factVsPpPercent;
    	let factVsBudget;
    	let factVsBudgetPercent;
    	let budget;
    	let year;
    	let units;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 1) {
    			 $$invalidate(3, { fact, factPp, factVsPp, factVsPpPercent, factVsBudget, factVsBudgetPercent, budget } = data.tooltip, fact, ($$invalidate(4, factPp), $$invalidate(0, data)), ($$invalidate(5, factVsPp), $$invalidate(0, data)), ($$invalidate(6, factVsPpPercent), $$invalidate(0, data)), ($$invalidate(7, factVsBudget), $$invalidate(0, data)), ($$invalidate(8, factVsBudgetPercent), $$invalidate(0, data)), ($$invalidate(9, budget), $$invalidate(0, data)));
    		}

    		if ($$self.$$.dirty & /*$date*/ 65536) {
    			 $$invalidate(10, year = renderYear($date));
    		}

    		if ($$self.$$.dirty & /*data*/ 1) {
    			 $$invalidate(11, units = data.units);
    		}

    		if ($$self.$$.dirty & /*$date, $datePoP, $datePrecision*/ 458752) {
    			 updateLabels();
    		}
    	};

    	return [
    		data,
    		factLabel,
    		factPoPlabel,
    		fact,
    		factPp,
    		factVsPp,
    		factVsPpPercent,
    		factVsBudget,
    		factVsBudgetPercent,
    		budget,
    		year,
    		units,
    		date,
    		datePoP,
    		datePrecision,
    		locale
    	];
    }

    class KPITooltip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1I, create_fragment$1I, safe_not_equal, { data: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KPITooltip",
    			options,
    			id: create_fragment$1I.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<KPITooltip> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<KPITooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<KPITooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/kpi/KPICell.svelte generated by Svelte v3.24.0 */
    const file$1t = "src/js/components/kpi/KPICell.svelte";

    // (42:2) {#if loaded}
    function create_if_block$s(ctx) {
    	let kpicolumn0;
    	let t0;
    	let kpicolumn1;
    	let t1;
    	let kpicolumn2;
    	let current;

    	kpicolumn0 = new KPIColumn({
    			props: {
    				$$slots: { default: [create_default_slot_6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	kpicolumn1 = new KPIColumn({
    			props: {
    				$$slots: { default: [create_default_slot_3$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	kpicolumn2 = new KPIColumn({
    			props: {
    				$$slots: { default: [create_default_slot$w] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(kpicolumn0.$$.fragment);
    			t0 = space();
    			create_component(kpicolumn1.$$.fragment);
    			t1 = space();
    			create_component(kpicolumn2.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(kpicolumn0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(kpicolumn1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(kpicolumn2, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const kpicolumn0_changes = {};

    			if (dirty & /*$$scope, arrow, fact, indicator, units*/ 16651) {
    				kpicolumn0_changes.$$scope = { dirty, ctx };
    			}

    			kpicolumn0.$set(kpicolumn0_changes);
    			const kpicolumn1_changes = {};

    			if (dirty & /*$$scope, fact, factVsPpPercent, arrow, units, factVsPp, indicator*/ 16699) {
    				kpicolumn1_changes.$$scope = { dirty, ctx };
    			}

    			kpicolumn1.$set(kpicolumn1_changes);
    			const kpicolumn2_changes = {};

    			if (dirty & /*$$scope, fact, factVsBudgetPercent, arrow, units, factVsBudget, indicator*/ 16843) {
    				kpicolumn2_changes.$$scope = { dirty, ctx };
    			}

    			kpicolumn2.$set(kpicolumn2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(kpicolumn0.$$.fragment, local);
    			transition_in(kpicolumn1.$$.fragment, local);
    			transition_in(kpicolumn2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(kpicolumn0.$$.fragment, local);
    			transition_out(kpicolumn1.$$.fragment, local);
    			transition_out(kpicolumn2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(kpicolumn0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(kpicolumn1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(kpicolumn2, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(42:2) {#if loaded}",
    		ctx
    	});

    	return block;
    }

    // (44:6) <KPIValue         units={0}         status={true}         dynamics={!arrow ? -1 : arrow.qNum } >
    function create_default_slot_7(ctx) {
    	let t_value = (/*fact*/ ctx[3]
    	? formatLabel(
    			/*indicator*/ ctx[1].id != 7 && /*indicator*/ ctx[1].id != 18
    			? /*fact*/ ctx[3].qNum
    			: /*fact*/ ctx[3].qNum / 1000,
    			/*units*/ ctx[0],
    			/*units*/ ctx[0] === "%" ? "%" : "",
    			/*indicator*/ ctx[1].id != 4 ? 1000000 : 1
    		)
    	: "-") + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fact, indicator, units*/ 11 && t_value !== (t_value = (/*fact*/ ctx[3]
    			? formatLabel(
    					/*indicator*/ ctx[1].id != 7 && /*indicator*/ ctx[1].id != 18
    					? /*fact*/ ctx[3].qNum
    					: /*fact*/ ctx[3].qNum / 1000,
    					/*units*/ ctx[0],
    					/*units*/ ctx[0] === "%" ? "%" : "",
    					/*indicator*/ ctx[1].id != 4 ? 1000000 : 1
    				)
    			: "-") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(44:6) <KPIValue         units={0}         status={true}         dynamics={!arrow ? -1 : arrow.qNum } >",
    		ctx
    	});

    	return block;
    }

    // (43:4) <KPIColumn>
    function create_default_slot_6(ctx) {
    	let kpivalue;
    	let current;

    	kpivalue = new KPIValue({
    			props: {
    				units: 0,
    				status: true,
    				dynamics: !/*arrow*/ ctx[8] ? -1 : /*arrow*/ ctx[8].qNum,
    				$$slots: { default: [create_default_slot_7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(kpivalue.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(kpivalue, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const kpivalue_changes = {};
    			if (dirty & /*arrow*/ 256) kpivalue_changes.dynamics = !/*arrow*/ ctx[8] ? -1 : /*arrow*/ ctx[8].qNum;

    			if (dirty & /*$$scope, fact, indicator, units*/ 16395) {
    				kpivalue_changes.$$scope = { dirty, ctx };
    			}

    			kpivalue.$set(kpivalue_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(kpivalue.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(kpivalue.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(kpivalue, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(43:4) <KPIColumn>",
    		ctx
    	});

    	return block;
    }

    // (53:6) <KPIValue         units={0}         dynamics={checkArrowDynamics(fact ? fact.qNum : 0, units !== '%' && factVsPp ? factVsPp.qNum : 0, !arrow ? -1 : arrow.qNum)}>
    function create_default_slot_5(ctx) {
    	let t_value = (/*units*/ ctx[0] !== "%"
    	? /*factVsPp*/ ctx[4]
    		? formatLabel(
    				/*indicator*/ ctx[1].id != 7 && /*indicator*/ ctx[1].id != 18
    				? /*factVsPp*/ ctx[4].qNum
    				: /*factVsPp*/ ctx[4].qNum / 1000,
    				/*units*/ ctx[0],
    				"",
    				/*indicator*/ ctx[1].id != 4 ? 1000000 : 1
    			)
    		: "-"
    	: "") + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*units, factVsPp, indicator*/ 19 && t_value !== (t_value = (/*units*/ ctx[0] !== "%"
    			? /*factVsPp*/ ctx[4]
    				? formatLabel(
    						/*indicator*/ ctx[1].id != 7 && /*indicator*/ ctx[1].id != 18
    						? /*factVsPp*/ ctx[4].qNum
    						: /*factVsPp*/ ctx[4].qNum / 1000,
    						/*units*/ ctx[0],
    						"",
    						/*indicator*/ ctx[1].id != 4 ? 1000000 : 1
    					)
    				: "-"
    			: "") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(53:6) <KPIValue         units={0}         dynamics={checkArrowDynamics(fact ? fact.qNum : 0, units !== '%' && factVsPp ? factVsPp.qNum : 0, !arrow ? -1 : arrow.qNum)}>",
    		ctx
    	});

    	return block;
    }

    // (59:6) <KPIValue         units={0}         dynamics={checkArrowDynamics(fact ? fact.qNum : 0, factVsPpPercent ? factVsPpPercent.qNum : 0, !arrow ? -1 : arrow.qNum)}>
    function create_default_slot_4(ctx) {
    	let t_value = (/*factVsPpPercent*/ ctx[5]
    	? formatLabel(/*factVsPpPercent*/ ctx[5].qNum, "%", /*units*/ ctx[0] === "%" ? "п.п." : "%")
    	: "-") + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*factVsPpPercent, units*/ 33 && t_value !== (t_value = (/*factVsPpPercent*/ ctx[5]
    			? formatLabel(/*factVsPpPercent*/ ctx[5].qNum, "%", /*units*/ ctx[0] === "%" ? "п.п." : "%")
    			: "-") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(59:6) <KPIValue         units={0}         dynamics={checkArrowDynamics(fact ? fact.qNum : 0, factVsPpPercent ? factVsPpPercent.qNum : 0, !arrow ? -1 : arrow.qNum)}>",
    		ctx
    	});

    	return block;
    }

    // (52:4) <KPIColumn>
    function create_default_slot_3$2(ctx) {
    	let kpivalue0;
    	let t;
    	let kpivalue1;
    	let current;

    	kpivalue0 = new KPIValue({
    			props: {
    				units: 0,
    				dynamics: checkArrowDynamics(
    					/*fact*/ ctx[3] ? /*fact*/ ctx[3].qNum : 0,
    					/*units*/ ctx[0] !== "%" && /*factVsPp*/ ctx[4]
    					? /*factVsPp*/ ctx[4].qNum
    					: 0,
    					!/*arrow*/ ctx[8] ? -1 : /*arrow*/ ctx[8].qNum
    				),
    				$$slots: { default: [create_default_slot_5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	kpivalue1 = new KPIValue({
    			props: {
    				units: 0,
    				dynamics: checkArrowDynamics(
    					/*fact*/ ctx[3] ? /*fact*/ ctx[3].qNum : 0,
    					/*factVsPpPercent*/ ctx[5]
    					? /*factVsPpPercent*/ ctx[5].qNum
    					: 0,
    					!/*arrow*/ ctx[8] ? -1 : /*arrow*/ ctx[8].qNum
    				),
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(kpivalue0.$$.fragment);
    			t = space();
    			create_component(kpivalue1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(kpivalue0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(kpivalue1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const kpivalue0_changes = {};

    			if (dirty & /*fact, units, factVsPp, arrow*/ 281) kpivalue0_changes.dynamics = checkArrowDynamics(
    				/*fact*/ ctx[3] ? /*fact*/ ctx[3].qNum : 0,
    				/*units*/ ctx[0] !== "%" && /*factVsPp*/ ctx[4]
    				? /*factVsPp*/ ctx[4].qNum
    				: 0,
    				!/*arrow*/ ctx[8] ? -1 : /*arrow*/ ctx[8].qNum
    			);

    			if (dirty & /*$$scope, units, factVsPp, indicator*/ 16403) {
    				kpivalue0_changes.$$scope = { dirty, ctx };
    			}

    			kpivalue0.$set(kpivalue0_changes);
    			const kpivalue1_changes = {};

    			if (dirty & /*fact, factVsPpPercent, arrow*/ 296) kpivalue1_changes.dynamics = checkArrowDynamics(
    				/*fact*/ ctx[3] ? /*fact*/ ctx[3].qNum : 0,
    				/*factVsPpPercent*/ ctx[5]
    				? /*factVsPpPercent*/ ctx[5].qNum
    				: 0,
    				!/*arrow*/ ctx[8] ? -1 : /*arrow*/ ctx[8].qNum
    			);

    			if (dirty & /*$$scope, factVsPpPercent, units*/ 16417) {
    				kpivalue1_changes.$$scope = { dirty, ctx };
    			}

    			kpivalue1.$set(kpivalue1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(kpivalue0.$$.fragment, local);
    			transition_in(kpivalue1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(kpivalue0.$$.fragment, local);
    			transition_out(kpivalue1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(kpivalue0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(kpivalue1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(52:4) <KPIColumn>",
    		ctx
    	});

    	return block;
    }

    // (66:6) <KPIValue         {units}         dynamics={checkArrowDynamics(fact ? fact.qNum : 0, units !== '%' && factVsBudget ? factVsBudget.qNum : 0, !arrow ? -1 : arrow.qNum)}>
    function create_default_slot_2$3(ctx) {
    	let t_value = (/*units*/ ctx[0] !== "%"
    	? /*factVsBudget*/ ctx[6]
    		? formatLabel(/*factVsBudget*/ ctx[6].qNum, /*units*/ ctx[0], "", /*indicator*/ ctx[1].id != 4 ? 1000000 : 1)
    		: "-"
    	: "") + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*units, factVsBudget, indicator*/ 67 && t_value !== (t_value = (/*units*/ ctx[0] !== "%"
    			? /*factVsBudget*/ ctx[6]
    				? formatLabel(/*factVsBudget*/ ctx[6].qNum, /*units*/ ctx[0], "", /*indicator*/ ctx[1].id != 4 ? 1000000 : 1)
    				: "-"
    			: "") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(66:6) <KPIValue         {units}         dynamics={checkArrowDynamics(fact ? fact.qNum : 0, units !== '%' && factVsBudget ? factVsBudget.qNum : 0, !arrow ? -1 : arrow.qNum)}>",
    		ctx
    	});

    	return block;
    }

    // (72:6) <KPIValue         units={0}         dynamics={checkArrowDynamics(fact ? fact.qNum : 0, factVsBudgetPercent ? factVsBudgetPercent.qNum : 0, !arrow ? -1 : arrow.qNum)}>
    function create_default_slot_1$8(ctx) {
    	let t_value = (/*factVsBudgetPercent*/ ctx[7]
    	? formatLabel(/*factVsBudgetPercent*/ ctx[7].qNum, "%", /*units*/ ctx[0] === "%" ? "п.п." : "%")
    	: "-") + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*factVsBudgetPercent, units*/ 129 && t_value !== (t_value = (/*factVsBudgetPercent*/ ctx[7]
    			? formatLabel(/*factVsBudgetPercent*/ ctx[7].qNum, "%", /*units*/ ctx[0] === "%" ? "п.п." : "%")
    			: "-") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(72:6) <KPIValue         units={0}         dynamics={checkArrowDynamics(fact ? fact.qNum : 0, factVsBudgetPercent ? factVsBudgetPercent.qNum : 0, !arrow ? -1 : arrow.qNum)}>",
    		ctx
    	});

    	return block;
    }

    // (65:4) <KPIColumn>
    function create_default_slot$w(ctx) {
    	let kpivalue0;
    	let t;
    	let kpivalue1;
    	let current;

    	kpivalue0 = new KPIValue({
    			props: {
    				units: /*units*/ ctx[0],
    				dynamics: checkArrowDynamics(
    					/*fact*/ ctx[3] ? /*fact*/ ctx[3].qNum : 0,
    					/*units*/ ctx[0] !== "%" && /*factVsBudget*/ ctx[6]
    					? /*factVsBudget*/ ctx[6].qNum
    					: 0,
    					!/*arrow*/ ctx[8] ? -1 : /*arrow*/ ctx[8].qNum
    				),
    				$$slots: { default: [create_default_slot_2$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	kpivalue1 = new KPIValue({
    			props: {
    				units: 0,
    				dynamics: checkArrowDynamics(
    					/*fact*/ ctx[3] ? /*fact*/ ctx[3].qNum : 0,
    					/*factVsBudgetPercent*/ ctx[7]
    					? /*factVsBudgetPercent*/ ctx[7].qNum
    					: 0,
    					!/*arrow*/ ctx[8] ? -1 : /*arrow*/ ctx[8].qNum
    				),
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(kpivalue0.$$.fragment);
    			t = space();
    			create_component(kpivalue1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(kpivalue0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(kpivalue1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const kpivalue0_changes = {};
    			if (dirty & /*units*/ 1) kpivalue0_changes.units = /*units*/ ctx[0];

    			if (dirty & /*fact, units, factVsBudget, arrow*/ 329) kpivalue0_changes.dynamics = checkArrowDynamics(
    				/*fact*/ ctx[3] ? /*fact*/ ctx[3].qNum : 0,
    				/*units*/ ctx[0] !== "%" && /*factVsBudget*/ ctx[6]
    				? /*factVsBudget*/ ctx[6].qNum
    				: 0,
    				!/*arrow*/ ctx[8] ? -1 : /*arrow*/ ctx[8].qNum
    			);

    			if (dirty & /*$$scope, units, factVsBudget, indicator*/ 16451) {
    				kpivalue0_changes.$$scope = { dirty, ctx };
    			}

    			kpivalue0.$set(kpivalue0_changes);
    			const kpivalue1_changes = {};

    			if (dirty & /*fact, factVsBudgetPercent, arrow*/ 392) kpivalue1_changes.dynamics = checkArrowDynamics(
    				/*fact*/ ctx[3] ? /*fact*/ ctx[3].qNum : 0,
    				/*factVsBudgetPercent*/ ctx[7]
    				? /*factVsBudgetPercent*/ ctx[7].qNum
    				: 0,
    				!/*arrow*/ ctx[8] ? -1 : /*arrow*/ ctx[8].qNum
    			);

    			if (dirty & /*$$scope, factVsBudgetPercent, units*/ 16513) {
    				kpivalue1_changes.$$scope = { dirty, ctx };
    			}

    			kpivalue1.$set(kpivalue1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(kpivalue0.$$.fragment, local);
    			transition_in(kpivalue1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(kpivalue0.$$.fragment, local);
    			transition_out(kpivalue1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(kpivalue0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(kpivalue1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$w.name,
    		type: "slot",
    		source: "(65:4) <KPIColumn>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1J(ctx) {
    	let div;
    	let tooltip_action;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*loaded*/ ctx[2] && create_if_block$s(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "txcm-kpiCell");
    			add_location(div, file$1t, 38, 0, 1012);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(tooltip_action = tooltip.call(null, div, /*tooltipOptions*/ ctx[9]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*loaded*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$s(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (tooltip_action && is_function(tooltip_action.update) && dirty & /*tooltipOptions*/ 512) tooltip_action.update.call(null, /*tooltipOptions*/ ctx[9]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1J($$self, $$props, $$invalidate) {
    	let $activeIndicators;
    	let { data } = $$props;
    	let { units } = $$props;
    	let { indicator } = $$props;
    	let { loaded } = $$props;
    	const activeIndicators = getActiveIndicatorsState();
    	validate_store(activeIndicators, "activeIndicators");
    	component_subscribe($$self, activeIndicators, value => $$invalidate(12, $activeIndicators = value));

    	function updateTooltip() {
    		return {
    			content: {
    				component: KPITooltip,
    				data: { tooltip: data, indicator, units }
    			},
    			side: "right"
    		};
    	}

    	const writable_props = ["data", "units", "indicator", "loaded"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<KPICell> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("KPICell", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(11, data = $$props.data);
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("loaded" in $$props) $$invalidate(2, loaded = $$props.loaded);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		tooltip,
    		checkArrowDynamics,
    		compareDynamics,
    		KPIColumn,
    		KPIValue,
    		KPITooltip,
    		formatLabel,
    		getActiveIndicatorsState,
    		data,
    		units,
    		indicator,
    		loaded,
    		activeIndicators,
    		updateTooltip,
    		fact,
    		factVsPp,
    		factVsPpPercent,
    		factVsBudget,
    		factVsBudgetPercent,
    		arrow,
    		tooltipOptions,
    		$activeIndicators
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(11, data = $$props.data);
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("loaded" in $$props) $$invalidate(2, loaded = $$props.loaded);
    		if ("fact" in $$props) $$invalidate(3, fact = $$props.fact);
    		if ("factVsPp" in $$props) $$invalidate(4, factVsPp = $$props.factVsPp);
    		if ("factVsPpPercent" in $$props) $$invalidate(5, factVsPpPercent = $$props.factVsPpPercent);
    		if ("factVsBudget" in $$props) $$invalidate(6, factVsBudget = $$props.factVsBudget);
    		if ("factVsBudgetPercent" in $$props) $$invalidate(7, factVsBudgetPercent = $$props.factVsBudgetPercent);
    		if ("arrow" in $$props) $$invalidate(8, arrow = $$props.arrow);
    		if ("tooltipOptions" in $$props) $$invalidate(9, tooltipOptions = $$props.tooltipOptions);
    	};

    	let fact;
    	let factVsPp;
    	let factVsPpPercent;
    	let factVsBudget;
    	let factVsBudgetPercent;
    	let arrow;
    	let tooltipOptions;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 2048) {
    			 $$invalidate(3, { fact, factVsPp, factVsPpPercent, factVsBudget, factVsBudgetPercent, arrow } = data, fact, ($$invalidate(4, factVsPp), $$invalidate(11, data)), ($$invalidate(5, factVsPpPercent), $$invalidate(11, data)), ($$invalidate(6, factVsBudget), $$invalidate(11, data)), ($$invalidate(7, factVsBudgetPercent), $$invalidate(11, data)), ($$invalidate(8, arrow), $$invalidate(11, data)));
    		}

    		if ($$self.$$.dirty & /*data, $activeIndicators*/ 6144) {
    			 $$invalidate(9, tooltipOptions = updateTooltip());
    		}
    	};

    	return [
    		units,
    		indicator,
    		loaded,
    		fact,
    		factVsPp,
    		factVsPpPercent,
    		factVsBudget,
    		factVsBudgetPercent,
    		arrow,
    		tooltipOptions,
    		activeIndicators,
    		data
    	];
    }

    class KPICell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1J, create_fragment$1J, safe_not_equal, {
    			data: 11,
    			units: 0,
    			indicator: 1,
    			loaded: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KPICell",
    			options,
    			id: create_fragment$1J.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[11] === undefined && !("data" in props)) {
    			console.warn("<KPICell> was created without expected prop 'data'");
    		}

    		if (/*units*/ ctx[0] === undefined && !("units" in props)) {
    			console.warn("<KPICell> was created without expected prop 'units'");
    		}

    		if (/*indicator*/ ctx[1] === undefined && !("indicator" in props)) {
    			console.warn("<KPICell> was created without expected prop 'indicator'");
    		}

    		if (/*loaded*/ ctx[2] === undefined && !("loaded" in props)) {
    			console.warn("<KPICell> was created without expected prop 'loaded'");
    		}
    	}

    	get data() {
    		throw new Error("<KPICell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<KPICell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<KPICell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<KPICell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<KPICell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<KPICell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get loaded() {
    		throw new Error("<KPICell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set loaded(value) {
    		throw new Error("<KPICell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/deviation/DeviationCount.svelte generated by Svelte v3.24.0 */
    const file$1u = "src/js/components/deviation/DeviationCount.svelte";

    function create_fragment$1K(ctx) {
    	let div;
    	let tooltip_action;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "txcm-deviationCount");
    			attr_dev(div, "data-count", /*value*/ ctx[0]);
    			add_location(div, file$1u, 16, 0, 326);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = action_destroyer(tooltip_action = tooltip.call(null, div, /*tooltipOptions*/ ctx[1]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*value*/ 1) {
    				attr_dev(div, "data-count", /*value*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1K($$self, $$props, $$invalidate) {
    	let { value } = $$props;

    	const tooltipOptions = {
    		content: {
    			component: DeviationHint,
    			data: "Количество отклонений"
    		},
    		side: "right",
    		theme: "txcm-tooltip-deviationHint"
    	};

    	const writable_props = ["value"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DeviationCount> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DeviationCount", $$slots, []);

    	$$self.$set = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    	};

    	$$self.$capture_state = () => ({
    		DeviationHint,
    		tooltip,
    		value,
    		tooltipOptions
    	});

    	$$self.$inject_state = $$props => {
    		if ("value" in $$props) $$invalidate(0, value = $$props.value);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [value, tooltipOptions];
    }

    class DeviationCount extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1K, create_fragment$1K, safe_not_equal, { value: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DeviationCount",
    			options,
    			id: create_fragment$1K.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*value*/ ctx[0] === undefined && !("value" in props)) {
    			console.warn("<DeviationCount> was created without expected prop 'value'");
    		}
    	}

    	get value() {
    		throw new Error("<DeviationCount>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<DeviationCount>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/deviation/DeviationLabel.svelte generated by Svelte v3.24.0 */
    const file$1v = "src/js/components/deviation/DeviationLabel.svelte";

    // (38:0) {:else}
    function create_else_block$5(ctx) {
    	let div;
    	let deviationcount;
    	let t;
    	let int;
    	let current;

    	deviationcount = new DeviationCount({
    			props: { value: /*data*/ ctx[0].countDeviation },
    			$$inline: true
    		});

    	int = new Int({
    			props: { key: /*label*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(deviationcount.$$.fragment);
    			t = space();
    			create_component(int.$$.fragment);
    			attr_dev(div, "class", "txcm-deviationLabel");
    			add_location(div, file$1v, 38, 2, 936);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(deviationcount, div, null);
    			append_dev(div, t);
    			mount_component(int, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const deviationcount_changes = {};
    			if (dirty & /*data*/ 1) deviationcount_changes.value = /*data*/ ctx[0].countDeviation;
    			deviationcount.$set(deviationcount_changes);
    			const int_changes = {};
    			if (dirty & /*label*/ 4) int_changes.key = /*label*/ ctx[2];
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deviationcount.$$.fragment, local);
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deviationcount.$$.fragment, local);
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(deviationcount);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(38:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (26:0) {#if indicator}
    function create_if_block$t(ctx) {
    	let div;
    	let navlink;
    	let current;

    	navlink = new NavLink({
    			props: {
    				to: /*renderDeviationURL*/ ctx[3](),
    				linkClass: "txcm-deviationLabelLink",
    				$$slots: { default: [create_default_slot$x] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(navlink.$$.fragment);
    			attr_dev(div, "class", "txcm-deviationLabel");
    			add_location(div, file$1v, 26, 0, 673);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(navlink, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navlink_changes = {};

    			if (dirty & /*$$scope, label, data*/ 261) {
    				navlink_changes.$$scope = { dirty, ctx };
    			}

    			navlink.$set(navlink_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navlink.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navlink.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(navlink);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(26:0) {#if indicator}",
    		ctx
    	});

    	return block;
    }

    // (29:4) <NavLink       to={renderDeviationURL()}       linkClass="txcm-deviationLabelLink">
    function create_default_slot$x(ctx) {
    	let deviationcount;
    	let t;
    	let int;
    	let current;

    	deviationcount = new DeviationCount({
    			props: { value: /*data*/ ctx[0].countDeviation },
    			$$inline: true
    		});

    	int = new Int({
    			props: { key: /*label*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(deviationcount.$$.fragment);
    			t = space();
    			create_component(int.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deviationcount, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(int, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const deviationcount_changes = {};
    			if (dirty & /*data*/ 1) deviationcount_changes.value = /*data*/ ctx[0].countDeviation;
    			deviationcount.$set(deviationcount_changes);
    			const int_changes = {};
    			if (dirty & /*label*/ 4) int_changes.key = /*label*/ ctx[2];
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deviationcount.$$.fragment, local);
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deviationcount.$$.fragment, local);
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deviationcount, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(int, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$x.name,
    		type: "slot",
    		source: "(29:4) <NavLink       to={renderDeviationURL()}       linkClass=\\\"txcm-deviationLabelLink\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1L(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$t, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*indicator*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1L($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { multiple } = $$props;
    	let { indicator = null } = $$props;
    	let { tab = null } = $$props;
    	const dashboard = getContext("config").getDashboard();

    	function renderLabel() {
    		return `Отклонения по ${multiple}`;
    	}

    	function renderDeviationURL() {
    		return `${renderURL(dashboard, indicator.url)}#${tab}`;
    	}

    	const writable_props = ["data", "multiple", "indicator", "tab"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DeviationLabel> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DeviationLabel", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("multiple" in $$props) $$invalidate(4, multiple = $$props.multiple);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("tab" in $$props) $$invalidate(5, tab = $$props.tab);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		Int,
    		NavLink,
    		renderURL,
    		DeviationCount,
    		data,
    		multiple,
    		indicator,
    		tab,
    		dashboard,
    		renderLabel,
    		renderDeviationURL,
    		label
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("multiple" in $$props) $$invalidate(4, multiple = $$props.multiple);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("tab" in $$props) $$invalidate(5, tab = $$props.tab);
    		if ("label" in $$props) $$invalidate(2, label = $$props.label);
    	};

    	let label;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 1) {
    			 $$invalidate(2, label = renderLabel());
    		}
    	};

    	return [data, indicator, label, renderDeviationURL, multiple, tab];
    }

    class DeviationLabel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1L, create_fragment$1L, safe_not_equal, {
    			data: 0,
    			multiple: 4,
    			indicator: 1,
    			tab: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DeviationLabel",
    			options,
    			id: create_fragment$1L.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<DeviationLabel> was created without expected prop 'data'");
    		}

    		if (/*multiple*/ ctx[4] === undefined && !("multiple" in props)) {
    			console.warn("<DeviationLabel> was created without expected prop 'multiple'");
    		}
    	}

    	get data() {
    		throw new Error("<DeviationLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<DeviationLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiple() {
    		throw new Error("<DeviationLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiple(value) {
    		throw new Error("<DeviationLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<DeviationLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<DeviationLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tab() {
    		throw new Error("<DeviationLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tab(value) {
    		throw new Error("<DeviationLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/deviation/DeviationColumn.svelte generated by Svelte v3.24.0 */

    const file$1w = "src/js/components/deviation/DeviationColumn.svelte";

    function create_fragment$1M(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "txcm-deviationColumn");
    			add_location(div, file$1w, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1M($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DeviationColumn> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DeviationColumn", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, $$slots];
    }

    class DeviationColumn extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1M, create_fragment$1M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DeviationColumn",
    			options,
    			id: create_fragment$1M.name
    		});
    	}
    }

    /* src/js/components/deviation/DeviationValue.svelte generated by Svelte v3.24.0 */
    const file$1x = "src/js/components/deviation/DeviationValue.svelte";

    function create_fragment$1N(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", div_class_value = renderDynamicsClass("txcm-deviationValue", /*dynamics*/ ctx[0]));
    			add_location(div, file$1x, 6, 0, 109);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*dynamics*/ 1 && div_class_value !== (div_class_value = renderDynamicsClass("txcm-deviationValue", /*dynamics*/ ctx[0]))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1N($$self, $$props, $$invalidate) {
    	let { dynamics = 0 } = $$props;
    	const writable_props = ["dynamics"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DeviationValue> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DeviationValue", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("dynamics" in $$props) $$invalidate(0, dynamics = $$props.dynamics);
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ renderDynamicsClass, dynamics });

    	$$self.$inject_state = $$props => {
    		if ("dynamics" in $$props) $$invalidate(0, dynamics = $$props.dynamics);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dynamics, $$scope, $$slots];
    }

    class DeviationValue extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1N, create_fragment$1N, safe_not_equal, { dynamics: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DeviationValue",
    			options,
    			id: create_fragment$1N.name
    		});
    	}

    	get dynamics() {
    		throw new Error("<DeviationValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dynamics(value) {
    		throw new Error("<DeviationValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/deviation/DeviationCell.svelte generated by Svelte v3.24.0 */
    const file$1y = "src/js/components/deviation/DeviationCell.svelte";

    // (18:6) <DeviationValue         dynamics={checkDynamics(budgetPercent ? budgetPercent.qNum : 0)}>
    function create_default_slot_3$3(ctx) {
    	let t_value = (/*budgetPercent*/ ctx[1]
    	? /*budgetPercent*/ ctx[1].qText
    	: "") + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*budgetPercent*/ 2 && t_value !== (t_value = (/*budgetPercent*/ ctx[1]
    			? /*budgetPercent*/ ctx[1].qText
    			: "") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(18:6) <DeviationValue         dynamics={checkDynamics(budgetPercent ? budgetPercent.qNum : 0)}>",
    		ctx
    	});

    	return block;
    }

    // (17:4) <DeviationColumn>
    function create_default_slot_2$4(ctx) {
    	let deviationvalue;
    	let current;

    	deviationvalue = new DeviationValue({
    			props: {
    				dynamics: checkDynamics(/*budgetPercent*/ ctx[1]
    				? /*budgetPercent*/ ctx[1].qNum
    				: 0),
    				$$slots: { default: [create_default_slot_3$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(deviationvalue.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deviationvalue, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const deviationvalue_changes = {};

    			if (dirty & /*budgetPercent*/ 2) deviationvalue_changes.dynamics = checkDynamics(/*budgetPercent*/ ctx[1]
    			? /*budgetPercent*/ ctx[1].qNum
    			: 0);

    			if (dirty & /*$$scope, budgetPercent*/ 18) {
    				deviationvalue_changes.$$scope = { dirty, ctx };
    			}

    			deviationvalue.$set(deviationvalue_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deviationvalue.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deviationvalue.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deviationvalue, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(17:4) <DeviationColumn>",
    		ctx
    	});

    	return block;
    }

    // (24:6) <DeviationValue         dynamics={checkDynamics(vsPpPercent ? vsPpPercent.qNum : 0)}>
    function create_default_slot_1$9(ctx) {
    	let t_value = (/*vsPpPercent*/ ctx[0]
    	? /*vsPpPercent*/ ctx[0].qText
    	: "") + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*vsPpPercent*/ 1 && t_value !== (t_value = (/*vsPpPercent*/ ctx[0]
    			? /*vsPpPercent*/ ctx[0].qText
    			: "") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(24:6) <DeviationValue         dynamics={checkDynamics(vsPpPercent ? vsPpPercent.qNum : 0)}>",
    		ctx
    	});

    	return block;
    }

    // (23:4) <DeviationColumn>
    function create_default_slot$y(ctx) {
    	let deviationvalue;
    	let current;

    	deviationvalue = new DeviationValue({
    			props: {
    				dynamics: checkDynamics(/*vsPpPercent*/ ctx[0] ? /*vsPpPercent*/ ctx[0].qNum : 0),
    				$$slots: { default: [create_default_slot_1$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(deviationvalue.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deviationvalue, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const deviationvalue_changes = {};
    			if (dirty & /*vsPpPercent*/ 1) deviationvalue_changes.dynamics = checkDynamics(/*vsPpPercent*/ ctx[0] ? /*vsPpPercent*/ ctx[0].qNum : 0);

    			if (dirty & /*$$scope, vsPpPercent*/ 17) {
    				deviationvalue_changes.$$scope = { dirty, ctx };
    			}

    			deviationvalue.$set(deviationvalue_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deviationvalue.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deviationvalue.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deviationvalue, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$y.name,
    		type: "slot",
    		source: "(23:4) <DeviationColumn>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1O(ctx) {
    	let div;
    	let deviationcolumn0;
    	let t;
    	let deviationcolumn1;
    	let current;

    	deviationcolumn0 = new DeviationColumn({
    			props: {
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	deviationcolumn1 = new DeviationColumn({
    			props: {
    				$$slots: { default: [create_default_slot$y] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(deviationcolumn0.$$.fragment);
    			t = space();
    			create_component(deviationcolumn1.$$.fragment);
    			attr_dev(div, "class", "txcm-deviationCell");
    			add_location(div, file$1y, 14, 0, 416);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(deviationcolumn0, div, null);
    			append_dev(div, t);
    			mount_component(deviationcolumn1, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const deviationcolumn0_changes = {};

    			if (dirty & /*$$scope, budgetPercent*/ 18) {
    				deviationcolumn0_changes.$$scope = { dirty, ctx };
    			}

    			deviationcolumn0.$set(deviationcolumn0_changes);
    			const deviationcolumn1_changes = {};

    			if (dirty & /*$$scope, vsPpPercent*/ 17) {
    				deviationcolumn1_changes.$$scope = { dirty, ctx };
    			}

    			deviationcolumn1.$set(deviationcolumn1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deviationcolumn0.$$.fragment, local);
    			transition_in(deviationcolumn1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deviationcolumn0.$$.fragment, local);
    			transition_out(deviationcolumn1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(deviationcolumn0);
    			destroy_component(deviationcolumn1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1O($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	const units = getDashboardState("units");
    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DeviationCell> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DeviationCell", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(2, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		checkDynamics,
    		DeviationColumn,
    		DeviationValue,
    		data,
    		units,
    		vsPpPercent,
    		budgetPercent
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(2, data = $$props.data);
    		if ("vsPpPercent" in $$props) $$invalidate(0, vsPpPercent = $$props.vsPpPercent);
    		if ("budgetPercent" in $$props) $$invalidate(1, budgetPercent = $$props.budgetPercent);
    	};

    	let vsPpPercent;
    	let budgetPercent;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 4) {
    			 $$invalidate(0, vsPpPercent = data ? data.vsPpPercent : null);
    		}

    		if ($$self.$$.dirty & /*data*/ 4) {
    			 $$invalidate(1, budgetPercent = data ? data.budgetPercent : null);
    		}
    	};

    	return [vsPpPercent, budgetPercent, data];
    }

    class DeviationCell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1O, create_fragment$1O, safe_not_equal, { data: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DeviationCell",
    			options,
    			id: create_fragment$1O.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[2] === undefined && !("data" in props)) {
    			console.warn("<DeviationCell> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<DeviationCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<DeviationCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/deviation/DeviationRow.svelte generated by Svelte v3.24.0 */
    const file$1z = "src/js/components/deviation/DeviationRow.svelte";

    // (19:4) {#if data}
    function create_if_block$u(ctx) {
    	let deviationcell0;
    	let t;
    	let deviationcell1;
    	let current;

    	deviationcell0 = new DeviationCell({
    			props: { data: /*data*/ ctx[0].column1 },
    			$$inline: true
    		});

    	deviationcell1 = new DeviationCell({
    			props: { data: /*data*/ ctx[0].column2 },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(deviationcell0.$$.fragment);
    			t = space();
    			create_component(deviationcell1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deviationcell0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(deviationcell1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const deviationcell0_changes = {};
    			if (dirty & /*data*/ 1) deviationcell0_changes.data = /*data*/ ctx[0].column1;
    			deviationcell0.$set(deviationcell0_changes);
    			const deviationcell1_changes = {};
    			if (dirty & /*data*/ 1) deviationcell1_changes.data = /*data*/ ctx[0].column2;
    			deviationcell1.$set(deviationcell1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deviationcell0.$$.fragment, local);
    			transition_in(deviationcell1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deviationcell0.$$.fragment, local);
    			transition_out(deviationcell1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deviationcell0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(deviationcell1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(19:4) {#if data}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1P(ctx) {
    	let div;
    	let deviationlabel;
    	let t;
    	let current;

    	deviationlabel = new DeviationLabel({
    			props: {
    				multiple: /*multiple*/ ctx[1],
    				data: /*data*/ ctx[0],
    				indicator: /*indicator*/ ctx[2],
    				tab: /*tab*/ ctx[3]
    			},
    			$$inline: true
    		});

    	let if_block = /*data*/ ctx[0] && create_if_block$u(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(deviationlabel.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "txcm-deviationRow");
    			add_location(div, file$1z, 11, 0, 216);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(deviationlabel, div, null);
    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const deviationlabel_changes = {};
    			if (dirty & /*multiple*/ 2) deviationlabel_changes.multiple = /*multiple*/ ctx[1];
    			if (dirty & /*data*/ 1) deviationlabel_changes.data = /*data*/ ctx[0];
    			if (dirty & /*indicator*/ 4) deviationlabel_changes.indicator = /*indicator*/ ctx[2];
    			if (dirty & /*tab*/ 8) deviationlabel_changes.tab = /*tab*/ ctx[3];
    			deviationlabel.$set(deviationlabel_changes);

    			if (/*data*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*data*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$u(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deviationlabel.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deviationlabel.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(deviationlabel);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1P($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { multiple } = $$props;
    	let { indicator } = $$props;
    	let { tab } = $$props;
    	const writable_props = ["data", "multiple", "indicator", "tab"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DeviationRow> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DeviationRow", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("multiple" in $$props) $$invalidate(1, multiple = $$props.multiple);
    		if ("indicator" in $$props) $$invalidate(2, indicator = $$props.indicator);
    		if ("tab" in $$props) $$invalidate(3, tab = $$props.tab);
    	};

    	$$self.$capture_state = () => ({
    		DeviationLabel,
    		DeviationCell,
    		data,
    		multiple,
    		indicator,
    		tab
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("multiple" in $$props) $$invalidate(1, multiple = $$props.multiple);
    		if ("indicator" in $$props) $$invalidate(2, indicator = $$props.indicator);
    		if ("tab" in $$props) $$invalidate(3, tab = $$props.tab);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [data, multiple, indicator, tab];
    }

    class DeviationRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1P, create_fragment$1P, safe_not_equal, {
    			data: 0,
    			multiple: 1,
    			indicator: 2,
    			tab: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DeviationRow",
    			options,
    			id: create_fragment$1P.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<DeviationRow> was created without expected prop 'data'");
    		}

    		if (/*multiple*/ ctx[1] === undefined && !("multiple" in props)) {
    			console.warn("<DeviationRow> was created without expected prop 'multiple'");
    		}

    		if (/*indicator*/ ctx[2] === undefined && !("indicator" in props)) {
    			console.warn("<DeviationRow> was created without expected prop 'indicator'");
    		}

    		if (/*tab*/ ctx[3] === undefined && !("tab" in props)) {
    			console.warn("<DeviationRow> was created without expected prop 'tab'");
    		}
    	}

    	get data() {
    		throw new Error("<DeviationRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<DeviationRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get multiple() {
    		throw new Error("<DeviationRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set multiple(value) {
    		throw new Error("<DeviationRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<DeviationRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<DeviationRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tab() {
    		throw new Error("<DeviationRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tab(value) {
    		throw new Error("<DeviationRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/kpi/KPIDeviations.svelte generated by Svelte v3.24.0 */

    // (18:0) {#if hasDeviations(formatDeviations)}
    function create_if_block_1$8(ctx) {
    	let deviationrow;
    	let current;

    	deviationrow = new DeviationRow({
    			props: {
    				multiple: "форматам",
    				data: /*formatDeviations*/ ctx[1],
    				indicator: /*indicator*/ ctx[0],
    				tab: "formats"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(deviationrow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deviationrow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const deviationrow_changes = {};
    			if (dirty & /*formatDeviations*/ 2) deviationrow_changes.data = /*formatDeviations*/ ctx[1];
    			if (dirty & /*indicator*/ 1) deviationrow_changes.indicator = /*indicator*/ ctx[0];
    			deviationrow.$set(deviationrow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deviationrow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deviationrow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deviationrow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(18:0) {#if hasDeviations(formatDeviations)}",
    		ctx
    	});

    	return block;
    }

    // (25:0) {#if hasDeviations(regionDeviations)}
    function create_if_block$v(ctx) {
    	let deviationrow;
    	let current;

    	deviationrow = new DeviationRow({
    			props: {
    				multiple: "регионам",
    				data: /*regionDeviations*/ ctx[2],
    				indicator: /*indicator*/ ctx[0],
    				tab: "regions"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(deviationrow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deviationrow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const deviationrow_changes = {};
    			if (dirty & /*regionDeviations*/ 4) deviationrow_changes.data = /*regionDeviations*/ ctx[2];
    			if (dirty & /*indicator*/ 1) deviationrow_changes.indicator = /*indicator*/ ctx[0];
    			deviationrow.$set(deviationrow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deviationrow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deviationrow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deviationrow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(25:0) {#if hasDeviations(regionDeviations)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1Q(ctx) {
    	let show_if_1 = hasDeviations(/*formatDeviations*/ ctx[1]);
    	let t;
    	let show_if = hasDeviations(/*regionDeviations*/ ctx[2]);
    	let if_block1_anchor;
    	let current;
    	let if_block0 = show_if_1 && create_if_block_1$8(ctx);
    	let if_block1 = show_if && create_if_block$v(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*formatDeviations*/ 2) show_if_1 = hasDeviations(/*formatDeviations*/ ctx[1]);

    			if (show_if_1) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*formatDeviations*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$8(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*regionDeviations*/ 4) show_if = hasDeviations(/*regionDeviations*/ ctx[2]);

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*regionDeviations*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$v(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function hasDeviations(key) {
    	return key && key.countDeviation > 0;
    }

    function instance$1Q($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { indicator } = $$props;
    	const units = getDashboardState("units");
    	const writable_props = ["data", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<KPIDeviations> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("KPIDeviations", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		DeviationRow,
    		data,
    		indicator,
    		units,
    		hasDeviations,
    		formatDeviations,
    		regionDeviations
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("formatDeviations" in $$props) $$invalidate(1, formatDeviations = $$props.formatDeviations);
    		if ("regionDeviations" in $$props) $$invalidate(2, regionDeviations = $$props.regionDeviations);
    	};

    	let formatDeviations;
    	let regionDeviations;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 8) {
    			 $$invalidate(1, { formatDeviations, regionDeviations } = data, formatDeviations, ($$invalidate(2, regionDeviations), $$invalidate(3, data)));
    		}
    	};

    	return [indicator, formatDeviations, regionDeviations, data];
    }

    class KPIDeviations extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1Q, create_fragment$1Q, safe_not_equal, { data: 3, indicator: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KPIDeviations",
    			options,
    			id: create_fragment$1Q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[3] === undefined && !("data" in props)) {
    			console.warn("<KPIDeviations> was created without expected prop 'data'");
    		}

    		if (/*indicator*/ ctx[0] === undefined && !("indicator" in props)) {
    			console.warn("<KPIDeviations> was created without expected prop 'indicator'");
    		}
    	}

    	get data() {
    		throw new Error("<KPIDeviations>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<KPIDeviations>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<KPIDeviations>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<KPIDeviations>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    function renderPointX(pointIndex, pointCount, offset = 0.5) {
      return `${(((pointIndex + offset) / pointCount) * 100)}%`;
    }

    function renderPointY(point, min, max, height, padding) {
      const paddedHeight = height - (padding * 2);
      const base = max - min;
      const fraction = base ? 1 - ((point - min) / (max - min)) : 0;
      return (paddedHeight * fraction) + padding + 0.5;
    }

    function fillDayData(series, timestamp) {    
      const fillData = data => {
        const seriesMap = data.reduce((acc, item) => {
          acc[item.name] = item;
          return acc;
        }, {});
        const newData = [];
        for (let i = 0; i < 31; ++i) {
          const date = new Date(timestamp);
          date.setDate(date.getDate() + i - 30);
          const month = `${date.getMonth() + 1}`.padStart(2, 0);
          const day = `${date.getDate()}`.padStart(2, 0);
          const name = `${date.getFullYear()}${month}${day}`;
          newData.push(seriesMap[name] ? seriesMap[name] : { name, data: null, text: '-' });
        }
        return newData;
      };
      return series.map(seriesData => ({
        name: seriesData.name,
        data: fillData(seriesData.data.slice())
      }));
    }

    function fillWeekData(series, timestamp) {
      const fillData = data => {
        const seriesMap = data.reduce((acc, item) => {
          acc[item.name] = item;
          return acc;
        }, {});
        const newData = [];
        const date = new Date(timestamp);
        for (let i = 0; i < 11; ++i) {      
          const week = new Date(addWeeks(date.getTime(), i - 10));
          const weekNumber = calculateWeekNumber(week.getDate(), week.getMonth(), week.getFullYear());
          const year = weekNumber === 53 && week.getMonth() === 0 ?
            week.getFullYear() - 1 : week.getFullYear();
          const name = `${year}${`${weekNumber}`.padStart(2, 0)}`;
          newData.push(seriesMap[name] ? seriesMap[name] : { name, data: null, text: '-' });
        }
        return newData;
      };
      return series.map(seriesData => ({
        name: seriesData.name,
        data: fillData(seriesData.data.slice())
      }));
    }

    function fillMonthData(series, timestamp) {
      const fillData = data => {
        const seriesMap = data.reduce((acc, item) => {
          acc[item.name] = item;
          return acc;
        }, {});
        const newData = [];
        for (let i = 0; i < 13; ++i) {
          const date = new Date(timestamp);
          date.setDate(1);
          date.setMonth(date.getMonth() + i- 12);
          const year = date.getFullYear();
          const month = `${date.getMonth() + 1}`.padStart(2, 0);
          const name = `${year}${month}`;
          newData.push(seriesMap[name] ? seriesMap[name] : { name, data: null, text: '-' });
        }
        return newData;
      };
      return series.map(seriesData => ({
        name: seriesData.name,
        data: fillData(seriesData.data.slice())
      }));
    }

    function fillQuaterData(series, timestamp) {
      const fillData = data => {
        const seriesMap = data.reduce((acc, item) => {
          acc[item.name] = item;
          return acc;
        }, {});
        const newData = [];
        for (let i = 0; i < 5; ++i) {
          const date = new Date(addMonths(timestamp, i * 3 - 12));
          const year = date.getFullYear();
          const quarter = `${calculateQuarter(date)}`.padStart(2, 0);
          const name = `${year}${quarter}`;
          newData.push(seriesMap[name] ? seriesMap[name] : { name, data: null, text: '-' });
        }
        return newData;
      };
      return series.map(seriesData => ({
        name: seriesData.name,
        data: fillData(seriesData.data.slice())
      }));
    }

    function fillYearData(series, timestamp) {
      const fillData = data => {
        const seriesMap = data.reduce((acc, item) => {
          acc[item.name] = item;
          return acc;
        }, {});
        const newData = [];
        for (let i = 0; i < 3; ++i) {
          const date = new Date(timestamp);
          const year = date.getFullYear() + i - 2;
          const name = `${year}`;
          newData.push(seriesMap[name] ? seriesMap[name] : { name, data: null, text: '-' });
        }
        return newData;
      };
      return series.map(seriesData => ({
        name: seriesData.name,
        data: fillData(seriesData.data.slice())
      }));
    }

    function filterPeriodData(series, startPeriod, endPeriod, timestamp, timestampPoP) {
      const startDate = new Date(timestampPoP);
      const startYear = startDate.getFullYear();
      const startName = `${startYear}${`${startPeriod}`.padStart(2, '0')}`;
      const startIndex = series[0].data.findIndex(point => point.name === startName);
      const endDate = new Date(timestamp);
      const endYear = endDate.getFullYear();
      const endName = `${endYear}${`${endPeriod}`.padStart(2, '0')}`;
      const endIndex = series[0].data.findIndex(point => point.name === endName);
      return series.map(seriesData => ({
        name: seriesData.name,
        data: endIndex < 0 ? seriesData.data.slice(Math.max(startIndex, 0)) 
                           : seriesData.data.slice(Math.max(startIndex, 0), endIndex + 1),
      }));
    }

    function filterDayData(series, timestamp, timestampPoP) {
      const startDay = new Date(timestampPoP);
      const endDay = new Date(timestamp);
      const startName = `${startDay.getFullYear()}${`${startDay.getMonth() + 1}`.padStart(2, '0')}${`${startDay.getDate()}`.padStart(2, '0')}`;
      const endName = `${endDay.getFullYear()}${`${endDay.getMonth() + 1}`.padStart(2, '0')}${`${endDay.getDate()}`.padStart(2, '0')}`;
      const startIndex = series[0].data.findIndex(point => point.name === startName);
      const endIndex = series[0].data.findIndex(point => point.name === endName);
      const data = series.map(seriesData => ({
        name: seriesData.name,
        data: endIndex < 0 ? seriesData.data.slice(Math.max(startIndex, 0)) 
                           : seriesData.data.slice(Math.max(startIndex, 0), endIndex + 1),
      }));
      return data;
    }

    function filterWeekData(series, timestamp, timestampPoP) {
      const startWeek = new Date(timestampPoP);
      const endWeek = new Date(timestamp);
      const startWeekNumber = calculateWeekNumber(startWeek.getDate(), startWeek.getMonth(), startWeek.getFullYear());
      const endWeekNumber = calculateWeekNumber(endWeek.getDate(), endWeek.getMonth(), endWeek.getFullYear());
      const startName = `${startWeek.getFullYear()}${`${startWeekNumber}`.padStart(2, '0')}`;
      const endName = `${endWeek.getFullYear()}${`${endWeekNumber}`.padStart(2, '0')}`;
      const startIndex = series[0].data.findIndex(point => point.name === startName);
      const endIndex = series[0].data.findIndex(point => point.name === endName);
      const data = series.map(seriesData => ({
        name: seriesData.name,
        data: endIndex < 0 ? seriesData.data.slice(Math.max(startIndex, 0)) 
                           : seriesData.data.slice(Math.max(startIndex, 0), endIndex + 1),
      }));
      return data;
    }

    function filterMonthData(series, timestamp, timestampPoP) {
      const startMonth = (new Date(timestampPoP)).getMonth() + 1;
      const endMonth = (new Date(timestamp)).getMonth() + 1;
      return filterPeriodData(series, startMonth, endMonth, timestamp, timestampPoP);
    }

    function filterQuarterData(series, timestamp, timestampPoP) {
      const startQuarter = calculateQuarter(timestampPoP);
      const endQuarter = calculateQuarter(timestamp);
      return filterPeriodData(series, startQuarter, endQuarter, timestamp, timestampPoP);
    }

    function filterYearData(series) {
      return series;
    }

    /* src/js/components/lineGraph/LineGraphAxes.svelte generated by Svelte v3.24.0 */

    const file$1A = "src/js/components/lineGraph/LineGraphAxes.svelte";

    function create_fragment$1R(ctx) {
    	let line0;
    	let t0;
    	let line1;
    	let t1;
    	let line2;
    	let line2_transform_value;

    	const block = {
    		c: function create() {
    			line0 = svg_element("line");
    			t0 = space();
    			line1 = svg_element("line");
    			t1 = space();
    			line2 = svg_element("line");
    			attr_dev(line0, "class", "txcm-lineGraphAxis");
    			attr_dev(line0, "x1", "0");
    			attr_dev(line0, "y1", /*padding*/ ctx[0]);
    			attr_dev(line0, "x2", "100%");
    			attr_dev(line0, "y2", /*padding*/ ctx[0]);
    			attr_dev(line0, "transform", "translate(0 0.5)");
    			add_location(line0, file$1A, 4, 0, 42);
    			attr_dev(line1, "class", "txcm-lineGraphAxis");
    			attr_dev(line1, "x1", "0");
    			attr_dev(line1, "y1", "50%");
    			attr_dev(line1, "x2", "100%");
    			attr_dev(line1, "y2", "50%");
    			attr_dev(line1, "transform", "translate(0 0.5)");
    			add_location(line1, file$1A, 11, 0, 162);
    			attr_dev(line2, "class", "txcm-lineGraphAxis");
    			attr_dev(line2, "x1", "0");
    			attr_dev(line2, "y1", "100%");
    			attr_dev(line2, "x2", "100%");
    			attr_dev(line2, "y2", "100%");
    			attr_dev(line2, "transform", line2_transform_value = `translate(0 ${-/*padding*/ ctx[0] + 0.5})`);
    			add_location(line2, file$1A, 18, 0, 274);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, line0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, line1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, line2, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*padding*/ 1) {
    				attr_dev(line0, "y1", /*padding*/ ctx[0]);
    			}

    			if (dirty & /*padding*/ 1) {
    				attr_dev(line0, "y2", /*padding*/ ctx[0]);
    			}

    			if (dirty & /*padding*/ 1 && line2_transform_value !== (line2_transform_value = `translate(0 ${-/*padding*/ ctx[0] + 0.5})`)) {
    				attr_dev(line2, "transform", line2_transform_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(line0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(line1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(line2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1R($$self, $$props, $$invalidate) {
    	let { padding } = $$props;
    	const writable_props = ["padding"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LineGraphAxes> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LineGraphAxes", $$slots, []);

    	$$self.$set = $$props => {
    		if ("padding" in $$props) $$invalidate(0, padding = $$props.padding);
    	};

    	$$self.$capture_state = () => ({ padding });

    	$$self.$inject_state = $$props => {
    		if ("padding" in $$props) $$invalidate(0, padding = $$props.padding);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [padding];
    }

    class LineGraphAxes extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1R, create_fragment$1R, safe_not_equal, { padding: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LineGraphAxes",
    			options,
    			id: create_fragment$1R.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*padding*/ ctx[0] === undefined && !("padding" in props)) {
    			console.warn("<LineGraphAxes> was created without expected prop 'padding'");
    		}
    	}

    	get padding() {
    		throw new Error("<LineGraphAxes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<LineGraphAxes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/graphTooltip/GraphTooltip.svelte generated by Svelte v3.24.0 */

    const { console: console_1$2 } = globals;
    const file$1B = "src/js/components/graphTooltip/GraphTooltip.svelte";

    // (58:0) {#if data}
    function create_if_block$w(ctx) {
    	let table;
    	let tr0;
    	let th0;
    	let int0;
    	let t0;
    	let t1;
    	let t2;
    	let td0;
    	let t3_value = (/*data*/ ctx[0].fact ? /*data*/ ctx[0].fact : "-") + "";
    	let t3;
    	let t4;
    	let tr1;
    	let th1;
    	let int1;
    	let t5;
    	let t6;
    	let t7;
    	let td1;
    	let t8_value = (/*data*/ ctx[0].vsPp ? /*data*/ ctx[0].vsPp : "-") + "";
    	let t8;
    	let t9;
    	let tr2;
    	let th2;
    	let int2;
    	let t10;
    	let t11;
    	let t12;
    	let td2;

    	let t13_value = (/*data*/ ctx[0].vsPpPercent
    	? /*data*/ ctx[0].vsPpPercent
    	: "-") + "";

    	let t13;
    	let t14;
    	let tr3;
    	let th3;
    	let int3;
    	let t15;
    	let t16_value = /*data*/ ctx[0].year + "";
    	let t16;
    	let t17;
    	let td3;

    	let t18_value = (/*data*/ ctx[0].vsBudget
    	? /*data*/ ctx[0].vsBudget
    	: "-") + "";

    	let t18;
    	let t19;
    	let tr4;
    	let th4;
    	let int4;
    	let t20;
    	let td4;

    	let t21_value = (/*data*/ ctx[0].vsBudgetPercent
    	? /*data*/ ctx[0].vsBudgetPercent
    	: "-") + "";

    	let t21;
    	let current;
    	int0 = new Int({ props: { key: "Факт" }, $$inline: true });
    	int1 = new Int({ props: { key: "Факт" }, $$inline: true });
    	int2 = new Int({ props: { key: "∆ от" }, $$inline: true });
    	int3 = new Int({ props: { key: "План" }, $$inline: true });

    	int4 = new Int({
    			props: { key: "∆ от плана" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			table = element("table");
    			tr0 = element("tr");
    			th0 = element("th");
    			create_component(int0.$$.fragment);
    			t0 = space();
    			t1 = text(/*factLabel*/ ctx[1]);
    			t2 = space();
    			td0 = element("td");
    			t3 = text(t3_value);
    			t4 = space();
    			tr1 = element("tr");
    			th1 = element("th");
    			create_component(int1.$$.fragment);
    			t5 = space();
    			t6 = text(/*factPrevLabel*/ ctx[2]);
    			t7 = space();
    			td1 = element("td");
    			t8 = text(t8_value);
    			t9 = space();
    			tr2 = element("tr");
    			th2 = element("th");
    			create_component(int2.$$.fragment);
    			t10 = space();
    			t11 = text(/*factPrevLabel*/ ctx[2]);
    			t12 = space();
    			td2 = element("td");
    			t13 = text(t13_value);
    			t14 = space();
    			tr3 = element("tr");
    			th3 = element("th");
    			create_component(int3.$$.fragment);
    			t15 = space();
    			t16 = text(t16_value);
    			t17 = space();
    			td3 = element("td");
    			t18 = text(t18_value);
    			t19 = space();
    			tr4 = element("tr");
    			th4 = element("th");
    			create_component(int4.$$.fragment);
    			t20 = space();
    			td4 = element("td");
    			t21 = text(t21_value);
    			attr_dev(th0, "class", "txcm-graphTooltipRowHeader txcm-graphTooltipRowHeader-fact");
    			toggle_class(th0, "txcm-graphTooltipRowHeader-fact-normal", !/*data*/ ctx[0].deviations);
    			add_location(th0, file$1B, 62, 10, 2244);
    			attr_dev(td0, "class", "txcm-graphTooltipRowCell");
    			add_location(td0, file$1B, 67, 10, 2474);
    			attr_dev(tr0, "class", "txcm-graphTooltipRow");
    			add_location(tr0, file$1B, 60, 6, 2192);
    			attr_dev(th1, "class", "txcm-graphTooltipRowHeader");
    			add_location(th1, file$1B, 73, 10, 2646);
    			attr_dev(td1, "class", "txcm-graphTooltipRowCell");
    			add_location(td1, file$1B, 77, 10, 2772);
    			attr_dev(tr1, "class", "txcm-graphTooltipRow");
    			add_location(tr1, file$1B, 71, 8, 2592);
    			attr_dev(th2, "class", "txcm-graphTooltipRowHeader txcm-graphTooltipRowHeader-deltaBudget");
    			add_location(th2, file$1B, 84, 8, 2952);
    			attr_dev(td2, "class", "txcm-graphTooltipRowCell");
    			add_location(td2, file$1B, 88, 8, 3109);
    			attr_dev(tr2, "class", "txcm-graphTooltipRow");
    			add_location(tr2, file$1B, 82, 6, 2902);
    			attr_dev(th3, "class", "txcm-graphTooltipRowHeader");
    			add_location(th3, file$1B, 95, 10, 3302);
    			attr_dev(td3, "class", "txcm-graphTooltipRowCell");
    			add_location(td3, file$1B, 99, 10, 3424);
    			attr_dev(tr3, "class", "txcm-graphTooltipRow");
    			add_location(tr3, file$1B, 93, 8, 3248);
    			attr_dev(th4, "class", "txcm-graphTooltipRowHeader txcm-graphTooltipRowHeader-deltaPoP");
    			add_location(th4, file$1B, 106, 8, 3612);
    			attr_dev(td4, "class", "txcm-graphTooltipRowCell");
    			add_location(td4, file$1B, 110, 8, 3756);
    			attr_dev(tr4, "class", "txcm-graphTooltipRow");
    			add_location(tr4, file$1B, 104, 6, 3562);
    			attr_dev(table, "class", "txcm-graphTooltip");
    			add_location(table, file$1B, 58, 2, 2148);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, tr0);
    			append_dev(tr0, th0);
    			mount_component(int0, th0, null);
    			append_dev(th0, t0);
    			append_dev(th0, t1);
    			append_dev(tr0, t2);
    			append_dev(tr0, td0);
    			append_dev(td0, t3);
    			append_dev(tr0, t4);
    			append_dev(table, tr1);
    			append_dev(tr1, th1);
    			mount_component(int1, th1, null);
    			append_dev(th1, t5);
    			append_dev(th1, t6);
    			append_dev(tr1, t7);
    			append_dev(tr1, td1);
    			append_dev(td1, t8);
    			append_dev(table, t9);
    			append_dev(table, tr2);
    			append_dev(tr2, th2);
    			mount_component(int2, th2, null);
    			append_dev(th2, t10);
    			append_dev(th2, t11);
    			append_dev(tr2, t12);
    			append_dev(tr2, td2);
    			append_dev(td2, t13);
    			append_dev(table, t14);
    			append_dev(table, tr3);
    			append_dev(tr3, th3);
    			mount_component(int3, th3, null);
    			append_dev(th3, t15);
    			append_dev(th3, t16);
    			append_dev(tr3, t17);
    			append_dev(tr3, td3);
    			append_dev(td3, t18);
    			append_dev(table, t19);
    			append_dev(table, tr4);
    			append_dev(tr4, th4);
    			mount_component(int4, th4, null);
    			append_dev(tr4, t20);
    			append_dev(tr4, td4);
    			append_dev(td4, t21);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*factLabel*/ 2) set_data_dev(t1, /*factLabel*/ ctx[1]);

    			if (dirty & /*data*/ 1) {
    				toggle_class(th0, "txcm-graphTooltipRowHeader-fact-normal", !/*data*/ ctx[0].deviations);
    			}

    			if ((!current || dirty & /*data*/ 1) && t3_value !== (t3_value = (/*data*/ ctx[0].fact ? /*data*/ ctx[0].fact : "-") + "")) set_data_dev(t3, t3_value);
    			if (!current || dirty & /*factPrevLabel*/ 4) set_data_dev(t6, /*factPrevLabel*/ ctx[2]);
    			if ((!current || dirty & /*data*/ 1) && t8_value !== (t8_value = (/*data*/ ctx[0].vsPp ? /*data*/ ctx[0].vsPp : "-") + "")) set_data_dev(t8, t8_value);
    			if (!current || dirty & /*factPrevLabel*/ 4) set_data_dev(t11, /*factPrevLabel*/ ctx[2]);

    			if ((!current || dirty & /*data*/ 1) && t13_value !== (t13_value = (/*data*/ ctx[0].vsPpPercent
    			? /*data*/ ctx[0].vsPpPercent
    			: "-") + "")) set_data_dev(t13, t13_value);

    			if ((!current || dirty & /*data*/ 1) && t16_value !== (t16_value = /*data*/ ctx[0].year + "")) set_data_dev(t16, t16_value);

    			if ((!current || dirty & /*data*/ 1) && t18_value !== (t18_value = (/*data*/ ctx[0].vsBudget
    			? /*data*/ ctx[0].vsBudget
    			: "-") + "")) set_data_dev(t18, t18_value);

    			if ((!current || dirty & /*data*/ 1) && t21_value !== (t21_value = (/*data*/ ctx[0].vsBudgetPercent
    			? /*data*/ ctx[0].vsBudgetPercent
    			: "-") + "")) set_data_dev(t21, t21_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			transition_in(int2.$$.fragment, local);
    			transition_in(int3.$$.fragment, local);
    			transition_in(int4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			transition_out(int2.$$.fragment, local);
    			transition_out(int3.$$.fragment, local);
    			transition_out(int4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_component(int0);
    			destroy_component(int1);
    			destroy_component(int2);
    			destroy_component(int3);
    			destroy_component(int4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(58:0) {#if data}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1S(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*data*/ ctx[0] && create_if_block$w(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*data*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*data*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$w(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1S($$self, $$props, $$invalidate) {
    	let $dynamics;
    	let $locale;
    	const dynamics = getGraphsState("dynamics");
    	validate_store(dynamics, "dynamics");
    	component_subscribe($$self, dynamics, value => $$invalidate(5, $dynamics = value));
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(6, $locale = value));
    	let { data } = $$props;

    	function updateFactLabel() {
    		try {
    			if ($dynamics === "graphDetailDay") {
    				const month = renderMonthShort(new Date(data.year, data.month - 1, data.day).getTime(), $locale);
    				return `${data.day} ${month} ${data.year}`;
    			}

    			if ($dynamics === "graphDetailWeek") return `${data.month} ${translate("Неделя", $locale)} ${data.year}`;

    			if ($dynamics === "graphDetailMonth") {
    				const month = renderMonthShort(new Date(data.year, data.month - 1, 1).getTime(), $locale);
    				return `${month} ${data.year}`;
    			}

    			if ($dynamics === "graphDetailQuarter") return `${data.month} ${translate("Квартал", $locale)} ${data.year}`;
    		} catch(e) {
    			console.log("updateFactLabel", e);
    		}

    		return `${data.year}`;
    	}

    	function updateFactPrevLabel() {
    		try {
    			if ($dynamics === "graphDetailDay") {
    				const month = renderMonthShort(new Date(data.year - 1, data.month - 1, data.day).getTime(), $locale);
    				return `${data.day} ${month} ${data.year - 1}`;
    			}

    			if ($dynamics === "graphDetailWeek") return `${data.month} ${translate("Неделя", $locale)} ${data.year - 1}`;

    			if ($dynamics === "graphDetailMonth") {
    				const month = renderMonthShort(new Date(data.year - 1, data.month - 1, 1).getTime(), $locale);
    				return `${month} ${data.year - 1}`;
    			}

    			if ($dynamics === "graphDetailQuarter") return `${data.month} ${translate("Квартал", $locale)} ${data.year - 1}`;
    		} catch(e) {
    			console.log("updateFactLabel", e);
    		}

    		return `${data.year - 1}`;
    	}

    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<GraphTooltip> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("GraphTooltip", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		renderMonthShort,
    		getGraphsState,
    		translate,
    		getUIState,
    		Int,
    		dynamics,
    		locale,
    		data,
    		updateFactLabel,
    		updateFactPrevLabel,
    		factLabel,
    		$dynamics,
    		$locale,
    		factPrevLabel
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("factLabel" in $$props) $$invalidate(1, factLabel = $$props.factLabel);
    		if ("factPrevLabel" in $$props) $$invalidate(2, factPrevLabel = $$props.factPrevLabel);
    	};

    	let factLabel;
    	let factPrevLabel;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data, $dynamics, $locale*/ 97) {
    			 $$invalidate(1, factLabel = updateFactLabel());
    		}

    		if ($$self.$$.dirty & /*data, $dynamics, $locale*/ 97) {
    			 $$invalidate(2, factPrevLabel = updateFactPrevLabel());
    		}
    	};

    	return [data, factLabel, factPrevLabel, dynamics, locale];
    }

    class GraphTooltip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1S, create_fragment$1S, safe_not_equal, { data: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "GraphTooltip",
    			options,
    			id: create_fragment$1S.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console_1$2.warn("<GraphTooltip> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<GraphTooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<GraphTooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/lineGraph/LineGraphPoint.svelte generated by Svelte v3.24.0 */
    const file$1C = "src/js/components/lineGraph/LineGraphPoint.svelte";

    // (58:0) {#if shouldDrawPoint(data)}
    function create_if_block$x(ctx) {
    	let g;
    	let circle0;
    	let circle0_r_value;
    	let circle1;
    	let tooltip_action;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			g = svg_element("g");
    			circle0 = svg_element("circle");
    			circle1 = svg_element("circle");
    			attr_dev(circle0, "class", "txcm-lineGraphPointDummy");
    			attr_dev(circle0, "r", circle0_r_value = /*r*/ ctx[5] * DUMMY_QUOTIENT);
    			attr_dev(circle0, "cx", /*cx*/ ctx[1]);
    			attr_dev(circle0, "cy", /*cy*/ ctx[2]);
    			attr_dev(circle0, "transform", /*transform*/ ctx[4]);
    			add_location(circle0, file$1C, 61, 6, 1281);
    			attr_dev(circle1, "class", "txcm-lineGraphPoint");
    			attr_dev(circle1, "r", /*r*/ ctx[5]);
    			attr_dev(circle1, "cx", /*cx*/ ctx[1]);
    			attr_dev(circle1, "cy", /*cy*/ ctx[2]);
    			attr_dev(circle1, "transform", /*transform*/ ctx[4]);
    			toggle_class(circle1, "txcm-lineGraphPoint-has-deviations", /*data*/ ctx[0].deviations);
    			toggle_class(circle1, "txcm-lineGraphPoint-no-budget", /*data*/ ctx[0].vsBudget === "-");
    			add_location(circle1, file$1C, 67, 6, 1416);
    			attr_dev(g, "class", "txcm-lineGraphPointGroup");
    			add_location(g, file$1C, 58, 2, 1201);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);
    			append_dev(g, circle0);
    			append_dev(g, circle1);

    			if (!mounted) {
    				dispose = action_destroyer(tooltip_action = tooltip.call(null, g, /*tooltipOptions*/ ctx[3]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*cx*/ 2) {
    				attr_dev(circle0, "cx", /*cx*/ ctx[1]);
    			}

    			if (dirty & /*cy*/ 4) {
    				attr_dev(circle0, "cy", /*cy*/ ctx[2]);
    			}

    			if (dirty & /*transform*/ 16) {
    				attr_dev(circle0, "transform", /*transform*/ ctx[4]);
    			}

    			if (dirty & /*cx*/ 2) {
    				attr_dev(circle1, "cx", /*cx*/ ctx[1]);
    			}

    			if (dirty & /*cy*/ 4) {
    				attr_dev(circle1, "cy", /*cy*/ ctx[2]);
    			}

    			if (dirty & /*transform*/ 16) {
    				attr_dev(circle1, "transform", /*transform*/ ctx[4]);
    			}

    			if (dirty & /*data*/ 1) {
    				toggle_class(circle1, "txcm-lineGraphPoint-has-deviations", /*data*/ ctx[0].deviations);
    			}

    			if (dirty & /*data*/ 1) {
    				toggle_class(circle1, "txcm-lineGraphPoint-no-budget", /*data*/ ctx[0].vsBudget === "-");
    			}

    			if (tooltip_action && is_function(tooltip_action.update) && dirty & /*tooltipOptions*/ 8) tooltip_action.update.call(null, /*tooltipOptions*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$x.name,
    		type: "if",
    		source: "(58:0) {#if shouldDrawPoint(data)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1T(ctx) {
    	let show_if = /*shouldDrawPoint*/ ctx[6](/*data*/ ctx[0]);
    	let if_block_anchor;
    	let if_block = show_if && create_if_block$x(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*data*/ 1) show_if = /*shouldDrawPoint*/ ctx[6](/*data*/ ctx[0]);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$x(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const DEFAULT_RADIUS = 2.5;
    const DUMMY_QUOTIENT = 7;

    function instance$1T($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { index } = $$props;
    	let { min } = $$props;
    	let { max } = $$props;
    	let { count } = $$props;
    	let { shift } = $$props;
    	let { height } = $$props;
    	let { padding } = $$props;
    	const r = DEFAULT_RADIUS;
    	let cx;
    	let cy;
    	let tooltipOptions;

    	function shouldDrawPoint() {
    		return data.point !== null;
    	}

    	function updateTooltipData() {
    		if (!data) return null;
    		return data;
    	}

    	function updateTooltip() {
    		$$invalidate(3, tooltipOptions = {
    			content: {
    				component: GraphTooltip,
    				data: updateTooltipData()
    			},
    			side: "left"
    		});
    	}

    	function calculatePosition() {
    		$$invalidate(1, cx = renderPointX(index, count));
    		$$invalidate(2, cy = renderPointY(data.point || 0, min, max, height, padding));
    	}

    	function calculateTransform() {
    		return `translate(${shift} 0)`;
    	}

    	const writable_props = ["data", "index", "min", "max", "count", "shift", "height", "padding"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LineGraphPoint> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LineGraphPoint", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("index" in $$props) $$invalidate(7, index = $$props.index);
    		if ("min" in $$props) $$invalidate(8, min = $$props.min);
    		if ("max" in $$props) $$invalidate(9, max = $$props.max);
    		if ("count" in $$props) $$invalidate(10, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(11, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(12, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(13, padding = $$props.padding);
    	};

    	$$self.$capture_state = () => ({
    		tooltip,
    		renderPointX,
    		renderPointY,
    		GraphTooltip,
    		DEFAULT_RADIUS,
    		DUMMY_QUOTIENT,
    		data,
    		index,
    		min,
    		max,
    		count,
    		shift,
    		height,
    		padding,
    		r,
    		cx,
    		cy,
    		tooltipOptions,
    		shouldDrawPoint,
    		updateTooltipData,
    		updateTooltip,
    		calculatePosition,
    		calculateTransform,
    		transform
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("index" in $$props) $$invalidate(7, index = $$props.index);
    		if ("min" in $$props) $$invalidate(8, min = $$props.min);
    		if ("max" in $$props) $$invalidate(9, max = $$props.max);
    		if ("count" in $$props) $$invalidate(10, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(11, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(12, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(13, padding = $$props.padding);
    		if ("cx" in $$props) $$invalidate(1, cx = $$props.cx);
    		if ("cy" in $$props) $$invalidate(2, cy = $$props.cy);
    		if ("tooltipOptions" in $$props) $$invalidate(3, tooltipOptions = $$props.tooltipOptions);
    		if ("transform" in $$props) $$invalidate(4, transform = $$props.transform);
    	};

    	let transform;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*shift*/ 2048) {
    			 $$invalidate(4, transform = calculateTransform());
    		}

    		if ($$self.$$.dirty & /*data, min, max, count*/ 1793) {
    			 calculatePosition(data.point || 0);
    		}

    		if ($$self.$$.dirty & /*data*/ 1) {
    			 updateTooltip();
    		}
    	};

    	return [
    		data,
    		cx,
    		cy,
    		tooltipOptions,
    		transform,
    		r,
    		shouldDrawPoint,
    		index,
    		min,
    		max,
    		count,
    		shift,
    		height,
    		padding
    	];
    }

    class LineGraphPoint extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1T, create_fragment$1T, safe_not_equal, {
    			data: 0,
    			index: 7,
    			min: 8,
    			max: 9,
    			count: 10,
    			shift: 11,
    			height: 12,
    			padding: 13
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LineGraphPoint",
    			options,
    			id: create_fragment$1T.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<LineGraphPoint> was created without expected prop 'data'");
    		}

    		if (/*index*/ ctx[7] === undefined && !("index" in props)) {
    			console.warn("<LineGraphPoint> was created without expected prop 'index'");
    		}

    		if (/*min*/ ctx[8] === undefined && !("min" in props)) {
    			console.warn("<LineGraphPoint> was created without expected prop 'min'");
    		}

    		if (/*max*/ ctx[9] === undefined && !("max" in props)) {
    			console.warn("<LineGraphPoint> was created without expected prop 'max'");
    		}

    		if (/*count*/ ctx[10] === undefined && !("count" in props)) {
    			console.warn("<LineGraphPoint> was created without expected prop 'count'");
    		}

    		if (/*shift*/ ctx[11] === undefined && !("shift" in props)) {
    			console.warn("<LineGraphPoint> was created without expected prop 'shift'");
    		}

    		if (/*height*/ ctx[12] === undefined && !("height" in props)) {
    			console.warn("<LineGraphPoint> was created without expected prop 'height'");
    		}

    		if (/*padding*/ ctx[13] === undefined && !("padding" in props)) {
    			console.warn("<LineGraphPoint> was created without expected prop 'padding'");
    		}
    	}

    	get data() {
    		throw new Error("<LineGraphPoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<LineGraphPoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<LineGraphPoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<LineGraphPoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<LineGraphPoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<LineGraphPoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<LineGraphPoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<LineGraphPoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<LineGraphPoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<LineGraphPoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shift() {
    		throw new Error("<LineGraphPoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shift(value) {
    		throw new Error("<LineGraphPoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<LineGraphPoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<LineGraphPoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<LineGraphPoint>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<LineGraphPoint>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/lineGraph/LineGraphPoints.svelte generated by Svelte v3.24.0 */

    function get_each_context$o(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (14:2) {#if point}
    function create_if_block$y(ctx) {
    	let linegraphpoint;
    	let current;

    	linegraphpoint = new LineGraphPoint({
    			props: {
    				count: /*count*/ ctx[3],
    				shift: /*shift*/ ctx[4],
    				height: /*height*/ ctx[5],
    				padding: /*padding*/ ctx[6],
    				index: /*index*/ ctx[9],
    				min: /*min*/ ctx[1],
    				max: /*max*/ ctx[2],
    				data: /*point*/ ctx[7]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(linegraphpoint.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(linegraphpoint, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const linegraphpoint_changes = {};
    			if (dirty & /*count*/ 8) linegraphpoint_changes.count = /*count*/ ctx[3];
    			if (dirty & /*shift*/ 16) linegraphpoint_changes.shift = /*shift*/ ctx[4];
    			if (dirty & /*height*/ 32) linegraphpoint_changes.height = /*height*/ ctx[5];
    			if (dirty & /*padding*/ 64) linegraphpoint_changes.padding = /*padding*/ ctx[6];
    			if (dirty & /*min*/ 2) linegraphpoint_changes.min = /*min*/ ctx[1];
    			if (dirty & /*max*/ 4) linegraphpoint_changes.max = /*max*/ ctx[2];
    			if (dirty & /*points*/ 1) linegraphpoint_changes.data = /*point*/ ctx[7];
    			linegraphpoint.$set(linegraphpoint_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linegraphpoint.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linegraphpoint.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(linegraphpoint, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$y.name,
    		type: "if",
    		source: "(14:2) {#if point}",
    		ctx
    	});

    	return block;
    }

    // (13:0) {#each points as point, index}
    function create_each_block$o(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*point*/ ctx[7] && create_if_block$y(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*point*/ ctx[7]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*points*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$y(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$o.name,
    		type: "each",
    		source: "(13:0) {#each points as point, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1U(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*points*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$o(get_each_context$o(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*count, shift, height, padding, min, max, points*/ 127) {
    				each_value = /*points*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$o(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$o(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1U($$self, $$props, $$invalidate) {
    	let { points } = $$props;
    	let { min } = $$props;
    	let { max } = $$props;
    	let { count } = $$props;
    	let { shift } = $$props;
    	let { height } = $$props;
    	let { padding } = $$props;
    	const writable_props = ["points", "min", "max", "count", "shift", "height", "padding"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LineGraphPoints> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LineGraphPoints", $$slots, []);

    	$$self.$set = $$props => {
    		if ("points" in $$props) $$invalidate(0, points = $$props.points);
    		if ("min" in $$props) $$invalidate(1, min = $$props.min);
    		if ("max" in $$props) $$invalidate(2, max = $$props.max);
    		if ("count" in $$props) $$invalidate(3, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(4, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(5, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(6, padding = $$props.padding);
    	};

    	$$self.$capture_state = () => ({
    		LineGraphPoint,
    		points,
    		min,
    		max,
    		count,
    		shift,
    		height,
    		padding
    	});

    	$$self.$inject_state = $$props => {
    		if ("points" in $$props) $$invalidate(0, points = $$props.points);
    		if ("min" in $$props) $$invalidate(1, min = $$props.min);
    		if ("max" in $$props) $$invalidate(2, max = $$props.max);
    		if ("count" in $$props) $$invalidate(3, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(4, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(5, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(6, padding = $$props.padding);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [points, min, max, count, shift, height, padding];
    }

    class LineGraphPoints extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1U, create_fragment$1U, safe_not_equal, {
    			points: 0,
    			min: 1,
    			max: 2,
    			count: 3,
    			shift: 4,
    			height: 5,
    			padding: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LineGraphPoints",
    			options,
    			id: create_fragment$1U.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*points*/ ctx[0] === undefined && !("points" in props)) {
    			console.warn("<LineGraphPoints> was created without expected prop 'points'");
    		}

    		if (/*min*/ ctx[1] === undefined && !("min" in props)) {
    			console.warn("<LineGraphPoints> was created without expected prop 'min'");
    		}

    		if (/*max*/ ctx[2] === undefined && !("max" in props)) {
    			console.warn("<LineGraphPoints> was created without expected prop 'max'");
    		}

    		if (/*count*/ ctx[3] === undefined && !("count" in props)) {
    			console.warn("<LineGraphPoints> was created without expected prop 'count'");
    		}

    		if (/*shift*/ ctx[4] === undefined && !("shift" in props)) {
    			console.warn("<LineGraphPoints> was created without expected prop 'shift'");
    		}

    		if (/*height*/ ctx[5] === undefined && !("height" in props)) {
    			console.warn("<LineGraphPoints> was created without expected prop 'height'");
    		}

    		if (/*padding*/ ctx[6] === undefined && !("padding" in props)) {
    			console.warn("<LineGraphPoints> was created without expected prop 'padding'");
    		}
    	}

    	get points() {
    		throw new Error("<LineGraphPoints>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set points(value) {
    		throw new Error("<LineGraphPoints>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<LineGraphPoints>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<LineGraphPoints>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<LineGraphPoints>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<LineGraphPoints>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<LineGraphPoints>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<LineGraphPoints>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shift() {
    		throw new Error("<LineGraphPoints>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shift(value) {
    		throw new Error("<LineGraphPoints>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<LineGraphPoints>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<LineGraphPoints>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<LineGraphPoints>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<LineGraphPoints>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/lineGraph/LineGraphSegment.svelte generated by Svelte v3.24.0 */
    const file$1D = "src/js/components/lineGraph/LineGraphSegment.svelte";

    // (69:0) {#if shouldDrawPoint(points)}
    function create_if_block$z(ctx) {
    	let line;
    	let line_class_value;

    	const block = {
    		c: function create() {
    			line = svg_element("line");
    			attr_dev(line, "class", line_class_value = `txcm-lineGraphSegment${/*renderSegmentStatusClass*/ ctx[7](/*points*/ ctx[0])}`);
    			attr_dev(line, "x1", /*x1*/ ctx[1]);
    			attr_dev(line, "y1", /*y1*/ ctx[2]);
    			attr_dev(line, "x2", /*x2*/ ctx[3]);
    			attr_dev(line, "y2", /*y2*/ ctx[4]);
    			attr_dev(line, "transform", /*transform*/ ctx[5]);
    			add_location(line, file$1D, 69, 2, 1619);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, line, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*points*/ 1 && line_class_value !== (line_class_value = `txcm-lineGraphSegment${/*renderSegmentStatusClass*/ ctx[7](/*points*/ ctx[0])}`)) {
    				attr_dev(line, "class", line_class_value);
    			}

    			if (dirty & /*x1*/ 2) {
    				attr_dev(line, "x1", /*x1*/ ctx[1]);
    			}

    			if (dirty & /*y1*/ 4) {
    				attr_dev(line, "y1", /*y1*/ ctx[2]);
    			}

    			if (dirty & /*x2*/ 8) {
    				attr_dev(line, "x2", /*x2*/ ctx[3]);
    			}

    			if (dirty & /*y2*/ 16) {
    				attr_dev(line, "y2", /*y2*/ ctx[4]);
    			}

    			if (dirty & /*transform*/ 32) {
    				attr_dev(line, "transform", /*transform*/ ctx[5]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(line);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$z.name,
    		type: "if",
    		source: "(69:0) {#if shouldDrawPoint(points)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1V(ctx) {
    	let show_if = /*shouldDrawPoint*/ ctx[6](/*points*/ ctx[0]);
    	let if_block_anchor;
    	let if_block = show_if && create_if_block$z(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*points*/ 1) show_if = /*shouldDrawPoint*/ ctx[6](/*points*/ ctx[0]);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$z(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1V($$self, $$props, $$invalidate) {
    	let { points } = $$props;
    	let { index } = $$props;
    	let { min } = $$props;
    	let { max } = $$props;
    	let { count } = $$props;
    	let { shift } = $$props;
    	let { height } = $$props;
    	let { padding } = $$props;
    	let x1;
    	let y1;
    	let x2;
    	let y2;

    	function shouldDrawPoint() {
    		return points.every(point => point.point !== null);
    	}

    	function calculateX1() {
    		return renderPointX(index - 1, count);
    	}

    	function calculateY1() {
    		const [{ point }] = points;
    		const value = point || 0;
    		return renderPointY(value, min, max, height, padding);
    	}

    	function calculateX2() {
    		return renderPointX(index, count);
    	}

    	function calculateY2() {
    		const [,{ point }] = points;
    		const value = point || 0;
    		return renderPointY(value, min, max, height, padding);
    	}

    	function calculatePosition() {
    		$$invalidate(1, x1 = calculateX1());
    		$$invalidate(2, y1 = calculateY1());
    		$$invalidate(3, x2 = calculateX2());
    		$$invalidate(4, y2 = calculateY2());
    	}

    	function calculateTransform() {
    		return `translate(${shift} 0)`;
    	}

    	function renderSegmentStatusClass() {
    		if (points[0].vsBudget === "-" || points[1].vsBudget === "-") {
    			return " txcm-lineGraphSegment-no-budget";
    		}

    		if (points[0].deviations) {
    			if (points[1].deviations) return " txcm-lineGraphSegment-has-fullDeviations";
    			return " txcm-lineGraphSegment-has-leftDeviations";
    		} else if (points[1].deviations) return " txcm-lineGraphSegment-has-rightDeviations";

    		return "";
    	}

    	const writable_props = ["points", "index", "min", "max", "count", "shift", "height", "padding"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LineGraphSegment> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LineGraphSegment", $$slots, []);

    	$$self.$set = $$props => {
    		if ("points" in $$props) $$invalidate(0, points = $$props.points);
    		if ("index" in $$props) $$invalidate(8, index = $$props.index);
    		if ("min" in $$props) $$invalidate(9, min = $$props.min);
    		if ("max" in $$props) $$invalidate(10, max = $$props.max);
    		if ("count" in $$props) $$invalidate(11, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(12, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(13, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(14, padding = $$props.padding);
    	};

    	$$self.$capture_state = () => ({
    		renderPointX,
    		renderPointY,
    		points,
    		index,
    		min,
    		max,
    		count,
    		shift,
    		height,
    		padding,
    		x1,
    		y1,
    		x2,
    		y2,
    		shouldDrawPoint,
    		calculateX1,
    		calculateY1,
    		calculateX2,
    		calculateY2,
    		calculatePosition,
    		calculateTransform,
    		renderSegmentStatusClass,
    		transform
    	});

    	$$self.$inject_state = $$props => {
    		if ("points" in $$props) $$invalidate(0, points = $$props.points);
    		if ("index" in $$props) $$invalidate(8, index = $$props.index);
    		if ("min" in $$props) $$invalidate(9, min = $$props.min);
    		if ("max" in $$props) $$invalidate(10, max = $$props.max);
    		if ("count" in $$props) $$invalidate(11, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(12, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(13, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(14, padding = $$props.padding);
    		if ("x1" in $$props) $$invalidate(1, x1 = $$props.x1);
    		if ("y1" in $$props) $$invalidate(2, y1 = $$props.y1);
    		if ("x2" in $$props) $$invalidate(3, x2 = $$props.x2);
    		if ("y2" in $$props) $$invalidate(4, y2 = $$props.y2);
    		if ("transform" in $$props) $$invalidate(5, transform = $$props.transform);
    	};

    	let transform;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*shift*/ 4096) {
    			 $$invalidate(5, transform = calculateTransform());
    		}

    		if ($$self.$$.dirty & /*points, min, max, count*/ 3585) {
    			 calculatePosition();
    		}
    	};

    	return [
    		points,
    		x1,
    		y1,
    		x2,
    		y2,
    		transform,
    		shouldDrawPoint,
    		renderSegmentStatusClass,
    		index,
    		min,
    		max,
    		count,
    		shift,
    		height,
    		padding
    	];
    }

    class LineGraphSegment extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1V, create_fragment$1V, safe_not_equal, {
    			points: 0,
    			index: 8,
    			min: 9,
    			max: 10,
    			count: 11,
    			shift: 12,
    			height: 13,
    			padding: 14
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LineGraphSegment",
    			options,
    			id: create_fragment$1V.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*points*/ ctx[0] === undefined && !("points" in props)) {
    			console.warn("<LineGraphSegment> was created without expected prop 'points'");
    		}

    		if (/*index*/ ctx[8] === undefined && !("index" in props)) {
    			console.warn("<LineGraphSegment> was created without expected prop 'index'");
    		}

    		if (/*min*/ ctx[9] === undefined && !("min" in props)) {
    			console.warn("<LineGraphSegment> was created without expected prop 'min'");
    		}

    		if (/*max*/ ctx[10] === undefined && !("max" in props)) {
    			console.warn("<LineGraphSegment> was created without expected prop 'max'");
    		}

    		if (/*count*/ ctx[11] === undefined && !("count" in props)) {
    			console.warn("<LineGraphSegment> was created without expected prop 'count'");
    		}

    		if (/*shift*/ ctx[12] === undefined && !("shift" in props)) {
    			console.warn("<LineGraphSegment> was created without expected prop 'shift'");
    		}

    		if (/*height*/ ctx[13] === undefined && !("height" in props)) {
    			console.warn("<LineGraphSegment> was created without expected prop 'height'");
    		}

    		if (/*padding*/ ctx[14] === undefined && !("padding" in props)) {
    			console.warn("<LineGraphSegment> was created without expected prop 'padding'");
    		}
    	}

    	get points() {
    		throw new Error("<LineGraphSegment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set points(value) {
    		throw new Error("<LineGraphSegment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<LineGraphSegment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<LineGraphSegment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<LineGraphSegment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<LineGraphSegment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<LineGraphSegment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<LineGraphSegment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<LineGraphSegment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<LineGraphSegment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shift() {
    		throw new Error("<LineGraphSegment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shift(value) {
    		throw new Error("<LineGraphSegment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<LineGraphSegment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<LineGraphSegment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<LineGraphSegment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<LineGraphSegment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/lineGraph/LineGraphSegments.svelte generated by Svelte v3.24.0 */

    function get_each_context$p(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	child_ctx[10] = i;
    	return child_ctx;
    }

    // (18:2) {#if shouldDrawSegment(segments, index)}
    function create_if_block$A(ctx) {
    	let linegraphsegment;
    	let current;

    	linegraphsegment = new LineGraphSegment({
    			props: {
    				count: /*count*/ ctx[3],
    				shift: /*shift*/ ctx[4],
    				height: /*height*/ ctx[5],
    				padding: /*padding*/ ctx[6],
    				index: /*index*/ ctx[10],
    				min: /*min*/ ctx[1],
    				max: /*max*/ ctx[2],
    				points: [/*point*/ ctx[8], /*segments*/ ctx[0][/*index*/ ctx[10] + 1]]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(linegraphsegment.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(linegraphsegment, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const linegraphsegment_changes = {};
    			if (dirty & /*count*/ 8) linegraphsegment_changes.count = /*count*/ ctx[3];
    			if (dirty & /*shift*/ 16) linegraphsegment_changes.shift = /*shift*/ ctx[4];
    			if (dirty & /*height*/ 32) linegraphsegment_changes.height = /*height*/ ctx[5];
    			if (dirty & /*padding*/ 64) linegraphsegment_changes.padding = /*padding*/ ctx[6];
    			if (dirty & /*min*/ 2) linegraphsegment_changes.min = /*min*/ ctx[1];
    			if (dirty & /*max*/ 4) linegraphsegment_changes.max = /*max*/ ctx[2];
    			if (dirty & /*segments*/ 1) linegraphsegment_changes.points = [/*point*/ ctx[8], /*segments*/ ctx[0][/*index*/ ctx[10] + 1]];
    			linegraphsegment.$set(linegraphsegment_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linegraphsegment.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linegraphsegment.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(linegraphsegment, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$A.name,
    		type: "if",
    		source: "(18:2) {#if shouldDrawSegment(segments, index)}",
    		ctx
    	});

    	return block;
    }

    // (17:0) {#each segments as point, index}
    function create_each_block$p(ctx) {
    	let show_if = /*shouldDrawSegment*/ ctx[7](/*segments*/ ctx[0], /*index*/ ctx[10]);
    	let if_block_anchor;
    	let current;
    	let if_block = show_if && create_if_block$A(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*segments*/ 1) show_if = /*shouldDrawSegment*/ ctx[7](/*segments*/ ctx[0], /*index*/ ctx[10]);

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*segments*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$A(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$p.name,
    		type: "each",
    		source: "(17:0) {#each segments as point, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1W(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*segments*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$p(get_each_context$p(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*count, shift, height, padding, min, max, segments, shouldDrawSegment*/ 255) {
    				each_value = /*segments*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$p(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$p(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1W($$self, $$props, $$invalidate) {
    	let { segments } = $$props;
    	let { min } = $$props;
    	let { max } = $$props;
    	let { count } = $$props;
    	let { shift } = $$props;
    	let { height } = $$props;
    	let { padding } = $$props;

    	function shouldDrawSegment(point, index) {
    		return segments[index] && segments[index + 1];
    	}

    	const writable_props = ["segments", "min", "max", "count", "shift", "height", "padding"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LineGraphSegments> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LineGraphSegments", $$slots, []);

    	$$self.$set = $$props => {
    		if ("segments" in $$props) $$invalidate(0, segments = $$props.segments);
    		if ("min" in $$props) $$invalidate(1, min = $$props.min);
    		if ("max" in $$props) $$invalidate(2, max = $$props.max);
    		if ("count" in $$props) $$invalidate(3, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(4, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(5, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(6, padding = $$props.padding);
    	};

    	$$self.$capture_state = () => ({
    		LineGraphSegment,
    		segments,
    		min,
    		max,
    		count,
    		shift,
    		height,
    		padding,
    		shouldDrawSegment
    	});

    	$$self.$inject_state = $$props => {
    		if ("segments" in $$props) $$invalidate(0, segments = $$props.segments);
    		if ("min" in $$props) $$invalidate(1, min = $$props.min);
    		if ("max" in $$props) $$invalidate(2, max = $$props.max);
    		if ("count" in $$props) $$invalidate(3, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(4, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(5, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(6, padding = $$props.padding);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [segments, min, max, count, shift, height, padding, shouldDrawSegment];
    }

    class LineGraphSegments extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1W, create_fragment$1W, safe_not_equal, {
    			segments: 0,
    			min: 1,
    			max: 2,
    			count: 3,
    			shift: 4,
    			height: 5,
    			padding: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LineGraphSegments",
    			options,
    			id: create_fragment$1W.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*segments*/ ctx[0] === undefined && !("segments" in props)) {
    			console.warn("<LineGraphSegments> was created without expected prop 'segments'");
    		}

    		if (/*min*/ ctx[1] === undefined && !("min" in props)) {
    			console.warn("<LineGraphSegments> was created without expected prop 'min'");
    		}

    		if (/*max*/ ctx[2] === undefined && !("max" in props)) {
    			console.warn("<LineGraphSegments> was created without expected prop 'max'");
    		}

    		if (/*count*/ ctx[3] === undefined && !("count" in props)) {
    			console.warn("<LineGraphSegments> was created without expected prop 'count'");
    		}

    		if (/*shift*/ ctx[4] === undefined && !("shift" in props)) {
    			console.warn("<LineGraphSegments> was created without expected prop 'shift'");
    		}

    		if (/*height*/ ctx[5] === undefined && !("height" in props)) {
    			console.warn("<LineGraphSegments> was created without expected prop 'height'");
    		}

    		if (/*padding*/ ctx[6] === undefined && !("padding" in props)) {
    			console.warn("<LineGraphSegments> was created without expected prop 'padding'");
    		}
    	}

    	get segments() {
    		throw new Error("<LineGraphSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set segments(value) {
    		throw new Error("<LineGraphSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<LineGraphSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<LineGraphSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<LineGraphSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<LineGraphSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<LineGraphSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<LineGraphSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shift() {
    		throw new Error("<LineGraphSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shift(value) {
    		throw new Error("<LineGraphSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<LineGraphSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<LineGraphSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<LineGraphSegments>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<LineGraphSegments>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/lineGraph/LineGraphLabels.svelte generated by Svelte v3.24.0 */
    const file$1E = "src/js/components/lineGraph/LineGraphLabels.svelte";

    function create_fragment$1X(ctx) {
    	let div3;
    	let div0;

    	let t0_value = (Math.abs(/*max*/ ctx[1]) <= 0.00001
    	? 0
    	: formatLabel(/*max*/ ctx[1], /*units*/ ctx[3], "%", /*base*/ ctx[5])) + "";

    	let t0;
    	let t1;
    	let div1;

    	let t2_value = (Math.abs(/*average*/ ctx[4]) <= 0.00001
    	? 0
    	: formatLabel(/*average*/ ctx[4], /*units*/ ctx[3], "%", /*base*/ ctx[5])) + "";

    	let t2;
    	let t3;
    	let div2;

    	let t4_value = (Math.abs(/*min*/ ctx[0]) <= 0.00001
    	? 0
    	: formatLabel(/*min*/ ctx[0], /*units*/ ctx[3], "%", /*base*/ ctx[5])) + "";

    	let t4;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div2 = element("div");
    			t4 = text(t4_value);
    			attr_dev(div0, "class", "txcm-linearGraphLabel");
    			add_location(div0, file$1E, 18, 4, 389);
    			attr_dev(div1, "class", "txcm-linearGraphLabel");
    			add_location(div1, file$1E, 22, 4, 523);
    			attr_dev(div2, "class", "txcm-linearGraphLabel");
    			add_location(div2, file$1E, 26, 4, 665);
    			attr_dev(div3, "class", "txcm-linearGraphLabels");
    			toggle_class(div3, "txcm-linearGraphLabels-is-compact", /*isCompact*/ ctx[2]);
    			add_location(div3, file$1E, 15, 0, 292);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div1, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			append_dev(div2, t4);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*max, units, base*/ 42 && t0_value !== (t0_value = (Math.abs(/*max*/ ctx[1]) <= 0.00001
    			? 0
    			: formatLabel(/*max*/ ctx[1], /*units*/ ctx[3], "%", /*base*/ ctx[5])) + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*average, units, base*/ 56 && t2_value !== (t2_value = (Math.abs(/*average*/ ctx[4]) <= 0.00001
    			? 0
    			: formatLabel(/*average*/ ctx[4], /*units*/ ctx[3], "%", /*base*/ ctx[5])) + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*min, units, base*/ 41 && t4_value !== (t4_value = (Math.abs(/*min*/ ctx[0]) <= 0.00001
    			? 0
    			: formatLabel(/*min*/ ctx[0], /*units*/ ctx[3], "%", /*base*/ ctx[5])) + "")) set_data_dev(t4, t4_value);

    			if (dirty & /*isCompact*/ 4) {
    				toggle_class(div3, "txcm-linearGraphLabels-is-compact", /*isCompact*/ ctx[2]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1X($$self, $$props, $$invalidate) {
    	let { min } = $$props;
    	let { max } = $$props;
    	let { isCompact } = $$props;
    	let { units } = $$props;
    	let { indicator } = $$props;
    	const writable_props = ["min", "max", "isCompact", "units", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LineGraphLabels> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LineGraphLabels", $$slots, []);

    	$$self.$set = $$props => {
    		if ("min" in $$props) $$invalidate(0, min = $$props.min);
    		if ("max" in $$props) $$invalidate(1, max = $$props.max);
    		if ("isCompact" in $$props) $$invalidate(2, isCompact = $$props.isCompact);
    		if ("units" in $$props) $$invalidate(3, units = $$props.units);
    		if ("indicator" in $$props) $$invalidate(6, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		formatLabel,
    		min,
    		max,
    		isCompact,
    		units,
    		indicator,
    		average,
    		base
    	});

    	$$self.$inject_state = $$props => {
    		if ("min" in $$props) $$invalidate(0, min = $$props.min);
    		if ("max" in $$props) $$invalidate(1, max = $$props.max);
    		if ("isCompact" in $$props) $$invalidate(2, isCompact = $$props.isCompact);
    		if ("units" in $$props) $$invalidate(3, units = $$props.units);
    		if ("indicator" in $$props) $$invalidate(6, indicator = $$props.indicator);
    		if ("average" in $$props) $$invalidate(4, average = $$props.average);
    		if ("base" in $$props) $$invalidate(5, base = $$props.base);
    	};

    	let average;
    	let base;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*max, min*/ 3) {
    			 $$invalidate(4, average = Math.round((max + min) / 2 * 10000) / 10000);
    		}

    		if ($$self.$$.dirty & /*indicator*/ 64) {
    			 $$invalidate(5, base = indicator.id != "4" ? 1000000 : 1);
    		}
    	};

    	return [min, max, isCompact, units, average, base, indicator];
    }

    class LineGraphLabels extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1X, create_fragment$1X, safe_not_equal, {
    			min: 0,
    			max: 1,
    			isCompact: 2,
    			units: 3,
    			indicator: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LineGraphLabels",
    			options,
    			id: create_fragment$1X.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*min*/ ctx[0] === undefined && !("min" in props)) {
    			console.warn("<LineGraphLabels> was created without expected prop 'min'");
    		}

    		if (/*max*/ ctx[1] === undefined && !("max" in props)) {
    			console.warn("<LineGraphLabels> was created without expected prop 'max'");
    		}

    		if (/*isCompact*/ ctx[2] === undefined && !("isCompact" in props)) {
    			console.warn("<LineGraphLabels> was created without expected prop 'isCompact'");
    		}

    		if (/*units*/ ctx[3] === undefined && !("units" in props)) {
    			console.warn("<LineGraphLabels> was created without expected prop 'units'");
    		}

    		if (/*indicator*/ ctx[6] === undefined && !("indicator" in props)) {
    			console.warn("<LineGraphLabels> was created without expected prop 'indicator'");
    		}
    	}

    	get min() {
    		throw new Error("<LineGraphLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<LineGraphLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<LineGraphLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<LineGraphLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isCompact() {
    		throw new Error("<LineGraphLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isCompact(value) {
    		throw new Error("<LineGraphLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<LineGraphLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<LineGraphLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<LineGraphLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<LineGraphLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/lineGraph/LineGraph.svelte generated by Svelte v3.24.0 */
    const file$1F = "src/js/components/lineGraph/LineGraph.svelte";

    function create_fragment$1Y(ctx) {
    	let linegraphlabels;
    	let t;
    	let div;
    	let svg;
    	let linegraphaxes;
    	let linegraphsegments;
    	let linegraphpoints;
    	let current;
    	let mounted;
    	let dispose;

    	linegraphlabels = new LineGraphLabels({
    			props: {
    				units: /*units*/ ctx[5],
    				min: /*min*/ ctx[8],
    				max: /*max*/ ctx[10],
    				minLabel: /*minLabel*/ ctx[9],
    				maxLabel: /*maxLabel*/ ctx[11],
    				indicator: /*indicator*/ ctx[0],
    				isCompact: /*isCompact*/ ctx[4]
    			},
    			$$inline: true
    		});

    	linegraphaxes = new LineGraphAxes({
    			props: { padding: /*padding*/ ctx[3] },
    			$$inline: true
    		});

    	linegraphsegments = new LineGraphSegments({
    			props: {
    				count: /*count*/ ctx[1],
    				shift: /*shift*/ ctx[2],
    				height: /*height*/ ctx[12],
    				padding: /*padding*/ ctx[3],
    				min: /*min*/ ctx[8],
    				max: /*max*/ ctx[10],
    				segments: /*segments*/ ctx[7]
    			},
    			$$inline: true
    		});

    	linegraphpoints = new LineGraphPoints({
    			props: {
    				count: /*count*/ ctx[1],
    				shift: /*shift*/ ctx[2],
    				height: /*height*/ ctx[12],
    				padding: /*padding*/ ctx[3],
    				min: /*min*/ ctx[8],
    				max: /*max*/ ctx[10],
    				points: /*points*/ ctx[6]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(linegraphlabels.$$.fragment);
    			t = space();
    			div = element("div");
    			svg = svg_element("svg");
    			create_component(linegraphaxes.$$.fragment);
    			create_component(linegraphsegments.$$.fragment);
    			create_component(linegraphpoints.$$.fragment);
    			attr_dev(svg, "class", "txcm-lineGraph");
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", /*height*/ ctx[12]);
    			toggle_class(svg, "txcm-lineGraph-is-compact", /*isCompact*/ ctx[4]);
    			add_location(svg, file$1F, 153, 4, 5074);
    			attr_dev(div, "class", "txcm-lineGraphHolder");
    			add_location(div, file$1F, 147, 0, 4863);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(linegraphlabels, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			mount_component(linegraphaxes, svg, null);
    			mount_component(linegraphsegments, svg, null);
    			mount_component(linegraphpoints, svg, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "click", stop_propagation(prevent_default(/*click_handler*/ ctx[19])), false, true, true),
    					listen_dev(div, "mousedown", stop_propagation(prevent_default(/*onPointerDown*/ ctx[16])), false, true, true),
    					listen_dev(div, "touchstart", stop_propagation(prevent_default(/*onPointerDown*/ ctx[16])), false, true, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const linegraphlabels_changes = {};
    			if (dirty[0] & /*units*/ 32) linegraphlabels_changes.units = /*units*/ ctx[5];
    			if (dirty[0] & /*min*/ 256) linegraphlabels_changes.min = /*min*/ ctx[8];
    			if (dirty[0] & /*max*/ 1024) linegraphlabels_changes.max = /*max*/ ctx[10];
    			if (dirty[0] & /*minLabel*/ 512) linegraphlabels_changes.minLabel = /*minLabel*/ ctx[9];
    			if (dirty[0] & /*maxLabel*/ 2048) linegraphlabels_changes.maxLabel = /*maxLabel*/ ctx[11];
    			if (dirty[0] & /*indicator*/ 1) linegraphlabels_changes.indicator = /*indicator*/ ctx[0];
    			if (dirty[0] & /*isCompact*/ 16) linegraphlabels_changes.isCompact = /*isCompact*/ ctx[4];
    			linegraphlabels.$set(linegraphlabels_changes);
    			const linegraphaxes_changes = {};
    			if (dirty[0] & /*padding*/ 8) linegraphaxes_changes.padding = /*padding*/ ctx[3];
    			linegraphaxes.$set(linegraphaxes_changes);
    			const linegraphsegments_changes = {};
    			if (dirty[0] & /*count*/ 2) linegraphsegments_changes.count = /*count*/ ctx[1];
    			if (dirty[0] & /*shift*/ 4) linegraphsegments_changes.shift = /*shift*/ ctx[2];
    			if (dirty[0] & /*height*/ 4096) linegraphsegments_changes.height = /*height*/ ctx[12];
    			if (dirty[0] & /*padding*/ 8) linegraphsegments_changes.padding = /*padding*/ ctx[3];
    			if (dirty[0] & /*min*/ 256) linegraphsegments_changes.min = /*min*/ ctx[8];
    			if (dirty[0] & /*max*/ 1024) linegraphsegments_changes.max = /*max*/ ctx[10];
    			if (dirty[0] & /*segments*/ 128) linegraphsegments_changes.segments = /*segments*/ ctx[7];
    			linegraphsegments.$set(linegraphsegments_changes);
    			const linegraphpoints_changes = {};
    			if (dirty[0] & /*count*/ 2) linegraphpoints_changes.count = /*count*/ ctx[1];
    			if (dirty[0] & /*shift*/ 4) linegraphpoints_changes.shift = /*shift*/ ctx[2];
    			if (dirty[0] & /*height*/ 4096) linegraphpoints_changes.height = /*height*/ ctx[12];
    			if (dirty[0] & /*padding*/ 8) linegraphpoints_changes.padding = /*padding*/ ctx[3];
    			if (dirty[0] & /*min*/ 256) linegraphpoints_changes.min = /*min*/ ctx[8];
    			if (dirty[0] & /*max*/ 1024) linegraphpoints_changes.max = /*max*/ ctx[10];
    			if (dirty[0] & /*points*/ 64) linegraphpoints_changes.points = /*points*/ ctx[6];
    			linegraphpoints.$set(linegraphpoints_changes);

    			if (!current || dirty[0] & /*height*/ 4096) {
    				attr_dev(svg, "height", /*height*/ ctx[12]);
    			}

    			if (dirty[0] & /*isCompact*/ 16) {
    				toggle_class(svg, "txcm-lineGraph-is-compact", /*isCompact*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linegraphlabels.$$.fragment, local);
    			transition_in(linegraphaxes.$$.fragment, local);
    			transition_in(linegraphsegments.$$.fragment, local);
    			transition_in(linegraphpoints.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linegraphlabels.$$.fragment, local);
    			transition_out(linegraphaxes.$$.fragment, local);
    			transition_out(linegraphsegments.$$.fragment, local);
    			transition_out(linegraphpoints.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(linegraphlabels, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			destroy_component(linegraphaxes);
    			destroy_component(linegraphsegments);
    			destroy_component(linegraphpoints);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const DEFAULT_HEIGHT = 82;
    const DEFAULT_COMPACT_HEIGHT = 56;
    const DEFAULT_PADDING = 10;

    function normalizeValue(option) {
    	return option.data;
    }

    function instance$1Y($$self, $$props, $$invalidate) {
    	let $locale;
    	let $scroll;
    	let $scrollMax;
    	const scroll = getGraphsState("scroll");
    	validate_store(scroll, "scroll");
    	component_subscribe($$self, scroll, value => $$invalidate(24, $scroll = value));
    	const scrollMax = getGraphsState("scrollMax");
    	validate_store(scrollMax, "scrollMax");
    	component_subscribe($$self, scrollMax, value => $$invalidate(25, $scrollMax = value));
    	let { indicator } = $$props;
    	let { data } = $$props;
    	let { step } = $$props;
    	let { count } = $$props;
    	let { shift } = $$props;
    	let { padding = DEFAULT_PADDING } = $$props;
    	let { isCompact = false } = $$props;
    	let { units } = $$props;
    	let points = [];
    	let segments = [];
    	let min;
    	let minLabel;
    	let max;
    	let maxLabel;
    	let pointer = null;
    	let pointerPositionStart;
    	let pointerScrollStart;
    	let pointerPositionCurrent;
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(23, $locale = value));

    	function calculateLimits() {
    		if (data.length === 0) return;
    		const values = data[0].data.map(normalizeValue).filter(item => item !== null && !isNaN(item));

    		if (values && data[0].data && data[0].data.length > 0) {
    			const minRaw = Math.min(...values);
    			const maxRaw = Math.max(...values);
    			$$invalidate(8, min = Math.round(minRaw * 10000) / 10000);
    			$$invalidate(10, max = Math.round(maxRaw * 10000) / 10000);
    			$$invalidate(9, minLabel = (data[0].data.find(option => option.data === minRaw) || {}).text || "0.00%");
    			$$invalidate(11, maxLabel = (data[0].data.find(option => option.data === maxRaw) || {}).text || "1.00%");
    		} else {
    			$$invalidate(8, min = 0);
    			$$invalidate(10, max = 1);
    			$$invalidate(9, minLabel = "0.00%");
    			$$invalidate(11, maxLabel = "1.00%");
    		}
    	}

    	function zipPoints() {
    		return data[0].data.map((point, index) => ({
    			point: point.data && !isNaN(point.data) ? point.data : null,
    			name: point.name,
    			year: parseInt(point.name.slice(0, 4)),
    			month: parseInt(point.name.slice(4, 6)),
    			day: parseInt(point.name.slice(6, 8)),
    			fact: point.text,
    			vsPp: data[1]
    			? data[1].data[index].data !== 0 && data[1].data[index].data !== null
    				? data[1].data[index].text || "-"
    				: "-"
    			: "-",
    			vsPpPercent: data[2]
    			? data[2].data[index].data !== 0 && data[2].data[index].data !== null
    				? data[2].data[index].text || "-"
    				: "-"
    			: "-",
    			vsBudget: data[3]
    			? data[3].data[index].data !== 0 && data[3].data[index].data !== null
    				? data[3].data[index].text || "-"
    				: "-"
    			: "-",
    			vsBudgetPercent: data[4]
    			? data[4].data[index].data !== 0 && data[4].data[index].data !== null
    				? data[4].data[index].text || "-"
    				: "-"
    			: "-",
    			deviations: data.length > 3
    			? data[0].data[index].data !== null && data[3].data[index].data !== null && data[3].data[index].data > data[0].data[index].data
    			: undefined
    		}));
    	}

    	function updateLines() {
    		if (data.length === 0) return;
    		const [{ length }] = data;
    		const fragment = zipPoints();

    		if (length <= count) {
    			$$invalidate(6, points = fragment.slice());
    			$$invalidate(7, segments = [null, ...fragment]);
    		} else {
    			$$invalidate(6, points = fragment.slice(step, step + count + 1));
    			const newSegments = [...points];
    			newSegments.unshift(fragment[step - 1] || null);
    			newSegments.push(fragment[step + count + 1] || null);
    			$$invalidate(7, segments = newSegments);
    		}
    	}

    	function changeScroll(deltaX) {
    		if (pointerScrollStart + deltaX <= 0) set_store_value(scroll, $scroll = 0); else if (pointerScrollStart + deltaX >= $scrollMax) set_store_value(scroll, $scroll = $scrollMax); else set_store_value(scroll, $scroll = pointerScrollStart + deltaX);
    	}

    	function onPointerMove(event) {
    		pointerPositionCurrent = event.touches ? event.touches[0].clientX : event.clientX;
    		const diff = pointerPositionStart - pointerPositionCurrent;
    		changeScroll(diff);
    	}

    	function onPointerUp(event) {
    		event.preventDefault();
    		event.stopPropagation();
    		unsubscribeWindow();
    	}

    	function subscribeWindow() {
    		window.addEventListener("mousemove", onPointerMove);
    		window.addEventListener("touchmove", onPointerMove);
    		window.addEventListener("mouseup", onPointerUp);
    		window.addEventListener("touchend", onPointerUp);
    	}

    	function unsubscribeWindow() {
    		window.removeEventListener("mousemove", onPointerMove);
    		window.removeEventListener("touchmove", onPointerMove);
    		window.removeEventListener("mouseup", onPointerUp);
    		window.removeEventListener("touchend", onPointerUp);
    	}

    	function onPointerDown(event) {
    		pointerPositionStart = event.touches ? event.touches[0].clientX : event.clientX;
    		pointerScrollStart = $scroll;
    		subscribeWindow();
    	}

    	const writable_props = ["indicator", "data", "step", "count", "shift", "padding", "isCompact", "units"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<LineGraph> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("LineGraph", $$slots, []);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("data" in $$props) $$invalidate(17, data = $$props.data);
    		if ("step" in $$props) $$invalidate(18, step = $$props.step);
    		if ("count" in $$props) $$invalidate(1, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(2, shift = $$props.shift);
    		if ("padding" in $$props) $$invalidate(3, padding = $$props.padding);
    		if ("isCompact" in $$props) $$invalidate(4, isCompact = $$props.isCompact);
    		if ("units" in $$props) $$invalidate(5, units = $$props.units);
    	};

    	$$self.$capture_state = () => ({
    		LineGraphAxes,
    		LineGraphPoints,
    		LineGraphSegments,
    		LineGraphLabels,
    		getUIState,
    		getGraphsState,
    		DEFAULT_HEIGHT,
    		DEFAULT_COMPACT_HEIGHT,
    		DEFAULT_PADDING,
    		scroll,
    		scrollMax,
    		indicator,
    		data,
    		step,
    		count,
    		shift,
    		padding,
    		isCompact,
    		units,
    		points,
    		segments,
    		min,
    		minLabel,
    		max,
    		maxLabel,
    		pointer,
    		pointerPositionStart,
    		pointerScrollStart,
    		pointerPositionCurrent,
    		locale,
    		normalizeValue,
    		calculateLimits,
    		zipPoints,
    		updateLines,
    		changeScroll,
    		onPointerMove,
    		onPointerUp,
    		subscribeWindow,
    		unsubscribeWindow,
    		onPointerDown,
    		height,
    		$locale,
    		$scroll,
    		$scrollMax
    	});

    	$$self.$inject_state = $$props => {
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("data" in $$props) $$invalidate(17, data = $$props.data);
    		if ("step" in $$props) $$invalidate(18, step = $$props.step);
    		if ("count" in $$props) $$invalidate(1, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(2, shift = $$props.shift);
    		if ("padding" in $$props) $$invalidate(3, padding = $$props.padding);
    		if ("isCompact" in $$props) $$invalidate(4, isCompact = $$props.isCompact);
    		if ("units" in $$props) $$invalidate(5, units = $$props.units);
    		if ("points" in $$props) $$invalidate(6, points = $$props.points);
    		if ("segments" in $$props) $$invalidate(7, segments = $$props.segments);
    		if ("min" in $$props) $$invalidate(8, min = $$props.min);
    		if ("minLabel" in $$props) $$invalidate(9, minLabel = $$props.minLabel);
    		if ("max" in $$props) $$invalidate(10, max = $$props.max);
    		if ("maxLabel" in $$props) $$invalidate(11, maxLabel = $$props.maxLabel);
    		if ("pointer" in $$props) pointer = $$props.pointer;
    		if ("pointerPositionStart" in $$props) pointerPositionStart = $$props.pointerPositionStart;
    		if ("pointerScrollStart" in $$props) pointerScrollStart = $$props.pointerScrollStart;
    		if ("pointerPositionCurrent" in $$props) pointerPositionCurrent = $$props.pointerPositionCurrent;
    		if ("height" in $$props) $$invalidate(12, height = $$props.height);
    	};

    	let height;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*isCompact*/ 16) {
    			 $$invalidate(12, height = isCompact ? DEFAULT_COMPACT_HEIGHT : DEFAULT_HEIGHT);
    		}

    		if ($$self.$$.dirty[0] & /*data*/ 131072) {
    			 calculateLimits();
    		}

    		if ($$self.$$.dirty[0] & /*data, step, count, $locale*/ 8781826) {
    			 updateLines();
    		}
    	};

    	return [
    		indicator,
    		count,
    		shift,
    		padding,
    		isCompact,
    		units,
    		points,
    		segments,
    		min,
    		minLabel,
    		max,
    		maxLabel,
    		height,
    		scroll,
    		scrollMax,
    		locale,
    		onPointerDown,
    		data,
    		step,
    		click_handler
    	];
    }

    class LineGraph extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$1Y,
    			create_fragment$1Y,
    			safe_not_equal,
    			{
    				indicator: 0,
    				data: 17,
    				step: 18,
    				count: 1,
    				shift: 2,
    				padding: 3,
    				isCompact: 4,
    				units: 5
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "LineGraph",
    			options,
    			id: create_fragment$1Y.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*indicator*/ ctx[0] === undefined && !("indicator" in props)) {
    			console.warn("<LineGraph> was created without expected prop 'indicator'");
    		}

    		if (/*data*/ ctx[17] === undefined && !("data" in props)) {
    			console.warn("<LineGraph> was created without expected prop 'data'");
    		}

    		if (/*step*/ ctx[18] === undefined && !("step" in props)) {
    			console.warn("<LineGraph> was created without expected prop 'step'");
    		}

    		if (/*count*/ ctx[1] === undefined && !("count" in props)) {
    			console.warn("<LineGraph> was created without expected prop 'count'");
    		}

    		if (/*shift*/ ctx[2] === undefined && !("shift" in props)) {
    			console.warn("<LineGraph> was created without expected prop 'shift'");
    		}

    		if (/*units*/ ctx[5] === undefined && !("units" in props)) {
    			console.warn("<LineGraph> was created without expected prop 'units'");
    		}
    	}

    	get indicator() {
    		throw new Error("<LineGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<LineGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<LineGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<LineGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get step() {
    		throw new Error("<LineGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set step(value) {
    		throw new Error("<LineGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<LineGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<LineGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shift() {
    		throw new Error("<LineGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shift(value) {
    		throw new Error("<LineGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<LineGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<LineGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isCompact() {
    		throw new Error("<LineGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isCompact(value) {
    		throw new Error("<LineGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<LineGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<LineGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/barChart/BarChartComparison.svelte generated by Svelte v3.24.0 */
    const file$1G = "src/js/components/barChart/BarChartComparison.svelte";

    // (40:4) {#if !!point.left && Math.abs(point.left / 10000) >= 0.0001 && ((!isInverted && point.left < 0) || (isInverted && point.left > 0))}
    function create_if_block_1$9(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "txcm-barChartBar txcm-barChartBar-left");
    			set_style(div, "--valueScale", /*leftValue*/ ctx[2] + "%");
    			add_location(div, file$1G, 40, 6, 952);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*leftValue*/ 4) {
    				set_style(div, "--valueScale", /*leftValue*/ ctx[2] + "%");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(40:4) {#if !!point.left && Math.abs(point.left / 10000) >= 0.0001 && ((!isInverted && point.left < 0) || (isInverted && point.left > 0))}",
    		ctx
    	});

    	return block;
    }

    // (45:4) {#if !!point.right && Math.abs(point.right / 10000) >= 0.0001 && ((!isInverted && point.right < 0) || (isInverted && point.right > 0))}
    function create_if_block$B(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "txcm-barChartBar txcm-barChartBar-right");
    			set_style(div, "--valueScale", /*rightValue*/ ctx[3] + "%");
    			add_location(div, file$1G, 45, 6, 1215);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*rightValue*/ 8) {
    				set_style(div, "--valueScale", /*rightValue*/ ctx[3] + "%");
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$B.name,
    		type: "if",
    		source: "(45:4) {#if !!point.right && Math.abs(point.right / 10000) >= 0.0001 && ((!isInverted && point.right < 0) || (isInverted && point.right > 0))}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1Z(ctx) {
    	let div;
    	let show_if_1 = !!/*point*/ ctx[0].left && Math.abs(/*point*/ ctx[0].left / 10000) >= 0.0001 && (!/*isInverted*/ ctx[1] && /*point*/ ctx[0].left < 0 || /*isInverted*/ ctx[1] && /*point*/ ctx[0].left > 0);
    	let t;
    	let show_if = !!/*point*/ ctx[0].right && Math.abs(/*point*/ ctx[0].right / 10000) >= 0.0001 && (!/*isInverted*/ ctx[1] && /*point*/ ctx[0].right < 0 || /*isInverted*/ ctx[1] && /*point*/ ctx[0].right > 0);
    	let tooltip_action;
    	let mounted;
    	let dispose;
    	let if_block0 = show_if_1 && create_if_block_1$9(ctx);
    	let if_block1 = show_if && create_if_block$B(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "txcm-barChartComparison");
    			add_location(div, file$1G, 36, 0, 739);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);
    			if (if_block1) if_block1.m(div, null);

    			if (!mounted) {
    				dispose = action_destroyer(tooltip_action = tooltip.call(null, div, /*tooltipOptions*/ ctx[4]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*point, isInverted*/ 3) show_if_1 = !!/*point*/ ctx[0].left && Math.abs(/*point*/ ctx[0].left / 10000) >= 0.0001 && (!/*isInverted*/ ctx[1] && /*point*/ ctx[0].left < 0 || /*isInverted*/ ctx[1] && /*point*/ ctx[0].left > 0);

    			if (show_if_1) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_1$9(ctx);
    					if_block0.c();
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*point, isInverted*/ 3) show_if = !!/*point*/ ctx[0].right && Math.abs(/*point*/ ctx[0].right / 10000) >= 0.0001 && (!/*isInverted*/ ctx[1] && /*point*/ ctx[0].right < 0 || /*isInverted*/ ctx[1] && /*point*/ ctx[0].right > 0);

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block$B(ctx);
    					if_block1.c();
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (tooltip_action && is_function(tooltip_action.update) && dirty & /*tooltipOptions*/ 16) tooltip_action.update.call(null, /*tooltipOptions*/ ctx[4]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1Z($$self, $$props, $$invalidate) {
    	let { point } = $$props;
    	let { min } = $$props;
    	let { max } = $$props;
    	let { isInverted } = $$props;
    	let leftValue;
    	let rightValue;
    	let tooltipOptions;

    	function updateTooltip() {
    		$$invalidate(4, tooltipOptions = {
    			content: {
    				component: GraphTooltip,
    				data: point.tooltip ? point : null
    			},
    			side: "left"
    		});
    	}

    	function updateValues() {
    		if (!!point.left) $$invalidate(2, leftValue = -(1 - Math.abs(point.left / min)) * 100);

    		if (!!point.right) {
    			$$invalidate(3, rightValue = -(1 - Math.abs(point.right / min)) * 100);
    		}
    	}

    	const writable_props = ["point", "min", "max", "isInverted"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BarChartComparison> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("BarChartComparison", $$slots, []);

    	$$self.$set = $$props => {
    		if ("point" in $$props) $$invalidate(0, point = $$props.point);
    		if ("min" in $$props) $$invalidate(5, min = $$props.min);
    		if ("max" in $$props) $$invalidate(6, max = $$props.max);
    		if ("isInverted" in $$props) $$invalidate(1, isInverted = $$props.isInverted);
    	};

    	$$self.$capture_state = () => ({
    		tooltip,
    		GraphTooltip,
    		point,
    		min,
    		max,
    		isInverted,
    		leftValue,
    		rightValue,
    		tooltipOptions,
    		updateTooltip,
    		updateValues
    	});

    	$$self.$inject_state = $$props => {
    		if ("point" in $$props) $$invalidate(0, point = $$props.point);
    		if ("min" in $$props) $$invalidate(5, min = $$props.min);
    		if ("max" in $$props) $$invalidate(6, max = $$props.max);
    		if ("isInverted" in $$props) $$invalidate(1, isInverted = $$props.isInverted);
    		if ("leftValue" in $$props) $$invalidate(2, leftValue = $$props.leftValue);
    		if ("rightValue" in $$props) $$invalidate(3, rightValue = $$props.rightValue);
    		if ("tooltipOptions" in $$props) $$invalidate(4, tooltipOptions = $$props.tooltipOptions);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*point*/ 1) {
    			 updateTooltip();
    		}

    		if ($$self.$$.dirty & /*point, min, max*/ 97) {
    			 updateValues();
    		}
    	};

    	return [point, isInverted, leftValue, rightValue, tooltipOptions, min, max];
    }

    class BarChartComparison extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1Z, create_fragment$1Z, safe_not_equal, { point: 0, min: 5, max: 6, isInverted: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BarChartComparison",
    			options,
    			id: create_fragment$1Z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*point*/ ctx[0] === undefined && !("point" in props)) {
    			console.warn("<BarChartComparison> was created without expected prop 'point'");
    		}

    		if (/*min*/ ctx[5] === undefined && !("min" in props)) {
    			console.warn("<BarChartComparison> was created without expected prop 'min'");
    		}

    		if (/*max*/ ctx[6] === undefined && !("max" in props)) {
    			console.warn("<BarChartComparison> was created without expected prop 'max'");
    		}

    		if (/*isInverted*/ ctx[1] === undefined && !("isInverted" in props)) {
    			console.warn("<BarChartComparison> was created without expected prop 'isInverted'");
    		}
    	}

    	get point() {
    		throw new Error("<BarChartComparison>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set point(value) {
    		throw new Error("<BarChartComparison>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<BarChartComparison>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<BarChartComparison>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<BarChartComparison>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<BarChartComparison>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isInverted() {
    		throw new Error("<BarChartComparison>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isInverted(value) {
    		throw new Error("<BarChartComparison>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/barChart/BarChart.svelte generated by Svelte v3.24.0 */
    const file$1H = "src/js/components/barChart/BarChart.svelte";

    function get_each_context$q(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[16] = list[i];
    	return child_ctx;
    }

    // (81:4) {#each fragment as point}
    function create_each_block$q(ctx) {
    	let barchartcomparison;
    	let current;

    	barchartcomparison = new BarChartComparison({
    			props: {
    				isInverted: /*isInverted*/ ctx[3],
    				point: /*point*/ ctx[16],
    				min: /*min*/ ctx[4],
    				max: /*max*/ ctx[6]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(barchartcomparison.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(barchartcomparison, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const barchartcomparison_changes = {};
    			if (dirty & /*isInverted*/ 8) barchartcomparison_changes.isInverted = /*isInverted*/ ctx[3];
    			if (dirty & /*fragment*/ 32) barchartcomparison_changes.point = /*point*/ ctx[16];
    			if (dirty & /*min*/ 16) barchartcomparison_changes.min = /*min*/ ctx[4];
    			barchartcomparison.$set(barchartcomparison_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(barchartcomparison.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(barchartcomparison.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(barchartcomparison, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$q.name,
    		type: "each",
    		source: "(81:4) {#each fragment as point}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1_(ctx) {
    	let div;
    	let current;
    	let each_value = /*fragment*/ ctx[5];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$q(get_each_context$q(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-barChart");
    			toggle_class(div, "txcm-barChart-is-scrollable", /*checkScroll*/ ctx[7](/*data*/ ctx[0], /*count*/ ctx[1]));
    			toggle_class(div, "txcm-barChart-is-atLimit", /*checkLimit*/ ctx[8](/*data*/ ctx[0], /*step*/ ctx[2], /*count*/ ctx[1]));
    			add_location(div, file$1H, 76, 0, 2971);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*isInverted, fragment, min, max*/ 120) {
    				each_value = /*fragment*/ ctx[5];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$q(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$q(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*checkScroll, data, count*/ 131) {
    				toggle_class(div, "txcm-barChart-is-scrollable", /*checkScroll*/ ctx[7](/*data*/ ctx[0], /*count*/ ctx[1]));
    			}

    			if (dirty & /*checkLimit, data, step, count*/ 263) {
    				toggle_class(div, "txcm-barChart-is-atLimit", /*checkLimit*/ ctx[8](/*data*/ ctx[0], /*step*/ ctx[2], /*count*/ ctx[1]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1_($$self, $$props, $$invalidate) {
    	const dynamics = getGraphsState("dynamics");
    	let { data } = $$props;
    	let { count } = $$props;
    	let { step } = $$props;
    	let { indicator } = $$props;
    	let { isInverted } = $$props;
    	let min;
    	let max;
    	let points;
    	let fragment;

    	function calculateLimits() {
    		const indexes = [4, 2];

    		if (!isInverted) {
    			const valuesLeft = data[indexes[1]]
    			? data[indexes[1]].data.map(item => item.data < 0 ? item.data : 0)
    			: [0];

    			const valuesRight = data[indexes[0]]
    			? data[indexes[0]].data.map(item => item.data < 0 ? item.data : 0)
    			: [0];

    			$$invalidate(4, min = Math.min(...valuesLeft, ...valuesRight) * 10000);
    		} else {
    			const valuesLeft = data[indexes[1]]
    			? data[indexes[1]].data.map(item => item.data > 0 ? item.data : 0)
    			: [0];

    			const valuesRight = data[indexes[0]]
    			? data[indexes[0]].data.map(item => item.data > 0 ? item.data : 0)
    			: [0];

    			$$invalidate(4, min = Math.max(...valuesLeft, ...valuesRight) * 10000);
    		}
    	}

    	function zipPoints() {
    		return data[0].data.reduce(
    			(result, point, index) => {
    				result.push({
    					tooltip: true,
    					name: point.name,
    					year: parseInt(point.name.slice(0, 4)),
    					month: parseInt(point.name.slice(4, 6)),
    					day: parseInt(point.name.slice(6, 8)),
    					fact: point.text,
    					vsPp: data[1]
    					? data[1].data[index].data !== 0 && data[1].data[index].data !== null
    						? data[1].data[index].text || "-"
    						: "-"
    					: "-",
    					vsPpPercent: data[2]
    					? data[2].data[index].data !== 0 && data[2].data[index].data !== null
    						? data[2].data[index].text || "-"
    						: "-"
    					: "-",
    					vsBudget: data[3]
    					? data[3].data[index].data !== 0 && data[3].data[index].data !== null
    						? data[3].data[index].text || "-"
    						: "-"
    					: "-",
    					vsBudgetPercent: data[4]
    					? data[4].data[index].data !== 0 && data[4].data[index].data !== null
    						? data[4].data[index].text || "-"
    						: "-"
    					: "-",
    					left: data[2]
    					? data[2].data[index].data !== null && !isNaN(data[2].data[index].data)
    						? data[2].data[index].data * 10000
    						: null
    					: null,
    					right: data[4]
    					? data[4].data[index].data !== null && !isNaN(data[4].data[index].data)
    						? data[4].data[index].data * 10000
    						: null
    					: null,
    					deviations: data.length > 3
    					? data[0].data[index].data !== null && data[3].data[index].data !== null && data[3].data[index].data > data[0].data[index].data
    					: undefined
    				});

    				return result;
    			},
    			[]
    		);
    	}

    	function updateCharts() {
    		$$invalidate(5, fragment = points.slice(step, step + count + 1));
    	}

    	function updatePoints() {
    		$$invalidate(10, points = zipPoints());
    	}

    	function checkScroll() {
    		return data[0].data.length > count;
    	}

    	function checkLimit() {
    		return step === data[0].data.length - count;
    	}

    	const writable_props = ["data", "count", "step", "indicator", "isInverted"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BarChart> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("BarChart", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("count" in $$props) $$invalidate(1, count = $$props.count);
    		if ("step" in $$props) $$invalidate(2, step = $$props.step);
    		if ("indicator" in $$props) $$invalidate(9, indicator = $$props.indicator);
    		if ("isInverted" in $$props) $$invalidate(3, isInverted = $$props.isInverted);
    	};

    	$$self.$capture_state = () => ({
    		BarChartComparison,
    		getGraphsState,
    		renderMonthShort,
    		dynamics,
    		data,
    		count,
    		step,
    		indicator,
    		isInverted,
    		min,
    		max,
    		points,
    		fragment,
    		calculateLimits,
    		zipPoints,
    		updateCharts,
    		updatePoints,
    		checkScroll,
    		checkLimit
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("count" in $$props) $$invalidate(1, count = $$props.count);
    		if ("step" in $$props) $$invalidate(2, step = $$props.step);
    		if ("indicator" in $$props) $$invalidate(9, indicator = $$props.indicator);
    		if ("isInverted" in $$props) $$invalidate(3, isInverted = $$props.isInverted);
    		if ("min" in $$props) $$invalidate(4, min = $$props.min);
    		if ("max" in $$props) $$invalidate(6, max = $$props.max);
    		if ("points" in $$props) $$invalidate(10, points = $$props.points);
    		if ("fragment" in $$props) $$invalidate(5, fragment = $$props.fragment);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data, indicator*/ 513) {
    			 updatePoints();
    		}

    		if ($$self.$$.dirty & /*points, step, count*/ 1030) {
    			 updateCharts();
    		}

    		if ($$self.$$.dirty & /*data*/ 1) {
    			 calculateLimits();
    		}
    	};

    	return [
    		data,
    		count,
    		step,
    		isInverted,
    		min,
    		fragment,
    		max,
    		checkScroll,
    		checkLimit,
    		indicator
    	];
    }

    class BarChart extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1_, create_fragment$1_, safe_not_equal, {
    			data: 0,
    			count: 1,
    			step: 2,
    			indicator: 9,
    			isInverted: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BarChart",
    			options,
    			id: create_fragment$1_.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<BarChart> was created without expected prop 'data'");
    		}

    		if (/*count*/ ctx[1] === undefined && !("count" in props)) {
    			console.warn("<BarChart> was created without expected prop 'count'");
    		}

    		if (/*step*/ ctx[2] === undefined && !("step" in props)) {
    			console.warn("<BarChart> was created without expected prop 'step'");
    		}

    		if (/*indicator*/ ctx[9] === undefined && !("indicator" in props)) {
    			console.warn("<BarChart> was created without expected prop 'indicator'");
    		}

    		if (/*isInverted*/ ctx[3] === undefined && !("isInverted" in props)) {
    			console.warn("<BarChart> was created without expected prop 'isInverted'");
    		}
    	}

    	get data() {
    		throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get step() {
    		throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set step(value) {
    		throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isInverted() {
    		throw new Error("<BarChart>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isInverted(value) {
    		throw new Error("<BarChart>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comboBarGraph/ComboBarTooltip.svelte generated by Svelte v3.24.0 */
    const file$1I = "src/js/components/comboBarGraph/ComboBarTooltip.svelte";

    function create_fragment$1$(ctx) {
    	let table;
    	let tr0;
    	let th0;
    	let int0;
    	let t0;
    	let td0;

    	let t1_value = (/*data*/ ctx[0][0]
    	? formatLabel(/*data*/ ctx[0][0].point, "%", "%")
    	: "-") + "";

    	let t1;
    	let t2;
    	let tr1;
    	let th1;
    	let int1;
    	let t3;
    	let td1;

    	let t4_value = (/*data*/ ctx[0][1]
    	? formatLabel(/*data*/ ctx[0][1].point, "%", "%")
    	: "-") + "";

    	let t4;
    	let t5;
    	let tr2;
    	let th2;
    	let int2;
    	let t6;
    	let td2;

    	let t7_value = (/*data*/ ctx[0][2]
    	? formatLabel(/*data*/ ctx[0][2].point, "%", "%")
    	: "-") + "";

    	let t7;
    	let t8;
    	let tr3;
    	let th3;
    	let int3;
    	let t9;
    	let td3;

    	let t10_value = (/*data*/ ctx[0][3]
    	? formatLabel(/*data*/ ctx[0][3].point, "%", "%")
    	: "-") + "";

    	let t10;
    	let t11;
    	let tr4;
    	let th4;
    	let int4;
    	let t12;
    	let td4;

    	let t13_value = (/*data*/ ctx[0][4]
    	? formatLabel(/*data*/ ctx[0][4].point, "%", "%")
    	: "-") + "";

    	let t13;
    	let current;

    	int0 = new Int({
    			props: { key: "Влияние товарно-ценовой MIX'a" },
    			$$inline: true
    		});

    	int1 = new Int({
    			props: { key: "Влияние комплексности" },
    			$$inline: true
    		});

    	int2 = new Int({
    			props: { key: "Влияние динамики нерегулярных цен" },
    			$$inline: true
    		});

    	int3 = new Int({
    			props: { key: "Влияние инфляции розничных цен, %" },
    			$$inline: true
    		});

    	int4 = new Int({
    			props: { key: "Влияние товаров лояльности, %" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			table = element("table");
    			tr0 = element("tr");
    			th0 = element("th");
    			create_component(int0.$$.fragment);
    			t0 = space();
    			td0 = element("td");
    			t1 = text(t1_value);
    			t2 = space();
    			tr1 = element("tr");
    			th1 = element("th");
    			create_component(int1.$$.fragment);
    			t3 = space();
    			td1 = element("td");
    			t4 = text(t4_value);
    			t5 = space();
    			tr2 = element("tr");
    			th2 = element("th");
    			create_component(int2.$$.fragment);
    			t6 = space();
    			td2 = element("td");
    			t7 = text(t7_value);
    			t8 = space();
    			tr3 = element("tr");
    			th3 = element("th");
    			create_component(int3.$$.fragment);
    			t9 = space();
    			td3 = element("td");
    			t10 = text(t10_value);
    			t11 = space();
    			tr4 = element("tr");
    			th4 = element("th");
    			create_component(int4.$$.fragment);
    			t12 = space();
    			td4 = element("td");
    			t13 = text(t13_value);
    			attr_dev(th0, "class", "txcm-comboBarTooltipRowHeader txcm-comboBarTooltipRowHeader-bar1");
    			add_location(th0, file$1I, 10, 4, 240);
    			attr_dev(td0, "class", "txcm-comboBarTooltipRowCell");
    			add_location(td0, file$1I, 13, 4, 381);
    			attr_dev(tr0, "class", "txcm-graphTooltipRow");
    			add_location(tr0, file$1I, 9, 2, 201);
    			attr_dev(th1, "class", "txcm-comboBarTooltipRowHeader txcm-comboBarTooltipRowHeader-bar2");
    			add_location(th1, file$1I, 18, 4, 541);
    			attr_dev(td1, "class", "txcm-comboBarTooltipRowCell");
    			add_location(td1, file$1I, 21, 4, 674);
    			attr_dev(tr1, "class", "txcm-graphTooltipRow");
    			add_location(tr1, file$1I, 17, 2, 503);
    			attr_dev(th2, "class", "txcm-comboBarTooltipRowHeader txcm-comboBarTooltipRowHeader-bar3");
    			add_location(th2, file$1I, 26, 4, 834);
    			attr_dev(td2, "class", "txcm-comboBarTooltipRowCell");
    			add_location(td2, file$1I, 29, 4, 979);
    			attr_dev(tr2, "class", "txcm-graphTooltipRow");
    			add_location(tr2, file$1I, 25, 2, 796);
    			attr_dev(th3, "class", "txcm-comboBarTooltipRowHeader txcm-comboBarTooltipRowHeader-bar4");
    			add_location(th3, file$1I, 34, 4, 1139);
    			attr_dev(td3, "class", "txcm-comboBarTooltipRowCell");
    			add_location(td3, file$1I, 37, 4, 1284);
    			attr_dev(tr3, "class", "txcm-graphTooltipRow");
    			add_location(tr3, file$1I, 33, 2, 1101);
    			attr_dev(th4, "class", "txcm-comboBarTooltipRowHeader txcm-comboBarTooltipRowHeader-bar5");
    			add_location(th4, file$1I, 42, 4, 1444);
    			attr_dev(td4, "class", "txcm-comboBarTooltipRowCell");
    			add_location(td4, file$1I, 45, 4, 1585);
    			attr_dev(tr4, "class", "txcm-graphTooltipRow");
    			add_location(tr4, file$1I, 41, 2, 1406);
    			attr_dev(table, "class", "txcm-comboBarTooltip");
    			add_location(table, file$1I, 8, 0, 162);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, table, anchor);
    			append_dev(table, tr0);
    			append_dev(tr0, th0);
    			mount_component(int0, th0, null);
    			append_dev(tr0, t0);
    			append_dev(tr0, td0);
    			append_dev(td0, t1);
    			append_dev(table, t2);
    			append_dev(table, tr1);
    			append_dev(tr1, th1);
    			mount_component(int1, th1, null);
    			append_dev(tr1, t3);
    			append_dev(tr1, td1);
    			append_dev(td1, t4);
    			append_dev(table, t5);
    			append_dev(table, tr2);
    			append_dev(tr2, th2);
    			mount_component(int2, th2, null);
    			append_dev(tr2, t6);
    			append_dev(tr2, td2);
    			append_dev(td2, t7);
    			append_dev(table, t8);
    			append_dev(table, tr3);
    			append_dev(tr3, th3);
    			mount_component(int3, th3, null);
    			append_dev(tr3, t9);
    			append_dev(tr3, td3);
    			append_dev(td3, t10);
    			append_dev(table, t11);
    			append_dev(table, tr4);
    			append_dev(tr4, th4);
    			mount_component(int4, th4, null);
    			append_dev(tr4, t12);
    			append_dev(tr4, td4);
    			append_dev(td4, t13);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*data*/ 1) && t1_value !== (t1_value = (/*data*/ ctx[0][0]
    			? formatLabel(/*data*/ ctx[0][0].point, "%", "%")
    			: "-") + "")) set_data_dev(t1, t1_value);

    			if ((!current || dirty & /*data*/ 1) && t4_value !== (t4_value = (/*data*/ ctx[0][1]
    			? formatLabel(/*data*/ ctx[0][1].point, "%", "%")
    			: "-") + "")) set_data_dev(t4, t4_value);

    			if ((!current || dirty & /*data*/ 1) && t7_value !== (t7_value = (/*data*/ ctx[0][2]
    			? formatLabel(/*data*/ ctx[0][2].point, "%", "%")
    			: "-") + "")) set_data_dev(t7, t7_value);

    			if ((!current || dirty & /*data*/ 1) && t10_value !== (t10_value = (/*data*/ ctx[0][3]
    			? formatLabel(/*data*/ ctx[0][3].point, "%", "%")
    			: "-") + "")) set_data_dev(t10, t10_value);

    			if ((!current || dirty & /*data*/ 1) && t13_value !== (t13_value = (/*data*/ ctx[0][4]
    			? formatLabel(/*data*/ ctx[0][4].point, "%", "%")
    			: "-") + "")) set_data_dev(t13, t13_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			transition_in(int2.$$.fragment, local);
    			transition_in(int3.$$.fragment, local);
    			transition_in(int4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			transition_out(int2.$$.fragment, local);
    			transition_out(int3.$$.fragment, local);
    			transition_out(int4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(table);
    			destroy_component(int0);
    			destroy_component(int1);
    			destroy_component(int2);
    			destroy_component(int3);
    			destroy_component(int4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1$($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComboBarTooltip> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComboBarTooltip", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({ formatLabel, Int, data });

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [data];
    }

    class ComboBarTooltip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1$, create_fragment$1$, safe_not_equal, { data: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComboBarTooltip",
    			options,
    			id: create_fragment$1$.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<ComboBarTooltip> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<ComboBarTooltip>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<ComboBarTooltip>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comboBarGraph/ComboBar.svelte generated by Svelte v3.24.0 */
    const file$1J = "src/js/components/comboBarGraph/ComboBar.svelte";

    function get_each_context$r(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	return child_ctx;
    }

    // (67:4) {#if bar !== null}
    function create_if_block$C(ctx) {
    	let rect;
    	let rect_x_value;
    	let rect_y_value;
    	let rect_width_value;
    	let rect_height_value;

    	const block = {
    		c: function create() {
    			rect = svg_element("rect");
    			attr_dev(rect, "class", "txcm-comboBar");
    			attr_dev(rect, "x", rect_x_value = /*bar*/ ctx[17].x);
    			attr_dev(rect, "y", rect_y_value = /*bar*/ ctx[17].y);
    			attr_dev(rect, "width", rect_width_value = 15);
    			attr_dev(rect, "height", rect_height_value = /*bar*/ ctx[17].height);
    			set_style(rect, "--theme-color", /*bar*/ ctx[17].color);
    			attr_dev(rect, "transform", /*transform*/ ctx[2]);
    			add_location(rect, file$1J, 67, 6, 1679);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, rect, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bars*/ 1 && rect_x_value !== (rect_x_value = /*bar*/ ctx[17].x)) {
    				attr_dev(rect, "x", rect_x_value);
    			}

    			if (dirty & /*bars*/ 1 && rect_y_value !== (rect_y_value = /*bar*/ ctx[17].y)) {
    				attr_dev(rect, "y", rect_y_value);
    			}

    			if (dirty & /*bars*/ 1 && rect_height_value !== (rect_height_value = /*bar*/ ctx[17].height)) {
    				attr_dev(rect, "height", rect_height_value);
    			}

    			if (dirty & /*bars*/ 1) {
    				set_style(rect, "--theme-color", /*bar*/ ctx[17].color);
    			}

    			if (dirty & /*transform*/ 4) {
    				attr_dev(rect, "transform", /*transform*/ ctx[2]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(rect);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$C.name,
    		type: "if",
    		source: "(67:4) {#if bar !== null}",
    		ctx
    	});

    	return block;
    }

    // (66:2) {#each bars as bar}
    function create_each_block$r(ctx) {
    	let if_block_anchor;
    	let if_block = /*bar*/ ctx[17] !== null && create_if_block$C(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*bar*/ ctx[17] !== null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$C(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$r.name,
    		type: "each",
    		source: "(66:2) {#each bars as bar}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$20(ctx) {
    	let g;
    	let tooltip_action;
    	let mounted;
    	let dispose;
    	let each_value = /*bars*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$r(get_each_context$r(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			g = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(g, file$1J, 64, 0, 1595);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g, null);
    			}

    			if (!mounted) {
    				dispose = action_destroyer(tooltip_action = tooltip.call(null, g, /*tooltipOptions*/ ctx[1]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*bars, transform*/ 5) {
    				each_value = /*bars*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$r(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$r(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (tooltip_action && is_function(tooltip_action.update) && dirty & /*tooltipOptions*/ 2) tooltip_action.update.call(null, /*tooltipOptions*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$20.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$20($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { index } = $$props;
    	let { min } = $$props;
    	let { max } = $$props;
    	let { count } = $$props;
    	let { shift } = $$props;
    	let { height } = $$props;
    	let { padding } = $$props;
    	let bars = [];
    	let colors = ["#57599C", "#F4C856", "#E36735", "#5D86C0", "#9D4B99", "#5BAFD4"];
    	let tooltipOptions;

    	async function clearBars() {
    		$$invalidate(0, bars = []);
    		await tick();
    	}

    	async function calculatePosition() {
    		await clearBars();
    		const x = renderPointX(index, count, 6 / 20);
    		const mid = renderPointY(0, min, max, height, padding);

    		$$invalidate(0, bars = data.map(item => {
    			const y = renderPointY(item.point || 0, min, max, height, padding);

    			return item.point
    			? {
    					x,
    					y: item.point > 0 ? y : mid,
    					height: item.point > 0 ? mid - y : y - mid,
    					color: colors[item.index - 1]
    				}
    			: null;
    		}));
    	}

    	function calculateTransform() {
    		return `translate(${shift} 0)`;
    	}

    	function updateTooltipData() {
    		if (!data) return null;
    		return data.slice().sort((a, b) => a.index - b.index);
    	}

    	function updateTooltip() {
    		$$invalidate(1, tooltipOptions = {
    			content: {
    				component: ComboBarTooltip,
    				data: updateTooltipData()
    			},
    			side: "left"
    		});
    	}

    	const writable_props = ["data", "index", "min", "max", "count", "shift", "height", "padding"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComboBar> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComboBar", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("index" in $$props) $$invalidate(4, index = $$props.index);
    		if ("min" in $$props) $$invalidate(5, min = $$props.min);
    		if ("max" in $$props) $$invalidate(6, max = $$props.max);
    		if ("count" in $$props) $$invalidate(7, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(8, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(9, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(10, padding = $$props.padding);
    	};

    	$$self.$capture_state = () => ({
    		tick,
    		tooltip,
    		renderPointX,
    		renderPointY,
    		ComboBarTooltip,
    		data,
    		index,
    		min,
    		max,
    		count,
    		shift,
    		height,
    		padding,
    		bars,
    		colors,
    		tooltipOptions,
    		clearBars,
    		calculatePosition,
    		calculateTransform,
    		updateTooltipData,
    		updateTooltip,
    		transform
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("index" in $$props) $$invalidate(4, index = $$props.index);
    		if ("min" in $$props) $$invalidate(5, min = $$props.min);
    		if ("max" in $$props) $$invalidate(6, max = $$props.max);
    		if ("count" in $$props) $$invalidate(7, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(8, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(9, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(10, padding = $$props.padding);
    		if ("bars" in $$props) $$invalidate(0, bars = $$props.bars);
    		if ("colors" in $$props) colors = $$props.colors;
    		if ("tooltipOptions" in $$props) $$invalidate(1, tooltipOptions = $$props.tooltipOptions);
    		if ("transform" in $$props) $$invalidate(2, transform = $$props.transform);
    	};

    	let transform;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*shift*/ 256) {
    			 $$invalidate(2, transform = calculateTransform());
    		}

    		if ($$self.$$.dirty & /*data, min, max, count*/ 232) {
    			 calculatePosition();
    		}

    		if ($$self.$$.dirty & /*data*/ 8) {
    			 updateTooltip();
    		}
    	};

    	return [
    		bars,
    		tooltipOptions,
    		transform,
    		data,
    		index,
    		min,
    		max,
    		count,
    		shift,
    		height,
    		padding
    	];
    }

    class ComboBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$20, create_fragment$20, safe_not_equal, {
    			data: 3,
    			index: 4,
    			min: 5,
    			max: 6,
    			count: 7,
    			shift: 8,
    			height: 9,
    			padding: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComboBar",
    			options,
    			id: create_fragment$20.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[3] === undefined && !("data" in props)) {
    			console.warn("<ComboBar> was created without expected prop 'data'");
    		}

    		if (/*index*/ ctx[4] === undefined && !("index" in props)) {
    			console.warn("<ComboBar> was created without expected prop 'index'");
    		}

    		if (/*min*/ ctx[5] === undefined && !("min" in props)) {
    			console.warn("<ComboBar> was created without expected prop 'min'");
    		}

    		if (/*max*/ ctx[6] === undefined && !("max" in props)) {
    			console.warn("<ComboBar> was created without expected prop 'max'");
    		}

    		if (/*count*/ ctx[7] === undefined && !("count" in props)) {
    			console.warn("<ComboBar> was created without expected prop 'count'");
    		}

    		if (/*shift*/ ctx[8] === undefined && !("shift" in props)) {
    			console.warn("<ComboBar> was created without expected prop 'shift'");
    		}

    		if (/*height*/ ctx[9] === undefined && !("height" in props)) {
    			console.warn("<ComboBar> was created without expected prop 'height'");
    		}

    		if (/*padding*/ ctx[10] === undefined && !("padding" in props)) {
    			console.warn("<ComboBar> was created without expected prop 'padding'");
    		}
    	}

    	get data() {
    		throw new Error("<ComboBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<ComboBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<ComboBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<ComboBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<ComboBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<ComboBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<ComboBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<ComboBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<ComboBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<ComboBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shift() {
    		throw new Error("<ComboBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shift(value) {
    		throw new Error("<ComboBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<ComboBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<ComboBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<ComboBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<ComboBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comboBarGraph/ComboBars.svelte generated by Svelte v3.24.0 */

    function get_each_context$s(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (14:2) {#if point}
    function create_if_block$D(ctx) {
    	let combobar;
    	let current;

    	combobar = new ComboBar({
    			props: {
    				count: /*count*/ ctx[3],
    				shift: /*shift*/ ctx[4],
    				height: /*height*/ ctx[5],
    				padding: /*padding*/ ctx[6],
    				index: /*index*/ ctx[9],
    				min: /*min*/ ctx[1],
    				max: /*max*/ ctx[2],
    				data: /*point*/ ctx[7]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(combobar.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(combobar, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const combobar_changes = {};
    			if (dirty & /*count*/ 8) combobar_changes.count = /*count*/ ctx[3];
    			if (dirty & /*shift*/ 16) combobar_changes.shift = /*shift*/ ctx[4];
    			if (dirty & /*height*/ 32) combobar_changes.height = /*height*/ ctx[5];
    			if (dirty & /*padding*/ 64) combobar_changes.padding = /*padding*/ ctx[6];
    			if (dirty & /*min*/ 2) combobar_changes.min = /*min*/ ctx[1];
    			if (dirty & /*max*/ 4) combobar_changes.max = /*max*/ ctx[2];
    			if (dirty & /*points*/ 1) combobar_changes.data = /*point*/ ctx[7];
    			combobar.$set(combobar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(combobar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(combobar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(combobar, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$D.name,
    		type: "if",
    		source: "(14:2) {#if point}",
    		ctx
    	});

    	return block;
    }

    // (13:0) {#each points as point, index}
    function create_each_block$s(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*point*/ ctx[7] && create_if_block$D(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*point*/ ctx[7]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*points*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$D(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$s.name,
    		type: "each",
    		source: "(13:0) {#each points as point, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$21(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*points*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$s(get_each_context$s(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*count, shift, height, padding, min, max, points*/ 127) {
    				each_value = /*points*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$s(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$s(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$21.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$21($$self, $$props, $$invalidate) {
    	let { points } = $$props;
    	let { min } = $$props;
    	let { max } = $$props;
    	let { count } = $$props;
    	let { shift } = $$props;
    	let { height } = $$props;
    	let { padding } = $$props;
    	const writable_props = ["points", "min", "max", "count", "shift", "height", "padding"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComboBars> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComboBars", $$slots, []);

    	$$self.$set = $$props => {
    		if ("points" in $$props) $$invalidate(0, points = $$props.points);
    		if ("min" in $$props) $$invalidate(1, min = $$props.min);
    		if ("max" in $$props) $$invalidate(2, max = $$props.max);
    		if ("count" in $$props) $$invalidate(3, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(4, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(5, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(6, padding = $$props.padding);
    	};

    	$$self.$capture_state = () => ({
    		ComboBar,
    		points,
    		min,
    		max,
    		count,
    		shift,
    		height,
    		padding
    	});

    	$$self.$inject_state = $$props => {
    		if ("points" in $$props) $$invalidate(0, points = $$props.points);
    		if ("min" in $$props) $$invalidate(1, min = $$props.min);
    		if ("max" in $$props) $$invalidate(2, max = $$props.max);
    		if ("count" in $$props) $$invalidate(3, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(4, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(5, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(6, padding = $$props.padding);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [points, min, max, count, shift, height, padding];
    }

    class ComboBars extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$21, create_fragment$21, safe_not_equal, {
    			points: 0,
    			min: 1,
    			max: 2,
    			count: 3,
    			shift: 4,
    			height: 5,
    			padding: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComboBars",
    			options,
    			id: create_fragment$21.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*points*/ ctx[0] === undefined && !("points" in props)) {
    			console.warn("<ComboBars> was created without expected prop 'points'");
    		}

    		if (/*min*/ ctx[1] === undefined && !("min" in props)) {
    			console.warn("<ComboBars> was created without expected prop 'min'");
    		}

    		if (/*max*/ ctx[2] === undefined && !("max" in props)) {
    			console.warn("<ComboBars> was created without expected prop 'max'");
    		}

    		if (/*count*/ ctx[3] === undefined && !("count" in props)) {
    			console.warn("<ComboBars> was created without expected prop 'count'");
    		}

    		if (/*shift*/ ctx[4] === undefined && !("shift" in props)) {
    			console.warn("<ComboBars> was created without expected prop 'shift'");
    		}

    		if (/*height*/ ctx[5] === undefined && !("height" in props)) {
    			console.warn("<ComboBars> was created without expected prop 'height'");
    		}

    		if (/*padding*/ ctx[6] === undefined && !("padding" in props)) {
    			console.warn("<ComboBars> was created without expected prop 'padding'");
    		}
    	}

    	get points() {
    		throw new Error("<ComboBars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set points(value) {
    		throw new Error("<ComboBars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<ComboBars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<ComboBars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<ComboBars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<ComboBars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<ComboBars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<ComboBars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shift() {
    		throw new Error("<ComboBars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shift(value) {
    		throw new Error("<ComboBars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<ComboBars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<ComboBars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<ComboBars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<ComboBars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comboBarGraph/ComboBarGraph.svelte generated by Svelte v3.24.0 */
    const file$1K = "src/js/components/comboBarGraph/ComboBarGraph.svelte";

    function create_fragment$22(ctx) {
    	let linegraphlabels;
    	let t;
    	let div;
    	let svg;
    	let linegraphaxes;
    	let combobars;
    	let current;
    	let mounted;
    	let dispose;

    	linegraphlabels = new LineGraphLabels({
    			props: {
    				units: /*units*/ ctx[4],
    				min: /*min*/ ctx[5],
    				max: /*max*/ ctx[6],
    				indicator: /*indicator*/ ctx[0]
    			},
    			$$inline: true
    		});

    	linegraphaxes = new LineGraphAxes({
    			props: { padding: /*padding*/ ctx[3] },
    			$$inline: true
    		});

    	combobars = new ComboBars({
    			props: {
    				count: /*count*/ ctx[1],
    				shift: /*shift*/ ctx[2],
    				height: /*height*/ ctx[10],
    				padding: /*padding*/ ctx[3],
    				min: /*min*/ ctx[5],
    				max: /*max*/ ctx[6],
    				points: /*points*/ ctx[7]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(linegraphlabels.$$.fragment);
    			t = space();
    			div = element("div");
    			svg = svg_element("svg");
    			create_component(linegraphaxes.$$.fragment);
    			create_component(combobars.$$.fragment);
    			attr_dev(svg, "class", "txcm-lineGraph");
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", /*height*/ ctx[10]);
    			toggle_class(svg, "txcm-lineGraph-is-compact", false);
    			add_location(svg, file$1K, 131, 4, 3607);
    			attr_dev(div, "class", "txcm-lineGraphHolder");
    			add_location(div, file$1K, 126, 0, 3399);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(linegraphlabels, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			mount_component(linegraphaxes, svg, null);
    			mount_component(combobars, svg, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "click", stop_propagation(prevent_default(/*click_handler*/ ctx[14])), false, true, true),
    					listen_dev(div, "mousedown", stop_propagation(prevent_default(/*onPointerDown*/ ctx[11])), false, true, true),
    					listen_dev(div, "touchstart", stop_propagation(prevent_default(/*onPointerDown*/ ctx[11])), false, true, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const linegraphlabels_changes = {};
    			if (dirty & /*units*/ 16) linegraphlabels_changes.units = /*units*/ ctx[4];
    			if (dirty & /*min*/ 32) linegraphlabels_changes.min = /*min*/ ctx[5];
    			if (dirty & /*max*/ 64) linegraphlabels_changes.max = /*max*/ ctx[6];
    			if (dirty & /*indicator*/ 1) linegraphlabels_changes.indicator = /*indicator*/ ctx[0];
    			linegraphlabels.$set(linegraphlabels_changes);
    			const linegraphaxes_changes = {};
    			if (dirty & /*padding*/ 8) linegraphaxes_changes.padding = /*padding*/ ctx[3];
    			linegraphaxes.$set(linegraphaxes_changes);
    			const combobars_changes = {};
    			if (dirty & /*count*/ 2) combobars_changes.count = /*count*/ ctx[1];
    			if (dirty & /*shift*/ 4) combobars_changes.shift = /*shift*/ ctx[2];
    			if (dirty & /*padding*/ 8) combobars_changes.padding = /*padding*/ ctx[3];
    			if (dirty & /*min*/ 32) combobars_changes.min = /*min*/ ctx[5];
    			if (dirty & /*max*/ 64) combobars_changes.max = /*max*/ ctx[6];
    			if (dirty & /*points*/ 128) combobars_changes.points = /*points*/ ctx[7];
    			combobars.$set(combobars_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linegraphlabels.$$.fragment, local);
    			transition_in(linegraphaxes.$$.fragment, local);
    			transition_in(combobars.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linegraphlabels.$$.fragment, local);
    			transition_out(linegraphaxes.$$.fragment, local);
    			transition_out(combobars.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(linegraphlabels, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div);
    			destroy_component(linegraphaxes);
    			destroy_component(combobars);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$22.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const DEFAULT_HEIGHT$1 = 82;
    const DEFAULT_PADDING$1 = 10;

    function sortBars(a, b) {
    	return Math.abs(b.point) - Math.abs(a.point);
    }

    function instance$22($$self, $$props, $$invalidate) {
    	let $scroll;
    	let $scrollMax;
    	const scroll = getGraphsState("scroll");
    	validate_store(scroll, "scroll");
    	component_subscribe($$self, scroll, value => $$invalidate(19, $scroll = value));
    	const scrollMax = getGraphsState("scrollMax");
    	validate_store(scrollMax, "scrollMax");
    	component_subscribe($$self, scrollMax, value => $$invalidate(20, $scrollMax = value));
    	let { indicator } = $$props;
    	let { step } = $$props;
    	let { count } = $$props;
    	let { shift } = $$props;
    	let { data } = $$props;
    	let { padding = DEFAULT_PADDING$1 } = $$props;
    	let { units } = $$props;
    	let height = DEFAULT_HEIGHT$1;
    	let min;
    	let max;
    	let points = [];
    	let fragment;
    	let pointer = null;
    	let pointerPositionStart;
    	let pointerScrollStart;
    	let pointerPositionCurrent;

    	function calculateLimits() {
    		if (data.length === 0) return;

    		const values = data.reduce(
    			(result, item, index) => {
    				item.data.forEach(item => item.data && result.push(Math.abs(item.data)));
    				return result;
    			},
    			[]
    		);

    		if (values && values.length) {
    			$$invalidate(6, max = Math.max(...values));
    			$$invalidate(5, min = -max);
    		} else {
    			$$invalidate(5, min = -1);
    			$$invalidate(6, max = 1);
    		}
    	}

    	function zipPoints() {
    		if (data.length === 0) return;

    		return data[0].data.reduce(
    			(result, item, index) => {
    				const bars = [];

    				for (let i = 0; i < 6; ++i) {
    					const bar = {
    						index: i + 1,
    						point: data[i] && data[i].data[index].data !== null && !isNaN(data[i].data[index].data)
    						? data[i].data[index].data
    						: null
    					};

    					bars.push(bar);
    				}

    				bars.sort(sortBars);
    				result.push(bars);
    				return result;
    			},
    			[]
    		);
    	}

    	async function updateCharts() {
    		if (data.length === 0) return;
    		const { length } = data[0];
    		if (!fragment) fragment = zipPoints();
    		if (length <= count) $$invalidate(7, points = fragment.slice()); else $$invalidate(7, points = fragment.slice(step, step + count + 1));
    	}

    	function changeScroll(deltaX) {
    		if (pointerScrollStart + deltaX <= 0) set_store_value(scroll, $scroll = 0); else if (pointerScrollStart + deltaX >= $scrollMax) set_store_value(scroll, $scroll = $scrollMax); else set_store_value(scroll, $scroll = pointerScrollStart + deltaX);
    	}

    	function onPointerMove(event) {
    		pointerPositionCurrent = event.touches ? event.touches[0].clientX : event.clientX;
    		const diff = pointerPositionStart - pointerPositionCurrent;
    		changeScroll(diff);
    	}

    	function onPointerUp(event) {
    		event.preventDefault();
    		event.stopPropagation();
    		unsubscribeWindow();
    	}

    	function subscribeWindow() {
    		window.addEventListener("mousemove", onPointerMove);
    		window.addEventListener("touchmove", onPointerMove);
    		window.addEventListener("mouseup", onPointerUp);
    		window.addEventListener("touchend", onPointerUp);
    	}

    	function unsubscribeWindow() {
    		window.removeEventListener("mousemove", onPointerMove);
    		window.removeEventListener("touchmove", onPointerMove);
    		window.removeEventListener("mouseup", onPointerUp);
    		window.removeEventListener("touchend", onPointerUp);
    	}

    	function onPointerDown(event) {
    		pointerPositionStart = event.touches ? event.touches[0].clientX : event.clientX;
    		pointerScrollStart = $scroll;
    		subscribeWindow();
    	}

    	const writable_props = ["indicator", "step", "count", "shift", "data", "padding", "units"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComboBarGraph> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComboBarGraph", $$slots, []);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("step" in $$props) $$invalidate(12, step = $$props.step);
    		if ("count" in $$props) $$invalidate(1, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(2, shift = $$props.shift);
    		if ("data" in $$props) $$invalidate(13, data = $$props.data);
    		if ("padding" in $$props) $$invalidate(3, padding = $$props.padding);
    		if ("units" in $$props) $$invalidate(4, units = $$props.units);
    	};

    	$$self.$capture_state = () => ({
    		LineGraphAxes,
    		LineGraphLabels,
    		ComboBars,
    		getGraphsState,
    		DEFAULT_HEIGHT: DEFAULT_HEIGHT$1,
    		DEFAULT_PADDING: DEFAULT_PADDING$1,
    		scroll,
    		scrollMax,
    		indicator,
    		step,
    		count,
    		shift,
    		data,
    		padding,
    		units,
    		height,
    		min,
    		max,
    		points,
    		fragment,
    		pointer,
    		pointerPositionStart,
    		pointerScrollStart,
    		pointerPositionCurrent,
    		calculateLimits,
    		sortBars,
    		zipPoints,
    		updateCharts,
    		changeScroll,
    		onPointerMove,
    		onPointerUp,
    		subscribeWindow,
    		unsubscribeWindow,
    		onPointerDown,
    		$scroll,
    		$scrollMax
    	});

    	$$self.$inject_state = $$props => {
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("step" in $$props) $$invalidate(12, step = $$props.step);
    		if ("count" in $$props) $$invalidate(1, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(2, shift = $$props.shift);
    		if ("data" in $$props) $$invalidate(13, data = $$props.data);
    		if ("padding" in $$props) $$invalidate(3, padding = $$props.padding);
    		if ("units" in $$props) $$invalidate(4, units = $$props.units);
    		if ("height" in $$props) $$invalidate(10, height = $$props.height);
    		if ("min" in $$props) $$invalidate(5, min = $$props.min);
    		if ("max" in $$props) $$invalidate(6, max = $$props.max);
    		if ("points" in $$props) $$invalidate(7, points = $$props.points);
    		if ("fragment" in $$props) fragment = $$props.fragment;
    		if ("pointer" in $$props) pointer = $$props.pointer;
    		if ("pointerPositionStart" in $$props) pointerPositionStart = $$props.pointerPositionStart;
    		if ("pointerScrollStart" in $$props) pointerScrollStart = $$props.pointerScrollStart;
    		if ("pointerPositionCurrent" in $$props) pointerPositionCurrent = $$props.pointerPositionCurrent;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 8192) {
    			 calculateLimits();
    		}

    		if ($$self.$$.dirty & /*data, step, count*/ 12290) {
    			 updateCharts();
    		}
    	};

    	return [
    		indicator,
    		count,
    		shift,
    		padding,
    		units,
    		min,
    		max,
    		points,
    		scroll,
    		scrollMax,
    		height,
    		onPointerDown,
    		step,
    		data,
    		click_handler
    	];
    }

    class ComboBarGraph extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$22, create_fragment$22, safe_not_equal, {
    			indicator: 0,
    			step: 12,
    			count: 1,
    			shift: 2,
    			data: 13,
    			padding: 3,
    			units: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComboBarGraph",
    			options,
    			id: create_fragment$22.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*indicator*/ ctx[0] === undefined && !("indicator" in props)) {
    			console.warn("<ComboBarGraph> was created without expected prop 'indicator'");
    		}

    		if (/*step*/ ctx[12] === undefined && !("step" in props)) {
    			console.warn("<ComboBarGraph> was created without expected prop 'step'");
    		}

    		if (/*count*/ ctx[1] === undefined && !("count" in props)) {
    			console.warn("<ComboBarGraph> was created without expected prop 'count'");
    		}

    		if (/*shift*/ ctx[2] === undefined && !("shift" in props)) {
    			console.warn("<ComboBarGraph> was created without expected prop 'shift'");
    		}

    		if (/*data*/ ctx[13] === undefined && !("data" in props)) {
    			console.warn("<ComboBarGraph> was created without expected prop 'data'");
    		}

    		if (/*units*/ ctx[4] === undefined && !("units" in props)) {
    			console.warn("<ComboBarGraph> was created without expected prop 'units'");
    		}
    	}

    	get indicator() {
    		throw new Error("<ComboBarGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<ComboBarGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get step() {
    		throw new Error("<ComboBarGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set step(value) {
    		throw new Error("<ComboBarGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<ComboBarGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<ComboBarGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shift() {
    		throw new Error("<ComboBarGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shift(value) {
    		throw new Error("<ComboBarGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<ComboBarGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<ComboBarGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<ComboBarGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<ComboBarGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<ComboBarGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<ComboBarGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comboBarGraph/ComboBarShowLabel.svelte generated by Svelte v3.24.0 */
    const file$1L = "src/js/components/comboBarGraph/ComboBarShowLabel.svelte";

    // (26:4) {:else}
    function create_else_block$6(ctx) {
    	let int;
    	let current;

    	int = new Int({
    			props: { key: "Скрыть структуру чека" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(int.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(int, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(int, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(26:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (24:4) {#if !extend}
    function create_if_block$E(ctx) {
    	let int;
    	let current;

    	int = new Int({
    			props: { key: "Раскрыть структуру чека" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(int.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(int, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(int, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$E.name,
    		type: "if",
    		source: "(24:4) {#if !extend}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$23(ctx) {
    	let div1;
    	let div0;
    	let svg;
    	let use;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$E, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*extend*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t = space();
    			if_block.c();
    			xlink_attr(use, "xlink:href", "#txspt-icons-angleArrow");
    			add_location(use, file$1L, 20, 8, 467);
    			attr_dev(svg, "class", "txcm-comboBarShowLabelIcon");
    			toggle_class(svg, "txcm-comboBarShowLabelIcon-extended", /*extend*/ ctx[0]);
    			add_location(svg, file$1L, 17, 4, 355);
    			attr_dev(div0, "class", "txcm-comboBarShowLabelText");
    			add_location(div0, file$1L, 16, 2, 287);
    			attr_dev(div1, "class", "txcm-comboBarShowLabel");
    			toggle_class(div1, "txcm-comboBarShowLabel-extended", /*extend*/ ctx[0]);
    			add_location(div1, file$1L, 12, 0, 193);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, svg);
    			append_dev(svg, use);
    			append_dev(div0, t);
    			if_blocks[current_block_type_index].m(div0, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div0, "click", /*handleClick*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*extend*/ 1) {
    				toggle_class(svg, "txcm-comboBarShowLabelIcon-extended", /*extend*/ ctx[0]);
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div0, null);
    			}

    			if (dirty & /*extend*/ 1) {
    				toggle_class(div1, "txcm-comboBarShowLabel-extended", /*extend*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$23.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$23($$self, $$props, $$invalidate) {
    	let { extended } = $$props;
    	let { extend } = $$props;

    	function handleClick() {
    		$$invalidate(2, extended = !extended);
    	}

    	const writable_props = ["extended", "extend"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComboBarShowLabel> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComboBarShowLabel", $$slots, []);

    	$$self.$set = $$props => {
    		if ("extended" in $$props) $$invalidate(2, extended = $$props.extended);
    		if ("extend" in $$props) $$invalidate(0, extend = $$props.extend);
    	};

    	$$self.$capture_state = () => ({ Int, extended, extend, handleClick });

    	$$self.$inject_state = $$props => {
    		if ("extended" in $$props) $$invalidate(2, extended = $$props.extended);
    		if ("extend" in $$props) $$invalidate(0, extend = $$props.extend);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [extend, handleClick, extended];
    }

    class ComboBarShowLabel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$23, create_fragment$23, safe_not_equal, { extended: 2, extend: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComboBarShowLabel",
    			options,
    			id: create_fragment$23.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*extended*/ ctx[2] === undefined && !("extended" in props)) {
    			console.warn("<ComboBarShowLabel> was created without expected prop 'extended'");
    		}

    		if (/*extend*/ ctx[0] === undefined && !("extend" in props)) {
    			console.warn("<ComboBarShowLabel> was created without expected prop 'extend'");
    		}
    	}

    	get extended() {
    		throw new Error("<ComboBarShowLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set extended(value) {
    		throw new Error("<ComboBarShowLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get extend() {
    		throw new Error("<ComboBarShowLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set extend(value) {
    		throw new Error("<ComboBarShowLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comboBarGraphExt/ComboBarGraphExtAxes.svelte generated by Svelte v3.24.0 */

    const file$1M = "src/js/components/comboBarGraphExt/ComboBarGraphExtAxes.svelte";

    function create_fragment$24(ctx) {
    	let line0;
    	let t0;
    	let line1;
    	let t1;
    	let line2;
    	let t2;
    	let line3;
    	let t3;
    	let line4;
    	let t4;
    	let line5;
    	let t5;
    	let line6;
    	let t6;
    	let line7;
    	let t7;
    	let line8;

    	const block = {
    		c: function create() {
    			line0 = svg_element("line");
    			t0 = space();
    			line1 = svg_element("line");
    			t1 = space();
    			line2 = svg_element("line");
    			t2 = space();
    			line3 = svg_element("line");
    			t3 = space();
    			line4 = svg_element("line");
    			t4 = space();
    			line5 = svg_element("line");
    			t5 = space();
    			line6 = svg_element("line");
    			t6 = space();
    			line7 = svg_element("line");
    			t7 = space();
    			line8 = svg_element("line");
    			attr_dev(line0, "class", "txcm-lineGraphAxis");
    			attr_dev(line0, "x1", "0");
    			attr_dev(line0, "y1", "40px");
    			attr_dev(line0, "x2", "100%");
    			attr_dev(line0, "y2", "40px");
    			attr_dev(line0, "transform", "translate(0 0.5)");
    			add_location(line0, file$1M, 3, 0, 20);
    			attr_dev(line1, "class", "txcm-lineGraphAxis");
    			attr_dev(line1, "x1", "0");
    			attr_dev(line1, "y1", "80px");
    			attr_dev(line1, "x2", "100%");
    			attr_dev(line1, "y2", "80px");
    			attr_dev(line1, "transform", "translate(0 0.5)");
    			add_location(line1, file$1M, 10, 0, 135);
    			attr_dev(line2, "class", "txcm-lineGraphAxis");
    			attr_dev(line2, "x1", "0");
    			attr_dev(line2, "y1", "120px");
    			attr_dev(line2, "x2", "100%");
    			attr_dev(line2, "y2", "120px");
    			attr_dev(line2, "transform", "translate(0 0.5)");
    			add_location(line2, file$1M, 17, 0, 250);
    			attr_dev(line3, "class", "txcm-lineGraphAxis");
    			attr_dev(line3, "x1", "0");
    			attr_dev(line3, "y1", "160px");
    			attr_dev(line3, "x2", "100%");
    			attr_dev(line3, "y2", "160px");
    			attr_dev(line3, "transform", "translate(0 0.5)");
    			add_location(line3, file$1M, 24, 0, 366);
    			attr_dev(line4, "class", "txcm-comboBarZeroGraphAxis");
    			attr_dev(line4, "x1", "0");
    			attr_dev(line4, "y1", "200px");
    			attr_dev(line4, "x2", "100%");
    			attr_dev(line4, "y2", "200px");
    			attr_dev(line4, "transform", "translate(0 0.5)");
    			add_location(line4, file$1M, 31, 0, 482);
    			attr_dev(line5, "class", "txcm-lineGraphAxis");
    			attr_dev(line5, "x1", "0");
    			attr_dev(line5, "y1", "240px");
    			attr_dev(line5, "x2", "100%");
    			attr_dev(line5, "y2", "240px");
    			attr_dev(line5, "transform", "translate(0 0.5)");
    			add_location(line5, file$1M, 38, 0, 606);
    			attr_dev(line6, "class", "txcm-lineGraphAxis");
    			attr_dev(line6, "x1", "0");
    			attr_dev(line6, "y1", "280px");
    			attr_dev(line6, "x2", "100%");
    			attr_dev(line6, "y2", "280px");
    			attr_dev(line6, "transform", "translate(0 0.5)");
    			add_location(line6, file$1M, 45, 0, 722);
    			attr_dev(line7, "class", "txcm-lineGraphAxis");
    			attr_dev(line7, "x1", "0");
    			attr_dev(line7, "y1", "320px");
    			attr_dev(line7, "x2", "100%");
    			attr_dev(line7, "y2", "320px");
    			attr_dev(line7, "transform", "translate(0 0.5)");
    			add_location(line7, file$1M, 52, 0, 838);
    			attr_dev(line8, "class", "txcm-lineGraphAxis");
    			attr_dev(line8, "x1", "0");
    			attr_dev(line8, "y1", "360px");
    			attr_dev(line8, "x2", "100%");
    			attr_dev(line8, "y2", "360px");
    			attr_dev(line8, "transform", "translate(0 0.5)");
    			add_location(line8, file$1M, 59, 0, 954);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, line0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, line1, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, line2, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, line3, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, line4, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, line5, anchor);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, line6, anchor);
    			insert_dev(target, t6, anchor);
    			insert_dev(target, line7, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, line8, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(line0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(line1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(line2);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(line3);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(line4);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(line5);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(line6);
    			if (detaching) detach_dev(t6);
    			if (detaching) detach_dev(line7);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(line8);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$24.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$24($$self, $$props) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComboBarGraphExtAxes> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComboBarGraphExtAxes", $$slots, []);
    	return [];
    }

    class ComboBarGraphExtAxes extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$24, create_fragment$24, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComboBarGraphExtAxes",
    			options,
    			id: create_fragment$24.name
    		});
    	}
    }

    /* src/js/components/comboBarGraphExt/ComboBarGraphExtLabels.svelte generated by Svelte v3.24.0 */

    const file$1N = "src/js/components/comboBarGraphExt/ComboBarGraphExtLabels.svelte";

    function create_fragment$25(ctx) {
    	let div9;
    	let div0;
    	let t0_value = `${4 * /*div*/ ctx[0]}%` + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2_value = `${3 * /*div*/ ctx[0]}%` + "";
    	let t2;
    	let t3;
    	let div2;
    	let t4_value = `${2 * /*div*/ ctx[0]}%` + "";
    	let t4;
    	let t5;
    	let div3;
    	let t6_value = `${1 * /*div*/ ctx[0]}%` + "";
    	let t6;
    	let t7;
    	let div4;
    	let t9;
    	let div5;
    	let t10_value = `-${1 * /*div*/ ctx[0]}%` + "";
    	let t10;
    	let t11;
    	let div6;
    	let t12_value = `-${2 * /*div*/ ctx[0]}%` + "";
    	let t12;
    	let t13;
    	let div7;
    	let t14_value = `-${3 * /*div*/ ctx[0]}%` + "";
    	let t14;
    	let t15;
    	let div8;
    	let t16_value = `-${4 * /*div*/ ctx[0]}%` + "";
    	let t16;

    	const block = {
    		c: function create() {
    			div9 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div2 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			div3 = element("div");
    			t6 = text(t6_value);
    			t7 = space();
    			div4 = element("div");
    			div4.textContent = "0%";
    			t9 = space();
    			div5 = element("div");
    			t10 = text(t10_value);
    			t11 = space();
    			div6 = element("div");
    			t12 = text(t12_value);
    			t13 = space();
    			div7 = element("div");
    			t14 = text(t14_value);
    			t15 = space();
    			div8 = element("div");
    			t16 = text(t16_value);
    			attr_dev(div0, "class", "txcm-linearGraphLabel");
    			add_location(div0, file$1N, 9, 4, 123);
    			attr_dev(div1, "class", "txcm-linearGraphLabel");
    			add_location(div1, file$1N, 14, 4, 205);
    			attr_dev(div2, "class", "txcm-linearGraphLabel");
    			add_location(div2, file$1N, 19, 4, 287);
    			attr_dev(div3, "class", "txcm-linearGraphLabel");
    			add_location(div3, file$1N, 24, 4, 369);
    			attr_dev(div4, "class", "txcm-linearGraphLabel");
    			add_location(div4, file$1N, 29, 4, 451);
    			attr_dev(div5, "class", "txcm-linearGraphLabel");
    			add_location(div5, file$1N, 34, 4, 520);
    			attr_dev(div6, "class", "txcm-linearGraphLabel");
    			add_location(div6, file$1N, 39, 4, 603);
    			attr_dev(div7, "class", "txcm-linearGraphLabel");
    			add_location(div7, file$1N, 44, 4, 686);
    			attr_dev(div8, "class", "txcm-linearGraphLabel");
    			add_location(div8, file$1N, 49, 4, 769);
    			attr_dev(div9, "class", "txcm-comboBarGraphExtLabels");
    			add_location(div9, file$1N, 7, 0, 75);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div9, anchor);
    			append_dev(div9, div0);
    			append_dev(div0, t0);
    			append_dev(div9, t1);
    			append_dev(div9, div1);
    			append_dev(div1, t2);
    			append_dev(div9, t3);
    			append_dev(div9, div2);
    			append_dev(div2, t4);
    			append_dev(div9, t5);
    			append_dev(div9, div3);
    			append_dev(div3, t6);
    			append_dev(div9, t7);
    			append_dev(div9, div4);
    			append_dev(div9, t9);
    			append_dev(div9, div5);
    			append_dev(div5, t10);
    			append_dev(div9, t11);
    			append_dev(div9, div6);
    			append_dev(div6, t12);
    			append_dev(div9, t13);
    			append_dev(div9, div7);
    			append_dev(div7, t14);
    			append_dev(div9, t15);
    			append_dev(div9, div8);
    			append_dev(div8, t16);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*div*/ 1 && t0_value !== (t0_value = `${4 * /*div*/ ctx[0]}%` + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*div*/ 1 && t2_value !== (t2_value = `${3 * /*div*/ ctx[0]}%` + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*div*/ 1 && t4_value !== (t4_value = `${2 * /*div*/ ctx[0]}%` + "")) set_data_dev(t4, t4_value);
    			if (dirty & /*div*/ 1 && t6_value !== (t6_value = `${1 * /*div*/ ctx[0]}%` + "")) set_data_dev(t6, t6_value);
    			if (dirty & /*div*/ 1 && t10_value !== (t10_value = `-${1 * /*div*/ ctx[0]}%` + "")) set_data_dev(t10, t10_value);
    			if (dirty & /*div*/ 1 && t12_value !== (t12_value = `-${2 * /*div*/ ctx[0]}%` + "")) set_data_dev(t12, t12_value);
    			if (dirty & /*div*/ 1 && t14_value !== (t14_value = `-${3 * /*div*/ ctx[0]}%` + "")) set_data_dev(t14, t14_value);
    			if (dirty & /*div*/ 1 && t16_value !== (t16_value = `-${4 * /*div*/ ctx[0]}%` + "")) set_data_dev(t16, t16_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div9);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$25.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$25($$self, $$props, $$invalidate) {
    	let { max } = $$props;
    	let { min } = $$props;
    	let { div } = $$props;
    	const writable_props = ["max", "min", "div"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComboBarGraphExtLabels> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComboBarGraphExtLabels", $$slots, []);

    	$$self.$set = $$props => {
    		if ("max" in $$props) $$invalidate(1, max = $$props.max);
    		if ("min" in $$props) $$invalidate(2, min = $$props.min);
    		if ("div" in $$props) $$invalidate(0, div = $$props.div);
    	};

    	$$self.$capture_state = () => ({ max, min, div });

    	$$self.$inject_state = $$props => {
    		if ("max" in $$props) $$invalidate(1, max = $$props.max);
    		if ("min" in $$props) $$invalidate(2, min = $$props.min);
    		if ("div" in $$props) $$invalidate(0, div = $$props.div);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [div, max, min];
    }

    class ComboBarGraphExtLabels extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$25, create_fragment$25, safe_not_equal, { max: 1, min: 2, div: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComboBarGraphExtLabels",
    			options,
    			id: create_fragment$25.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*max*/ ctx[1] === undefined && !("max" in props)) {
    			console.warn("<ComboBarGraphExtLabels> was created without expected prop 'max'");
    		}

    		if (/*min*/ ctx[2] === undefined && !("min" in props)) {
    			console.warn("<ComboBarGraphExtLabels> was created without expected prop 'min'");
    		}

    		if (/*div*/ ctx[0] === undefined && !("div" in props)) {
    			console.warn("<ComboBarGraphExtLabels> was created without expected prop 'div'");
    		}
    	}

    	get max() {
    		throw new Error("<ComboBarGraphExtLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<ComboBarGraphExtLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<ComboBarGraphExtLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<ComboBarGraphExtLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get div() {
    		throw new Error("<ComboBarGraphExtLabels>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set div(value) {
    		throw new Error("<ComboBarGraphExtLabels>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comboBarGraphExt/ComboBarGraphExtLegends.svelte generated by Svelte v3.24.0 */

    const file$1O = "src/js/components/comboBarGraphExt/ComboBarGraphExtLegends.svelte";

    function create_fragment$26(ctx) {
    	let scipt;
    	let t0;
    	let table;
    	let tr0;
    	let td0;
    	let t2;
    	let td1;
    	let t4;
    	let tr1;
    	let td2;
    	let t6;
    	let td3;
    	let t8;
    	let tr2;
    	let td4;

    	const block = {
    		c: function create() {
    			scipt = element("scipt");
    			t0 = space();
    			table = element("table");
    			tr0 = element("tr");
    			td0 = element("td");
    			td0.textContent = "Влияние товарно-ценовой MIX'a";
    			t2 = space();
    			td1 = element("td");
    			td1.textContent = "Влияние динамики нерегулярных цен";
    			t4 = space();
    			tr1 = element("tr");
    			td2 = element("td");
    			td2.textContent = "Влияние комплексности";
    			t6 = space();
    			td3 = element("td");
    			td3.textContent = "Влияние инфляции розничных цен, %";
    			t8 = space();
    			tr2 = element("tr");
    			td4 = element("td");
    			td4.textContent = "Влияние товаров лояльности, %";
    			add_location(scipt, file$1O, 0, 0, 0);
    			attr_dev(td0, "class", "txcm-comboBarGraphExtLegendsCell");
    			toggle_class(td0, "txcm-comboBarGraphExtLegendsCell-bar1", true);
    			add_location(td0, file$1O, 5, 4, 74);
    			attr_dev(td1, "class", "txcm-comboBarGraphExtLegendsCell");
    			toggle_class(td1, "txcm-comboBarGraphExtLegendsCell-bar3", true);
    			add_location(td1, file$1O, 11, 4, 240);
    			add_location(tr0, file$1O, 4, 2, 65);
    			attr_dev(td2, "class", "txcm-comboBarGraphExtLegendsCell");
    			toggle_class(td2, "txcm-comboBarGraphExtLegendsCell-bar2", true);
    			add_location(td2, file$1O, 19, 4, 425);
    			attr_dev(td3, "class", "txcm-comboBarGraphExtLegendsCell");
    			toggle_class(td3, "txcm-comboBarGraphExtLegendsCell-bar4", true);
    			add_location(td3, file$1O, 25, 4, 582);
    			add_location(tr1, file$1O, 18, 2, 416);
    			attr_dev(td4, "class", "txcm-comboBarGraphExtLegendsCell");
    			toggle_class(td4, "txcm-comboBarGraphExtLegendsCell-bar5", true);
    			add_location(td4, file$1O, 33, 4, 767);
    			add_location(tr2, file$1O, 32, 2, 758);
    			attr_dev(table, "class", "txcm-comboBarGraphExtLegends");
    			add_location(table, file$1O, 3, 0, 18);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, scipt, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, table, anchor);
    			append_dev(table, tr0);
    			append_dev(tr0, td0);
    			append_dev(tr0, t2);
    			append_dev(tr0, td1);
    			append_dev(table, t4);
    			append_dev(table, tr1);
    			append_dev(tr1, td2);
    			append_dev(tr1, t6);
    			append_dev(tr1, td3);
    			append_dev(table, t8);
    			append_dev(table, tr2);
    			append_dev(tr2, td4);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(scipt);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(table);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$26.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$26($$self, $$props) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComboBarGraphExtLegends> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComboBarGraphExtLegends", $$slots, []);
    	return [];
    }

    class ComboBarGraphExtLegends extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$26, create_fragment$26, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComboBarGraphExtLegends",
    			options,
    			id: create_fragment$26.name
    		});
    	}
    }

    /* src/js/components/comboBarGraphExt/ComboBarsGraphExtBar.svelte generated by Svelte v3.24.0 */
    const file$1P = "src/js/components/comboBarGraphExt/ComboBarsGraphExtBar.svelte";

    function get_each_context$t(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	return child_ctx;
    }

    // (67:4) {#if bar !== null}
    function create_if_block$F(ctx) {
    	let rect;
    	let rect_x_value;
    	let rect_y_value;
    	let rect_width_value;
    	let rect_height_value;

    	const block = {
    		c: function create() {
    			rect = svg_element("rect");
    			attr_dev(rect, "class", "txcm-comboBarGraphExtBar");
    			attr_dev(rect, "x", rect_x_value = /*bar*/ ctx[17].x);
    			attr_dev(rect, "y", rect_y_value = /*bar*/ ctx[17].y);
    			attr_dev(rect, "width", rect_width_value = 23);
    			attr_dev(rect, "height", rect_height_value = /*bar*/ ctx[17].height);
    			set_style(rect, "--theme-color", /*bar*/ ctx[17].color);
    			attr_dev(rect, "transform", /*transform*/ ctx[2]);
    			add_location(rect, file$1P, 67, 6, 1681);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, rect, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*bars*/ 1 && rect_x_value !== (rect_x_value = /*bar*/ ctx[17].x)) {
    				attr_dev(rect, "x", rect_x_value);
    			}

    			if (dirty & /*bars*/ 1 && rect_y_value !== (rect_y_value = /*bar*/ ctx[17].y)) {
    				attr_dev(rect, "y", rect_y_value);
    			}

    			if (dirty & /*bars*/ 1 && rect_height_value !== (rect_height_value = /*bar*/ ctx[17].height)) {
    				attr_dev(rect, "height", rect_height_value);
    			}

    			if (dirty & /*bars*/ 1) {
    				set_style(rect, "--theme-color", /*bar*/ ctx[17].color);
    			}

    			if (dirty & /*transform*/ 4) {
    				attr_dev(rect, "transform", /*transform*/ ctx[2]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(rect);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$F.name,
    		type: "if",
    		source: "(67:4) {#if bar !== null}",
    		ctx
    	});

    	return block;
    }

    // (66:2) {#each bars as bar}
    function create_each_block$t(ctx) {
    	let if_block_anchor;
    	let if_block = /*bar*/ ctx[17] !== null && create_if_block$F(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*bar*/ ctx[17] !== null) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$F(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$t.name,
    		type: "each",
    		source: "(66:2) {#each bars as bar}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$27(ctx) {
    	let g;
    	let tooltip_action;
    	let mounted;
    	let dispose;
    	let each_value = /*bars*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$t(get_each_context$t(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			g = svg_element("g");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(g, file$1P, 64, 0, 1597);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, g, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(g, null);
    			}

    			if (!mounted) {
    				dispose = action_destroyer(tooltip_action = tooltip.call(null, g, /*tooltipOptions*/ ctx[1]));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*bars, transform*/ 5) {
    				each_value = /*bars*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$t(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$t(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(g, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (tooltip_action && is_function(tooltip_action.update) && dirty & /*tooltipOptions*/ 2) tooltip_action.update.call(null, /*tooltipOptions*/ ctx[1]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(g);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$27.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$27($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { index } = $$props;
    	let { min } = $$props;
    	let { max } = $$props;
    	let { count } = $$props;
    	let { shift } = $$props;
    	let { height } = $$props;
    	let { padding } = $$props;
    	let bars = [];
    	let colors = ["#57599C", "#F4C856", "#E36735", "#5D86C0", "#9D4B99", "#5BAFD4"];
    	let tooltipOptions;

    	async function clearBars() {
    		$$invalidate(0, bars = []);
    		await tick();
    	}

    	async function calculatePosition() {
    		await clearBars();
    		const x = renderPointX(index, count, 6 / 20);
    		const mid = renderPointY(0, min, max, height, padding);

    		$$invalidate(0, bars = data.map(item => {
    			const y = renderPointY(item.point || 0, min, max, height, padding);

    			return item.point
    			? {
    					x,
    					y: item.point > 0 ? y : mid,
    					height: item.point > 0 ? mid - y : y - mid,
    					color: colors[item.index - 1]
    				}
    			: null;
    		}));
    	}

    	function calculateTransform() {
    		return `translate(${shift} 0.5)`;
    	}

    	function updateTooltipData() {
    		if (!data) return null;
    		return data.slice().sort((a, b) => a.index - b.index);
    	}

    	function updateTooltip() {
    		$$invalidate(1, tooltipOptions = {
    			content: {
    				component: ComboBarTooltip,
    				data: updateTooltipData()
    			},
    			side: "left"
    		});
    	}

    	const writable_props = ["data", "index", "min", "max", "count", "shift", "height", "padding"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComboBarsGraphExtBar> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComboBarsGraphExtBar", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("index" in $$props) $$invalidate(4, index = $$props.index);
    		if ("min" in $$props) $$invalidate(5, min = $$props.min);
    		if ("max" in $$props) $$invalidate(6, max = $$props.max);
    		if ("count" in $$props) $$invalidate(7, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(8, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(9, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(10, padding = $$props.padding);
    	};

    	$$self.$capture_state = () => ({
    		tick,
    		tooltip,
    		renderPointX,
    		renderPointY,
    		ComboBarTooltip,
    		data,
    		index,
    		min,
    		max,
    		count,
    		shift,
    		height,
    		padding,
    		bars,
    		colors,
    		tooltipOptions,
    		clearBars,
    		calculatePosition,
    		calculateTransform,
    		updateTooltipData,
    		updateTooltip,
    		transform
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("index" in $$props) $$invalidate(4, index = $$props.index);
    		if ("min" in $$props) $$invalidate(5, min = $$props.min);
    		if ("max" in $$props) $$invalidate(6, max = $$props.max);
    		if ("count" in $$props) $$invalidate(7, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(8, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(9, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(10, padding = $$props.padding);
    		if ("bars" in $$props) $$invalidate(0, bars = $$props.bars);
    		if ("colors" in $$props) colors = $$props.colors;
    		if ("tooltipOptions" in $$props) $$invalidate(1, tooltipOptions = $$props.tooltipOptions);
    		if ("transform" in $$props) $$invalidate(2, transform = $$props.transform);
    	};

    	let transform;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*shift*/ 256) {
    			 $$invalidate(2, transform = calculateTransform());
    		}

    		if ($$self.$$.dirty & /*data, min, max, count*/ 232) {
    			 calculatePosition();
    		}

    		if ($$self.$$.dirty & /*data*/ 8) {
    			 updateTooltip();
    		}
    	};

    	return [
    		bars,
    		tooltipOptions,
    		transform,
    		data,
    		index,
    		min,
    		max,
    		count,
    		shift,
    		height,
    		padding
    	];
    }

    class ComboBarsGraphExtBar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$27, create_fragment$27, safe_not_equal, {
    			data: 3,
    			index: 4,
    			min: 5,
    			max: 6,
    			count: 7,
    			shift: 8,
    			height: 9,
    			padding: 10
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComboBarsGraphExtBar",
    			options,
    			id: create_fragment$27.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[3] === undefined && !("data" in props)) {
    			console.warn("<ComboBarsGraphExtBar> was created without expected prop 'data'");
    		}

    		if (/*index*/ ctx[4] === undefined && !("index" in props)) {
    			console.warn("<ComboBarsGraphExtBar> was created without expected prop 'index'");
    		}

    		if (/*min*/ ctx[5] === undefined && !("min" in props)) {
    			console.warn("<ComboBarsGraphExtBar> was created without expected prop 'min'");
    		}

    		if (/*max*/ ctx[6] === undefined && !("max" in props)) {
    			console.warn("<ComboBarsGraphExtBar> was created without expected prop 'max'");
    		}

    		if (/*count*/ ctx[7] === undefined && !("count" in props)) {
    			console.warn("<ComboBarsGraphExtBar> was created without expected prop 'count'");
    		}

    		if (/*shift*/ ctx[8] === undefined && !("shift" in props)) {
    			console.warn("<ComboBarsGraphExtBar> was created without expected prop 'shift'");
    		}

    		if (/*height*/ ctx[9] === undefined && !("height" in props)) {
    			console.warn("<ComboBarsGraphExtBar> was created without expected prop 'height'");
    		}

    		if (/*padding*/ ctx[10] === undefined && !("padding" in props)) {
    			console.warn("<ComboBarsGraphExtBar> was created without expected prop 'padding'");
    		}
    	}

    	get data() {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get index() {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shift() {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shift(value) {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<ComboBarsGraphExtBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comboBarGraphExt/ComboBarsGraphExtBars.svelte generated by Svelte v3.24.0 */

    function get_each_context$u(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (14:2) {#if point}
    function create_if_block$G(ctx) {
    	let combobarsgraphextbar;
    	let current;

    	combobarsgraphextbar = new ComboBarsGraphExtBar({
    			props: {
    				count: /*count*/ ctx[3],
    				shift: /*shift*/ ctx[4],
    				height: /*height*/ ctx[5],
    				padding: /*padding*/ ctx[6],
    				index: /*index*/ ctx[9],
    				min: /*min*/ ctx[1],
    				max: /*max*/ ctx[2],
    				data: /*point*/ ctx[7]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(combobarsgraphextbar.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(combobarsgraphextbar, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const combobarsgraphextbar_changes = {};
    			if (dirty & /*count*/ 8) combobarsgraphextbar_changes.count = /*count*/ ctx[3];
    			if (dirty & /*shift*/ 16) combobarsgraphextbar_changes.shift = /*shift*/ ctx[4];
    			if (dirty & /*height*/ 32) combobarsgraphextbar_changes.height = /*height*/ ctx[5];
    			if (dirty & /*padding*/ 64) combobarsgraphextbar_changes.padding = /*padding*/ ctx[6];
    			if (dirty & /*min*/ 2) combobarsgraphextbar_changes.min = /*min*/ ctx[1];
    			if (dirty & /*max*/ 4) combobarsgraphextbar_changes.max = /*max*/ ctx[2];
    			if (dirty & /*points*/ 1) combobarsgraphextbar_changes.data = /*point*/ ctx[7];
    			combobarsgraphextbar.$set(combobarsgraphextbar_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(combobarsgraphextbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(combobarsgraphextbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(combobarsgraphextbar, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$G.name,
    		type: "if",
    		source: "(14:2) {#if point}",
    		ctx
    	});

    	return block;
    }

    // (13:0) {#each points as point, index}
    function create_each_block$u(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*point*/ ctx[7] && create_if_block$G(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*point*/ ctx[7]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*points*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$G(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$u.name,
    		type: "each",
    		source: "(13:0) {#each points as point, index}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$28(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*points*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$u(get_each_context$u(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*count, shift, height, padding, min, max, points*/ 127) {
    				each_value = /*points*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$u(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$u(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$28.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$28($$self, $$props, $$invalidate) {
    	let { points } = $$props;
    	let { min } = $$props;
    	let { max } = $$props;
    	let { count } = $$props;
    	let { shift } = $$props;
    	let { height } = $$props;
    	let { padding } = $$props;
    	const writable_props = ["points", "min", "max", "count", "shift", "height", "padding"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComboBarsGraphExtBars> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComboBarsGraphExtBars", $$slots, []);

    	$$self.$set = $$props => {
    		if ("points" in $$props) $$invalidate(0, points = $$props.points);
    		if ("min" in $$props) $$invalidate(1, min = $$props.min);
    		if ("max" in $$props) $$invalidate(2, max = $$props.max);
    		if ("count" in $$props) $$invalidate(3, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(4, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(5, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(6, padding = $$props.padding);
    	};

    	$$self.$capture_state = () => ({
    		ComboBarsGraphExtBar,
    		points,
    		min,
    		max,
    		count,
    		shift,
    		height,
    		padding
    	});

    	$$self.$inject_state = $$props => {
    		if ("points" in $$props) $$invalidate(0, points = $$props.points);
    		if ("min" in $$props) $$invalidate(1, min = $$props.min);
    		if ("max" in $$props) $$invalidate(2, max = $$props.max);
    		if ("count" in $$props) $$invalidate(3, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(4, shift = $$props.shift);
    		if ("height" in $$props) $$invalidate(5, height = $$props.height);
    		if ("padding" in $$props) $$invalidate(6, padding = $$props.padding);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [points, min, max, count, shift, height, padding];
    }

    class ComboBarsGraphExtBars extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$28, create_fragment$28, safe_not_equal, {
    			points: 0,
    			min: 1,
    			max: 2,
    			count: 3,
    			shift: 4,
    			height: 5,
    			padding: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComboBarsGraphExtBars",
    			options,
    			id: create_fragment$28.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*points*/ ctx[0] === undefined && !("points" in props)) {
    			console.warn("<ComboBarsGraphExtBars> was created without expected prop 'points'");
    		}

    		if (/*min*/ ctx[1] === undefined && !("min" in props)) {
    			console.warn("<ComboBarsGraphExtBars> was created without expected prop 'min'");
    		}

    		if (/*max*/ ctx[2] === undefined && !("max" in props)) {
    			console.warn("<ComboBarsGraphExtBars> was created without expected prop 'max'");
    		}

    		if (/*count*/ ctx[3] === undefined && !("count" in props)) {
    			console.warn("<ComboBarsGraphExtBars> was created without expected prop 'count'");
    		}

    		if (/*shift*/ ctx[4] === undefined && !("shift" in props)) {
    			console.warn("<ComboBarsGraphExtBars> was created without expected prop 'shift'");
    		}

    		if (/*height*/ ctx[5] === undefined && !("height" in props)) {
    			console.warn("<ComboBarsGraphExtBars> was created without expected prop 'height'");
    		}

    		if (/*padding*/ ctx[6] === undefined && !("padding" in props)) {
    			console.warn("<ComboBarsGraphExtBars> was created without expected prop 'padding'");
    		}
    	}

    	get points() {
    		throw new Error("<ComboBarsGraphExtBars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set points(value) {
    		throw new Error("<ComboBarsGraphExtBars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get min() {
    		throw new Error("<ComboBarsGraphExtBars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set min(value) {
    		throw new Error("<ComboBarsGraphExtBars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get max() {
    		throw new Error("<ComboBarsGraphExtBars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set max(value) {
    		throw new Error("<ComboBarsGraphExtBars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<ComboBarsGraphExtBars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<ComboBarsGraphExtBars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shift() {
    		throw new Error("<ComboBarsGraphExtBars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shift(value) {
    		throw new Error("<ComboBarsGraphExtBars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get height() {
    		throw new Error("<ComboBarsGraphExtBars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set height(value) {
    		throw new Error("<ComboBarsGraphExtBars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get padding() {
    		throw new Error("<ComboBarsGraphExtBars>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set padding(value) {
    		throw new Error("<ComboBarsGraphExtBars>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comboBarGraphExt/ComboBarGraphExt.svelte generated by Svelte v3.24.0 */
    const file$1Q = "src/js/components/comboBarGraphExt/ComboBarGraphExt.svelte";

    function create_fragment$29(ctx) {
    	let combobargraphextlabels;
    	let t0;
    	let div_1;
    	let svg;
    	let combobargraphextaxes;
    	let combobarsgraphextbars;
    	let t1;
    	let combobargraphextlegends;
    	let t2;
    	let current;
    	let mounted;
    	let dispose;

    	combobargraphextlabels = new ComboBarGraphExtLabels({
    			props: {
    				max: /*max*/ ctx[3],
    				min: /*min*/ ctx[2],
    				div: /*div*/ ctx[4]
    			},
    			$$inline: true
    		});

    	combobargraphextaxes = new ComboBarGraphExtAxes({ $$inline: true });

    	combobarsgraphextbars = new ComboBarsGraphExtBars({
    			props: {
    				count: /*count*/ ctx[0],
    				shift: /*shift*/ ctx[1],
    				height: DEFAULT_HEIGHT$2,
    				padding: DEFAULT_PADDING$2,
    				min: /*min*/ ctx[2],
    				max: /*max*/ ctx[3],
    				points: /*points*/ ctx[5]
    			},
    			$$inline: true
    		});

    	combobargraphextlegends = new ComboBarGraphExtLegends({ $$inline: true });
    	const default_slot_template = /*$$slots*/ ctx[15].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[14], null);

    	const block = {
    		c: function create() {
    			create_component(combobargraphextlabels.$$.fragment);
    			t0 = space();
    			div_1 = element("div");
    			svg = svg_element("svg");
    			create_component(combobargraphextaxes.$$.fragment);
    			create_component(combobarsgraphextbars.$$.fragment);
    			t1 = space();
    			create_component(combobargraphextlegends.$$.fragment);
    			t2 = space();
    			if (default_slot) default_slot.c();
    			attr_dev(svg, "class", "txcm-comboBarGraph");
    			attr_dev(svg, "width", "100%");
    			attr_dev(svg, "height", /*height*/ ctx[8]);
    			add_location(svg, file$1Q, 135, 2, 3709);
    			attr_dev(div_1, "class", "txcm-comboBarGraphExt");
    			add_location(div_1, file$1Q, 129, 0, 3501);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(combobargraphextlabels, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div_1, anchor);
    			append_dev(div_1, svg);
    			mount_component(combobargraphextaxes, svg, null);
    			mount_component(combobarsgraphextbars, svg, null);
    			append_dev(div_1, t1);
    			mount_component(combobargraphextlegends, div_1, null);
    			append_dev(div_1, t2);

    			if (default_slot) {
    				default_slot.m(div_1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div_1, "click", stop_propagation(prevent_default(/*click_handler*/ ctx[16])), false, true, true),
    					listen_dev(div_1, "mousedown", stop_propagation(prevent_default(/*onPointerDown*/ ctx[9])), false, true, true),
    					listen_dev(div_1, "touchstart", stop_propagation(prevent_default(/*onPointerDown*/ ctx[9])), false, true, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const combobargraphextlabels_changes = {};
    			if (dirty[0] & /*max*/ 8) combobargraphextlabels_changes.max = /*max*/ ctx[3];
    			if (dirty[0] & /*min*/ 4) combobargraphextlabels_changes.min = /*min*/ ctx[2];
    			if (dirty[0] & /*div*/ 16) combobargraphextlabels_changes.div = /*div*/ ctx[4];
    			combobargraphextlabels.$set(combobargraphextlabels_changes);
    			const combobarsgraphextbars_changes = {};
    			if (dirty[0] & /*count*/ 1) combobarsgraphextbars_changes.count = /*count*/ ctx[0];
    			if (dirty[0] & /*shift*/ 2) combobarsgraphextbars_changes.shift = /*shift*/ ctx[1];
    			if (dirty[0] & /*min*/ 4) combobarsgraphextbars_changes.min = /*min*/ ctx[2];
    			if (dirty[0] & /*max*/ 8) combobarsgraphextbars_changes.max = /*max*/ ctx[3];
    			if (dirty[0] & /*points*/ 32) combobarsgraphextbars_changes.points = /*points*/ ctx[5];
    			combobarsgraphextbars.$set(combobarsgraphextbars_changes);

    			if (default_slot) {
    				if (default_slot.p && dirty[0] & /*$$scope*/ 16384) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[14], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(combobargraphextlabels.$$.fragment, local);
    			transition_in(combobargraphextaxes.$$.fragment, local);
    			transition_in(combobarsgraphextbars.$$.fragment, local);
    			transition_in(combobargraphextlegends.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(combobargraphextlabels.$$.fragment, local);
    			transition_out(combobargraphextaxes.$$.fragment, local);
    			transition_out(combobarsgraphextbars.$$.fragment, local);
    			transition_out(combobargraphextlegends.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(combobargraphextlabels, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div_1);
    			destroy_component(combobargraphextaxes);
    			destroy_component(combobarsgraphextbars);
    			destroy_component(combobargraphextlegends);
    			if (default_slot) default_slot.d(detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$29.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const DEFAULT_HEIGHT$2 = 400;
    const DEFAULT_PADDING$2 = 40;

    function sortBars$1(a, b) {
    	return Math.abs(b.point) - Math.abs(a.point);
    }

    function instance$29($$self, $$props, $$invalidate) {
    	let $scroll;
    	let $scrollMax;
    	const scroll = getGraphsState("scroll");
    	validate_store(scroll, "scroll");
    	component_subscribe($$self, scroll, value => $$invalidate(21, $scroll = value));
    	const scrollMax = getGraphsState("scrollMax");
    	validate_store(scrollMax, "scrollMax");
    	component_subscribe($$self, scrollMax, value => $$invalidate(22, $scrollMax = value));
    	let { indicator } = $$props;
    	let { step } = $$props;
    	let { count } = $$props;
    	let { shift } = $$props;
    	let { data } = $$props;
    	let { units } = $$props;
    	let height = DEFAULT_HEIGHT$2;
    	let min;
    	let max;
    	let div;
    	let points = [];
    	let fragment;
    	let pointer = null;
    	let pointerPositionStart;
    	let pointerScrollStart;
    	let pointerPositionCurrent;

    	function calculateLimits() {
    		if (data.length === 0) return;

    		const values = data.reduce(
    			(result, item, index) => {
    				item.data.forEach(item => item.data && result.push(Math.abs(item.data)));
    				return result;
    			},
    			[]
    		);

    		if (values && values.length) {
    			$$invalidate(3, max = Math.max(...values));
    			$$invalidate(4, div = Math.round(max * 100 / 4));
    			$$invalidate(2, min = -max);
    		} else {
    			$$invalidate(2, min = -1);
    			$$invalidate(4, div = 1);
    			$$invalidate(3, max = 1);
    		}
    	}

    	function zipPoints() {
    		if (data.length === 0) return;

    		return data[0].data.reduce(
    			(result, item, index) => {
    				const bars = [];

    				for (let i = 0; i < 6; ++i) {
    					const bar = {
    						index: i + 1,
    						point: data[i] && data[i].data[index].data !== null && !isNaN(data[i].data[index].data)
    						? data[i].data[index].data
    						: null
    					};

    					bars.push(bar);
    				}

    				bars.sort(sortBars$1);
    				result.push(bars);
    				return result;
    			},
    			[]
    		);
    	}

    	async function updateCharts() {
    		if (data.length === 0) return;
    		const { length } = data[0];
    		if (!fragment) fragment = zipPoints();
    		if (length <= count) $$invalidate(5, points = fragment.slice()); else $$invalidate(5, points = fragment.slice(step, step + count + 1));
    	}

    	function changeScroll(deltaX) {
    		if (pointerScrollStart + deltaX <= 0) set_store_value(scroll, $scroll = 0); else if (pointerScrollStart + deltaX >= $scrollMax) set_store_value(scroll, $scroll = $scrollMax); else set_store_value(scroll, $scroll = pointerScrollStart + deltaX);
    	}

    	function onPointerMove(event) {
    		pointerPositionCurrent = event.touches ? event.touches[0].clientX : event.clientX;
    		const diff = pointerPositionStart - pointerPositionCurrent;
    		changeScroll(diff);
    	}

    	function onPointerUp(event) {
    		event.preventDefault();
    		event.stopPropagation();
    		unsubscribeWindow();
    	}

    	function subscribeWindow() {
    		window.addEventListener("mousemove", onPointerMove);
    		window.addEventListener("touchmove", onPointerMove);
    		window.addEventListener("mouseup", onPointerUp);
    		window.addEventListener("touchend", onPointerUp);
    	}

    	function unsubscribeWindow() {
    		window.removeEventListener("mousemove", onPointerMove);
    		window.removeEventListener("touchmove", onPointerMove);
    		window.removeEventListener("mouseup", onPointerUp);
    		window.removeEventListener("touchend", onPointerUp);
    	}

    	function onPointerDown(event) {
    		pointerPositionStart = event.touches ? event.touches[0].clientX : event.clientX;
    		pointerScrollStart = $scroll;
    		subscribeWindow();
    	}

    	const writable_props = ["indicator", "step", "count", "shift", "data", "units"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComboBarGraphExt> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComboBarGraphExt", $$slots, ['default']);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("indicator" in $$props) $$invalidate(10, indicator = $$props.indicator);
    		if ("step" in $$props) $$invalidate(11, step = $$props.step);
    		if ("count" in $$props) $$invalidate(0, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(1, shift = $$props.shift);
    		if ("data" in $$props) $$invalidate(12, data = $$props.data);
    		if ("units" in $$props) $$invalidate(13, units = $$props.units);
    		if ("$$scope" in $$props) $$invalidate(14, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ComboBarGraphExtAxes,
    		ComboBarGraphExtLabels,
    		ComboBarGraphExtLegends,
    		ComboBarsGraphExtBars,
    		getGraphsState,
    		DEFAULT_HEIGHT: DEFAULT_HEIGHT$2,
    		DEFAULT_PADDING: DEFAULT_PADDING$2,
    		scroll,
    		scrollMax,
    		indicator,
    		step,
    		count,
    		shift,
    		data,
    		units,
    		height,
    		min,
    		max,
    		div,
    		points,
    		fragment,
    		pointer,
    		pointerPositionStart,
    		pointerScrollStart,
    		pointerPositionCurrent,
    		calculateLimits,
    		sortBars: sortBars$1,
    		zipPoints,
    		updateCharts,
    		changeScroll,
    		onPointerMove,
    		onPointerUp,
    		subscribeWindow,
    		unsubscribeWindow,
    		onPointerDown,
    		$scroll,
    		$scrollMax
    	});

    	$$self.$inject_state = $$props => {
    		if ("indicator" in $$props) $$invalidate(10, indicator = $$props.indicator);
    		if ("step" in $$props) $$invalidate(11, step = $$props.step);
    		if ("count" in $$props) $$invalidate(0, count = $$props.count);
    		if ("shift" in $$props) $$invalidate(1, shift = $$props.shift);
    		if ("data" in $$props) $$invalidate(12, data = $$props.data);
    		if ("units" in $$props) $$invalidate(13, units = $$props.units);
    		if ("height" in $$props) $$invalidate(8, height = $$props.height);
    		if ("min" in $$props) $$invalidate(2, min = $$props.min);
    		if ("max" in $$props) $$invalidate(3, max = $$props.max);
    		if ("div" in $$props) $$invalidate(4, div = $$props.div);
    		if ("points" in $$props) $$invalidate(5, points = $$props.points);
    		if ("fragment" in $$props) fragment = $$props.fragment;
    		if ("pointer" in $$props) pointer = $$props.pointer;
    		if ("pointerPositionStart" in $$props) pointerPositionStart = $$props.pointerPositionStart;
    		if ("pointerScrollStart" in $$props) pointerScrollStart = $$props.pointerScrollStart;
    		if ("pointerPositionCurrent" in $$props) pointerPositionCurrent = $$props.pointerPositionCurrent;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*data*/ 4096) {
    			 calculateLimits();
    		}

    		if ($$self.$$.dirty[0] & /*data, step, count*/ 6145) {
    			 updateCharts();
    		}
    	};

    	return [
    		count,
    		shift,
    		min,
    		max,
    		div,
    		points,
    		scroll,
    		scrollMax,
    		height,
    		onPointerDown,
    		indicator,
    		step,
    		data,
    		units,
    		$$scope,
    		$$slots,
    		click_handler
    	];
    }

    class ComboBarGraphExt extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$29,
    			create_fragment$29,
    			safe_not_equal,
    			{
    				indicator: 10,
    				step: 11,
    				count: 0,
    				shift: 1,
    				data: 12,
    				units: 13
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComboBarGraphExt",
    			options,
    			id: create_fragment$29.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*indicator*/ ctx[10] === undefined && !("indicator" in props)) {
    			console.warn("<ComboBarGraphExt> was created without expected prop 'indicator'");
    		}

    		if (/*step*/ ctx[11] === undefined && !("step" in props)) {
    			console.warn("<ComboBarGraphExt> was created without expected prop 'step'");
    		}

    		if (/*count*/ ctx[0] === undefined && !("count" in props)) {
    			console.warn("<ComboBarGraphExt> was created without expected prop 'count'");
    		}

    		if (/*shift*/ ctx[1] === undefined && !("shift" in props)) {
    			console.warn("<ComboBarGraphExt> was created without expected prop 'shift'");
    		}

    		if (/*data*/ ctx[12] === undefined && !("data" in props)) {
    			console.warn("<ComboBarGraphExt> was created without expected prop 'data'");
    		}

    		if (/*units*/ ctx[13] === undefined && !("units" in props)) {
    			console.warn("<ComboBarGraphExt> was created without expected prop 'units'");
    		}
    	}

    	get indicator() {
    		throw new Error("<ComboBarGraphExt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<ComboBarGraphExt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get step() {
    		throw new Error("<ComboBarGraphExt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set step(value) {
    		throw new Error("<ComboBarGraphExt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get count() {
    		throw new Error("<ComboBarGraphExt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set count(value) {
    		throw new Error("<ComboBarGraphExt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shift() {
    		throw new Error("<ComboBarGraphExt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shift(value) {
    		throw new Error("<ComboBarGraphExt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<ComboBarGraphExt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<ComboBarGraphExt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<ComboBarGraphExt>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<ComboBarGraphExt>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/kpi/KPIGraph.svelte generated by Svelte v3.24.0 */
    const file$1R = "src/js/components/kpi/KPIGraph.svelte";

    // (87:8) {#if $kind === 0}
    function create_if_block_2$3(ctx) {
    	let linegraph;
    	let t;
    	let if_block_anchor;
    	let current;

    	linegraph = new LineGraph({
    			props: {
    				units: /*units*/ ctx[1],
    				indicator: /*indicator*/ ctx[0],
    				data: /*fragment*/ ctx[3],
    				count: /*$count*/ ctx[6],
    				step: /*$step*/ ctx[10],
    				shift: /*$shift*/ ctx[8],
    				isCompact: /*hasDeviations*/ ctx[4]
    			},
    			$$inline: true
    		});

    	let if_block = /*hasDeviations*/ ctx[4] && create_if_block_3(ctx);

    	const block = {
    		c: function create() {
    			create_component(linegraph.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(linegraph, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const linegraph_changes = {};
    			if (dirty & /*units*/ 2) linegraph_changes.units = /*units*/ ctx[1];
    			if (dirty & /*indicator*/ 1) linegraph_changes.indicator = /*indicator*/ ctx[0];
    			if (dirty & /*fragment*/ 8) linegraph_changes.data = /*fragment*/ ctx[3];
    			if (dirty & /*$count*/ 64) linegraph_changes.count = /*$count*/ ctx[6];
    			if (dirty & /*$step*/ 1024) linegraph_changes.step = /*$step*/ ctx[10];
    			if (dirty & /*$shift*/ 256) linegraph_changes.shift = /*$shift*/ ctx[8];
    			if (dirty & /*hasDeviations*/ 16) linegraph_changes.isCompact = /*hasDeviations*/ ctx[4];
    			linegraph.$set(linegraph_changes);

    			if (/*hasDeviations*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*hasDeviations*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linegraph.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linegraph.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(linegraph, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(87:8) {#if $kind === 0}",
    		ctx
    	});

    	return block;
    }

    // (96:10) {#if hasDeviations}
    function create_if_block_3(ctx) {
    	let barchart;
    	let current;

    	barchart = new BarChart({
    			props: {
    				indicator: /*indicator*/ ctx[0],
    				isInverted: /*isInverted*/ ctx[2],
    				data: /*fragment*/ ctx[3],
    				count: /*$count*/ ctx[6],
    				step: /*$step*/ ctx[10],
    				shift: /*$shift*/ ctx[8]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(barchart.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(barchart, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const barchart_changes = {};
    			if (dirty & /*indicator*/ 1) barchart_changes.indicator = /*indicator*/ ctx[0];
    			if (dirty & /*isInverted*/ 4) barchart_changes.isInverted = /*isInverted*/ ctx[2];
    			if (dirty & /*fragment*/ 8) barchart_changes.data = /*fragment*/ ctx[3];
    			if (dirty & /*$count*/ 64) barchart_changes.count = /*$count*/ ctx[6];
    			if (dirty & /*$step*/ 1024) barchart_changes.step = /*$step*/ ctx[10];
    			if (dirty & /*$shift*/ 256) barchart_changes.shift = /*$shift*/ ctx[8];
    			barchart.$set(barchart_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(barchart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(barchart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(barchart, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(96:10) {#if hasDeviations}",
    		ctx
    	});

    	return block;
    }

    // (107:8) {#if $kind === 1}
    function create_if_block$H(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$a, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*extended*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$H.name,
    		type: "if",
    		source: "(107:8) {#if $kind === 1}",
    		ctx
    	});

    	return block;
    }

    // (121:10) {:else}
    function create_else_block$7(ctx) {
    	let combobargraphext;
    	let current;

    	combobargraphext = new ComboBarGraphExt({
    			props: {
    				units: /*units*/ ctx[1],
    				indicator: /*indicator*/ ctx[0],
    				data: /*fragment*/ ctx[3],
    				count: /*$count*/ ctx[6],
    				step: /*$step*/ ctx[10],
    				shift: /*$shift*/ ctx[8],
    				$$slots: { default: [create_default_slot$z] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(combobargraphext.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(combobargraphext, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const combobargraphext_changes = {};
    			if (dirty & /*units*/ 2) combobargraphext_changes.units = /*units*/ ctx[1];
    			if (dirty & /*indicator*/ 1) combobargraphext_changes.indicator = /*indicator*/ ctx[0];
    			if (dirty & /*fragment*/ 8) combobargraphext_changes.data = /*fragment*/ ctx[3];
    			if (dirty & /*$count*/ 64) combobargraphext_changes.count = /*$count*/ ctx[6];
    			if (dirty & /*$step*/ 1024) combobargraphext_changes.step = /*$step*/ ctx[10];
    			if (dirty & /*$shift*/ 256) combobargraphext_changes.shift = /*$shift*/ ctx[8];

    			if (dirty & /*$$scope, extended*/ 268435488) {
    				combobargraphext_changes.$$scope = { dirty, ctx };
    			}

    			combobargraphext.$set(combobargraphext_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(combobargraphext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(combobargraphext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(combobargraphext, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(121:10) {:else}",
    		ctx
    	});

    	return block;
    }

    // (108:10) {#if !extended}
    function create_if_block_1$a(ctx) {
    	let combobargraph;
    	let t;
    	let combobarshowlabel;
    	let updating_extended;
    	let current;

    	combobargraph = new ComboBarGraph({
    			props: {
    				units: /*units*/ ctx[1],
    				indicator: /*indicator*/ ctx[0],
    				data: /*fragment*/ ctx[3],
    				count: /*$count*/ ctx[6],
    				step: /*$step*/ ctx[10],
    				shift: /*$shift*/ ctx[8]
    			},
    			$$inline: true
    		});

    	function combobarshowlabel_extended_binding(value) {
    		/*combobarshowlabel_extended_binding*/ ctx[20].call(null, value);
    	}

    	let combobarshowlabel_props = { extend: false };

    	if (/*extended*/ ctx[5] !== void 0) {
    		combobarshowlabel_props.extended = /*extended*/ ctx[5];
    	}

    	combobarshowlabel = new ComboBarShowLabel({
    			props: combobarshowlabel_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(combobarshowlabel, "extended", combobarshowlabel_extended_binding));

    	const block = {
    		c: function create() {
    			create_component(combobargraph.$$.fragment);
    			t = space();
    			create_component(combobarshowlabel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(combobargraph, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(combobarshowlabel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const combobargraph_changes = {};
    			if (dirty & /*units*/ 2) combobargraph_changes.units = /*units*/ ctx[1];
    			if (dirty & /*indicator*/ 1) combobargraph_changes.indicator = /*indicator*/ ctx[0];
    			if (dirty & /*fragment*/ 8) combobargraph_changes.data = /*fragment*/ ctx[3];
    			if (dirty & /*$count*/ 64) combobargraph_changes.count = /*$count*/ ctx[6];
    			if (dirty & /*$step*/ 1024) combobargraph_changes.step = /*$step*/ ctx[10];
    			if (dirty & /*$shift*/ 256) combobargraph_changes.shift = /*$shift*/ ctx[8];
    			combobargraph.$set(combobargraph_changes);
    			const combobarshowlabel_changes = {};

    			if (!updating_extended && dirty & /*extended*/ 32) {
    				updating_extended = true;
    				combobarshowlabel_changes.extended = /*extended*/ ctx[5];
    				add_flush_callback(() => updating_extended = false);
    			}

    			combobarshowlabel.$set(combobarshowlabel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(combobargraph.$$.fragment, local);
    			transition_in(combobarshowlabel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(combobargraph.$$.fragment, local);
    			transition_out(combobarshowlabel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(combobargraph, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(combobarshowlabel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(108:10) {#if !extended}",
    		ctx
    	});

    	return block;
    }

    // (122:12) <ComboBarGraphExt                {units}               {indicator}               data={fragment}               count={$count}               step={$step}               shift={$shift}             >
    function create_default_slot$z(ctx) {
    	let combobarshowlabel;
    	let updating_extended;
    	let current;

    	function combobarshowlabel_extended_binding_1(value) {
    		/*combobarshowlabel_extended_binding_1*/ ctx[21].call(null, value);
    	}

    	let combobarshowlabel_props = { extend: true };

    	if (/*extended*/ ctx[5] !== void 0) {
    		combobarshowlabel_props.extended = /*extended*/ ctx[5];
    	}

    	combobarshowlabel = new ComboBarShowLabel({
    			props: combobarshowlabel_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(combobarshowlabel, "extended", combobarshowlabel_extended_binding_1));

    	const block = {
    		c: function create() {
    			create_component(combobarshowlabel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(combobarshowlabel, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const combobarshowlabel_changes = {};

    			if (!updating_extended && dirty & /*extended*/ 32) {
    				updating_extended = true;
    				combobarshowlabel_changes.extended = /*extended*/ ctx[5];
    				add_flush_callback(() => updating_extended = false);
    			}

    			combobarshowlabel.$set(combobarshowlabel_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(combobarshowlabel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(combobarshowlabel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(combobarshowlabel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$z.name,
    		type: "slot",
    		source: "(122:12) <ComboBarGraphExt                {units}               {indicator}               data={fragment}               count={$count}               step={$step}               shift={$shift}             >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2a(ctx) {
    	let div1;
    	let div0;
    	let t;
    	let current;
    	let if_block0 = /*$kind*/ ctx[9] === 0 && create_if_block_2$3(ctx);
    	let if_block1 = /*$kind*/ ctx[9] === 1 && create_if_block$H(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div0, "class", "txcm-kpiGraphHolder");
    			toggle_class(div0, "txcm-kpiGraphHolder-is-expanded", /*isExpanded*/ ctx[18]);
    			add_location(div0, file$1R, 83, 4, 3085);
    			attr_dev(div1, "class", "txcm-kpiGraph");
    			set_style(div1, "--highlightWidth", 100 / /*$count*/ ctx[6] + "%");
    			set_style(div1, "--highlightPosition", 100 * /*$highlighted*/ ctx[7] + "%");
    			set_style(div1, "--highlightOpacity", /*$highlighted*/ ctx[7] === null ? 0 : 1);
    			set_style(div1, "--highlightShift", /*$shift*/ ctx[8] + "px");
    			add_location(div1, file$1R, 80, 0, 2880);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div0, t);
    			if (if_block1) if_block1.m(div0, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$kind*/ ctx[9] === 0) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$kind*/ 512) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$kind*/ ctx[9] === 1) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$kind*/ 512) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$H(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div0, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*isExpanded*/ 262144) {
    				toggle_class(div0, "txcm-kpiGraphHolder-is-expanded", /*isExpanded*/ ctx[18]);
    			}

    			if (!current || dirty & /*$count*/ 64) {
    				set_style(div1, "--highlightWidth", 100 / /*$count*/ ctx[6] + "%");
    			}

    			if (!current || dirty & /*$highlighted*/ 128) {
    				set_style(div1, "--highlightPosition", 100 * /*$highlighted*/ ctx[7] + "%");
    			}

    			if (!current || dirty & /*$highlighted*/ 128) {
    				set_style(div1, "--highlightOpacity", /*$highlighted*/ ctx[7] === null ? 0 : 1);
    			}

    			if (!current || dirty & /*$shift*/ 256) {
    				set_style(div1, "--highlightShift", /*$shift*/ ctx[8] + "px");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function checkDeviation(point, index) {
    	return point.data !== null && !isNaN(point.data);
    }

    function instance$2a($$self, $$props, $$invalidate) {
    	let $dynamics;
    	let $date;
    	let $count;
    	let $highlighted;
    	let $shift;
    	let $kind;
    	let $step;
    	let { data } = $$props;
    	let { indicator } = $$props;
    	let { units } = $$props;
    	let { isInverted } = $$props;
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(23, $date = value));
    	const dynamics = getGraphsState("dynamics");
    	validate_store(dynamics, "dynamics");
    	component_subscribe($$self, dynamics, value => $$invalidate(22, $dynamics = value));
    	const kind = getGraphsState("kind");
    	validate_store(kind, "kind");
    	component_subscribe($$self, kind, value => $$invalidate(9, $kind = value));
    	const step = getGraphsState("step");
    	validate_store(step, "step");
    	component_subscribe($$self, step, value => $$invalidate(10, $step = value));
    	const count = getGraphsState("count");
    	validate_store(count, "count");
    	component_subscribe($$self, count, value => $$invalidate(6, $count = value));
    	const highlighted = getGraphsState("highlighted");
    	validate_store(highlighted, "highlighted");
    	component_subscribe($$self, highlighted, value => $$invalidate(7, $highlighted = value));
    	const shift = getGraphsState("shift");
    	validate_store(shift, "shift");
    	component_subscribe($$self, shift, value => $$invalidate(8, $shift = value));
    	let fragment;
    	let isExpanded;
    	let hasDeviations;
    	let extended = false;

    	function checkDeviations() {
    		return fragment[2] && fragment[2].data.some(checkDeviation) || fragment[4] && fragment[4].data.some(checkDeviation);
    	}

    	function fillData(data) {
    		if (!data || !data.length) return [];
    		if ($dynamics === "graphDetailDay" || $dynamics === "graphDetailAvgCheck") return fillDayData(data, $date);
    		if ($dynamics === "graphDetailWeek") return fillWeekData(data, $date);
    		if ($dynamics === "graphDetailMonth") return fillMonthData(data, $date);
    		if ($dynamics === "graphDetailQuarter") return fillQuaterData(data, $date);
    		if ($dynamics === "graphDetailYear") return fillYearData(data, $date);
    		return data;
    	}

    	function filterData(data) {
    		if (!data || !data.length) return [];
    		const datePoP = calculateDatePoP($date, $dynamics);
    		if ($dynamics === "graphDetailDay" || $dynamics === "graphDetailAvgCheck") return filterDayData(data, $date, datePoP);
    		if ($dynamics === "graphDetailWeek") return filterWeekData(data, $date, datePoP);
    		if ($dynamics === "graphDetailMonth") return filterMonthData(data, $date, datePoP);
    		if ($dynamics === "graphDetailQuarter") return filterQuarterData(data, $date, datePoP);
    		if ($dynamics === "graphDetailYear") return filterYearData(data);
    		return data;
    	}

    	function updateFragments() {
    		$$invalidate(3, fragment = filterData(data.series));
    		$$invalidate(3, fragment = fillData(fragment));
    		$$invalidate(4, hasDeviations = checkDeviations());
    	}

    	const writable_props = ["data", "indicator", "units", "isInverted"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<KPIGraph> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("KPIGraph", $$slots, []);

    	function combobarshowlabel_extended_binding(value) {
    		extended = value;
    		$$invalidate(5, extended);
    	}

    	function combobarshowlabel_extended_binding_1(value) {
    		extended = value;
    		$$invalidate(5, extended);
    	}

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(19, data = $$props.data);
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("units" in $$props) $$invalidate(1, units = $$props.units);
    		if ("isInverted" in $$props) $$invalidate(2, isInverted = $$props.isInverted);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		getGraphsState,
    		calculateDatePoP,
    		filterDayData,
    		filterWeekData,
    		filterMonthData,
    		filterQuarterData,
    		filterYearData,
    		fillDayData,
    		fillWeekData,
    		fillMonthData,
    		fillQuaterData,
    		fillYearData,
    		LineGraph,
    		BarChart,
    		ComboBarGraph,
    		ComboBarShowLabel,
    		ComboBarGraphExt,
    		data,
    		indicator,
    		units,
    		isInverted,
    		date,
    		dynamics,
    		kind,
    		step,
    		count,
    		highlighted,
    		shift,
    		fragment,
    		isExpanded,
    		hasDeviations,
    		extended,
    		checkDeviation,
    		checkDeviations,
    		fillData,
    		filterData,
    		updateFragments,
    		$dynamics,
    		$date,
    		$count,
    		$highlighted,
    		$shift,
    		$kind,
    		$step
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(19, data = $$props.data);
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("units" in $$props) $$invalidate(1, units = $$props.units);
    		if ("isInverted" in $$props) $$invalidate(2, isInverted = $$props.isInverted);
    		if ("fragment" in $$props) $$invalidate(3, fragment = $$props.fragment);
    		if ("isExpanded" in $$props) $$invalidate(18, isExpanded = $$props.isExpanded);
    		if ("hasDeviations" in $$props) $$invalidate(4, hasDeviations = $$props.hasDeviations);
    		if ("extended" in $$props) $$invalidate(5, extended = $$props.extended);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 524288) {
    			 updateFragments();
    		}
    	};

    	return [
    		indicator,
    		units,
    		isInverted,
    		fragment,
    		hasDeviations,
    		extended,
    		$count,
    		$highlighted,
    		$shift,
    		$kind,
    		$step,
    		date,
    		dynamics,
    		kind,
    		step,
    		count,
    		highlighted,
    		shift,
    		isExpanded,
    		data,
    		combobarshowlabel_extended_binding,
    		combobarshowlabel_extended_binding_1
    	];
    }

    class KPIGraph extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$2a, create_fragment$2a, safe_not_equal, {
    			data: 19,
    			indicator: 0,
    			units: 1,
    			isInverted: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KPIGraph",
    			options,
    			id: create_fragment$2a.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[19] === undefined && !("data" in props)) {
    			console.warn("<KPIGraph> was created without expected prop 'data'");
    		}

    		if (/*indicator*/ ctx[0] === undefined && !("indicator" in props)) {
    			console.warn("<KPIGraph> was created without expected prop 'indicator'");
    		}

    		if (/*units*/ ctx[1] === undefined && !("units" in props)) {
    			console.warn("<KPIGraph> was created without expected prop 'units'");
    		}

    		if (/*isInverted*/ ctx[2] === undefined && !("isInverted" in props)) {
    			console.warn("<KPIGraph> was created without expected prop 'isInverted'");
    		}
    	}

    	get data() {
    		throw new Error("<KPIGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<KPIGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<KPIGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<KPIGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<KPIGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<KPIGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isInverted() {
    		throw new Error("<KPIGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isInverted(value) {
    		throw new Error("<KPIGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/kpi/KPIRow.svelte generated by Svelte v3.24.0 */
    const file$1S = "src/js/components/kpi/KPIRow.svelte";

    // (51:4) {#if data }
    function create_if_block$I(ctx) {
    	let kpicell0;
    	let t0;
    	let kpicell1;
    	let t1;
    	let t2;
    	let kpideviations;
    	let current;

    	kpicell0 = new KPICell({
    			props: {
    				units: /*data*/ ctx[0].units,
    				data: /*data*/ ctx[0].column1,
    				indicator: /*indicator*/ ctx[1],
    				loaded: /*data*/ ctx[0].loaded
    			},
    			$$inline: true
    		});

    	kpicell1 = new KPICell({
    			props: {
    				units: /*data*/ ctx[0].units,
    				data: /*data*/ ctx[0].column2,
    				indicator: /*indicator*/ ctx[1],
    				loaded: /*data*/ ctx[0].loaded
    			},
    			$$inline: true
    		});

    	let if_block = /*hasGraph*/ ctx[4] && create_if_block_1$b(ctx);

    	kpideviations = new KPIDeviations({
    			props: {
    				indicator: /*indicator*/ ctx[1],
    				data: /*data*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(kpicell0.$$.fragment);
    			t0 = space();
    			create_component(kpicell1.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			create_component(kpideviations.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(kpicell0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(kpicell1, target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(kpideviations, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const kpicell0_changes = {};
    			if (dirty & /*data*/ 1) kpicell0_changes.units = /*data*/ ctx[0].units;
    			if (dirty & /*data*/ 1) kpicell0_changes.data = /*data*/ ctx[0].column1;
    			if (dirty & /*indicator*/ 2) kpicell0_changes.indicator = /*indicator*/ ctx[1];
    			if (dirty & /*data*/ 1) kpicell0_changes.loaded = /*data*/ ctx[0].loaded;
    			kpicell0.$set(kpicell0_changes);
    			const kpicell1_changes = {};
    			if (dirty & /*data*/ 1) kpicell1_changes.units = /*data*/ ctx[0].units;
    			if (dirty & /*data*/ 1) kpicell1_changes.data = /*data*/ ctx[0].column2;
    			if (dirty & /*indicator*/ 2) kpicell1_changes.indicator = /*indicator*/ ctx[1];
    			if (dirty & /*data*/ 1) kpicell1_changes.loaded = /*data*/ ctx[0].loaded;
    			kpicell1.$set(kpicell1_changes);

    			if (/*hasGraph*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*hasGraph*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$b(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t2.parentNode, t2);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const kpideviations_changes = {};
    			if (dirty & /*indicator*/ 2) kpideviations_changes.indicator = /*indicator*/ ctx[1];
    			if (dirty & /*data*/ 1) kpideviations_changes.data = /*data*/ ctx[0];
    			kpideviations.$set(kpideviations_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(kpicell0.$$.fragment, local);
    			transition_in(kpicell1.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(kpideviations.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(kpicell0.$$.fragment, local);
    			transition_out(kpicell1.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(kpideviations.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(kpicell0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(kpicell1, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(kpideviations, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$I.name,
    		type: "if",
    		source: "(51:4) {#if data }",
    		ctx
    	});

    	return block;
    }

    // (64:6) {#if hasGraph}
    function create_if_block_1$b(ctx) {
    	let kpigraph;
    	let current;

    	kpigraph = new KPIGraph({
    			props: {
    				indicator: /*indicator*/ ctx[1],
    				isInverted: /*isInverted*/ ctx[2],
    				units: /*data*/ ctx[0].units,
    				data: /*data*/ ctx[0].graphs
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(kpigraph.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(kpigraph, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const kpigraph_changes = {};
    			if (dirty & /*indicator*/ 2) kpigraph_changes.indicator = /*indicator*/ ctx[1];
    			if (dirty & /*isInverted*/ 4) kpigraph_changes.isInverted = /*isInverted*/ ctx[2];
    			if (dirty & /*data*/ 1) kpigraph_changes.units = /*data*/ ctx[0].units;
    			if (dirty & /*data*/ 1) kpigraph_changes.data = /*data*/ ctx[0].graphs;
    			kpigraph.$set(kpigraph_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(kpigraph.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(kpigraph.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(kpigraph, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(64:6) {#if hasGraph}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2b(ctx) {
    	let div;
    	let kpilabel;
    	let t;
    	let div_transition;
    	let current;

    	kpilabel = new KPILabel({
    			props: {
    				data: /*data*/ ctx[0],
    				indicator: /*indicator*/ ctx[1]
    			},
    			$$inline: true
    		});

    	let if_block = /*data*/ ctx[0] && create_if_block$I(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(kpilabel.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "txcm-kpiRow");
    			toggle_class(div, "txcm-kpiRow-has-deviations", /*hasDeviations*/ ctx[5](/*data*/ ctx[0]));
    			toggle_class(div, "txcm-kpiRow-has-graph", /*hasGraph*/ ctx[4]);
    			toggle_class(div, "txcm-kpiRow-loaded", /*data*/ ctx[0].allLoaded);
    			add_location(div, file$1S, 41, 0, 1111);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(kpilabel, div, null);
    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const kpilabel_changes = {};
    			if (dirty & /*data*/ 1) kpilabel_changes.data = /*data*/ ctx[0];
    			if (dirty & /*indicator*/ 2) kpilabel_changes.indicator = /*indicator*/ ctx[1];
    			kpilabel.$set(kpilabel_changes);

    			if (/*data*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*data*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$I(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*hasDeviations, data*/ 33) {
    				toggle_class(div, "txcm-kpiRow-has-deviations", /*hasDeviations*/ ctx[5](/*data*/ ctx[0]));
    			}

    			if (dirty & /*hasGraph*/ 16) {
    				toggle_class(div, "txcm-kpiRow-has-graph", /*hasGraph*/ ctx[4]);
    			}

    			if (dirty & /*data*/ 1) {
    				toggle_class(div, "txcm-kpiRow-loaded", /*data*/ ctx[0].allLoaded);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(kpilabel.$$.fragment, local);
    			transition_in(if_block);

    			if (local) {
    				add_render_callback(() => {
    					if (!div_transition) div_transition = create_bidirectional_transition(div, shiftVertical, { height: /*height*/ ctx[3] }, true);
    					div_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(kpilabel.$$.fragment, local);
    			transition_out(if_block);

    			if (local) {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, shiftVertical, { height: /*height*/ ctx[3] }, false);
    				div_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(kpilabel);
    			if (if_block) if_block.d();
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const BASE_HEIGHT = 110;
    const DEVIATION_HEIGHT = 32;

    function calculateHeight(data) {
    	let height = BASE_HEIGHT;
    	height += data.formatDeviations ? DEVIATION_HEIGHT : 0;
    	height += data.regionDeviations ? DEVIATION_HEIGHT : 0;
    	return height;
    }

    function instance$2b($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { indicator } = $$props;
    	let isInverted = false;

    	function hasDeviations() {
    		return data.regionDeviations && data.regionDeviations.countDeviation > 0 || data.formatDeviation && data.formatDeviation.countDeviation > 0;
    	}

    	function checkInverted() {
    		const arrow = data.column1.arrow ? data.column1.arrow.qNum : 0;
    		$$invalidate(2, isInverted = arrow === 2 || arrow === 3);
    	}

    	const writable_props = ["data", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<KPIRow> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("KPIRow", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		BASE_HEIGHT,
    		DEVIATION_HEIGHT,
    		calculateHeight,
    		shiftVertical,
    		KPILabel,
    		KPICell,
    		KPIDeviations,
    		KPIGraph,
    		data,
    		indicator,
    		isInverted,
    		hasDeviations,
    		checkInverted,
    		height,
    		hasGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("isInverted" in $$props) $$invalidate(2, isInverted = $$props.isInverted);
    		if ("height" in $$props) $$invalidate(3, height = $$props.height);
    		if ("hasGraph" in $$props) $$invalidate(4, hasGraph = $$props.hasGraph);
    	};

    	let height;
    	let hasGraph;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 1) {
    			 $$invalidate(3, height = calculateHeight(data));
    		}

    		if ($$self.$$.dirty & /*data*/ 1) {
    			 $$invalidate(4, hasGraph = !!data.graphs);
    		}

    		if ($$self.$$.dirty & /*data*/ 1) {
    			 checkInverted();
    		}
    	};

    	return [data, indicator, isInverted, height, hasGraph, hasDeviations];
    }

    class KPIRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2b, create_fragment$2b, safe_not_equal, { data: 0, indicator: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KPIRow",
    			options,
    			id: create_fragment$2b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<KPIRow> was created without expected prop 'data'");
    		}

    		if (/*indicator*/ ctx[1] === undefined && !("indicator" in props)) {
    			console.warn("<KPIRow> was created without expected prop 'indicator'");
    		}
    	}

    	get data() {
    		throw new Error("<KPIRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<KPIRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<KPIRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<KPIRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/kpi/KPIGroup.svelte generated by Svelte v3.24.0 */
    const file$1T = "src/js/components/kpi/KPIGroup.svelte";

    // (9:0) {#if hasIndicators}
    function create_if_block$J(ctx) {
    	let div;
    	let span;
    	let int;
    	let t;
    	let current;

    	int = new Int({
    			props: { key: /*label*/ ctx[0] },
    			$$inline: true
    		});

    	const default_slot_template = /*$$slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[2], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			create_component(int.$$.fragment);
    			t = space();
    			if (default_slot) default_slot.c();
    			attr_dev(span, "class", "txcm-kpiText");
    			set_style(span, "font-weight", "600");
    			add_location(span, file$1T, 10, 4, 243);
    			attr_dev(div, "class", "txcm-kpiLabel-is-small");
    			set_style(div, "margin-left", "32px");
    			add_location(div, file$1T, 9, 2, 176);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			mount_component(int, span, null);
    			insert_dev(target, t, anchor);

    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*label*/ 1) int_changes.key = /*label*/ ctx[0];
    			int.$set(int_changes);

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[2], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    			if (detaching) detach_dev(t);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$J.name,
    		type: "if",
    		source: "(9:0) {#if hasIndicators}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2c(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*hasIndicators*/ ctx[1] && create_if_block$J(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*hasIndicators*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*hasIndicators*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$J(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2c($$self, $$props, $$invalidate) {
    	let { label = null } = $$props;
    	let { hasIndicators = false } = $$props;
    	const writable_props = ["label", "hasIndicators"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<KPIGroup> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("KPIGroup", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("hasIndicators" in $$props) $$invalidate(1, hasIndicators = $$props.hasIndicators);
    		if ("$$scope" in $$props) $$invalidate(2, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ Int, label, hasIndicators });

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("hasIndicators" in $$props) $$invalidate(1, hasIndicators = $$props.hasIndicators);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [label, hasIndicators, $$scope, $$slots];
    }

    class KPIGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2c, create_fragment$2c, safe_not_equal, { label: 0, hasIndicators: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "KPIGroup",
    			options,
    			id: create_fragment$2c.name
    		});
    	}

    	get label() {
    		throw new Error("<KPIGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<KPIGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hasIndicators() {
    		throw new Error("<KPIGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hasIndicators(value) {
    		throw new Error("<KPIGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/overview/OverviewIndicators.svelte generated by Svelte v3.24.0 */

    const { Object: Object_1$3 } = globals;
    const file$1U = "src/js/components/overview/OverviewIndicators.svelte";

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[17] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	return child_ctx;
    }

    function get_each_context$v(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (72:10) {#if activeIndicator.id == indicator.id}
    function create_if_block$K(ctx) {
    	let kpirow;
    	let current;

    	kpirow = new KPIRow({
    			props: {
    				indicator: /*indicators*/ ctx[2][/*activeIndicator*/ ctx[17].id],
    				data: /*activeIndicator*/ ctx[17]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(kpirow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(kpirow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const kpirow_changes = {};
    			if (dirty & /*active*/ 1) kpirow_changes.indicator = /*indicators*/ ctx[2][/*activeIndicator*/ ctx[17].id];
    			if (dirty & /*active*/ 1) kpirow_changes.data = /*activeIndicator*/ ctx[17];
    			kpirow.$set(kpirow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(kpirow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(kpirow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(kpirow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$K.name,
    		type: "if",
    		source: "(72:10) {#if activeIndicator.id == indicator.id}",
    		ctx
    	});

    	return block;
    }

    // (71:8) {#each active as activeIndicator (activeIndicator.id)}
    function create_each_block_2(key_1, ctx) {
    	let first;
    	let if_block_anchor;
    	let current;
    	let if_block = /*activeIndicator*/ ctx[17].id == /*indicator*/ ctx[14].id && create_if_block$K(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*activeIndicator*/ ctx[17].id == /*indicator*/ ctx[14].id) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*active, filtered*/ 3) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$K(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(71:8) {#each active as activeIndicator (activeIndicator.id)}",
    		ctx
    	});

    	return block;
    }

    // (70:6) {#each group.indicators as indicator (indicator.id)}
    function create_each_block_1$4(key_1, ctx) {
    	let first;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value_2 = /*active*/ ctx[0];
    	validate_each_argument(each_value_2);
    	const get_key = ctx => /*activeIndicator*/ ctx[17].id;
    	validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		let child_ctx = get_each_context_2(ctx, each_value_2, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_2(key, child_ctx));
    	}

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*indicators, active, filtered*/ 7) {
    				const each_value_2 = /*active*/ ctx[0];
    				validate_each_argument(each_value_2);
    				group_outros();
    				validate_each_keys(ctx, each_value_2, get_each_context_2, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_2, each_1_anchor, get_each_context_2);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(70:6) {#each group.indicators as indicator (indicator.id)}",
    		ctx
    	});

    	return block;
    }

    // (66:4) <KPIGroup       label={group.label}       hasIndicators={hasIndicators(group)}     >
    function create_default_slot$A(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t;
    	let current;
    	let each_value_1 = /*group*/ ctx[11].indicators;
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*indicator*/ ctx[14].id;
    	validate_each_keys(ctx, each_value_1, get_each_context_1$4, get_key);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$4(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block_1$4(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*active, indicators, filtered*/ 7) {
    				const each_value_1 = /*group*/ ctx[11].indicators;
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$4, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, t.parentNode, outro_and_destroy_block, create_each_block_1$4, t, get_each_context_1$4);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$A.name,
    		type: "slot",
    		source: "(66:4) <KPIGroup       label={group.label}       hasIndicators={hasIndicators(group)}     >",
    		ctx
    	});

    	return block;
    }

    // (65:2) {#each filtered as group}
    function create_each_block$v(ctx) {
    	let kpigroup;
    	let current;

    	kpigroup = new KPIGroup({
    			props: {
    				label: /*group*/ ctx[11].label,
    				hasIndicators: /*hasIndicators*/ ctx[4](/*group*/ ctx[11]),
    				$$slots: { default: [create_default_slot$A] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(kpigroup.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(kpigroup, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const kpigroup_changes = {};
    			if (dirty & /*filtered*/ 2) kpigroup_changes.label = /*group*/ ctx[11].label;
    			if (dirty & /*filtered*/ 2) kpigroup_changes.hasIndicators = /*hasIndicators*/ ctx[4](/*group*/ ctx[11]);

    			if (dirty & /*$$scope, filtered, active*/ 1048579) {
    				kpigroup_changes.$$scope = { dirty, ctx };
    			}

    			kpigroup.$set(kpigroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(kpigroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(kpigroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(kpigroup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$v.name,
    		type: "each",
    		source: "(65:2) {#each filtered as group}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2d(ctx) {
    	let div;
    	let sectionScroll_action;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*filtered*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$v(get_each_context$v(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-overviewRows");
    			add_location(div, file$1U, 60, 0, 1570);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(sectionScroll_action = sectionScroll.call(null, div, true));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*filtered, hasIndicators, active, indicators*/ 23) {
    				each_value = /*filtered*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$v(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$v(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function flattenIndicators(results, indicator) {
    	return { ...results, [indicator.id]: indicator };
    }

    function flattenCategories(results, group) {
    	return {
    		...results,
    		...group.indicators.reduce(flattenIndicators, {})
    	};
    }

    function instance$2d($$self, $$props, $$invalidate) {
    	let $activeIndicators;
    	let { data } = $$props;
    	const config = getContext("config").getIndicatorsConfig();
    	const indicators = Object.values(config).reduce(flattenCategories, {});
    	const activeIndicators = getActiveIndicatorsState();
    	validate_store(activeIndicators, "activeIndicators");
    	component_subscribe($$self, activeIndicators, value => $$invalidate(6, $activeIndicators = value));
    	let active = [];
    	let filtered = [];

    	function findActiveIndicator(option) {
    		return $activeIndicators.find(id => `${option.id}` === `${id}`);
    	}

    	function sortOrder(option1, option2) {
    		const order1 = indicators[option1.id].order;
    		const order2 = indicators[option2.id].order;
    		return order1 - order2;
    	}

    	function updateActive() {
    		if (data && data.length) {
    			$$invalidate(0, active = data.filter(findActiveIndicator).sort(sortOrder));
    			$$invalidate(1, filtered = filterIndicatorCategories(config, ""));
    		}
    	}

    	function hasIndicators(group) {
    		return group.indicators.some(item => {
    			return active.some(item2 => item2.id == item.id);
    		});
    	}

    	const writable_props = ["data"];

    	Object_1$3.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<OverviewIndicators> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("OverviewIndicators", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(5, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		getActiveIndicatorsState,
    		sectionScroll,
    		filterIndicatorCategories,
    		KPIRow,
    		KPIGroup,
    		data,
    		config,
    		indicators,
    		activeIndicators,
    		active,
    		filtered,
    		flattenIndicators,
    		flattenCategories,
    		findActiveIndicator,
    		sortOrder,
    		updateActive,
    		hasIndicators,
    		$activeIndicators
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(5, data = $$props.data);
    		if ("active" in $$props) $$invalidate(0, active = $$props.active);
    		if ("filtered" in $$props) $$invalidate(1, filtered = $$props.filtered);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$activeIndicators, data*/ 96) {
    			 updateActive();
    		}
    	};

    	return [active, filtered, indicators, activeIndicators, hasIndicators, data];
    }

    class OverviewIndicators extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2d, create_fragment$2d, safe_not_equal, { data: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "OverviewIndicators",
    			options,
    			id: create_fragment$2d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[5] === undefined && !("data" in props)) {
    			console.warn("<OverviewIndicators> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<OverviewIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<OverviewIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/overview/Overview.svelte generated by Svelte v3.24.0 */
    const file$1V = "src/js/components/overview/Overview.svelte";

    // (22:4) {#if overviewData}
    function create_if_block$L(ctx) {
    	let overviewindicators;
    	let current;

    	overviewindicators = new OverviewIndicators({
    			props: {
    				data: /*overviewData*/ ctx[2],
    				units: /*units*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(overviewindicators.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(overviewindicators, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const overviewindicators_changes = {};
    			if (dirty & /*overviewData*/ 4) overviewindicators_changes.data = /*overviewData*/ ctx[2];
    			if (dirty & /*units*/ 2) overviewindicators_changes.units = /*units*/ ctx[1];
    			overviewindicators.$set(overviewindicators_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(overviewindicators.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(overviewindicators.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(overviewindicators, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$L.name,
    		type: "if",
    		source: "(22:4) {#if overviewData}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2e(ctx) {
    	let section;
    	let overviewtableheader;
    	let t;
    	let current;

    	overviewtableheader = new OverviewTableHeader({
    			props: { dashboard: /*dashboard*/ ctx[0] },
    			$$inline: true
    		});

    	let if_block = /*overviewData*/ ctx[2] && create_if_block$L(ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			create_component(overviewtableheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(section, "class", "txcm-overviewSection");
    			add_location(section, file$1V, 17, 0, 337);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			mount_component(overviewtableheader, section, null);
    			append_dev(section, t);
    			if (if_block) if_block.m(section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const overviewtableheader_changes = {};
    			if (dirty & /*dashboard*/ 1) overviewtableheader_changes.dashboard = /*dashboard*/ ctx[0];
    			overviewtableheader.$set(overviewtableheader_changes);

    			if (/*overviewData*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*overviewData*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$L(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(section, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(overviewtableheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(overviewtableheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(overviewtableheader);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2e($$self, $$props, $$invalidate) {
    	let { data = null } = $$props;
    	let { dashboard } = $$props;
    	let { units = null } = $$props;
    	let overviewData;

    	function updateData() {
    		$$invalidate(2, overviewData = data || null);
    	}

    	const writable_props = ["data", "dashboard", "units"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Overview> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Overview", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("units" in $$props) $$invalidate(1, units = $$props.units);
    	};

    	$$self.$capture_state = () => ({
    		OverviewTableHeader,
    		OverviewIndicators,
    		data,
    		dashboard,
    		units,
    		overviewData,
    		updateData
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("units" in $$props) $$invalidate(1, units = $$props.units);
    		if ("overviewData" in $$props) $$invalidate(2, overviewData = $$props.overviewData);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 8) {
    			 updateData();
    		}
    	};

    	return [dashboard, units, overviewData, data];
    }

    class Overview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2e, create_fragment$2e, safe_not_equal, { data: 3, dashboard: 0, units: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Overview",
    			options,
    			id: create_fragment$2e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[0] === undefined && !("dashboard" in props)) {
    			console.warn("<Overview> was created without expected prop 'dashboard'");
    		}
    	}

    	get data() {
    		throw new Error("<Overview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Overview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dashboard() {
    		throw new Error("<Overview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<Overview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<Overview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<Overview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slices/SlicesTableHeader.svelte generated by Svelte v3.24.0 */
    const file$1W = "src/js/components/slices/SlicesTableHeader.svelte";

    function create_fragment$2f(ctx) {
    	let div;
    	let switch_instance;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[1]];
    	var switch_value = /*pickHeader*/ ctx[4](/*dashboard*/ ctx[0]);

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			attr_dev(div, "class", "txcm-slicesHeader");
    			add_location(div, file$1W, 36, 0, 909);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, div, null);
    			}

    			/*div_binding*/ ctx[6](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = (dirty & /*props*/ 2)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[1])])
    			: {};

    			if (switch_value !== (switch_value = /*pickHeader*/ ctx[4](/*dashboard*/ ctx[0]))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, div, null);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (switch_instance) destroy_component(switch_instance);
    			/*div_binding*/ ctx[6](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2f($$self, $$props, $$invalidate) {
    	let $sectionScrollX;

    	const TABLE_HEADERS = {
    		financial: TableHeaderFinOverview,
    		operational: TableHeaderOpOverview
    	};

    	let { dashboard } = $$props;
    	let { indicator } = $$props;
    	let props;
    	const sectionScrollX = getUIState("sectionScrollX");
    	validate_store(sectionScrollX, "sectionScrollX");
    	component_subscribe($$self, sectionScrollX, value => $$invalidate(7, $sectionScrollX = value));
    	let node;

    	function updateProps() {
    		$$invalidate(1, props = { indicator });
    	}

    	function pickHeader() {
    		if (TABLE_HEADERS[dashboard]) return TABLE_HEADERS[dashboard];
    		return TABLE_HEADERS.financial;
    	}

    	function updateScroll() {
    		if (node) $$invalidate(2, node.scrollLeft = $sectionScrollX, node);
    	}

    	const writable_props = ["dashboard", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SlicesTableHeader> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SlicesTableHeader", $$slots, []);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			node = $$value;
    			$$invalidate(2, node);
    		});
    	}

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(5, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getUIState,
    		TableHeaderFinancialOverview: TableHeaderFinOverview,
    		TableHeaderOperationalOverview: TableHeaderOpOverview,
    		TABLE_HEADERS,
    		dashboard,
    		indicator,
    		props,
    		sectionScrollX,
    		node,
    		updateProps,
    		pickHeader,
    		updateScroll,
    		$sectionScrollX
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(5, indicator = $$props.indicator);
    		if ("props" in $$props) $$invalidate(1, props = $$props.props);
    		if ("node" in $$props) $$invalidate(2, node = $$props.node);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$sectionScrollX*/ 128) {
    			 updateScroll();
    		}

    		if ($$self.$$.dirty & /*indicator*/ 32) {
    			 updateProps();
    		}
    	};

    	return [dashboard, props, node, sectionScrollX, pickHeader, indicator, div_binding];
    }

    class SlicesTableHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2f, create_fragment$2f, safe_not_equal, { dashboard: 0, indicator: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SlicesTableHeader",
    			options,
    			id: create_fragment$2f.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[0] === undefined && !("dashboard" in props)) {
    			console.warn("<SlicesTableHeader> was created without expected prop 'dashboard'");
    		}

    		if (/*indicator*/ ctx[5] === undefined && !("indicator" in props)) {
    			console.warn("<SlicesTableHeader> was created without expected prop 'indicator'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<SlicesTableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<SlicesTableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<SlicesTableHeader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<SlicesTableHeader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slices/SlicesTabs.svelte generated by Svelte v3.24.0 */
    const file$1X = "src/js/components/slices/SlicesTabs.svelte";

    function create_fragment$2g(ctx) {
    	let button0;
    	let int0;
    	let t;
    	let button1;
    	let int1;
    	let current;
    	let mounted;
    	let dispose;
    	int0 = new Int({ props: { key: "Все" }, $$inline: true });

    	int1 = new Int({
    			props: { key: "Отклонения" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			create_component(int0.$$.fragment);
    			t = space();
    			button1 = element("button");
    			create_component(int1.$$.fragment);
    			attr_dev(button0, "class", "txcm-slicesTab");
    			toggle_class(button0, "txcm-slicesTab-is-active", /*isAllActive*/ ctx[2](/*isActive*/ ctx[0], /*showDeviations*/ ctx[1]));
    			add_location(button0, file$1X, 26, 0, 513);
    			attr_dev(button1, "class", "txcm-slicesTab");
    			toggle_class(button1, "txcm-slicesTab-is-active", /*isDeviationsActive*/ ctx[3](/*isActive*/ ctx[0], /*showDeviations*/ ctx[1]));
    			add_location(button1, file$1X, 33, 0, 682);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			mount_component(int0, button0, null);
    			insert_dev(target, t, anchor);
    			insert_dev(target, button1, anchor);
    			mount_component(int1, button1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*onClickAll*/ ctx[4], false, false, false),
    					listen_dev(button1, "click", /*onClickDeviations*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*isAllActive, isActive, showDeviations*/ 7) {
    				toggle_class(button0, "txcm-slicesTab-is-active", /*isAllActive*/ ctx[2](/*isActive*/ ctx[0], /*showDeviations*/ ctx[1]));
    			}

    			if (dirty & /*isDeviationsActive, isActive, showDeviations*/ 11) {
    				toggle_class(button1, "txcm-slicesTab-is-active", /*isDeviationsActive*/ ctx[3](/*isActive*/ ctx[0], /*showDeviations*/ ctx[1]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			destroy_component(int0);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(button1);
    			destroy_component(int1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2g($$self, $$props, $$invalidate) {
    	let { isActive } = $$props;
    	let { showDeviations } = $$props;
    	const dispatch = createEventDispatcher();

    	function isAllActive() {
    		return isActive && !showDeviations;
    	}

    	function isDeviationsActive() {
    		return isActive && showDeviations;
    	}

    	function onClickAll() {
    		dispatch("tabsall");
    	}

    	function onClickDeviations() {
    		dispatch("tabsdeviations");
    	}

    	const writable_props = ["isActive", "showDeviations"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SlicesTabs> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SlicesTabs", $$slots, []);

    	$$self.$set = $$props => {
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    		if ("showDeviations" in $$props) $$invalidate(1, showDeviations = $$props.showDeviations);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		Int,
    		isActive,
    		showDeviations,
    		dispatch,
    		isAllActive,
    		isDeviationsActive,
    		onClickAll,
    		onClickDeviations
    	});

    	$$self.$inject_state = $$props => {
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    		if ("showDeviations" in $$props) $$invalidate(1, showDeviations = $$props.showDeviations);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isActive,
    		showDeviations,
    		isAllActive,
    		isDeviationsActive,
    		onClickAll,
    		onClickDeviations
    	];
    }

    class SlicesTabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2g, create_fragment$2g, safe_not_equal, { isActive: 0, showDeviations: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SlicesTabs",
    			options,
    			id: create_fragment$2g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*isActive*/ ctx[0] === undefined && !("isActive" in props)) {
    			console.warn("<SlicesTabs> was created without expected prop 'isActive'");
    		}

    		if (/*showDeviations*/ ctx[1] === undefined && !("showDeviations" in props)) {
    			console.warn("<SlicesTabs> was created without expected prop 'showDeviations'");
    		}
    	}

    	get isActive() {
    		throw new Error("<SlicesTabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isActive(value) {
    		throw new Error("<SlicesTabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get showDeviations() {
    		throw new Error("<SlicesTabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set showDeviations(value) {
    		throw new Error("<SlicesTabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slice/SliceLabel.svelte generated by Svelte v3.24.0 */
    const file$1Y = "src/js/components/slice/SliceLabel.svelte";

    function create_fragment$2h(ctx) {
    	let div;
    	let int;
    	let current;

    	int = new Int({
    			props: { key: /*label*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(int.$$.fragment);
    			attr_dev(div, "class", "txcm-sliceLabel");
    			add_location(div, file$1Y, 6, 0, 110);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(int, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const int_changes = {};
    			if (dirty & /*label*/ 1) int_changes.key = /*label*/ ctx[0];
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2h($$self, $$props, $$invalidate) {
    	let { label } = $$props;
    	const writable_props = ["label"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SliceLabel> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SliceLabel", $$slots, []);

    	$$self.$set = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    	};

    	$$self.$capture_state = () => ({ Int, label });

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [label];
    }

    class SliceLabel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2h, create_fragment$2h, safe_not_equal, { label: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SliceLabel",
    			options,
    			id: create_fragment$2h.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*label*/ ctx[0] === undefined && !("label" in props)) {
    			console.warn("<SliceLabel> was created without expected prop 'label'");
    		}
    	}

    	get label() {
    		throw new Error("<SliceLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<SliceLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slice/SliceRow.svelte generated by Svelte v3.24.0 */

    const file$1Z = "src/js/components/slice/SliceRow.svelte";

    function create_fragment$2i(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "txcm-sliceRow");
    			toggle_class(div, "txcm-sliceRow-has-graph", /*hasGraph*/ ctx[0]);
    			add_location(div, file$1Z, 4, 0, 43);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}

    			if (dirty & /*hasGraph*/ 1) {
    				toggle_class(div, "txcm-sliceRow-has-graph", /*hasGraph*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2i($$self, $$props, $$invalidate) {
    	let { hasGraph } = $$props;
    	const writable_props = ["hasGraph"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SliceRow> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SliceRow", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("hasGraph" in $$props) $$invalidate(0, hasGraph = $$props.hasGraph);
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ hasGraph });

    	$$self.$inject_state = $$props => {
    		if ("hasGraph" in $$props) $$invalidate(0, hasGraph = $$props.hasGraph);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [hasGraph, $$scope, $$slots];
    }

    class SliceRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2i, create_fragment$2i, safe_not_equal, { hasGraph: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SliceRow",
    			options,
    			id: create_fragment$2i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*hasGraph*/ ctx[0] === undefined && !("hasGraph" in props)) {
    			console.warn("<SliceRow> was created without expected prop 'hasGraph'");
    		}
    	}

    	get hasGraph() {
    		throw new Error("<SliceRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hasGraph(value) {
    		throw new Error("<SliceRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slice/SliceColumn.svelte generated by Svelte v3.24.0 */

    const file$1_ = "src/js/components/slice/SliceColumn.svelte";

    function create_fragment$2j(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "txcm-sliceColumn");
    			add_location(div, file$1_, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2j($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SliceColumn> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SliceColumn", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, $$slots];
    }

    class SliceColumn extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2j, create_fragment$2j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SliceColumn",
    			options,
    			id: create_fragment$2j.name
    		});
    	}
    }

    /* src/js/components/slice/SliceValueMain.svelte generated by Svelte v3.24.0 */

    const file$1$ = "src/js/components/slice/SliceValueMain.svelte";

    function create_fragment$2k(ctx) {
    	let div;
    	let svg;
    	let use;
    	let svg_class_value;
    	let t;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t = space();
    			if (default_slot) default_slot.c();
    			xlink_attr(use, "xlink:href", "#txspt-icons-fatArrow");
    			add_location(use, file$1$, 10, 8, 291);
    			attr_dev(svg, "class", svg_class_value = renderArrowDynamicsClass("txcm-sliceValueIcon", /*dynamics*/ ctx[0]));
    			add_location(svg, file$1$, 8, 4, 205);
    			attr_dev(div, "class", div_class_value = renderArrowDynamicsClass("txcm-sliceValue", /*dynamics*/ ctx[0]));
    			add_location(div, file$1$, 6, 0, 131);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, use);
    			append_dev(div, t);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*dynamics*/ 1 && svg_class_value !== (svg_class_value = renderArrowDynamicsClass("txcm-sliceValueIcon", /*dynamics*/ ctx[0]))) {
    				attr_dev(svg, "class", svg_class_value);
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*dynamics*/ 1 && div_class_value !== (div_class_value = renderArrowDynamicsClass("txcm-sliceValue", /*dynamics*/ ctx[0]))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2k($$self, $$props, $$invalidate) {
    	let { dynamics } = $$props;
    	const writable_props = ["dynamics"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SliceValueMain> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SliceValueMain", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("dynamics" in $$props) $$invalidate(0, dynamics = $$props.dynamics);
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		renderDynamicsClass,
    		renderArrowDynamicsClass,
    		dynamics
    	});

    	$$self.$inject_state = $$props => {
    		if ("dynamics" in $$props) $$invalidate(0, dynamics = $$props.dynamics);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dynamics, $$scope, $$slots];
    }

    class SliceValueMain extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2k, create_fragment$2k, safe_not_equal, { dynamics: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SliceValueMain",
    			options,
    			id: create_fragment$2k.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dynamics*/ ctx[0] === undefined && !("dynamics" in props)) {
    			console.warn("<SliceValueMain> was created without expected prop 'dynamics'");
    		}
    	}

    	get dynamics() {
    		throw new Error("<SliceValueMain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dynamics(value) {
    		throw new Error("<SliceValueMain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slice/SliceValueAdd.svelte generated by Svelte v3.24.0 */
    const file$20 = "src/js/components/slice/SliceValueAdd.svelte";

    function create_fragment$2l(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", div_class_value = renderDynamicsClass("txcm-sliceValueAdd", /*dynamics*/ ctx[0]));
    			add_location(div, file$20, 6, 0, 109);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*dynamics*/ 1 && div_class_value !== (div_class_value = renderDynamicsClass("txcm-sliceValueAdd", /*dynamics*/ ctx[0]))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2l($$self, $$props, $$invalidate) {
    	let { dynamics = 0 } = $$props;
    	const writable_props = ["dynamics"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SliceValueAdd> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SliceValueAdd", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("dynamics" in $$props) $$invalidate(0, dynamics = $$props.dynamics);
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ renderDynamicsClass, dynamics });

    	$$self.$inject_state = $$props => {
    		if ("dynamics" in $$props) $$invalidate(0, dynamics = $$props.dynamics);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dynamics, $$scope, $$slots];
    }

    class SliceValueAdd extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2l, create_fragment$2l, safe_not_equal, { dynamics: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SliceValueAdd",
    			options,
    			id: create_fragment$2l.name
    		});
    	}

    	get dynamics() {
    		throw new Error("<SliceValueAdd>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dynamics(value) {
    		throw new Error("<SliceValueAdd>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slice/SliceValue.svelte generated by Svelte v3.24.0 */

    // (14:0) <svelte:component   {dynamics}   this={pickValueType(status)}>
    function create_default_slot$B(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[3].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[4], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 16) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[4], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$B.name,
    		type: "slot",
    		source: "(14:0) <svelte:component   {dynamics}   this={pickValueType(status)}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2m(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*pickValueType*/ ctx[2](/*status*/ ctx[1]);

    	function switch_props(ctx) {
    		return {
    			props: {
    				dynamics: /*dynamics*/ ctx[0],
    				$$slots: { default: [create_default_slot$B] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const switch_instance_changes = {};
    			if (dirty & /*dynamics*/ 1) switch_instance_changes.dynamics = /*dynamics*/ ctx[0];

    			if (dirty & /*$$scope*/ 16) {
    				switch_instance_changes.$$scope = { dirty, ctx };
    			}

    			if (switch_value !== (switch_value = /*pickValueType*/ ctx[2](/*status*/ ctx[1]))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2m($$self, $$props, $$invalidate) {
    	let { dynamics = false } = $$props;
    	let { status = false } = $$props;

    	function pickValueType() {
    		if (status) return SliceValueMain;
    		return SliceValueAdd;
    	}

    	const writable_props = ["dynamics", "status"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SliceValue> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SliceValue", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("dynamics" in $$props) $$invalidate(0, dynamics = $$props.dynamics);
    		if ("status" in $$props) $$invalidate(1, status = $$props.status);
    		if ("$$scope" in $$props) $$invalidate(4, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		SliceValueMain,
    		SliceValueAdd,
    		dynamics,
    		status,
    		pickValueType
    	});

    	$$self.$inject_state = $$props => {
    		if ("dynamics" in $$props) $$invalidate(0, dynamics = $$props.dynamics);
    		if ("status" in $$props) $$invalidate(1, status = $$props.status);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dynamics, status, pickValueType, $$slots, $$scope];
    }

    class SliceValue extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2m, create_fragment$2m, safe_not_equal, { dynamics: 0, status: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SliceValue",
    			options,
    			id: create_fragment$2m.name
    		});
    	}

    	get dynamics() {
    		throw new Error("<SliceValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dynamics(value) {
    		throw new Error("<SliceValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get status() {
    		throw new Error("<SliceValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set status(value) {
    		throw new Error("<SliceValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slice/SliceCell.svelte generated by Svelte v3.24.0 */
    const file$21 = "src/js/components/slice/SliceCell.svelte";

    // (22:6) <SliceValue         dynamics={!arrow ? -1 : arrow.qNum}         status={true}>
    function create_default_slot_5$1(ctx) {
    	let t_value = (/*fact*/ ctx[1]
    	? formatLabel(/*fact*/ ctx[1].qNum, /*units*/ ctx[0], "", /*base*/ ctx[5])
    	: "-") + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fact, units, base*/ 35 && t_value !== (t_value = (/*fact*/ ctx[1]
    			? formatLabel(/*fact*/ ctx[1].qNum, /*units*/ ctx[0], "", /*base*/ ctx[5])
    			: "-") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(22:6) <SliceValue         dynamics={!arrow ? -1 : arrow.qNum}         status={true}>",
    		ctx
    	});

    	return block;
    }

    // (21:4) <SliceColumn>
    function create_default_slot_4$1(ctx) {
    	let slicevalue;
    	let current;

    	slicevalue = new SliceValue({
    			props: {
    				dynamics: !/*arrow*/ ctx[4] ? -1 : /*arrow*/ ctx[4].qNum,
    				status: true,
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(slicevalue.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slicevalue, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slicevalue_changes = {};
    			if (dirty & /*arrow*/ 16) slicevalue_changes.dynamics = !/*arrow*/ ctx[4] ? -1 : /*arrow*/ ctx[4].qNum;

    			if (dirty & /*$$scope, fact, units, base*/ 291) {
    				slicevalue_changes.$$scope = { dirty, ctx };
    			}

    			slicevalue.$set(slicevalue_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slicevalue.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slicevalue.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slicevalue, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(21:4) <SliceColumn>",
    		ctx
    	});

    	return block;
    }

    // (29:6) <SliceValue         dynamics={factVsPpPercent ? checkArrowDynamics(fact ? fact.qNum : 0, factVsPpPercent.qNum, !arrow ? -1 : arrow.qNum) : 0}>
    function create_default_slot_3$4(ctx) {
    	let t_value = (/*factVsPpPercent*/ ctx[3]
    	? formatLabel(/*factVsPpPercent*/ ctx[3].qNum, "%")
    	: "-") + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*factVsPpPercent*/ 8 && t_value !== (t_value = (/*factVsPpPercent*/ ctx[3]
    			? formatLabel(/*factVsPpPercent*/ ctx[3].qNum, "%")
    			: "-") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(29:6) <SliceValue         dynamics={factVsPpPercent ? checkArrowDynamics(fact ? fact.qNum : 0, factVsPpPercent.qNum, !arrow ? -1 : arrow.qNum) : 0}>",
    		ctx
    	});

    	return block;
    }

    // (28:4) <SliceColumn>
    function create_default_slot_2$5(ctx) {
    	let slicevalue;
    	let current;

    	slicevalue = new SliceValue({
    			props: {
    				dynamics: /*factVsPpPercent*/ ctx[3]
    				? checkArrowDynamics(/*fact*/ ctx[1] ? /*fact*/ ctx[1].qNum : 0, /*factVsPpPercent*/ ctx[3].qNum, !/*arrow*/ ctx[4] ? -1 : /*arrow*/ ctx[4].qNum)
    				: 0,
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(slicevalue.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slicevalue, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slicevalue_changes = {};

    			if (dirty & /*factVsPpPercent, fact, arrow*/ 26) slicevalue_changes.dynamics = /*factVsPpPercent*/ ctx[3]
    			? checkArrowDynamics(/*fact*/ ctx[1] ? /*fact*/ ctx[1].qNum : 0, /*factVsPpPercent*/ ctx[3].qNum, !/*arrow*/ ctx[4] ? -1 : /*arrow*/ ctx[4].qNum)
    			: 0;

    			if (dirty & /*$$scope, factVsPpPercent*/ 264) {
    				slicevalue_changes.$$scope = { dirty, ctx };
    			}

    			slicevalue.$set(slicevalue_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slicevalue.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slicevalue.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slicevalue, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(28:4) <SliceColumn>",
    		ctx
    	});

    	return block;
    }

    // (35:6) <SliceValue         dynamics={factVsBudgetPercent ? checkArrowDynamics(fact ? fact.qNum : 0, factVsBudgetPercent.qNum, !arrow ? -1 : arrow.qNum) : 0}>
    function create_default_slot_1$a(ctx) {
    	let t_value = (/*factVsBudgetPercent*/ ctx[2]
    	? formatLabel(/*factVsBudgetPercent*/ ctx[2].qNum, "%")
    	: "-") + "";

    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*factVsBudgetPercent*/ 4 && t_value !== (t_value = (/*factVsBudgetPercent*/ ctx[2]
    			? formatLabel(/*factVsBudgetPercent*/ ctx[2].qNum, "%")
    			: "-") + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(35:6) <SliceValue         dynamics={factVsBudgetPercent ? checkArrowDynamics(fact ? fact.qNum : 0, factVsBudgetPercent.qNum, !arrow ? -1 : arrow.qNum) : 0}>",
    		ctx
    	});

    	return block;
    }

    // (34:4) <SliceColumn>
    function create_default_slot$C(ctx) {
    	let slicevalue;
    	let current;

    	slicevalue = new SliceValue({
    			props: {
    				dynamics: /*factVsBudgetPercent*/ ctx[2]
    				? checkArrowDynamics(/*fact*/ ctx[1] ? /*fact*/ ctx[1].qNum : 0, /*factVsBudgetPercent*/ ctx[2].qNum, !/*arrow*/ ctx[4] ? -1 : /*arrow*/ ctx[4].qNum)
    				: 0,
    				$$slots: { default: [create_default_slot_1$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(slicevalue.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slicevalue, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slicevalue_changes = {};

    			if (dirty & /*factVsBudgetPercent, fact, arrow*/ 22) slicevalue_changes.dynamics = /*factVsBudgetPercent*/ ctx[2]
    			? checkArrowDynamics(/*fact*/ ctx[1] ? /*fact*/ ctx[1].qNum : 0, /*factVsBudgetPercent*/ ctx[2].qNum, !/*arrow*/ ctx[4] ? -1 : /*arrow*/ ctx[4].qNum)
    			: 0;

    			if (dirty & /*$$scope, factVsBudgetPercent*/ 260) {
    				slicevalue_changes.$$scope = { dirty, ctx };
    			}

    			slicevalue.$set(slicevalue_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slicevalue.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slicevalue.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slicevalue, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$C.name,
    		type: "slot",
    		source: "(34:4) <SliceColumn>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2n(ctx) {
    	let div;
    	let slicecolumn0;
    	let t0;
    	let slicecolumn1;
    	let t1;
    	let slicecolumn2;
    	let current;

    	slicecolumn0 = new SliceColumn({
    			props: {
    				$$slots: { default: [create_default_slot_4$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	slicecolumn1 = new SliceColumn({
    			props: {
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	slicecolumn2 = new SliceColumn({
    			props: {
    				$$slots: { default: [create_default_slot$C] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(slicecolumn0.$$.fragment);
    			t0 = space();
    			create_component(slicecolumn1.$$.fragment);
    			t1 = space();
    			create_component(slicecolumn2.$$.fragment);
    			attr_dev(div, "class", "txcm-sliceCell");
    			add_location(div, file$21, 18, 0, 511);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(slicecolumn0, div, null);
    			append_dev(div, t0);
    			mount_component(slicecolumn1, div, null);
    			append_dev(div, t1);
    			mount_component(slicecolumn2, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const slicecolumn0_changes = {};

    			if (dirty & /*$$scope, arrow, fact, units, base*/ 307) {
    				slicecolumn0_changes.$$scope = { dirty, ctx };
    			}

    			slicecolumn0.$set(slicecolumn0_changes);
    			const slicecolumn1_changes = {};

    			if (dirty & /*$$scope, factVsPpPercent, fact, arrow*/ 282) {
    				slicecolumn1_changes.$$scope = { dirty, ctx };
    			}

    			slicecolumn1.$set(slicecolumn1_changes);
    			const slicecolumn2_changes = {};

    			if (dirty & /*$$scope, factVsBudgetPercent, fact, arrow*/ 278) {
    				slicecolumn2_changes.$$scope = { dirty, ctx };
    			}

    			slicecolumn2.$set(slicecolumn2_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slicecolumn0.$$.fragment, local);
    			transition_in(slicecolumn1.$$.fragment, local);
    			transition_in(slicecolumn2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slicecolumn0.$$.fragment, local);
    			transition_out(slicecolumn1.$$.fragment, local);
    			transition_out(slicecolumn2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(slicecolumn0);
    			destroy_component(slicecolumn1);
    			destroy_component(slicecolumn2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2n($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { units } = $$props;
    	let { indicator } = $$props;
    	const writable_props = ["data", "units", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SliceCell> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SliceCell", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(6, data = $$props.data);
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("indicator" in $$props) $$invalidate(7, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		checkArrowDynamics,
    		compareDynamics,
    		SliceColumn,
    		SliceValue,
    		formatLabel,
    		data,
    		units,
    		indicator,
    		fact,
    		factVsBudgetPercent,
    		factVsPpPercent,
    		arrow,
    		base
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(6, data = $$props.data);
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("indicator" in $$props) $$invalidate(7, indicator = $$props.indicator);
    		if ("fact" in $$props) $$invalidate(1, fact = $$props.fact);
    		if ("factVsBudgetPercent" in $$props) $$invalidate(2, factVsBudgetPercent = $$props.factVsBudgetPercent);
    		if ("factVsPpPercent" in $$props) $$invalidate(3, factVsPpPercent = $$props.factVsPpPercent);
    		if ("arrow" in $$props) $$invalidate(4, arrow = $$props.arrow);
    		if ("base" in $$props) $$invalidate(5, base = $$props.base);
    	};

    	let fact;
    	let factVsBudgetPercent;
    	let factVsPpPercent;
    	let arrow;
    	let base;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 64) {
    			 $$invalidate(1, fact = data.fact);
    		}

    		if ($$self.$$.dirty & /*data*/ 64) {
    			 $$invalidate(2, factVsBudgetPercent = data.factVsBudgetPercent);
    		}

    		if ($$self.$$.dirty & /*data*/ 64) {
    			 $$invalidate(3, factVsPpPercent = data.factVsPpPercent);
    		}

    		if ($$self.$$.dirty & /*data*/ 64) {
    			 $$invalidate(4, arrow = data.arrow);
    		}

    		if ($$self.$$.dirty & /*indicator*/ 128) {
    			 $$invalidate(5, base = indicator.id != "4" ? 1000000 : 1);
    		}
    	};

    	return [
    		units,
    		fact,
    		factVsBudgetPercent,
    		factVsPpPercent,
    		arrow,
    		base,
    		data,
    		indicator
    	];
    }

    class SliceCell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2n, create_fragment$2n, safe_not_equal, { data: 6, units: 0, indicator: 7 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SliceCell",
    			options,
    			id: create_fragment$2n.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[6] === undefined && !("data" in props)) {
    			console.warn("<SliceCell> was created without expected prop 'data'");
    		}

    		if (/*units*/ ctx[0] === undefined && !("units" in props)) {
    			console.warn("<SliceCell> was created without expected prop 'units'");
    		}

    		if (/*indicator*/ ctx[7] === undefined && !("indicator" in props)) {
    			console.warn("<SliceCell> was created without expected prop 'indicator'");
    		}
    	}

    	get data() {
    		throw new Error("<SliceCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<SliceCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<SliceCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<SliceCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<SliceCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<SliceCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slice/SliceGraph.svelte generated by Svelte v3.24.0 */
    const file$22 = "src/js/components/slice/SliceGraph.svelte";

    function create_fragment$2o(ctx) {
    	let div1;
    	let div0;
    	let barchart;
    	let current;

    	barchart = new BarChart({
    			props: {
    				isInverted: /*isInverted*/ ctx[1],
    				indicator: /*indicator*/ ctx[0],
    				data: /*fragment*/ ctx[2],
    				count: /*$count*/ ctx[3],
    				step: /*$step*/ ctx[6],
    				shift: /*$shift*/ ctx[5]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(barchart.$$.fragment);
    			attr_dev(div0, "class", "txcm-sliceGraphHolder");
    			add_location(div0, file$22, 63, 4, 2229);
    			attr_dev(div1, "class", "txcm-sliceGraph");
    			set_style(div1, "--highlightWidth", 100 / /*$count*/ ctx[3] + "%");
    			set_style(div1, "--highlightPosition", 100 * /*$highlighted*/ ctx[4] + "%");
    			set_style(div1, "--highlightOpacity", /*$highlighted*/ ctx[4] === null ? 0 : 1);
    			set_style(div1, "--highlightShift", /*$shift*/ ctx[5] + "px");
    			add_location(div1, file$22, 60, 0, 2022);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(barchart, div0, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const barchart_changes = {};
    			if (dirty & /*isInverted*/ 2) barchart_changes.isInverted = /*isInverted*/ ctx[1];
    			if (dirty & /*indicator*/ 1) barchart_changes.indicator = /*indicator*/ ctx[0];
    			if (dirty & /*fragment*/ 4) barchart_changes.data = /*fragment*/ ctx[2];
    			if (dirty & /*$count*/ 8) barchart_changes.count = /*$count*/ ctx[3];
    			if (dirty & /*$step*/ 64) barchart_changes.step = /*$step*/ ctx[6];
    			if (dirty & /*$shift*/ 32) barchart_changes.shift = /*$shift*/ ctx[5];
    			barchart.$set(barchart_changes);

    			if (!current || dirty & /*$count*/ 8) {
    				set_style(div1, "--highlightWidth", 100 / /*$count*/ ctx[3] + "%");
    			}

    			if (!current || dirty & /*$highlighted*/ 16) {
    				set_style(div1, "--highlightPosition", 100 * /*$highlighted*/ ctx[4] + "%");
    			}

    			if (!current || dirty & /*$highlighted*/ 16) {
    				set_style(div1, "--highlightOpacity", /*$highlighted*/ ctx[4] === null ? 0 : 1);
    			}

    			if (!current || dirty & /*$shift*/ 32) {
    				set_style(div1, "--highlightShift", /*$shift*/ ctx[5] + "px");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(barchart.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(barchart.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(barchart);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2o($$self, $$props, $$invalidate) {
    	let $dynamics;
    	let $date;
    	let $count;
    	let $highlighted;
    	let $shift;
    	let $step;
    	let { data } = $$props;
    	let { indicator } = $$props;
    	let { isInverted } = $$props;
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(15, $date = value));
    	const dynamics = getGraphsState("dynamics");
    	validate_store(dynamics, "dynamics");
    	component_subscribe($$self, dynamics, value => $$invalidate(14, $dynamics = value));
    	const step = getGraphsState("step");
    	validate_store(step, "step");
    	component_subscribe($$self, step, value => $$invalidate(6, $step = value));
    	const count = getGraphsState("count");
    	validate_store(count, "count");
    	component_subscribe($$self, count, value => $$invalidate(3, $count = value));
    	const highlighted = getGraphsState("highlighted");
    	validate_store(highlighted, "highlighted");
    	component_subscribe($$self, highlighted, value => $$invalidate(4, $highlighted = value));
    	const shift = getGraphsState("shift");
    	validate_store(shift, "shift");
    	component_subscribe($$self, shift, value => $$invalidate(5, $shift = value));
    	let fragment;

    	function fillData(data) {
    		if (!data) return [];
    		if ($dynamics === "graphDetailDay") return fillDayData(data, $date);
    		if ($dynamics === "graphDetailWeek") return fillWeekData(data, $date);
    		if ($dynamics === "graphDetailMonth") return fillMonthData(data, $date);
    		if ($dynamics === "graphDetailQuarter") return fillQuaterData(data, $date);
    		if ($dynamics === "graphDetailYear") return fillYearData(data, $date);
    		return data;
    	}

    	function filterData(data) {
    		if (!data) return [];
    		const datePoP = calculateDatePoP($date, $dynamics);
    		if ($dynamics === "graphDetailDay" || $dynamics === "graphDetailAvgCheck") return filterDayData(data, $date, datePoP);
    		if ($dynamics === "graphDetailWeek") return filterWeekData(data, $date, datePoP);
    		if ($dynamics === "graphDetailMonth") return filterMonthData(data, $date, datePoP);
    		if ($dynamics === "graphDetailQuarter") return filterQuarterData(data, $date, datePoP);
    		if ($dynamics === "graphDetailYear") return filterYearData(data);
    		return data;
    	}

    	function updateFragments() {
    		$$invalidate(2, fragment = filterData(data.series));
    		$$invalidate(2, fragment = fillData(fragment));
    	}

    	const writable_props = ["data", "indicator", "isInverted"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SliceGraph> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SliceGraph", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(13, data = $$props.data);
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("isInverted" in $$props) $$invalidate(1, isInverted = $$props.isInverted);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		getGraphsState,
    		calculateDatePoP,
    		filterDayData,
    		filterWeekData,
    		filterMonthData,
    		filterQuarterData,
    		filterYearData,
    		fillDayData,
    		fillWeekData,
    		fillMonthData,
    		fillQuaterData,
    		fillYearData,
    		BarChart,
    		data,
    		indicator,
    		isInverted,
    		date,
    		dynamics,
    		step,
    		count,
    		highlighted,
    		shift,
    		fragment,
    		fillData,
    		filterData,
    		updateFragments,
    		$dynamics,
    		$date,
    		$count,
    		$highlighted,
    		$shift,
    		$step
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(13, data = $$props.data);
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("isInverted" in $$props) $$invalidate(1, isInverted = $$props.isInverted);
    		if ("fragment" in $$props) $$invalidate(2, fragment = $$props.fragment);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 8192) {
    			 updateFragments();
    		}
    	};

    	return [
    		indicator,
    		isInverted,
    		fragment,
    		$count,
    		$highlighted,
    		$shift,
    		$step,
    		date,
    		dynamics,
    		step,
    		count,
    		highlighted,
    		shift,
    		data
    	];
    }

    class SliceGraph extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2o, create_fragment$2o, safe_not_equal, { data: 13, indicator: 0, isInverted: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SliceGraph",
    			options,
    			id: create_fragment$2o.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[13] === undefined && !("data" in props)) {
    			console.warn("<SliceGraph> was created without expected prop 'data'");
    		}

    		if (/*indicator*/ ctx[0] === undefined && !("indicator" in props)) {
    			console.warn("<SliceGraph> was created without expected prop 'indicator'");
    		}

    		if (/*isInverted*/ ctx[1] === undefined && !("isInverted" in props)) {
    			console.warn("<SliceGraph> was created without expected prop 'isInverted'");
    		}
    	}

    	get data() {
    		throw new Error("<SliceGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<SliceGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<SliceGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<SliceGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isInverted() {
    		throw new Error("<SliceGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isInverted(value) {
    		throw new Error("<SliceGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slice/Slice.svelte generated by Svelte v3.24.0 */

    // (34:4) {#if row}
    function create_if_block$M(ctx) {
    	let slicelabel;
    	let t0;
    	let slicecell0;
    	let t1;
    	let slicecell1;
    	let t2;
    	let if_block_anchor;
    	let current;

    	slicelabel = new SliceLabel({
    			props: { label: /*row*/ ctx[0].name },
    			$$inline: true
    		});

    	slicecell0 = new SliceCell({
    			props: {
    				indicator: /*indicator*/ ctx[2],
    				units: /*units*/ ctx[1],
    				data: /*row*/ ctx[0].column1
    			},
    			$$inline: true
    		});

    	slicecell1 = new SliceCell({
    			props: {
    				indicator: /*indicator*/ ctx[2],
    				units: /*units*/ ctx[1],
    				data: /*row*/ ctx[0].column2
    			},
    			$$inline: true
    		});

    	let if_block = /*hasGraph*/ ctx[4] && create_if_block_1$c(ctx);

    	const block = {
    		c: function create() {
    			create_component(slicelabel.$$.fragment);
    			t0 = space();
    			create_component(slicecell0.$$.fragment);
    			t1 = space();
    			create_component(slicecell1.$$.fragment);
    			t2 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(slicelabel, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(slicecell0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(slicecell1, target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slicelabel_changes = {};
    			if (dirty & /*row*/ 1) slicelabel_changes.label = /*row*/ ctx[0].name;
    			slicelabel.$set(slicelabel_changes);
    			const slicecell0_changes = {};
    			if (dirty & /*indicator*/ 4) slicecell0_changes.indicator = /*indicator*/ ctx[2];
    			if (dirty & /*units*/ 2) slicecell0_changes.units = /*units*/ ctx[1];
    			if (dirty & /*row*/ 1) slicecell0_changes.data = /*row*/ ctx[0].column1;
    			slicecell0.$set(slicecell0_changes);
    			const slicecell1_changes = {};
    			if (dirty & /*indicator*/ 4) slicecell1_changes.indicator = /*indicator*/ ctx[2];
    			if (dirty & /*units*/ 2) slicecell1_changes.units = /*units*/ ctx[1];
    			if (dirty & /*row*/ 1) slicecell1_changes.data = /*row*/ ctx[0].column2;
    			slicecell1.$set(slicecell1_changes);

    			if (/*hasGraph*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*hasGraph*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slicelabel.$$.fragment, local);
    			transition_in(slicecell0.$$.fragment, local);
    			transition_in(slicecell1.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slicelabel.$$.fragment, local);
    			transition_out(slicecell0.$$.fragment, local);
    			transition_out(slicecell1.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slicelabel, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(slicecell0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(slicecell1, detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$M.name,
    		type: "if",
    		source: "(34:4) {#if row}",
    		ctx
    	});

    	return block;
    }

    // (47:6) {#if hasGraph}
    function create_if_block_1$c(ctx) {
    	let slicegraph;
    	let current;

    	slicegraph = new SliceGraph({
    			props: {
    				isInverted: /*isInverted*/ ctx[3],
    				indicator: /*indicator*/ ctx[2],
    				data: /*row*/ ctx[0].graphs
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(slicegraph.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slicegraph, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slicegraph_changes = {};
    			if (dirty & /*isInverted*/ 8) slicegraph_changes.isInverted = /*isInverted*/ ctx[3];
    			if (dirty & /*indicator*/ 4) slicegraph_changes.indicator = /*indicator*/ ctx[2];
    			if (dirty & /*row*/ 1) slicegraph_changes.data = /*row*/ ctx[0].graphs;
    			slicegraph.$set(slicegraph_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slicegraph.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slicegraph.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slicegraph, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(47:6) {#if hasGraph}",
    		ctx
    	});

    	return block;
    }

    // (32:0) <SliceRow   {hasGraph}>
    function create_default_slot$D(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*row*/ ctx[0] && create_if_block$M(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*row*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*row*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$M(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$D.name,
    		type: "slot",
    		source: "(32:0) <SliceRow   {hasGraph}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2p(ctx) {
    	let slicerow;
    	let current;

    	slicerow = new SliceRow({
    			props: {
    				hasGraph: /*hasGraph*/ ctx[4],
    				$$slots: { default: [create_default_slot$D] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(slicerow.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(slicerow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const slicerow_changes = {};
    			if (dirty & /*hasGraph*/ 16) slicerow_changes.hasGraph = /*hasGraph*/ ctx[4];

    			if (dirty & /*$$scope, isInverted, indicator, row, hasGraph, units*/ 95) {
    				slicerow_changes.$$scope = { dirty, ctx };
    			}

    			slicerow.$set(slicerow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slicerow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slicerow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slicerow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function sortGraph(graph1, graph2) {
    	if (graph1.name > graph2.name) return 1; else if (graph1.name < graph2.name) return -1;
    	return 0;
    }

    function sortGraphCategory(category) {
    	category.data.sort(sortGraph);
    }

    function instance$2p($$self, $$props, $$invalidate) {
    	let { row } = $$props;
    	let { units } = $$props;
    	let { indicator } = $$props;
    	let { isInverted } = $$props;

    	function sortGraphs() {
    		if (row && row.graphs) {
    			row.graphs.series.forEach(sortGraphCategory);
    		}
    	}

    	const writable_props = ["row", "units", "indicator", "isInverted"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Slice> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Slice", $$slots, []);

    	$$self.$set = $$props => {
    		if ("row" in $$props) $$invalidate(0, row = $$props.row);
    		if ("units" in $$props) $$invalidate(1, units = $$props.units);
    		if ("indicator" in $$props) $$invalidate(2, indicator = $$props.indicator);
    		if ("isInverted" in $$props) $$invalidate(3, isInverted = $$props.isInverted);
    	};

    	$$self.$capture_state = () => ({
    		SliceLabel,
    		SliceRow,
    		SliceCell,
    		SliceGraph,
    		row,
    		units,
    		indicator,
    		isInverted,
    		sortGraph,
    		sortGraphCategory,
    		sortGraphs,
    		hasGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ("row" in $$props) $$invalidate(0, row = $$props.row);
    		if ("units" in $$props) $$invalidate(1, units = $$props.units);
    		if ("indicator" in $$props) $$invalidate(2, indicator = $$props.indicator);
    		if ("isInverted" in $$props) $$invalidate(3, isInverted = $$props.isInverted);
    		if ("hasGraph" in $$props) $$invalidate(4, hasGraph = $$props.hasGraph);
    	};

    	let hasGraph;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*row*/ 1) {
    			 $$invalidate(4, hasGraph = !!row.graphs);
    		}

    		if ($$self.$$.dirty & /*row*/ 1) {
    			 sortGraphs();
    		}
    	};

    	return [row, units, indicator, isInverted, hasGraph];
    }

    class Slice extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$2p, create_fragment$2p, safe_not_equal, {
    			row: 0,
    			units: 1,
    			indicator: 2,
    			isInverted: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Slice",
    			options,
    			id: create_fragment$2p.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*row*/ ctx[0] === undefined && !("row" in props)) {
    			console.warn("<Slice> was created without expected prop 'row'");
    		}

    		if (/*units*/ ctx[1] === undefined && !("units" in props)) {
    			console.warn("<Slice> was created without expected prop 'units'");
    		}

    		if (/*indicator*/ ctx[2] === undefined && !("indicator" in props)) {
    			console.warn("<Slice> was created without expected prop 'indicator'");
    		}

    		if (/*isInverted*/ ctx[3] === undefined && !("isInverted" in props)) {
    			console.warn("<Slice> was created without expected prop 'isInverted'");
    		}
    	}

    	get row() {
    		throw new Error("<Slice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set row(value) {
    		throw new Error("<Slice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<Slice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<Slice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<Slice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<Slice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isInverted() {
    		throw new Error("<Slice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isInverted(value) {
    		throw new Error("<Slice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slices/SlicesTable.svelte generated by Svelte v3.24.0 */

    function get_each_context$w(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (33:0) {#each fragment as row (row.name)}
    function create_each_block$w(key_1, ctx) {
    	let first;
    	let slice;
    	let current;

    	slice = new Slice({
    			props: {
    				isInverted: /*isInverted*/ ctx[2],
    				indicator: /*indicator*/ ctx[1],
    				units: /*units*/ ctx[0],
    				row: /*row*/ ctx[7]
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(slice.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(slice, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slice_changes = {};
    			if (dirty & /*isInverted*/ 4) slice_changes.isInverted = /*isInverted*/ ctx[2];
    			if (dirty & /*indicator*/ 2) slice_changes.indicator = /*indicator*/ ctx[1];
    			if (dirty & /*units*/ 1) slice_changes.units = /*units*/ ctx[0];
    			if (dirty & /*fragment*/ 8) slice_changes.row = /*row*/ ctx[7];
    			slice.$set(slice_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slice.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slice.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(slice, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$w.name,
    		type: "each",
    		source: "(33:0) {#each fragment as row (row.name)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2q(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = /*fragment*/ ctx[3];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*row*/ ctx[7].name;
    	validate_each_keys(ctx, each_value, get_each_context$w, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$w(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$w(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*isInverted, indicator, units, fragment*/ 15) {
    				const each_value = /*fragment*/ ctx[3];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$w, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$w, each_1_anchor, get_each_context$w);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function checkValues(value) {
    	return value && value.qNum !== null && (value.qNum !== "NaN" || !isNaN(value.qNum));
    }

    function checkColumnData(column) {
    	return ["fact", "factVsPpPercent", "factVsBudgetPercent"].some(key => checkValues(column[key]));
    }

    function filterRow(row) {
    	return ["column1", "column2"].some(key => checkColumnData(row[key]));
    }

    function instance$2q($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { units } = $$props;
    	let { indicator } = $$props;
    	let { isInverted } = $$props;
    	let { hasData } = $$props;
    	let fragment;

    	function updateFragment() {
    		$$invalidate(3, fragment = data.filter(filterRow));
    		$$invalidate(4, hasData = fragment && fragment.length > 0);
    	}

    	const writable_props = ["data", "units", "indicator", "isInverted", "hasData"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SlicesTable> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SlicesTable", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(5, data = $$props.data);
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("isInverted" in $$props) $$invalidate(2, isInverted = $$props.isInverted);
    		if ("hasData" in $$props) $$invalidate(4, hasData = $$props.hasData);
    	};

    	$$self.$capture_state = () => ({
    		Slice,
    		data,
    		units,
    		indicator,
    		isInverted,
    		hasData,
    		fragment,
    		checkValues,
    		checkColumnData,
    		filterRow,
    		updateFragment
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(5, data = $$props.data);
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("isInverted" in $$props) $$invalidate(2, isInverted = $$props.isInverted);
    		if ("hasData" in $$props) $$invalidate(4, hasData = $$props.hasData);
    		if ("fragment" in $$props) $$invalidate(3, fragment = $$props.fragment);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 32) {
    			 updateFragment();
    		}
    	};

    	return [units, indicator, isInverted, fragment, hasData, data];
    }

    class SlicesTable extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$2q, create_fragment$2q, safe_not_equal, {
    			data: 5,
    			units: 0,
    			indicator: 1,
    			isInverted: 2,
    			hasData: 4
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SlicesTable",
    			options,
    			id: create_fragment$2q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[5] === undefined && !("data" in props)) {
    			console.warn("<SlicesTable> was created without expected prop 'data'");
    		}

    		if (/*units*/ ctx[0] === undefined && !("units" in props)) {
    			console.warn("<SlicesTable> was created without expected prop 'units'");
    		}

    		if (/*indicator*/ ctx[1] === undefined && !("indicator" in props)) {
    			console.warn("<SlicesTable> was created without expected prop 'indicator'");
    		}

    		if (/*isInverted*/ ctx[2] === undefined && !("isInverted" in props)) {
    			console.warn("<SlicesTable> was created without expected prop 'isInverted'");
    		}

    		if (/*hasData*/ ctx[4] === undefined && !("hasData" in props)) {
    			console.warn("<SlicesTable> was created without expected prop 'hasData'");
    		}
    	}

    	get data() {
    		throw new Error("<SlicesTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<SlicesTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<SlicesTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<SlicesTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<SlicesTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<SlicesTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isInverted() {
    		throw new Error("<SlicesTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isInverted(value) {
    		throw new Error("<SlicesTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hasData() {
    		throw new Error("<SlicesTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hasData(value) {
    		throw new Error("<SlicesTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slices/SlicesCategory.svelte generated by Svelte v3.24.0 */
    const file$23 = "src/js/components/slices/SlicesCategory.svelte";

    // (81:6) {#if hasDeviations}
    function create_if_block_1$d(ctx) {
    	let slicestabs;
    	let current;

    	slicestabs = new SlicesTabs({
    			props: {
    				isActive: /*isActive*/ ctx[6],
    				showDeviations: /*showDeviations*/ ctx[7]
    			},
    			$$inline: true
    		});

    	slicestabs.$on("tabsall", /*onTabsAll*/ ctx[9]);
    	slicestabs.$on("tabsdeviations", /*onTabsDeviations*/ ctx[10]);

    	const block = {
    		c: function create() {
    			create_component(slicestabs.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slicestabs, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slicestabs_changes = {};
    			if (dirty & /*isActive*/ 64) slicestabs_changes.isActive = /*isActive*/ ctx[6];
    			if (dirty & /*showDeviations*/ 128) slicestabs_changes.showDeviations = /*showDeviations*/ ctx[7];
    			slicestabs.$set(slicestabs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slicestabs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slicestabs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slicestabs, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(81:6) {#if hasDeviations}",
    		ctx
    	});

    	return block;
    }

    // (89:4) {#if isActive}
    function create_if_block$N(ctx) {
    	let slicestable;
    	let updating_hasData;
    	let current;

    	function slicestable_hasData_binding(value) {
    		/*slicestable_hasData_binding*/ ctx[15].call(null, value);
    	}

    	let slicestable_props = {
    		isInverted: /*isInverted*/ ctx[5],
    		indicator: /*indicator*/ ctx[4],
    		units: /*units*/ ctx[3],
    		data: /*filteredData*/ ctx[8]
    	};

    	if (/*hasData*/ ctx[1] !== void 0) {
    		slicestable_props.hasData = /*hasData*/ ctx[1];
    	}

    	slicestable = new SlicesTable({ props: slicestable_props, $$inline: true });
    	binding_callbacks.push(() => bind(slicestable, "hasData", slicestable_hasData_binding));

    	const block = {
    		c: function create() {
    			create_component(slicestable.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slicestable, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slicestable_changes = {};
    			if (dirty & /*isInverted*/ 32) slicestable_changes.isInverted = /*isInverted*/ ctx[5];
    			if (dirty & /*indicator*/ 16) slicestable_changes.indicator = /*indicator*/ ctx[4];
    			if (dirty & /*units*/ 8) slicestable_changes.units = /*units*/ ctx[3];
    			if (dirty & /*filteredData*/ 256) slicestable_changes.data = /*filteredData*/ ctx[8];

    			if (!updating_hasData && dirty & /*hasData*/ 2) {
    				updating_hasData = true;
    				slicestable_changes.hasData = /*hasData*/ ctx[1];
    				add_flush_callback(() => updating_hasData = false);
    			}

    			slicestable.$set(slicestable_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slicestable.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slicestable.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slicestable, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$N.name,
    		type: "if",
    		source: "(89:4) {#if isActive}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2r(ctx) {
    	let div1;
    	let div0;
    	let button;
    	let svg;
    	let use;
    	let t0;
    	let int;
    	let t1;
    	let t2;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*label*/ ctx[2] },
    			$$inline: true
    		});

    	let if_block0 = /*hasDeviations*/ ctx[0] && create_if_block_1$d(ctx);
    	let if_block1 = /*isActive*/ ctx[6] && create_if_block$N(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			button = element("button");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t0 = space();
    			create_component(int.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			xlink_attr(use, "xlink:href", "#txspt-icons-angleArrow");
    			add_location(use, file$23, 74, 14, 1721);
    			attr_dev(svg, "class", "txcm-slicesToggleIcon");
    			toggle_class(svg, "txcm-slicesToggleIcon-is-active", /*isActive*/ ctx[6]);
    			add_location(svg, file$23, 71, 10, 1598);
    			attr_dev(button, "class", "txcm-slicesToggle");
    			toggle_class(button, "txcm-slicesToggle-is-active", /*isActive*/ ctx[6]);
    			add_location(button, file$23, 67, 6, 1459);
    			attr_dev(div0, "class", "txcm-slicesCategoryControls");
    			add_location(div0, file$23, 66, 4, 1411);
    			attr_dev(div1, "class", "txcm-slicesCategory");
    			add_location(div1, file$23, 64, 0, 1371);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, button);
    			append_dev(button, svg);
    			append_dev(svg, use);
    			append_dev(button, t0);
    			mount_component(int, button, null);
    			append_dev(div0, t1);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div1, t2);
    			if (if_block1) if_block1.m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onToggleClick*/ ctx[11], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*isActive*/ 64) {
    				toggle_class(svg, "txcm-slicesToggleIcon-is-active", /*isActive*/ ctx[6]);
    			}

    			const int_changes = {};
    			if (dirty & /*label*/ 4) int_changes.key = /*label*/ ctx[2];
    			int.$set(int_changes);

    			if (dirty & /*isActive*/ 64) {
    				toggle_class(button, "txcm-slicesToggle-is-active", /*isActive*/ ctx[6]);
    			}

    			if (/*hasDeviations*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*hasDeviations*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$d(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*isActive*/ ctx[6]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*isActive*/ 64) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$N(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(int);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function checkFieldDeviations(field) {
    	return ["factVsBudgetPercent", "factVsPpPercent"].some(optionKey => field[optionKey] && field[optionKey].qNum < 0);
    }

    function checkOptionDeviations(option) {
    	return ["column1", "column2"].some(optionKey => checkFieldDeviations(option[optionKey]));
    }

    function instance$2r($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { label } = $$props;
    	let { key } = $$props;
    	let { tab } = $$props;
    	let { units } = $$props;
    	let { indicator } = $$props;
    	let { isInverted } = $$props;
    	let { hasDeviations } = $$props;
    	let { hasData } = $$props;
    	let isActive = !tab ? true : key === tab;
    	let showDeviations = key === tab;

    	function checkDeviations() {
    		$$invalidate(0, hasDeviations = data.some(checkOptionDeviations));
    	}

    	function toggle() {
    		$$invalidate(6, isActive = !isActive);
    	}

    	function onTabsAll() {
    		$$invalidate(7, showDeviations = false);
    		$$invalidate(6, isActive = true);
    	}

    	function onTabsDeviations() {
    		$$invalidate(7, showDeviations = true);
    		$$invalidate(6, isActive = true);
    	}

    	function onToggleClick() {
    		toggle();
    	}

    	function filterData() {
    		if (!showDeviations) return data;
    		return data.filter(checkOptionDeviations);
    	}

    	const writable_props = [
    		"data",
    		"label",
    		"key",
    		"tab",
    		"units",
    		"indicator",
    		"isInverted",
    		"hasDeviations",
    		"hasData"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SlicesCategory> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SlicesCategory", $$slots, []);

    	function slicestable_hasData_binding(value) {
    		hasData = value;
    		$$invalidate(1, hasData);
    	}

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(12, data = $$props.data);
    		if ("label" in $$props) $$invalidate(2, label = $$props.label);
    		if ("key" in $$props) $$invalidate(13, key = $$props.key);
    		if ("tab" in $$props) $$invalidate(14, tab = $$props.tab);
    		if ("units" in $$props) $$invalidate(3, units = $$props.units);
    		if ("indicator" in $$props) $$invalidate(4, indicator = $$props.indicator);
    		if ("isInverted" in $$props) $$invalidate(5, isInverted = $$props.isInverted);
    		if ("hasDeviations" in $$props) $$invalidate(0, hasDeviations = $$props.hasDeviations);
    		if ("hasData" in $$props) $$invalidate(1, hasData = $$props.hasData);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		SlicesTabs,
    		SlicesTable,
    		data,
    		label,
    		key,
    		tab,
    		units,
    		indicator,
    		isInverted,
    		hasDeviations,
    		hasData,
    		isActive,
    		showDeviations,
    		checkFieldDeviations,
    		checkOptionDeviations,
    		checkDeviations,
    		toggle,
    		onTabsAll,
    		onTabsDeviations,
    		onToggleClick,
    		filterData,
    		filteredData
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(12, data = $$props.data);
    		if ("label" in $$props) $$invalidate(2, label = $$props.label);
    		if ("key" in $$props) $$invalidate(13, key = $$props.key);
    		if ("tab" in $$props) $$invalidate(14, tab = $$props.tab);
    		if ("units" in $$props) $$invalidate(3, units = $$props.units);
    		if ("indicator" in $$props) $$invalidate(4, indicator = $$props.indicator);
    		if ("isInverted" in $$props) $$invalidate(5, isInverted = $$props.isInverted);
    		if ("hasDeviations" in $$props) $$invalidate(0, hasDeviations = $$props.hasDeviations);
    		if ("hasData" in $$props) $$invalidate(1, hasData = $$props.hasData);
    		if ("isActive" in $$props) $$invalidate(6, isActive = $$props.isActive);
    		if ("showDeviations" in $$props) $$invalidate(7, showDeviations = $$props.showDeviations);
    		if ("filteredData" in $$props) $$invalidate(8, filteredData = $$props.filteredData);
    	};

    	let filteredData;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data, showDeviations*/ 4224) {
    			 $$invalidate(8, filteredData = filterData());
    		}

    		if ($$self.$$.dirty & /*data, units*/ 4104) {
    			 checkDeviations();
    		}
    	};

    	return [
    		hasDeviations,
    		hasData,
    		label,
    		units,
    		indicator,
    		isInverted,
    		isActive,
    		showDeviations,
    		filteredData,
    		onTabsAll,
    		onTabsDeviations,
    		onToggleClick,
    		data,
    		key,
    		tab,
    		slicestable_hasData_binding
    	];
    }

    class SlicesCategory extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$2r, create_fragment$2r, safe_not_equal, {
    			data: 12,
    			label: 2,
    			key: 13,
    			tab: 14,
    			units: 3,
    			indicator: 4,
    			isInverted: 5,
    			hasDeviations: 0,
    			hasData: 1
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SlicesCategory",
    			options,
    			id: create_fragment$2r.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[12] === undefined && !("data" in props)) {
    			console.warn("<SlicesCategory> was created without expected prop 'data'");
    		}

    		if (/*label*/ ctx[2] === undefined && !("label" in props)) {
    			console.warn("<SlicesCategory> was created without expected prop 'label'");
    		}

    		if (/*key*/ ctx[13] === undefined && !("key" in props)) {
    			console.warn("<SlicesCategory> was created without expected prop 'key'");
    		}

    		if (/*tab*/ ctx[14] === undefined && !("tab" in props)) {
    			console.warn("<SlicesCategory> was created without expected prop 'tab'");
    		}

    		if (/*units*/ ctx[3] === undefined && !("units" in props)) {
    			console.warn("<SlicesCategory> was created without expected prop 'units'");
    		}

    		if (/*indicator*/ ctx[4] === undefined && !("indicator" in props)) {
    			console.warn("<SlicesCategory> was created without expected prop 'indicator'");
    		}

    		if (/*isInverted*/ ctx[5] === undefined && !("isInverted" in props)) {
    			console.warn("<SlicesCategory> was created without expected prop 'isInverted'");
    		}

    		if (/*hasDeviations*/ ctx[0] === undefined && !("hasDeviations" in props)) {
    			console.warn("<SlicesCategory> was created without expected prop 'hasDeviations'");
    		}

    		if (/*hasData*/ ctx[1] === undefined && !("hasData" in props)) {
    			console.warn("<SlicesCategory> was created without expected prop 'hasData'");
    		}
    	}

    	get data() {
    		throw new Error("<SlicesCategory>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<SlicesCategory>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<SlicesCategory>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<SlicesCategory>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get key() {
    		throw new Error("<SlicesCategory>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set key(value) {
    		throw new Error("<SlicesCategory>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tab() {
    		throw new Error("<SlicesCategory>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tab(value) {
    		throw new Error("<SlicesCategory>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<SlicesCategory>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<SlicesCategory>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<SlicesCategory>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<SlicesCategory>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isInverted() {
    		throw new Error("<SlicesCategory>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isInverted(value) {
    		throw new Error("<SlicesCategory>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hasDeviations() {
    		throw new Error("<SlicesCategory>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hasDeviations(value) {
    		throw new Error("<SlicesCategory>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hasData() {
    		throw new Error("<SlicesCategory>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hasData(value) {
    		throw new Error("<SlicesCategory>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slices/SlicesCategories.svelte generated by Svelte v3.24.0 */

    // (21:0) {#if shouldRender(formats) && hasFormats}
    function create_if_block_2$4(ctx) {
    	let slicescategory;
    	let updating_hasData;
    	let current;

    	function slicescategory_hasData_binding(value) {
    		/*slicescategory_hasData_binding*/ ctx[11].call(null, value);
    	}

    	let slicescategory_props = {
    		label: "Форматы",
    		data: /*formats*/ ctx[7],
    		key: "formats",
    		isInverted: /*isInverted*/ ctx[3],
    		indicator: /*indicator*/ ctx[2],
    		units: /*units*/ ctx[1],
    		tab: /*tab*/ ctx[0]
    	};

    	if (/*hasFormats*/ ctx[4] !== void 0) {
    		slicescategory_props.hasData = /*hasFormats*/ ctx[4];
    	}

    	slicescategory = new SlicesCategory({
    			props: slicescategory_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(slicescategory, "hasData", slicescategory_hasData_binding));

    	const block = {
    		c: function create() {
    			create_component(slicescategory.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slicescategory, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slicescategory_changes = {};
    			if (dirty & /*formats*/ 128) slicescategory_changes.data = /*formats*/ ctx[7];
    			if (dirty & /*isInverted*/ 8) slicescategory_changes.isInverted = /*isInverted*/ ctx[3];
    			if (dirty & /*indicator*/ 4) slicescategory_changes.indicator = /*indicator*/ ctx[2];
    			if (dirty & /*units*/ 2) slicescategory_changes.units = /*units*/ ctx[1];
    			if (dirty & /*tab*/ 1) slicescategory_changes.tab = /*tab*/ ctx[0];

    			if (!updating_hasData && dirty & /*hasFormats*/ 16) {
    				updating_hasData = true;
    				slicescategory_changes.hasData = /*hasFormats*/ ctx[4];
    				add_flush_callback(() => updating_hasData = false);
    			}

    			slicescategory.$set(slicescategory_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slicescategory.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slicescategory.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slicescategory, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(21:0) {#if shouldRender(formats) && hasFormats}",
    		ctx
    	});

    	return block;
    }

    // (32:0) {#if shouldRender(regions) && hasRegions}
    function create_if_block_1$e(ctx) {
    	let slicescategory;
    	let updating_hasData;
    	let current;

    	function slicescategory_hasData_binding_1(value) {
    		/*slicescategory_hasData_binding_1*/ ctx[12].call(null, value);
    	}

    	let slicescategory_props = {
    		label: "Округа",
    		data: /*regions*/ ctx[8],
    		key: "regions",
    		isInverted: /*isInverted*/ ctx[3],
    		indicator: /*indicator*/ ctx[2],
    		units: /*units*/ ctx[1],
    		tab: /*tab*/ ctx[0]
    	};

    	if (/*hasRegions*/ ctx[5] !== void 0) {
    		slicescategory_props.hasData = /*hasRegions*/ ctx[5];
    	}

    	slicescategory = new SlicesCategory({
    			props: slicescategory_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(slicescategory, "hasData", slicescategory_hasData_binding_1));

    	const block = {
    		c: function create() {
    			create_component(slicescategory.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slicescategory, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slicescategory_changes = {};
    			if (dirty & /*regions*/ 256) slicescategory_changes.data = /*regions*/ ctx[8];
    			if (dirty & /*isInverted*/ 8) slicescategory_changes.isInverted = /*isInverted*/ ctx[3];
    			if (dirty & /*indicator*/ 4) slicescategory_changes.indicator = /*indicator*/ ctx[2];
    			if (dirty & /*units*/ 2) slicescategory_changes.units = /*units*/ ctx[1];
    			if (dirty & /*tab*/ 1) slicescategory_changes.tab = /*tab*/ ctx[0];

    			if (!updating_hasData && dirty & /*hasRegions*/ 32) {
    				updating_hasData = true;
    				slicescategory_changes.hasData = /*hasRegions*/ ctx[5];
    				add_flush_callback(() => updating_hasData = false);
    			}

    			slicescategory.$set(slicescategory_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slicescategory.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slicescategory.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slicescategory, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(32:0) {#if shouldRender(regions) && hasRegions}",
    		ctx
    	});

    	return block;
    }

    // (43:0) {#if shouldRender(groups) && hasGroups}
    function create_if_block$O(ctx) {
    	let slicescategory;
    	let updating_hasData;
    	let current;

    	function slicescategory_hasData_binding_2(value) {
    		/*slicescategory_hasData_binding_2*/ ctx[13].call(null, value);
    	}

    	let slicescategory_props = {
    		label: "Категории",
    		data: /*groups*/ ctx[9],
    		key: "groups",
    		isInverted: /*isInverted*/ ctx[3],
    		indicator: /*indicator*/ ctx[2],
    		units: /*units*/ ctx[1],
    		tab: /*tab*/ ctx[0]
    	};

    	if (/*hasGroups*/ ctx[6] !== void 0) {
    		slicescategory_props.hasData = /*hasGroups*/ ctx[6];
    	}

    	slicescategory = new SlicesCategory({
    			props: slicescategory_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(slicescategory, "hasData", slicescategory_hasData_binding_2));

    	const block = {
    		c: function create() {
    			create_component(slicescategory.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slicescategory, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slicescategory_changes = {};
    			if (dirty & /*groups*/ 512) slicescategory_changes.data = /*groups*/ ctx[9];
    			if (dirty & /*isInverted*/ 8) slicescategory_changes.isInverted = /*isInverted*/ ctx[3];
    			if (dirty & /*indicator*/ 4) slicescategory_changes.indicator = /*indicator*/ ctx[2];
    			if (dirty & /*units*/ 2) slicescategory_changes.units = /*units*/ ctx[1];
    			if (dirty & /*tab*/ 1) slicescategory_changes.tab = /*tab*/ ctx[0];

    			if (!updating_hasData && dirty & /*hasGroups*/ 64) {
    				updating_hasData = true;
    				slicescategory_changes.hasData = /*hasGroups*/ ctx[6];
    				add_flush_callback(() => updating_hasData = false);
    			}

    			slicescategory.$set(slicescategory_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slicescategory.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slicescategory.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slicescategory, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$O.name,
    		type: "if",
    		source: "(43:0) {#if shouldRender(groups) && hasGroups}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2s(ctx) {
    	let show_if_2 = shouldRender(/*formats*/ ctx[7]) && /*hasFormats*/ ctx[4];
    	let t0;
    	let show_if_1 = shouldRender(/*regions*/ ctx[8]) && /*hasRegions*/ ctx[5];
    	let t1;
    	let show_if = shouldRender(/*groups*/ ctx[9]) && /*hasGroups*/ ctx[6];
    	let if_block2_anchor;
    	let current;
    	let if_block0 = show_if_2 && create_if_block_2$4(ctx);
    	let if_block1 = show_if_1 && create_if_block_1$e(ctx);
    	let if_block2 = show_if && create_if_block$O(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*formats, hasFormats*/ 144) show_if_2 = shouldRender(/*formats*/ ctx[7]) && /*hasFormats*/ ctx[4];

    			if (show_if_2) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*formats, hasFormats*/ 144) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*regions, hasRegions*/ 288) show_if_1 = shouldRender(/*regions*/ ctx[8]) && /*hasRegions*/ ctx[5];

    			if (show_if_1) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*regions, hasRegions*/ 288) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$e(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t1.parentNode, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*groups, hasGroups*/ 576) show_if = shouldRender(/*groups*/ ctx[9]) && /*hasGroups*/ ctx[6];

    			if (show_if) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*groups, hasGroups*/ 576) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$O(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function shouldRender(options) {
    	return options && options.length > 0;
    }

    function instance$2s($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { tab } = $$props;
    	let { units } = $$props;
    	let { indicator } = $$props;
    	let { isInverted } = $$props;
    	let hasFormats = true;
    	let hasRegions = true;
    	let hasGroups = true;
    	const writable_props = ["data", "tab", "units", "indicator", "isInverted"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SlicesCategories> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SlicesCategories", $$slots, []);

    	function slicescategory_hasData_binding(value) {
    		hasFormats = value;
    		$$invalidate(4, hasFormats);
    	}

    	function slicescategory_hasData_binding_1(value) {
    		hasRegions = value;
    		$$invalidate(5, hasRegions);
    	}

    	function slicescategory_hasData_binding_2(value) {
    		hasGroups = value;
    		$$invalidate(6, hasGroups);
    	}

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(10, data = $$props.data);
    		if ("tab" in $$props) $$invalidate(0, tab = $$props.tab);
    		if ("units" in $$props) $$invalidate(1, units = $$props.units);
    		if ("indicator" in $$props) $$invalidate(2, indicator = $$props.indicator);
    		if ("isInverted" in $$props) $$invalidate(3, isInverted = $$props.isInverted);
    	};

    	$$self.$capture_state = () => ({
    		SlicesCategory,
    		data,
    		tab,
    		units,
    		indicator,
    		isInverted,
    		hasFormats,
    		hasRegions,
    		hasGroups,
    		shouldRender,
    		formats,
    		regions,
    		groups
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(10, data = $$props.data);
    		if ("tab" in $$props) $$invalidate(0, tab = $$props.tab);
    		if ("units" in $$props) $$invalidate(1, units = $$props.units);
    		if ("indicator" in $$props) $$invalidate(2, indicator = $$props.indicator);
    		if ("isInverted" in $$props) $$invalidate(3, isInverted = $$props.isInverted);
    		if ("hasFormats" in $$props) $$invalidate(4, hasFormats = $$props.hasFormats);
    		if ("hasRegions" in $$props) $$invalidate(5, hasRegions = $$props.hasRegions);
    		if ("hasGroups" in $$props) $$invalidate(6, hasGroups = $$props.hasGroups);
    		if ("formats" in $$props) $$invalidate(7, formats = $$props.formats);
    		if ("regions" in $$props) $$invalidate(8, regions = $$props.regions);
    		if ("groups" in $$props) $$invalidate(9, groups = $$props.groups);
    	};

    	let formats;
    	let regions;
    	let groups;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 1024) {
    			 $$invalidate(7, { formats, regions, groups } = data, formats, ($$invalidate(8, regions), $$invalidate(10, data)), ($$invalidate(9, groups), $$invalidate(10, data)));
    		}
    	};

    	return [
    		tab,
    		units,
    		indicator,
    		isInverted,
    		hasFormats,
    		hasRegions,
    		hasGroups,
    		formats,
    		regions,
    		groups,
    		data,
    		slicescategory_hasData_binding,
    		slicescategory_hasData_binding_1,
    		slicescategory_hasData_binding_2
    	];
    }

    class SlicesCategories extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$2s, create_fragment$2s, safe_not_equal, {
    			data: 10,
    			tab: 0,
    			units: 1,
    			indicator: 2,
    			isInverted: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SlicesCategories",
    			options,
    			id: create_fragment$2s.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[10] === undefined && !("data" in props)) {
    			console.warn("<SlicesCategories> was created without expected prop 'data'");
    		}

    		if (/*tab*/ ctx[0] === undefined && !("tab" in props)) {
    			console.warn("<SlicesCategories> was created without expected prop 'tab'");
    		}

    		if (/*units*/ ctx[1] === undefined && !("units" in props)) {
    			console.warn("<SlicesCategories> was created without expected prop 'units'");
    		}

    		if (/*indicator*/ ctx[2] === undefined && !("indicator" in props)) {
    			console.warn("<SlicesCategories> was created without expected prop 'indicator'");
    		}

    		if (/*isInverted*/ ctx[3] === undefined && !("isInverted" in props)) {
    			console.warn("<SlicesCategories> was created without expected prop 'isInverted'");
    		}
    	}

    	get data() {
    		throw new Error("<SlicesCategories>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<SlicesCategories>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get tab() {
    		throw new Error("<SlicesCategories>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set tab(value) {
    		throw new Error("<SlicesCategories>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<SlicesCategories>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<SlicesCategories>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<SlicesCategories>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<SlicesCategories>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isInverted() {
    		throw new Error("<SlicesCategories>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isInverted(value) {
    		throw new Error("<SlicesCategories>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slices/SlicesLoader.svelte generated by Svelte v3.24.0 */
    const file$24 = "src/js/components/slices/SlicesLoader.svelte";

    // (31:6) {#if message}
    function create_if_block$P(ctx) {
    	let div;
    	let int;
    	let current;

    	int = new Int({
    			props: { key: /*message*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(int.$$.fragment);
    			attr_dev(div, "class", "txcm-slices-loaderMessage");
    			set_style(div, "top", /*shift*/ ctx[1] + "px");
    			add_location(div, file$24, 31, 8, 1178);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(int, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*message*/ 1) int_changes.key = /*message*/ ctx[0];
    			int.$set(int_changes);

    			if (!current || dirty & /*shift*/ 2) {
    				set_style(div, "top", /*shift*/ ctx[1] + "px");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$P.name,
    		type: "if",
    		source: "(31:6) {#if message}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2t(ctx) {
    	let div;
    	let svg;
    	let clipPath;
    	let path0;
    	let use;
    	let path1;
    	let t;
    	let current;
    	let if_block = /*message*/ ctx[0] && create_if_block$P(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			clipPath = svg_element("clipPath");
    			path0 = svg_element("path");
    			use = svg_element("use");
    			path1 = svg_element("path");
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(path0, "id", "txcm-loaderForm");
    			attr_dev(path0, "d", "M2.13 2.19A7.221 7.221 0 000 7.325v9.518l.652-.1C2.254 16.5 3.75 15 3.75 13.5v-6c0-.948.448-1.946 1.125-2.625C5.552 4.198 6.554 3.75 7.5 3.75H24V0H7.253C5.321 0 3.501.814 2.13 2.19zM21.87 21.81A7.221 7.221 0 0024 16.675V7.156l-.652.1C21.746 7.501 20.25 9 20.25 10.5v6c0 .948-.448 1.946-1.125 2.625-.677.677-1.679 1.125-2.625 1.125H0V24h16.747c1.932 0 3.752-.814 5.124-2.19z");
    			add_location(path0, file$24, 18, 10, 406);
    			attr_dev(clipPath, "id", "txcm-loaderClipPath");
    			add_location(clipPath, file$24, 17, 8, 360);
    			attr_dev(use, "class", "txcm-loaderForm");
    			xlink_attr(use, "xlink:href", "#txcm-loaderForm");
    			add_location(use, file$24, 22, 8, 866);
    			attr_dev(path1, "class", "txcm-loaderPath");
    			attr_dev(path1, "d", "M1.85 7v15.15H17c3.5 0 5.15-3.15 5.15-5.15V1.85H7C4.5 1.85 1.85 4.5 1.85 7z");
    			attr_dev(path1, "clip-path", "url(#txcm-loaderClipPath)");
    			add_location(path1, file$24, 25, 8, 956);
    			attr_dev(svg, "class", "txcm-slices-loaderIcon");
    			set_style(svg, "top", /*shift*/ ctx[1] + "px");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			add_location(svg, file$24, 10, 4, 185);
    			attr_dev(div, "class", "txcm-slices-loader");
    			add_location(div, file$24, 7, 0, 143);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, clipPath);
    			append_dev(clipPath, path0);
    			append_dev(svg, use);
    			append_dev(svg, path1);
    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*shift*/ 2) {
    				set_style(svg, "top", /*shift*/ ctx[1] + "px");
    			}

    			if (/*message*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*message*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$P(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2t($$self, $$props, $$invalidate) {
    	let { message = null } = $$props;
    	let { shift = 0 } = $$props;
    	const writable_props = ["message", "shift"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SlicesLoader> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("SlicesLoader", $$slots, []);

    	$$self.$set = $$props => {
    		if ("message" in $$props) $$invalidate(0, message = $$props.message);
    		if ("shift" in $$props) $$invalidate(1, shift = $$props.shift);
    	};

    	$$self.$capture_state = () => ({ Int, message, shift });

    	$$self.$inject_state = $$props => {
    		if ("message" in $$props) $$invalidate(0, message = $$props.message);
    		if ("shift" in $$props) $$invalidate(1, shift = $$props.shift);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [message, shift];
    }

    class SlicesLoader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2t, create_fragment$2t, safe_not_equal, { message: 0, shift: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SlicesLoader",
    			options,
    			id: create_fragment$2t.name
    		});
    	}

    	get message() {
    		throw new Error("<SlicesLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set message(value) {
    		throw new Error("<SlicesLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get shift() {
    		throw new Error("<SlicesLoader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set shift(value) {
    		throw new Error("<SlicesLoader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/slices/Slices.svelte generated by Svelte v3.24.0 */

    const { Object: Object_1$4 } = globals;
    const file$25 = "src/js/components/slices/Slices.svelte";

    // (61:4) {#if slicesData}
    function create_if_block$Q(ctx) {
    	let div;
    	let t0;
    	let slicescategories;
    	let t1;
    	let sectionScroll_action;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*slicesData*/ ctx[2].indicator && create_if_block_2$5(ctx);

    	slicescategories = new SlicesCategories({
    			props: {
    				isInverted: /*isInverted*/ ctx[3],
    				data: /*slicesData*/ ctx[2],
    				units: /*slicesData*/ ctx[2].units,
    				indicator: /*findIndicator*/ ctx[6](/*indicator*/ ctx[1]),
    				tab
    			},
    			$$inline: true
    		});

    	let if_block1 = /*$updating*/ ctx[4] > 0 && create_if_block_1$f(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			create_component(slicescategories.$$.fragment);
    			t1 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "txcm-slicesRows");
    			add_location(div, file$25, 61, 6, 1600);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			mount_component(slicescategories, div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(sectionScroll_action = sectionScroll.call(null, div, true));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*slicesData*/ ctx[2].indicator) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*slicesData*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const slicescategories_changes = {};
    			if (dirty & /*isInverted*/ 8) slicescategories_changes.isInverted = /*isInverted*/ ctx[3];
    			if (dirty & /*slicesData*/ 4) slicescategories_changes.data = /*slicesData*/ ctx[2];
    			if (dirty & /*slicesData*/ 4) slicescategories_changes.units = /*slicesData*/ ctx[2].units;
    			if (dirty & /*indicator*/ 2) slicescategories_changes.indicator = /*findIndicator*/ ctx[6](/*indicator*/ ctx[1]);
    			slicescategories.$set(slicescategories_changes);

    			if (/*$updating*/ ctx[4] > 0) {
    				if (if_block1) {
    					if (dirty & /*$updating*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$f(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(slicescategories.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(slicescategories.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			destroy_component(slicescategories);
    			if (if_block1) if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$Q.name,
    		type: "if",
    		source: "(61:4) {#if slicesData}",
    		ctx
    	});

    	return block;
    }

    // (65:10) {#if slicesData.indicator}
    function create_if_block_2$5(ctx) {
    	let kpirow;
    	let current;

    	kpirow = new KPIRow({
    			props: {
    				units: /*slicesData*/ ctx[2].units,
    				indicator: /*findIndicator*/ ctx[6](/*indicator*/ ctx[1]),
    				data: /*slicesData*/ ctx[2].indicator
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(kpirow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(kpirow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const kpirow_changes = {};
    			if (dirty & /*slicesData*/ 4) kpirow_changes.units = /*slicesData*/ ctx[2].units;
    			if (dirty & /*indicator*/ 2) kpirow_changes.indicator = /*findIndicator*/ ctx[6](/*indicator*/ ctx[1]);
    			if (dirty & /*slicesData*/ 4) kpirow_changes.data = /*slicesData*/ ctx[2].indicator;
    			kpirow.$set(kpirow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(kpirow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(kpirow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(kpirow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(65:10) {#if slicesData.indicator}",
    		ctx
    	});

    	return block;
    }

    // (77:10) {#if $updating > 0}
    function create_if_block_1$f(ctx) {
    	let slicesloader;
    	let current;
    	slicesloader = new SlicesLoader({ props: { shift: 80 }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(slicesloader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slicesloader, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slicesloader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slicesloader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slicesloader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(77:10) {#if $updating > 0}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2u(ctx) {
    	let section;
    	let slicestableheader;
    	let t;
    	let current;

    	slicestableheader = new SlicesTableHeader({
    			props: {
    				indicator: /*findIndicator*/ ctx[6](/*indicator*/ ctx[1]),
    				dashboard: /*dashboard*/ ctx[0]
    			},
    			$$inline: true
    		});

    	let if_block = /*slicesData*/ ctx[2] && create_if_block$Q(ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			create_component(slicestableheader.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(section, "class", "txcm-slicesSection");
    			add_location(section, file$25, 55, 0, 1447);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			mount_component(slicestableheader, section, null);
    			append_dev(section, t);
    			if (if_block) if_block.m(section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const slicestableheader_changes = {};
    			if (dirty & /*indicator*/ 2) slicestableheader_changes.indicator = /*findIndicator*/ ctx[6](/*indicator*/ ctx[1]);
    			if (dirty & /*dashboard*/ 1) slicestableheader_changes.dashboard = /*dashboard*/ ctx[0];
    			slicestableheader.$set(slicestableheader_changes);

    			if (/*slicesData*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*slicesData*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$Q(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(section, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slicestableheader.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slicestableheader.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(slicestableheader);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const tab = null;

    function flattenIndicators$1(results, option) {
    	return { ...results, [option.id]: option };
    }

    function flattenCategories$1(results, group) {
    	return {
    		...results,
    		...group.indicators.reduce(flattenIndicators$1, {})
    	};
    }

    function instance$2u($$self, $$props, $$invalidate) {
    	let $updating;
    	let { data = null } = $$props;
    	let { dashboard } = $$props;
    	let { indicator } = $$props;
    	const config = getContext("config").getIndicatorsConfig();
    	const indicators = Object.values(config).reduce(flattenCategories$1, {});
    	const updating = getUIState("updating");
    	validate_store(updating, "updating");
    	component_subscribe($$self, updating, value => $$invalidate(4, $updating = value));
    	let slicesData;
    	let isInverted = false;

    	function checkInverted() {
    		if (slicesData && slicesData.indicator) {
    			const data = slicesData.indicator;
    			const arrow = data.column1.arrow ? data.column1.arrow.qNum : 0;
    			$$invalidate(3, isInverted = arrow === 2 || arrow === 3);
    		}
    	}

    	function findIndicator() {
    		return Object.values(indicators).find(option => option.url === indicator);
    	}

    	function updateData() {
    		$$invalidate(2, slicesData = data || null);
    	}

    	const writable_props = ["data", "dashboard", "indicator"];

    	Object_1$4.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Slices> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Slices", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(7, data = $$props.data);
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		sectionScroll,
    		KPIRow,
    		SlicesTableHeader,
    		SlicesCategories,
    		SlicesLoader,
    		getUIState,
    		data,
    		dashboard,
    		indicator,
    		tab,
    		config,
    		indicators,
    		updating,
    		slicesData,
    		isInverted,
    		checkInverted,
    		flattenIndicators: flattenIndicators$1,
    		flattenCategories: flattenCategories$1,
    		findIndicator,
    		updateData,
    		$updating
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(7, data = $$props.data);
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("slicesData" in $$props) $$invalidate(2, slicesData = $$props.slicesData);
    		if ("isInverted" in $$props) $$invalidate(3, isInverted = $$props.isInverted);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 128) {
    			 updateData();
    		}

    		if ($$self.$$.dirty & /*slicesData*/ 4) {
    			 checkInverted();
    		}
    	};

    	return [
    		dashboard,
    		indicator,
    		slicesData,
    		isInverted,
    		$updating,
    		updating,
    		findIndicator,
    		data
    	];
    }

    class Slices extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2u, create_fragment$2u, safe_not_equal, { data: 7, dashboard: 0, indicator: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Slices",
    			options,
    			id: create_fragment$2u.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[0] === undefined && !("dashboard" in props)) {
    			console.warn("<Slices> was created without expected prop 'dashboard'");
    		}

    		if (/*indicator*/ ctx[1] === undefined && !("indicator" in props)) {
    			console.warn("<Slices> was created without expected prop 'indicator'");
    		}
    	}

    	get data() {
    		throw new Error("<Slices>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Slices>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dashboard() {
    		throw new Error("<Slices>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<Slices>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<Slices>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<Slices>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    let comparisonIndicatorsState;
    let comparisonIndicatorKeys;
    let activeComparisonIndicatorsState;

    function generateComponentState$2(state, { id }) {
      return {
        ...state,
        [id]: true,
      };
    }

    function generateInitialState$4(config) {
      return config.reduce(generateComponentState$2, {});
    }

    function initActiveComparisonIndicators() {
      const stores = Object.values(getComparisonIndicatorsState());
      activeComparisonIndicatorsState = derived(stores, updateActive$1);
    }

    function initComparisonIndicators(config) {
      const initialState = generateInitialState$4(config);
      comparisonIndicatorsState = initState(initialState);
      comparisonIndicatorKeys = Object.keys(comparisonIndicatorsState);
      initActiveComparisonIndicators();
    }

    function updateComparisonIndicators(update) {
      updateData(comparisonIndicatorsState, update);
    }

    function subscribeComparisonIndicators(key, task) {
      return subscribe$1(comparisonIndicatorsState, key, task);
    }

    function getComparisonIndicatorsData(keys) {
      return getStateData(comparisonIndicatorsState, keys);
    }

    function getComparisonIndicatorsState(keys) {
      return getState(comparisonIndicatorsState, keys);
    }

    function updateActiveKey$1(active, value, index) {
      if (value) active.push(comparisonIndicatorKeys[index]);
      return active;
    }

    function updateActive$1(update) {
      return update.reduce(updateActiveKey$1, []);
    }

    function getActiveComparisonIndicatorsState() {
      return activeComparisonIndicatorsState;
    }

    function destroyComparisons() {
      comparisonIndicatorsState = null;
      comparisonIndicatorKeys = null;
      activeComparisonIndicatorsState = null;
    }

    /* src/js/components/comparisonIndicators/ComparisonIndicatorsControl.svelte generated by Svelte v3.24.0 */
    const file$26 = "src/js/components/comparisonIndicators/ComparisonIndicatorsControl.svelte";

    // (32:0) {#if !exclude || (exclude && !checked)}
    function create_if_block$R(ctx) {
    	let input;
    	let t0;
    	let label_1;
    	let int;
    	let t1;
    	let svg;
    	let use;
    	let label_1_transition;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*label*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			input = element("input");
    			t0 = space();
    			label_1 = element("label");
    			create_component(int.$$.fragment);
    			t1 = space();
    			svg = svg_element("svg");
    			use = svg_element("use");
    			attr_dev(input, "class", "txcm-indicatorsInput");
    			attr_dev(input, "type", "checkbox");
    			attr_dev(input, "id", /*htmlID*/ ctx[4]);
    			input.__value = /*value*/ ctx[1];
    			input.value = input.__value;
    			add_location(input, file$26, 32, 2, 972);
    			xlink_attr(use, "xlink:href", "#txspt-icons-checkmark");
    			add_location(use, file$26, 47, 10, 1347);
    			attr_dev(svg, "class", "txcm-indicatorsControlIcon");
    			toggle_class(svg, "txcm-indicatorsControlIcon-is-visible", /*checked*/ ctx[3]);
    			add_location(svg, file$26, 44, 6, 1226);
    			attr_dev(label_1, "class", "txcm-indicatorsControl");
    			attr_dev(label_1, "for", /*htmlID*/ ctx[4]);
    			add_location(label_1, file$26, 38, 2, 1080);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = /*checked*/ ctx[3];
    			insert_dev(target, t0, anchor);
    			insert_dev(target, label_1, anchor);
    			mount_component(int, label_1, null);
    			append_dev(label_1, t1);
    			append_dev(label_1, svg);
    			append_dev(svg, use);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[6]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*value*/ 2) {
    				prop_dev(input, "__value", /*value*/ ctx[1]);
    				input.value = input.__value;
    			}

    			if (dirty & /*checked*/ 8) {
    				input.checked = /*checked*/ ctx[3];
    			}

    			const int_changes = {};
    			if (dirty & /*label*/ 1) int_changes.key = /*label*/ ctx[0];
    			int.$set(int_changes);

    			if (dirty & /*checked*/ 8) {
    				toggle_class(svg, "txcm-indicatorsControlIcon-is-visible", /*checked*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);

    			add_render_callback(() => {
    				if (!label_1_transition) label_1_transition = create_bidirectional_transition(label_1, shiftVertical, { height: 32 }, true);
    				label_1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			if (!label_1_transition) label_1_transition = create_bidirectional_transition(label_1, shiftVertical, { height: 32 }, false);
    			label_1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(label_1);
    			destroy_component(int);
    			if (detaching && label_1_transition) label_1_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$R.name,
    		type: "if",
    		source: "(32:0) {#if !exclude || (exclude && !checked)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2v(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = (!/*exclude*/ ctx[2] || /*exclude*/ ctx[2] && !/*checked*/ ctx[3]) && create_if_block$R(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*exclude*/ ctx[2] || /*exclude*/ ctx[2] && !/*checked*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*exclude, checked*/ 12) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$R(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2v($$self, $$props, $$invalidate) {
    	let { id } = $$props;
    	let { label } = $$props;
    	let { value } = $$props;
    	let { exclude = false } = $$props;
    	const htmlID = renderID("comparisonIndicatorToggle", id);
    	let checked = getComparisonIndicatorsData(id) || true;
    	const unsubscribeIndicator = subscribeComparisonIndicators(id, onComparisonIndicatorUpdate);
    	onDestroy(unsubscribeIndicator);

    	function onComparisonIndicatorUpdate(update) {
    		$$invalidate(3, checked = update);
    	}

    	function updateComparisonIndicatorValue() {
    		updateComparisonIndicators({ [id]: checked });
    	}

    	const writable_props = ["id", "label", "value", "exclude"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonIndicatorsControl> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonIndicatorsControl", $$slots, []);

    	function input_change_handler() {
    		checked = this.checked;
    		$$invalidate(3, checked);
    	}

    	$$self.$set = $$props => {
    		if ("id" in $$props) $$invalidate(5, id = $$props.id);
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("exclude" in $$props) $$invalidate(2, exclude = $$props.exclude);
    	};

    	$$self.$capture_state = () => ({
    		onDestroy,
    		renderID,
    		shiftVertical,
    		updateComparisonIndicators,
    		subscribeComparisonIndicators,
    		getComparisonIndicatorsData,
    		Int,
    		id,
    		label,
    		value,
    		exclude,
    		htmlID,
    		checked,
    		unsubscribeIndicator,
    		onComparisonIndicatorUpdate,
    		updateComparisonIndicatorValue
    	});

    	$$self.$inject_state = $$props => {
    		if ("id" in $$props) $$invalidate(5, id = $$props.id);
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    		if ("value" in $$props) $$invalidate(1, value = $$props.value);
    		if ("exclude" in $$props) $$invalidate(2, exclude = $$props.exclude);
    		if ("checked" in $$props) $$invalidate(3, checked = $$props.checked);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*checked*/ 8) {
    			 updateComparisonIndicatorValue();
    		}
    	};

    	return [label, value, exclude, checked, htmlID, id, input_change_handler];
    }

    class ComparisonIndicatorsControl extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2v, create_fragment$2v, safe_not_equal, { id: 5, label: 0, value: 1, exclude: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonIndicatorsControl",
    			options,
    			id: create_fragment$2v.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*id*/ ctx[5] === undefined && !("id" in props)) {
    			console.warn("<ComparisonIndicatorsControl> was created without expected prop 'id'");
    		}

    		if (/*label*/ ctx[0] === undefined && !("label" in props)) {
    			console.warn("<ComparisonIndicatorsControl> was created without expected prop 'label'");
    		}

    		if (/*value*/ ctx[1] === undefined && !("value" in props)) {
    			console.warn("<ComparisonIndicatorsControl> was created without expected prop 'value'");
    		}
    	}

    	get id() {
    		throw new Error("<ComparisonIndicatorsControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set id(value) {
    		throw new Error("<ComparisonIndicatorsControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get label() {
    		throw new Error("<ComparisonIndicatorsControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set label(value) {
    		throw new Error("<ComparisonIndicatorsControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get value() {
    		throw new Error("<ComparisonIndicatorsControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set value(value) {
    		throw new Error("<ComparisonIndicatorsControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get exclude() {
    		throw new Error("<ComparisonIndicatorsControl>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set exclude(value) {
    		throw new Error("<ComparisonIndicatorsControl>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comparisonIndicators/ComparisonIndicatorsActiveList.svelte generated by Svelte v3.24.0 */
    const file$27 = "src/js/components/comparisonIndicators/ComparisonIndicatorsActiveList.svelte";

    function get_each_context$x(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (26:4) {#each active as indicator (indicator.id)}
    function create_each_block$x(key_1, ctx) {
    	let first;
    	let comparisonindicatorscontrol;
    	let current;

    	comparisonindicatorscontrol = new ComparisonIndicatorsControl({
    			props: {
    				id: /*indicator*/ ctx[7].id,
    				label: /*indicator*/ ctx[7].label,
    				value: /*indicator*/ ctx[7].id
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(comparisonindicatorscontrol.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(comparisonindicatorscontrol, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comparisonindicatorscontrol_changes = {};
    			if (dirty & /*active*/ 1) comparisonindicatorscontrol_changes.id = /*indicator*/ ctx[7].id;
    			if (dirty & /*active*/ 1) comparisonindicatorscontrol_changes.label = /*indicator*/ ctx[7].label;
    			if (dirty & /*active*/ 1) comparisonindicatorscontrol_changes.value = /*indicator*/ ctx[7].id;
    			comparisonindicatorscontrol.$set(comparisonindicatorscontrol_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisonindicatorscontrol.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisonindicatorscontrol.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(comparisonindicatorscontrol, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$x.name,
    		type: "each",
    		source: "(26:4) {#each active as indicator (indicator.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2w(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value = /*active*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*indicator*/ ctx[7].id;
    	validate_each_keys(ctx, each_value, get_each_context$x, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$x(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$x(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-indicatorsActive");
    			toggle_class(div, "txcm-indicatorsActive-is-empty", /*isEmpty*/ ctx[1]);
    			add_location(div, file$27, 22, 0, 595);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*active*/ 1) {
    				const each_value = /*active*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$x, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$x, null, get_each_context$x);
    				check_outros();
    			}

    			if (dirty & /*isEmpty*/ 2) {
    				toggle_class(div, "txcm-indicatorsActive-is-empty", /*isEmpty*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2w($$self, $$props, $$invalidate) {
    	let $activeComparisonIndicators;
    	let { config } = $$props;
    	const activeComparisonIndicators = getActiveComparisonIndicatorsState();
    	validate_store(activeComparisonIndicators, "activeComparisonIndicators");
    	component_subscribe($$self, activeComparisonIndicators, value => $$invalidate(4, $activeComparisonIndicators = value));
    	let active = [];

    	function findActiveIndicator(option) {
    		return $activeComparisonIndicators.find(id => `${option.id}` === `${id}`);
    	}

    	function updateActive() {
    		$$invalidate(0, active = config.filter(findActiveIndicator));
    	}

    	const writable_props = ["config"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonIndicatorsActiveList> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonIndicatorsActiveList", $$slots, []);

    	$$self.$set = $$props => {
    		if ("config" in $$props) $$invalidate(3, config = $$props.config);
    	};

    	$$self.$capture_state = () => ({
    		getActiveComparisonIndicatorsState,
    		ComparisonIndicatorsControl,
    		config,
    		activeComparisonIndicators,
    		active,
    		findActiveIndicator,
    		updateActive,
    		$activeComparisonIndicators,
    		isEmpty
    	});

    	$$self.$inject_state = $$props => {
    		if ("config" in $$props) $$invalidate(3, config = $$props.config);
    		if ("active" in $$props) $$invalidate(0, active = $$props.active);
    		if ("isEmpty" in $$props) $$invalidate(1, isEmpty = $$props.isEmpty);
    	};

    	let isEmpty;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$activeComparisonIndicators*/ 16) {
    			 updateActive();
    		}

    		if ($$self.$$.dirty & /*active*/ 1) {
    			 $$invalidate(1, isEmpty = active.length === 0);
    		}
    	};

    	return [active, isEmpty, activeComparisonIndicators, config];
    }

    class ComparisonIndicatorsActiveList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2w, create_fragment$2w, safe_not_equal, { config: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonIndicatorsActiveList",
    			options,
    			id: create_fragment$2w.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*config*/ ctx[3] === undefined && !("config" in props)) {
    			console.warn("<ComparisonIndicatorsActiveList> was created without expected prop 'config'");
    		}
    	}

    	get config() {
    		throw new Error("<ComparisonIndicatorsActiveList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set config(value) {
    		throw new Error("<ComparisonIndicatorsActiveList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comparisonIndicators/ComparisonIndicatorsList.svelte generated by Svelte v3.24.0 */

    function get_each_context$y(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (17:4) {#each filtered as indicator (indicator.id)}
    function create_each_block$y(key_1, ctx) {
    	let first;
    	let comparisonindicatorscontrol;
    	let current;

    	comparisonindicatorscontrol = new ComparisonIndicatorsControl({
    			props: {
    				id: /*indicator*/ ctx[3].id,
    				label: /*indicator*/ ctx[3].label,
    				value: /*indicator*/ ctx[3].id,
    				exclude: true
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(comparisonindicatorscontrol.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(comparisonindicatorscontrol, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comparisonindicatorscontrol_changes = {};
    			if (dirty & /*filtered*/ 2) comparisonindicatorscontrol_changes.id = /*indicator*/ ctx[3].id;
    			if (dirty & /*filtered*/ 2) comparisonindicatorscontrol_changes.label = /*indicator*/ ctx[3].label;
    			if (dirty & /*filtered*/ 2) comparisonindicatorscontrol_changes.value = /*indicator*/ ctx[3].id;
    			comparisonindicatorscontrol.$set(comparisonindicatorscontrol_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisonindicatorscontrol.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisonindicatorscontrol.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(comparisonindicatorscontrol, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$y.name,
    		type: "each",
    		source: "(17:4) {#each filtered as indicator (indicator.id)}",
    		ctx
    	});

    	return block;
    }

    // (12:0) <ListGroup   count={1}   length={filtered.length}   fixed={true}   {filter}>
    function create_default_slot$E(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = /*filtered*/ ctx[1];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*indicator*/ ctx[3].id;
    	validate_each_keys(ctx, each_value, get_each_context$y, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$y(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$y(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*filtered*/ 2) {
    				const each_value = /*filtered*/ ctx[1];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$y, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$y, each_1_anchor, get_each_context$y);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$E.name,
    		type: "slot",
    		source: "(12:0) <ListGroup   count={1}   length={filtered.length}   fixed={true}   {filter}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2x(ctx) {
    	let listgroup;
    	let current;

    	listgroup = new ListGroup({
    			props: {
    				count: 1,
    				length: /*filtered*/ ctx[1].length,
    				fixed: true,
    				filter: /*filter*/ ctx[0],
    				$$slots: { default: [create_default_slot$E] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(listgroup.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(listgroup, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const listgroup_changes = {};
    			if (dirty & /*filtered*/ 2) listgroup_changes.length = /*filtered*/ ctx[1].length;
    			if (dirty & /*filter*/ 1) listgroup_changes.filter = /*filter*/ ctx[0];

    			if (dirty & /*$$scope, filtered*/ 66) {
    				listgroup_changes.$$scope = { dirty, ctx };
    			}

    			listgroup.$set(listgroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listgroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listgroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(listgroup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2x($$self, $$props, $$invalidate) {
    	let { config } = $$props;
    	let { filter } = $$props;
    	const writable_props = ["config", "filter"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonIndicatorsList> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonIndicatorsList", $$slots, []);

    	$$self.$set = $$props => {
    		if ("config" in $$props) $$invalidate(2, config = $$props.config);
    		if ("filter" in $$props) $$invalidate(0, filter = $$props.filter);
    	};

    	$$self.$capture_state = () => ({
    		ListGroup,
    		filterComparisonIndicators,
    		ComparisonIndicatorsControl,
    		config,
    		filter,
    		filtered
    	});

    	$$self.$inject_state = $$props => {
    		if ("config" in $$props) $$invalidate(2, config = $$props.config);
    		if ("filter" in $$props) $$invalidate(0, filter = $$props.filter);
    		if ("filtered" in $$props) $$invalidate(1, filtered = $$props.filtered);
    	};

    	let filtered;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*config, filter*/ 5) {
    			 $$invalidate(1, filtered = filterComparisonIndicators(config, filter));
    		}
    	};

    	return [filter, filtered, config];
    }

    class ComparisonIndicatorsList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2x, create_fragment$2x, safe_not_equal, { config: 2, filter: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonIndicatorsList",
    			options,
    			id: create_fragment$2x.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*config*/ ctx[2] === undefined && !("config" in props)) {
    			console.warn("<ComparisonIndicatorsList> was created without expected prop 'config'");
    		}

    		if (/*filter*/ ctx[0] === undefined && !("filter" in props)) {
    			console.warn("<ComparisonIndicatorsList> was created without expected prop 'filter'");
    		}
    	}

    	get config() {
    		throw new Error("<ComparisonIndicatorsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set config(value) {
    		throw new Error("<ComparisonIndicatorsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filter() {
    		throw new Error("<ComparisonIndicatorsList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filter(value) {
    		throw new Error("<ComparisonIndicatorsList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comparisonIndicators/ComparisonIndicatorsDrawer.svelte generated by Svelte v3.24.0 */
    const file$28 = "src/js/components/comparisonIndicators/ComparisonIndicatorsDrawer.svelte";

    function create_fragment$2y(ctx) {
    	let div;
    	let int;
    	let t0;
    	let listfilter;
    	let updating_value;
    	let t1;
    	let comparisonindicatorsactivelist;
    	let t2;
    	let comparisonindicatorslist;
    	let current;

    	int = new Int({
    			props: { key: "Добавить показатели" },
    			$$inline: true
    		});

    	function listfilter_value_binding(value) {
    		/*listfilter_value_binding*/ ctx[2].call(null, value);
    	}

    	let listfilter_props = {};

    	if (/*filter*/ ctx[0] !== void 0) {
    		listfilter_props.value = /*filter*/ ctx[0];
    	}

    	listfilter = new ListFilter({ props: listfilter_props, $$inline: true });
    	binding_callbacks.push(() => bind(listfilter, "value", listfilter_value_binding));

    	comparisonindicatorsactivelist = new ComparisonIndicatorsActiveList({
    			props: { config: /*config*/ ctx[1] },
    			$$inline: true
    		});

    	comparisonindicatorslist = new ComparisonIndicatorsList({
    			props: {
    				config: /*config*/ ctx[1],
    				filter: /*filter*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(int.$$.fragment);
    			t0 = space();
    			create_component(listfilter.$$.fragment);
    			t1 = space();
    			create_component(comparisonindicatorsactivelist.$$.fragment);
    			t2 = space();
    			create_component(comparisonindicatorslist.$$.fragment);
    			attr_dev(div, "class", "txcm-indicatorsHeader");
    			add_location(div, file$28, 12, 0, 457);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(int, div, null);
    			insert_dev(target, t0, anchor);
    			mount_component(listfilter, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(comparisonindicatorsactivelist, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(comparisonindicatorslist, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const listfilter_changes = {};

    			if (!updating_value && dirty & /*filter*/ 1) {
    				updating_value = true;
    				listfilter_changes.value = /*filter*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			listfilter.$set(listfilter_changes);
    			const comparisonindicatorslist_changes = {};
    			if (dirty & /*filter*/ 1) comparisonindicatorslist_changes.filter = /*filter*/ ctx[0];
    			comparisonindicatorslist.$set(comparisonindicatorslist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			transition_in(listfilter.$$.fragment, local);
    			transition_in(comparisonindicatorsactivelist.$$.fragment, local);
    			transition_in(comparisonindicatorslist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			transition_out(listfilter.$$.fragment, local);
    			transition_out(comparisonindicatorsactivelist.$$.fragment, local);
    			transition_out(comparisonindicatorslist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    			if (detaching) detach_dev(t0);
    			destroy_component(listfilter, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(comparisonindicatorsactivelist, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(comparisonindicatorslist, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2y($$self, $$props, $$invalidate) {
    	const config = getContext("comparisonsConfig").getComparisonIndicatorsConfig();
    	let filter = "";
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonIndicatorsDrawer> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonIndicatorsDrawer", $$slots, []);

    	function listfilter_value_binding(value) {
    		filter = value;
    		$$invalidate(0, filter);
    	}

    	$$self.$capture_state = () => ({
    		getContext,
    		ListFilter,
    		Int,
    		ComparisonIndicatorsActiveList,
    		ComparisonIndicatorsList,
    		config,
    		filter
    	});

    	$$self.$inject_state = $$props => {
    		if ("filter" in $$props) $$invalidate(0, filter = $$props.filter);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [filter, config, listfilter_value_binding];
    }

    class ComparisonIndicatorsDrawer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2y, create_fragment$2y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonIndicatorsDrawer",
    			options,
    			id: create_fragment$2y.name
    		});
    	}
    }

    /* src/js/components/comparisonIndicators/ComparisonIndicatorsMenu.svelte generated by Svelte v3.24.0 */

    // (6:0) <Drawer   store="comparisonIndicators">
    function create_default_slot$F(ctx) {
    	let comparisonindicatorsdrawer;
    	let current;
    	comparisonindicatorsdrawer = new ComparisonIndicatorsDrawer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(comparisonindicatorsdrawer.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(comparisonindicatorsdrawer, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisonindicatorsdrawer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisonindicatorsdrawer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(comparisonindicatorsdrawer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$F.name,
    		type: "slot",
    		source: "(6:0) <Drawer   store=\\\"comparisonIndicators\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2z(ctx) {
    	let drawer;
    	let current;

    	drawer = new Drawer({
    			props: {
    				store: "comparisonIndicators",
    				$$slots: { default: [create_default_slot$F] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(drawer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(drawer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const drawer_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				drawer_changes.$$scope = { dirty, ctx };
    			}

    			drawer.$set(drawer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(drawer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(drawer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(drawer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2z($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonIndicatorsMenu> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonIndicatorsMenu", $$slots, []);
    	$$self.$capture_state = () => ({ Drawer, ComparisonIndicatorsDrawer });
    	return [];
    }

    class ComparisonIndicatorsMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2z, create_fragment$2z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonIndicatorsMenu",
    			options,
    			id: create_fragment$2z.name
    		});
    	}
    }

    /* src/js/components/comparisonIndicators/ComparisonIndicatorsToggle.svelte generated by Svelte v3.24.0 */
    const file$29 = "src/js/components/comparisonIndicators/ComparisonIndicatorsToggle.svelte";

    function create_fragment$2A(ctx) {
    	let button;
    	let svg;
    	let use;
    	let t;
    	let int;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: "Добавить показатели" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t = space();
    			create_component(int.$$.fragment);
    			xlink_attr(use, "xlink:href", "#txspt-icons-plus");
    			add_location(use, file$29, 20, 8, 492);
    			attr_dev(svg, "class", "txcm-indicatorsToggleIcon");
    			add_location(svg, file$29, 18, 4, 438);
    			attr_dev(button, "class", "txcm-indicatorsToggle");
    			add_location(button, file$29, 15, 0, 366);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, use);
    			append_dev(button, t);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onToggleClick*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2A($$self, $$props, $$invalidate) {
    	let $comparisonIndicators;
    	const comparisonIndicators = getUIState("comparisonIndicators");
    	validate_store(comparisonIndicators, "comparisonIndicators");
    	component_subscribe($$self, comparisonIndicators, value => $$invalidate(2, $comparisonIndicators = value));

    	function show() {
    		updateUI({ comparisonIndicators: true });
    	}

    	function onToggleClick() {
    		if (!$comparisonIndicators) setTimeout(show, 5);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonIndicatorsToggle> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonIndicatorsToggle", $$slots, []);

    	$$self.$capture_state = () => ({
    		getUIState,
    		updateUI,
    		Int,
    		comparisonIndicators,
    		show,
    		onToggleClick,
    		$comparisonIndicators
    	});

    	return [comparisonIndicators, onToggleClick];
    }

    class ComparisonIndicatorsToggle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2A, create_fragment$2A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonIndicatorsToggle",
    			options,
    			id: create_fragment$2A.name
    		});
    	}
    }

    /* src/js/components/comparisonIndicators/ComparisonIndicators.svelte generated by Svelte v3.24.0 */

    function create_fragment$2B(ctx) {
    	let comparisonindicatorstoggle;
    	let t;
    	let comparisonindicatorsmenu;
    	let current;
    	comparisonindicatorstoggle = new ComparisonIndicatorsToggle({ $$inline: true });
    	comparisonindicatorsmenu = new ComparisonIndicatorsMenu({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(comparisonindicatorstoggle.$$.fragment);
    			t = space();
    			create_component(comparisonindicatorsmenu.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(comparisonindicatorstoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(comparisonindicatorsmenu, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisonindicatorstoggle.$$.fragment, local);
    			transition_in(comparisonindicatorsmenu.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisonindicatorstoggle.$$.fragment, local);
    			transition_out(comparisonindicatorsmenu.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(comparisonindicatorstoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(comparisonindicatorsmenu, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2B($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonIndicators> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonIndicators", $$slots, []);

    	$$self.$capture_state = () => ({
    		ComparisonIndicatorsMenu,
    		ComparisonIndicatorsToggle
    	});

    	return [];
    }

    class ComparisonIndicators extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2B, create_fragment$2B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonIndicators",
    			options,
    			id: create_fragment$2B.name
    		});
    	}
    }

    /* src/js/components/tableHeader/operational/comparisons/TableHeaderCellOpComparisons.svelte generated by Svelte v3.24.0 */
    const file$2a = "src/js/components/tableHeader/operational/comparisons/TableHeaderCellOpComparisons.svelte";

    // (15:0) <TableHeaderCell>
    function create_default_slot$G(ctx) {
    	let t0;
    	let div0;
    	let int0;
    	let br0;
    	let t1;
    	let int1;
    	let t2;
    	let div1;
    	let int2;
    	let br1;
    	let t3;
    	let t4;
    	let t5;
    	let div2;
    	let int3;
    	let br2;
    	let t6;
    	let int4;
    	let br3;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	int0 = new Int({
    			props: { key: "% от выр." },
    			$$inline: true
    		});

    	int1 = new Int({
    			props: { key: "млн. руб" },
    			$$inline: true
    		});

    	int2 = new Int({
    			props: { key: "∆ (ppt)" },
    			$$inline: true
    		});

    	int3 = new Int({
    			props: { key: "∆ (ppt)" },
    			$$inline: true
    		});

    	int4 = new Int({
    			props: { key: "от план" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    			t0 = space();
    			div0 = element("div");
    			create_component(int0.$$.fragment);
    			br0 = element("br");
    			t1 = space();
    			create_component(int1.$$.fragment);
    			t2 = space();
    			div1 = element("div");
    			create_component(int2.$$.fragment);
    			br1 = element("br");
    			t3 = space();
    			t4 = text(/*label*/ ctx[0]);
    			t5 = space();
    			div2 = element("div");
    			create_component(int3.$$.fragment);
    			br2 = element("br");
    			t6 = space();
    			create_component(int4.$$.fragment);
    			br3 = element("br");
    			add_location(br0, file$2a, 18, 28, 646);
    			attr_dev(div0, "class", "txcm-tableHeaderCellColumn");
    			add_location(div0, file$2a, 16, 2, 573);
    			add_location(br1, file$2a, 23, 26, 761);
    			attr_dev(div1, "class", "txcm-tableHeaderCellColumn");
    			add_location(div1, file$2a, 21, 2, 690);
    			add_location(br2, file$2a, 28, 26, 862);
    			add_location(br3, file$2a, 29, 26, 893);
    			attr_dev(div2, "class", "txcm-tableHeaderCellColumn");
    			add_location(div2, file$2a, 26, 2, 791);
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			insert_dev(target, t0, anchor);
    			insert_dev(target, div0, anchor);
    			mount_component(int0, div0, null);
    			append_dev(div0, br0);
    			append_dev(div0, t1);
    			mount_component(int1, div0, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			mount_component(int2, div1, null);
    			append_dev(div1, br1);
    			append_dev(div1, t3);
    			append_dev(div1, t4);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(int3, div2, null);
    			append_dev(div2, br2);
    			append_dev(div2, t6);
    			mount_component(int4, div2, null);
    			append_dev(div2, br3);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*label*/ 1) set_data_dev(t4, /*label*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			transition_in(int2.$$.fragment, local);
    			transition_in(int3.$$.fragment, local);
    			transition_in(int4.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			transition_out(int2.$$.fragment, local);
    			transition_out(int3.$$.fragment, local);
    			transition_out(int4.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div0);
    			destroy_component(int0);
    			destroy_component(int1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			destroy_component(int2);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div2);
    			destroy_component(int3);
    			destroy_component(int4);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$G.name,
    		type: "slot",
    		source: "(15:0) <TableHeaderCell>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2C(ctx) {
    	let tableheadercell;
    	let current;

    	tableheadercell = new TableHeaderCell({
    			props: {
    				$$slots: { default: [create_default_slot$G] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tableheadercell.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tableheadercell, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tableheadercell_changes = {};

    			if (dirty & /*$$scope, label*/ 33) {
    				tableheadercell_changes.$$scope = { dirty, ctx };
    			}

    			tableheadercell.$set(tableheadercell_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tableheadercell.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tableheadercell.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tableheadercell, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2C($$self, $$props, $$invalidate) {
    	let $datePoP;
    	let $datePrecision;
    	let $locale;
    	const datePoP = getDashboardState("datePoP");
    	validate_store(datePoP, "datePoP");
    	component_subscribe($$self, datePoP, value => $$invalidate(6, $datePoP = value));
    	const datePrecision = getDashboardState("datePrecision");
    	validate_store(datePrecision, "datePrecision");
    	component_subscribe($$self, datePrecision, value => $$invalidate(7, $datePrecision = value));
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(8, $locale = value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TableHeaderCellOpComparisons> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TableHeaderCellOpComparisons", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		getUIState,
    		renderPreciseCellDate,
    		TableHeaderCell,
    		Int,
    		datePoP,
    		datePrecision,
    		locale,
    		label,
    		$datePoP,
    		$datePrecision,
    		$locale
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    	};

    	let label;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$datePoP, $datePrecision, $locale*/ 448) {
    			 $$invalidate(0, label = renderPreciseCellDate($datePoP, $datePrecision, $locale));
    		}
    	};

    	return [label, datePoP, datePrecision, locale, $$slots, $$scope];
    }

    class TableHeaderCellOpComparisons extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2C, create_fragment$2C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableHeaderCellOpComparisons",
    			options,
    			id: create_fragment$2C.name
    		});
    	}
    }

    /* src/js/components/tableHeader/operational/comparisons/TableHeaderOpComparisons.svelte generated by Svelte v3.24.0 */
    const file$2b = "src/js/components/tableHeader/operational/comparisons/TableHeaderOpComparisons.svelte";

    // (18:2) <TableHeaderCellOperationalComparisons>
    function create_default_slot_3$5(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*label*/ ctx[0]);
    			attr_dev(div, "class", "txcm-tableHeaderCellLabel");
    			add_location(div, file$2b, 18, 4, 825);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*label*/ 1) set_data_dev(t, /*label*/ ctx[0]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(18:2) <TableHeaderCellOperationalComparisons>",
    		ctx
    	});

    	return block;
    }

    // (24:2) <TableHeaderCellOperationalComparisons>
    function create_default_slot_2$6(ctx) {
    	let div;
    	let columnoptions;
    	let current;
    	columnoptions = new ColumnOptions({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(columnoptions.$$.fragment);
    			attr_dev(div, "class", "txcm-tableHeaderCellLabel");
    			add_location(div, file$2b, 24, 4, 987);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(columnoptions, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(columnoptions.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(columnoptions.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(columnoptions);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(24:2) <TableHeaderCellOperationalComparisons>",
    		ctx
    	});

    	return block;
    }

    // (30:2) <TableHeaderGraph>
    function create_default_slot_1$b(ctx) {
    	let graphoptions;
    	let t;
    	let graphheader;
    	let current;
    	graphoptions = new GraphOptions({ $$inline: true });
    	graphheader = new GraphHeader({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(graphoptions.$$.fragment);
    			t = space();
    			create_component(graphheader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(graphoptions, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(graphheader, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(graphoptions.$$.fragment, local);
    			transition_in(graphheader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(graphoptions.$$.fragment, local);
    			transition_out(graphheader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(graphoptions, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(graphheader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(30:2) <TableHeaderGraph>",
    		ctx
    	});

    	return block;
    }

    // (17:0) <TableHeader>
    function create_default_slot$H(ctx) {
    	let tableheadercelloperationalcomparisons0;
    	let t0;
    	let tableheadercelloperationalcomparisons1;
    	let t1;
    	let tableheadergraph;
    	let current;

    	tableheadercelloperationalcomparisons0 = new TableHeaderCellOpComparisons({
    			props: {
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tableheadercelloperationalcomparisons1 = new TableHeaderCellOpComparisons({
    			props: {
    				$$slots: { default: [create_default_slot_2$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	tableheadergraph = new TableHeaderGraph({
    			props: {
    				$$slots: { default: [create_default_slot_1$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tableheadercelloperationalcomparisons0.$$.fragment);
    			t0 = space();
    			create_component(tableheadercelloperationalcomparisons1.$$.fragment);
    			t1 = space();
    			create_component(tableheadergraph.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tableheadercelloperationalcomparisons0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(tableheadercelloperationalcomparisons1, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(tableheadergraph, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tableheadercelloperationalcomparisons0_changes = {};

    			if (dirty & /*$$scope, label*/ 33) {
    				tableheadercelloperationalcomparisons0_changes.$$scope = { dirty, ctx };
    			}

    			tableheadercelloperationalcomparisons0.$set(tableheadercelloperationalcomparisons0_changes);
    			const tableheadercelloperationalcomparisons1_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				tableheadercelloperationalcomparisons1_changes.$$scope = { dirty, ctx };
    			}

    			tableheadercelloperationalcomparisons1.$set(tableheadercelloperationalcomparisons1_changes);
    			const tableheadergraph_changes = {};

    			if (dirty & /*$$scope*/ 32) {
    				tableheadergraph_changes.$$scope = { dirty, ctx };
    			}

    			tableheadergraph.$set(tableheadergraph_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tableheadercelloperationalcomparisons0.$$.fragment, local);
    			transition_in(tableheadercelloperationalcomparisons1.$$.fragment, local);
    			transition_in(tableheadergraph.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tableheadercelloperationalcomparisons0.$$.fragment, local);
    			transition_out(tableheadercelloperationalcomparisons1.$$.fragment, local);
    			transition_out(tableheadergraph.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tableheadercelloperationalcomparisons0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(tableheadercelloperationalcomparisons1, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(tableheadergraph, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$H.name,
    		type: "slot",
    		source: "(17:0) <TableHeader>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2D(ctx) {
    	let tableheader;
    	let current;

    	tableheader = new TableHeader({
    			props: {
    				$$slots: { default: [create_default_slot$H] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tableheader.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(tableheader, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tableheader_changes = {};

    			if (dirty & /*$$scope, label*/ 33) {
    				tableheader_changes.$$scope = { dirty, ctx };
    			}

    			tableheader.$set(tableheader_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tableheader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tableheader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tableheader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2D($$self, $$props, $$invalidate) {
    	let $date;
    	let $datePrecision;
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(3, $date = value));
    	const datePrecision = getDashboardState("datePrecision");
    	validate_store(datePrecision, "datePrecision");
    	component_subscribe($$self, datePrecision, value => $$invalidate(4, $datePrecision = value));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TableHeaderOpComparisons> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TableHeaderOpComparisons", $$slots, []);

    	$$self.$capture_state = () => ({
    		getDashboardState,
    		renderPreciseTableDate,
    		ColumnOptions,
    		GraphOptions,
    		GraphHeader,
    		TableHeader,
    		TableHeaderGraph,
    		TableHeaderCellOperationalComparisons: TableHeaderCellOpComparisons,
    		date,
    		datePrecision,
    		label,
    		$date,
    		$datePrecision
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    	};

    	let label;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$date, $datePrecision*/ 24) {
    			 $$invalidate(0, label = renderPreciseTableDate($date, $datePrecision));
    		}
    	};

    	return [label, date, datePrecision];
    }

    class TableHeaderOpComparisons extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2D, create_fragment$2D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TableHeaderOpComparisons",
    			options,
    			id: create_fragment$2D.name
    		});
    	}
    }

    /* src/js/components/comparisons/ComparisonsTableHeader.svelte generated by Svelte v3.24.0 */
    const file$2c = "src/js/components/comparisons/ComparisonsTableHeader.svelte";

    function create_fragment$2E(ctx) {
    	let div;
    	let tableheaderopcomparisons;
    	let current;
    	tableheaderopcomparisons = new TableHeaderOpComparisons({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(tableheaderopcomparisons.$$.fragment);
    			attr_dev(div, "class", "txcm-overviewHeader");
    			add_location(div, file$2c, 15, 0, 370);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(tableheaderopcomparisons, div, null);
    			/*div_binding*/ ctx[2](div);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tableheaderopcomparisons.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tableheaderopcomparisons.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(tableheaderopcomparisons);
    			/*div_binding*/ ctx[2](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2E($$self, $$props, $$invalidate) {
    	let $sectionScrollX;
    	const sectionScrollX = getUIState("sectionScrollX");
    	validate_store(sectionScrollX, "sectionScrollX");
    	component_subscribe($$self, sectionScrollX, value => $$invalidate(3, $sectionScrollX = value));
    	let node;

    	function updateScroll() {
    		if (node) $$invalidate(0, node.scrollLeft = $sectionScrollX, node);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonsTableHeader> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonsTableHeader", $$slots, []);

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			node = $$value;
    			$$invalidate(0, node);
    		});
    	}

    	$$self.$capture_state = () => ({
    		getUIState,
    		TableHeaderOpComparisons,
    		sectionScrollX,
    		node,
    		updateScroll,
    		$sectionScrollX
    	});

    	$$self.$inject_state = $$props => {
    		if ("node" in $$props) $$invalidate(0, node = $$props.node);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$sectionScrollX*/ 8) {
    			 updateScroll();
    		}
    	};

    	return [node, sectionScrollX, div_binding];
    }

    class ComparisonsTableHeader extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2E, create_fragment$2E, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonsTableHeader",
    			options,
    			id: create_fragment$2E.name
    		});
    	}
    }

    /* src/js/components/comparison/ComparisonLabel.svelte generated by Svelte v3.24.0 */
    const file$2d = "src/js/components/comparison/ComparisonLabel.svelte";

    // (19:4) {#if data.units}
    function create_if_block$S(ctx) {
    	let span;
    	let t_value = /*data*/ ctx[0].units + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "txcm-comparisonUnits");
    			add_location(span, file$2d, 19, 6, 436);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*data*/ 1 && t_value !== (t_value = /*data*/ ctx[0].units + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$S.name,
    		type: "if",
    		source: "(19:4) {#if data.units}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2F(ctx) {
    	let div;
    	let span;
    	let int0;
    	let t0;
    	let t1;
    	let button;
    	let int1;
    	let current;
    	let mounted;
    	let dispose;

    	int0 = new Int({
    			props: { key: /*data*/ ctx[0].label },
    			$$inline: true
    		});

    	let if_block = /*data*/ ctx[0].units && create_if_block$S(ctx);

    	int1 = new Int({
    			props: { key: "Убрать показатель" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			create_component(int0.$$.fragment);
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			button = element("button");
    			create_component(int1.$$.fragment);
    			attr_dev(span, "class", "txcm-comparisonText");
    			add_location(span, file$2d, 13, 4, 313);
    			attr_dev(button, "class", "txcm-comparisonCancel");
    			add_location(button, file$2d, 24, 4, 531);
    			attr_dev(div, "class", "txcm-comparisonLabel");
    			add_location(div, file$2d, 11, 0, 272);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			mount_component(int0, span, null);
    			append_dev(div, t0);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t1);
    			append_dev(div, button);
    			mount_component(int1, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onCancelClick*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const int0_changes = {};
    			if (dirty & /*data*/ 1) int0_changes.key = /*data*/ ctx[0].label;
    			int0.$set(int0_changes);

    			if (/*data*/ ctx[0].units) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$S(ctx);
    					if_block.c();
    					if_block.m(div, t1);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int0);
    			if (if_block) if_block.d();
    			destroy_component(int1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2F($$self, $$props, $$invalidate) {
    	let { data } = $$props;

    	function onCancelClick() {
    		updateComparisonIndicators({ [data.id]: false });
    	}

    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonLabel> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonLabel", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		updateComparisonIndicators,
    		data,
    		onCancelClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [data, onCancelClick];
    }

    class ComparisonLabel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2F, create_fragment$2F, safe_not_equal, { data: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonLabel",
    			options,
    			id: create_fragment$2F.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<ComparisonLabel> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<ComparisonLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<ComparisonLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comparison/ComparisonColumn.svelte generated by Svelte v3.24.0 */

    const file$2e = "src/js/components/comparison/ComparisonColumn.svelte";

    function create_fragment$2G(ctx) {
    	let div;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[1].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[0], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", "txcm-comparisonColumn");
    			add_location(div, file$2e, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 1) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[0], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2G($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonColumn> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonColumn", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("$$scope" in $$props) $$invalidate(0, $$scope = $$props.$$scope);
    	};

    	return [$$scope, $$slots];
    }

    class ComparisonColumn extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2G, create_fragment$2G, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonColumn",
    			options,
    			id: create_fragment$2G.name
    		});
    	}
    }

    /* src/js/components/comparison/ComparisonValueMain.svelte generated by Svelte v3.24.0 */
    const file$2f = "src/js/components/comparison/ComparisonValueMain.svelte";

    function create_fragment$2H(ctx) {
    	let div;
    	let svg;
    	let use;
    	let svg_class_value;
    	let t;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[3], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t = space();
    			if (default_slot) default_slot.c();
    			xlink_attr(use, "xlink:href", "#txspt-icons-fatArrow");
    			add_location(use, file$2f, 19, 8, 476);
    			attr_dev(svg, "class", svg_class_value = renderDynamicsClass("txcm-comparisonValueIcon", /*dynamics*/ ctx[2]));
    			add_location(svg, file$2f, 17, 4, 390);
    			attr_dev(div, "class", "txcm-comparisonValue");
    			toggle_class(div, "txcm-comparisonValue-is-highlighted", isHighlighted$1(/*units*/ ctx[0], /*valueUnits*/ ctx[1]));
    			add_location(div, file$2f, 14, 0, 270);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, use);
    			append_dev(div, t);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*dynamics*/ 4 && svg_class_value !== (svg_class_value = renderDynamicsClass("txcm-comparisonValueIcon", /*dynamics*/ ctx[2]))) {
    				attr_dev(svg, "class", svg_class_value);
    			}

    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 8) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[3], dirty, null, null);
    				}
    			}

    			if (dirty & /*isHighlighted, units, valueUnits*/ 3) {
    				toggle_class(div, "txcm-comparisonValue-is-highlighted", isHighlighted$1(/*units*/ ctx[0], /*valueUnits*/ ctx[1]));
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function isHighlighted$1(units, valueUnits) {
    	return units === valueUnits;
    }

    function instance$2H($$self, $$props, $$invalidate) {
    	let { units } = $$props;
    	let { valueUnits } = $$props;
    	let { dynamics } = $$props;
    	const writable_props = ["units", "valueUnits", "dynamics"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonValueMain> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonValueMain", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("valueUnits" in $$props) $$invalidate(1, valueUnits = $$props.valueUnits);
    		if ("dynamics" in $$props) $$invalidate(2, dynamics = $$props.dynamics);
    		if ("$$scope" in $$props) $$invalidate(3, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		isHighlighted: isHighlighted$1,
    		renderDynamicsClass,
    		units,
    		valueUnits,
    		dynamics
    	});

    	$$self.$inject_state = $$props => {
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("valueUnits" in $$props) $$invalidate(1, valueUnits = $$props.valueUnits);
    		if ("dynamics" in $$props) $$invalidate(2, dynamics = $$props.dynamics);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [units, valueUnits, dynamics, $$scope, $$slots];
    }

    class ComparisonValueMain extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2H, create_fragment$2H, safe_not_equal, { units: 0, valueUnits: 1, dynamics: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonValueMain",
    			options,
    			id: create_fragment$2H.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*units*/ ctx[0] === undefined && !("units" in props)) {
    			console.warn("<ComparisonValueMain> was created without expected prop 'units'");
    		}

    		if (/*valueUnits*/ ctx[1] === undefined && !("valueUnits" in props)) {
    			console.warn("<ComparisonValueMain> was created without expected prop 'valueUnits'");
    		}

    		if (/*dynamics*/ ctx[2] === undefined && !("dynamics" in props)) {
    			console.warn("<ComparisonValueMain> was created without expected prop 'dynamics'");
    		}
    	}

    	get units() {
    		throw new Error("<ComparisonValueMain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<ComparisonValueMain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valueUnits() {
    		throw new Error("<ComparisonValueMain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valueUnits(value) {
    		throw new Error("<ComparisonValueMain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dynamics() {
    		throw new Error("<ComparisonValueMain>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dynamics(value) {
    		throw new Error("<ComparisonValueMain>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comparison/ComparisonValueAdd.svelte generated by Svelte v3.24.0 */
    const file$2g = "src/js/components/comparison/ComparisonValueAdd.svelte";

    function create_fragment$2I(ctx) {
    	let div;
    	let div_class_value;
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (default_slot) default_slot.c();
    			attr_dev(div, "class", div_class_value = renderDynamicsClass("txcm-comparisonValueAdd", /*dynamics*/ ctx[0]));
    			add_location(div, file$2g, 6, 0, 105);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (default_slot) {
    				default_slot.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}

    			if (!current || dirty & /*dynamics*/ 1 && div_class_value !== (div_class_value = renderDynamicsClass("txcm-comparisonValueAdd", /*dynamics*/ ctx[0]))) {
    				attr_dev(div, "class", div_class_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2I($$self, $$props, $$invalidate) {
    	let { dynamics } = $$props;
    	const writable_props = ["dynamics"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonValueAdd> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonValueAdd", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("dynamics" in $$props) $$invalidate(0, dynamics = $$props.dynamics);
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ renderDynamicsClass, dynamics });

    	$$self.$inject_state = $$props => {
    		if ("dynamics" in $$props) $$invalidate(0, dynamics = $$props.dynamics);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [dynamics, $$scope, $$slots];
    }

    class ComparisonValueAdd extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2I, create_fragment$2I, safe_not_equal, { dynamics: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonValueAdd",
    			options,
    			id: create_fragment$2I.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dynamics*/ ctx[0] === undefined && !("dynamics" in props)) {
    			console.warn("<ComparisonValueAdd> was created without expected prop 'dynamics'");
    		}
    	}

    	get dynamics() {
    		throw new Error("<ComparisonValueAdd>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dynamics(value) {
    		throw new Error("<ComparisonValueAdd>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comparison/ComparisonValue.svelte generated by Svelte v3.24.0 */

    // (18:0) {:else}
    function create_else_block$8(ctx) {
    	let comparisonvalueadd;
    	let current;

    	comparisonvalueadd = new ComparisonValueAdd({
    			props: {
    				dynamics: /*dynamics*/ ctx[2],
    				$$slots: { default: [create_default_slot_1$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(comparisonvalueadd.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(comparisonvalueadd, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comparisonvalueadd_changes = {};
    			if (dirty & /*dynamics*/ 4) comparisonvalueadd_changes.dynamics = /*dynamics*/ ctx[2];

    			if (dirty & /*$$scope*/ 32) {
    				comparisonvalueadd_changes.$$scope = { dirty, ctx };
    			}

    			comparisonvalueadd.$set(comparisonvalueadd_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisonvalueadd.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisonvalueadd.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(comparisonvalueadd, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(18:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (11:0) {#if status}
    function create_if_block$T(ctx) {
    	let comparisonvaluemain;
    	let current;

    	comparisonvaluemain = new ComparisonValueMain({
    			props: {
    				units: /*units*/ ctx[0],
    				valueUnits: /*valueUnits*/ ctx[1],
    				dynamics: /*dynamics*/ ctx[2],
    				$$slots: { default: [create_default_slot$I] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(comparisonvaluemain.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(comparisonvaluemain, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comparisonvaluemain_changes = {};
    			if (dirty & /*units*/ 1) comparisonvaluemain_changes.units = /*units*/ ctx[0];
    			if (dirty & /*valueUnits*/ 2) comparisonvaluemain_changes.valueUnits = /*valueUnits*/ ctx[1];
    			if (dirty & /*dynamics*/ 4) comparisonvaluemain_changes.dynamics = /*dynamics*/ ctx[2];

    			if (dirty & /*$$scope*/ 32) {
    				comparisonvaluemain_changes.$$scope = { dirty, ctx };
    			}

    			comparisonvaluemain.$set(comparisonvaluemain_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisonvaluemain.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisonvaluemain.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(comparisonvaluemain, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$T.name,
    		type: "if",
    		source: "(11:0) {#if status}",
    		ctx
    	});

    	return block;
    }

    // (19:2) <ComparisonValueAdd     {dynamics}>
    function create_default_slot_1$c(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(19:2) <ComparisonValueAdd     {dynamics}>",
    		ctx
    	});

    	return block;
    }

    // (12:2) <ComparisonValueMain     {units}     {valueUnits}     {dynamics}>
    function create_default_slot$I(ctx) {
    	let current;
    	const default_slot_template = /*$$slots*/ ctx[4].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 32) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[5], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$I.name,
    		type: "slot",
    		source: "(12:2) <ComparisonValueMain     {units}     {valueUnits}     {dynamics}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2J(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$T, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*status*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2J($$self, $$props, $$invalidate) {
    	let { units = 0 } = $$props;
    	let { valueUnits = 0 } = $$props;
    	let { dynamics = 0 } = $$props;
    	let { status = false } = $$props;
    	const writable_props = ["units", "valueUnits", "dynamics", "status"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonValue> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonValue", $$slots, ['default']);

    	$$self.$set = $$props => {
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("valueUnits" in $$props) $$invalidate(1, valueUnits = $$props.valueUnits);
    		if ("dynamics" in $$props) $$invalidate(2, dynamics = $$props.dynamics);
    		if ("status" in $$props) $$invalidate(3, status = $$props.status);
    		if ("$$scope" in $$props) $$invalidate(5, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ComparisonValueMain,
    		ComparisonValueAdd,
    		units,
    		valueUnits,
    		dynamics,
    		status
    	});

    	$$self.$inject_state = $$props => {
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("valueUnits" in $$props) $$invalidate(1, valueUnits = $$props.valueUnits);
    		if ("dynamics" in $$props) $$invalidate(2, dynamics = $$props.dynamics);
    		if ("status" in $$props) $$invalidate(3, status = $$props.status);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [units, valueUnits, dynamics, status, $$slots, $$scope];
    }

    class ComparisonValue extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$2J, create_fragment$2J, safe_not_equal, {
    			units: 0,
    			valueUnits: 1,
    			dynamics: 2,
    			status: 3
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonValue",
    			options,
    			id: create_fragment$2J.name
    		});
    	}

    	get units() {
    		throw new Error("<ComparisonValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<ComparisonValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get valueUnits() {
    		throw new Error("<ComparisonValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set valueUnits(value) {
    		throw new Error("<ComparisonValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dynamics() {
    		throw new Error("<ComparisonValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dynamics(value) {
    		throw new Error("<ComparisonValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get status() {
    		throw new Error("<ComparisonValue>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set status(value) {
    		throw new Error("<ComparisonValue>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comparison/ComparisonCell.svelte generated by Svelte v3.24.0 */
    const file$2h = "src/js/components/comparison/ComparisonCell.svelte";

    // (15:6) <ComparisonValue         {units}         status={true}         dynamics={checkDynamics(revenuePercent.qNum)}>
    function create_default_slot_3$6(ctx) {
    	let t_value = /*revenuePercent*/ ctx[1].qText + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*revenuePercent*/ 2 && t_value !== (t_value = /*revenuePercent*/ ctx[1].qText + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$6.name,
    		type: "slot",
    		source: "(15:6) <ComparisonValue         {units}         status={true}         dynamics={checkDynamics(revenuePercent.qNum)}>",
    		ctx
    	});

    	return block;
    }

    // (14:4) <ComparisonColumn>
    function create_default_slot_2$7(ctx) {
    	let comparisonvalue;
    	let current;

    	comparisonvalue = new ComparisonValue({
    			props: {
    				units: /*units*/ ctx[0],
    				status: true,
    				dynamics: checkDynamics(/*revenuePercent*/ ctx[1].qNum),
    				$$slots: { default: [create_default_slot_3$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(comparisonvalue.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(comparisonvalue, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comparisonvalue_changes = {};
    			if (dirty & /*units*/ 1) comparisonvalue_changes.units = /*units*/ ctx[0];
    			if (dirty & /*revenuePercent*/ 2) comparisonvalue_changes.dynamics = checkDynamics(/*revenuePercent*/ ctx[1].qNum);

    			if (dirty & /*$$scope, revenuePercent*/ 18) {
    				comparisonvalue_changes.$$scope = { dirty, ctx };
    			}

    			comparisonvalue.$set(comparisonvalue_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisonvalue.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisonvalue.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(comparisonvalue, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(14:4) <ComparisonColumn>",
    		ctx
    	});

    	return block;
    }

    // (23:6) <ComparisonValue         dynamics={checkDynamics(dateDeltaPercent.qNum)}>
    function create_default_slot_1$d(ctx) {
    	let t_value = /*dateDeltaPercent*/ ctx[2].qText + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*dateDeltaPercent*/ 4 && t_value !== (t_value = /*dateDeltaPercent*/ ctx[2].qText + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(23:6) <ComparisonValue         dynamics={checkDynamics(dateDeltaPercent.qNum)}>",
    		ctx
    	});

    	return block;
    }

    // (22:4) <ComparisonColumn>
    function create_default_slot$J(ctx) {
    	let comparisonvalue;
    	let current;

    	comparisonvalue = new ComparisonValue({
    			props: {
    				dynamics: checkDynamics(/*dateDeltaPercent*/ ctx[2].qNum),
    				$$slots: { default: [create_default_slot_1$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(comparisonvalue.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(comparisonvalue, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comparisonvalue_changes = {};
    			if (dirty & /*dateDeltaPercent*/ 4) comparisonvalue_changes.dynamics = checkDynamics(/*dateDeltaPercent*/ ctx[2].qNum);

    			if (dirty & /*$$scope, dateDeltaPercent*/ 20) {
    				comparisonvalue_changes.$$scope = { dirty, ctx };
    			}

    			comparisonvalue.$set(comparisonvalue_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisonvalue.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisonvalue.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(comparisonvalue, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$J.name,
    		type: "slot",
    		source: "(22:4) <ComparisonColumn>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2K(ctx) {
    	let div;
    	let comparisoncolumn0;
    	let t;
    	let comparisoncolumn1;
    	let current;

    	comparisoncolumn0 = new ComparisonColumn({
    			props: {
    				$$slots: { default: [create_default_slot_2$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	comparisoncolumn1 = new ComparisonColumn({
    			props: {
    				$$slots: { default: [create_default_slot$J] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(comparisoncolumn0.$$.fragment);
    			t = space();
    			create_component(comparisoncolumn1.$$.fragment);
    			attr_dev(div, "class", "txcm-comparisonCell");
    			add_location(div, file$2h, 11, 0, 286);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(comparisoncolumn0, div, null);
    			append_dev(div, t);
    			mount_component(comparisoncolumn1, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const comparisoncolumn0_changes = {};

    			if (dirty & /*$$scope, units, revenuePercent*/ 19) {
    				comparisoncolumn0_changes.$$scope = { dirty, ctx };
    			}

    			comparisoncolumn0.$set(comparisoncolumn0_changes);
    			const comparisoncolumn1_changes = {};

    			if (dirty & /*$$scope, dateDeltaPercent*/ 20) {
    				comparisoncolumn1_changes.$$scope = { dirty, ctx };
    			}

    			comparisoncolumn1.$set(comparisoncolumn1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisoncolumn0.$$.fragment, local);
    			transition_in(comparisoncolumn1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisoncolumn0.$$.fragment, local);
    			transition_out(comparisoncolumn1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(comparisoncolumn0);
    			destroy_component(comparisoncolumn1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2K($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { units } = $$props;
    	const writable_props = ["data", "units"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonCell> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonCell", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    	};

    	$$self.$capture_state = () => ({
    		checkDynamics,
    		ComparisonColumn,
    		ComparisonValue,
    		data,
    		units,
    		revenuePercent,
    		dateDeltaPercent
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(3, data = $$props.data);
    		if ("units" in $$props) $$invalidate(0, units = $$props.units);
    		if ("revenuePercent" in $$props) $$invalidate(1, revenuePercent = $$props.revenuePercent);
    		if ("dateDeltaPercent" in $$props) $$invalidate(2, dateDeltaPercent = $$props.dateDeltaPercent);
    	};

    	let revenuePercent;
    	let dateDeltaPercent;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 8) {
    			 $$invalidate(1, { revenuePercent, dateDeltaPercent } = data, revenuePercent, ($$invalidate(2, dateDeltaPercent), $$invalidate(3, data)));
    		}
    	};

    	return [units, revenuePercent, dateDeltaPercent, data];
    }

    class ComparisonCell extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2K, create_fragment$2K, safe_not_equal, { data: 3, units: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonCell",
    			options,
    			id: create_fragment$2K.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[3] === undefined && !("data" in props)) {
    			console.warn("<ComparisonCell> was created without expected prop 'data'");
    		}

    		if (/*units*/ ctx[0] === undefined && !("units" in props)) {
    			console.warn("<ComparisonCell> was created without expected prop 'units'");
    		}
    	}

    	get data() {
    		throw new Error("<ComparisonCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<ComparisonCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<ComparisonCell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<ComparisonCell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comparison/ComparisonGraph.svelte generated by Svelte v3.24.0 */
    const file$2i = "src/js/components/comparison/ComparisonGraph.svelte";

    function create_fragment$2L(ctx) {
    	let div1;
    	let div0;
    	let linegraph;
    	let current;

    	linegraph = new LineGraph({
    			props: {
    				data: /*data*/ ctx[0].chart,
    				count: /*$count*/ ctx[1],
    				step: /*$step*/ ctx[4],
    				shift: /*$shift*/ ctx[3]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(linegraph.$$.fragment);
    			attr_dev(div0, "class", "txcm-comparisonGraphHolder");
    			add_location(div0, file$2i, 15, 4, 541);
    			attr_dev(div1, "class", "txcm-comparisonGraph");
    			set_style(div1, "--highlightWidth", 100 / /*$count*/ ctx[1] + "%");
    			set_style(div1, "--highlightPosition", 100 * /*$highlighted*/ ctx[2] + "%");
    			set_style(div1, "--highlightOpacity", /*$highlighted*/ ctx[2] === null ? 0 : 1);
    			set_style(div1, "--highlightShift", /*$shift*/ ctx[3] + "px");
    			add_location(div1, file$2i, 12, 0, 329);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(linegraph, div0, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const linegraph_changes = {};
    			if (dirty & /*data*/ 1) linegraph_changes.data = /*data*/ ctx[0].chart;
    			if (dirty & /*$count*/ 2) linegraph_changes.count = /*$count*/ ctx[1];
    			if (dirty & /*$step*/ 16) linegraph_changes.step = /*$step*/ ctx[4];
    			if (dirty & /*$shift*/ 8) linegraph_changes.shift = /*$shift*/ ctx[3];
    			linegraph.$set(linegraph_changes);

    			if (!current || dirty & /*$count*/ 2) {
    				set_style(div1, "--highlightWidth", 100 / /*$count*/ ctx[1] + "%");
    			}

    			if (!current || dirty & /*$highlighted*/ 4) {
    				set_style(div1, "--highlightPosition", 100 * /*$highlighted*/ ctx[2] + "%");
    			}

    			if (!current || dirty & /*$highlighted*/ 4) {
    				set_style(div1, "--highlightOpacity", /*$highlighted*/ ctx[2] === null ? 0 : 1);
    			}

    			if (!current || dirty & /*$shift*/ 8) {
    				set_style(div1, "--highlightShift", /*$shift*/ ctx[3] + "px");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(linegraph.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(linegraph.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(linegraph);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2L($$self, $$props, $$invalidate) {
    	let $count;
    	let $highlighted;
    	let $shift;
    	let $step;
    	let { data } = $$props;
    	const step = getGraphsState("step");
    	validate_store(step, "step");
    	component_subscribe($$self, step, value => $$invalidate(4, $step = value));
    	const count = getGraphsState("count");
    	validate_store(count, "count");
    	component_subscribe($$self, count, value => $$invalidate(1, $count = value));
    	const highlighted = getGraphsState("highlighted");
    	validate_store(highlighted, "highlighted");
    	component_subscribe($$self, highlighted, value => $$invalidate(2, $highlighted = value));
    	const shift = getGraphsState("shift");
    	validate_store(shift, "shift");
    	component_subscribe($$self, shift, value => $$invalidate(3, $shift = value));
    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonGraph> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonGraph", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		getGraphsState,
    		LineGraph,
    		data,
    		step,
    		count,
    		highlighted,
    		shift,
    		$count,
    		$highlighted,
    		$shift,
    		$step
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [data, $count, $highlighted, $shift, $step, step, count, highlighted, shift];
    }

    class ComparisonGraph extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2L, create_fragment$2L, safe_not_equal, { data: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonGraph",
    			options,
    			id: create_fragment$2L.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<ComparisonGraph> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<ComparisonGraph>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<ComparisonGraph>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comparison/ComparisonDeviations.svelte generated by Svelte v3.24.0 */

    // (9:0) {#if formatDeviations}
    function create_if_block_1$g(ctx) {
    	let deviationrow;
    	let current;

    	deviationrow = new DeviationRow({
    			props: {
    				multiple: "форматам",
    				key: "formatName",
    				data: /*formatDeviations*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(deviationrow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deviationrow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const deviationrow_changes = {};
    			if (dirty & /*formatDeviations*/ 1) deviationrow_changes.data = /*formatDeviations*/ ctx[0];
    			deviationrow.$set(deviationrow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deviationrow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deviationrow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deviationrow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(9:0) {#if formatDeviations}",
    		ctx
    	});

    	return block;
    }

    // (15:0) {#if regionDeviations}
    function create_if_block$U(ctx) {
    	let deviationrow;
    	let current;

    	deviationrow = new DeviationRow({
    			props: {
    				multiple: "регионам",
    				key: "regionName",
    				data: /*regionDeviations*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(deviationrow.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(deviationrow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const deviationrow_changes = {};
    			if (dirty & /*regionDeviations*/ 2) deviationrow_changes.data = /*regionDeviations*/ ctx[1];
    			deviationrow.$set(deviationrow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(deviationrow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(deviationrow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(deviationrow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$U.name,
    		type: "if",
    		source: "(15:0) {#if regionDeviations}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2M(ctx) {
    	let t;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*formatDeviations*/ ctx[0] && create_if_block_1$g(ctx);
    	let if_block1 = /*regionDeviations*/ ctx[1] && create_if_block$U(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*formatDeviations*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*formatDeviations*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$g(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t.parentNode, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*regionDeviations*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*regionDeviations*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$U(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2M($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonDeviations> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonDeviations", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(2, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		DeviationRow,
    		data,
    		formatDeviations,
    		regionDeviations
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(2, data = $$props.data);
    		if ("formatDeviations" in $$props) $$invalidate(0, formatDeviations = $$props.formatDeviations);
    		if ("regionDeviations" in $$props) $$invalidate(1, regionDeviations = $$props.regionDeviations);
    	};

    	let formatDeviations;
    	let regionDeviations;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 4) {
    			 $$invalidate(0, { formatDeviations, regionDeviations } = data, formatDeviations, ($$invalidate(1, regionDeviations), $$invalidate(2, data)));
    		}
    	};

    	return [formatDeviations, regionDeviations, data];
    }

    class ComparisonDeviations extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2M, create_fragment$2M, safe_not_equal, { data: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonDeviations",
    			options,
    			id: create_fragment$2M.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[2] === undefined && !("data" in props)) {
    			console.warn("<ComparisonDeviations> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<ComparisonDeviations>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<ComparisonDeviations>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comparison/ComparisonRow.svelte generated by Svelte v3.24.0 */
    const file$2j = "src/js/components/comparison/ComparisonRow.svelte";

    // (41:4) {#if hasGraph}
    function create_if_block$V(ctx) {
    	let comparisongraph;
    	let current;

    	comparisongraph = new ComparisonGraph({
    			props: { data: /*data*/ ctx[0].graph },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(comparisongraph.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(comparisongraph, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comparisongraph_changes = {};
    			if (dirty & /*data*/ 1) comparisongraph_changes.data = /*data*/ ctx[0].graph;
    			comparisongraph.$set(comparisongraph_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisongraph.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisongraph.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(comparisongraph, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$V.name,
    		type: "if",
    		source: "(41:4) {#if hasGraph}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2N(ctx) {
    	let div;
    	let comparisonlabel;
    	let t0;
    	let comparisoncell0;
    	let t1;
    	let comparisoncell1;
    	let t2;
    	let t3;
    	let comparisondeviations;
    	let div_transition;
    	let current;

    	comparisonlabel = new ComparisonLabel({
    			props: { data: /*data*/ ctx[0] },
    			$$inline: true
    		});

    	comparisoncell0 = new ComparisonCell({
    			props: {
    				units: /*units*/ ctx[1],
    				data: /*data*/ ctx[0].column1
    			},
    			$$inline: true
    		});

    	comparisoncell1 = new ComparisonCell({
    			props: {
    				units: /*units*/ ctx[1],
    				data: /*data*/ ctx[0].column2
    			},
    			$$inline: true
    		});

    	let if_block = /*hasGraph*/ ctx[4] && create_if_block$V(ctx);

    	comparisondeviations = new ComparisonDeviations({
    			props: { data: /*data*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(comparisonlabel.$$.fragment);
    			t0 = space();
    			create_component(comparisoncell0.$$.fragment);
    			t1 = space();
    			create_component(comparisoncell1.$$.fragment);
    			t2 = space();
    			if (if_block) if_block.c();
    			t3 = space();
    			create_component(comparisondeviations.$$.fragment);
    			attr_dev(div, "class", "txcm-comparisonRow");
    			toggle_class(div, "txcm-comparisonRow-has-deviations", /*hasDeviations*/ ctx[3]);
    			toggle_class(div, "txcm-comparisonRow-has-graph", /*hasGraph*/ ctx[4]);
    			add_location(div, file$2j, 27, 0, 799);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(comparisonlabel, div, null);
    			append_dev(div, t0);
    			mount_component(comparisoncell0, div, null);
    			append_dev(div, t1);
    			mount_component(comparisoncell1, div, null);
    			append_dev(div, t2);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t3);
    			mount_component(comparisondeviations, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const comparisonlabel_changes = {};
    			if (dirty & /*data*/ 1) comparisonlabel_changes.data = /*data*/ ctx[0];
    			comparisonlabel.$set(comparisonlabel_changes);
    			const comparisoncell0_changes = {};
    			if (dirty & /*units*/ 2) comparisoncell0_changes.units = /*units*/ ctx[1];
    			if (dirty & /*data*/ 1) comparisoncell0_changes.data = /*data*/ ctx[0].column1;
    			comparisoncell0.$set(comparisoncell0_changes);
    			const comparisoncell1_changes = {};
    			if (dirty & /*units*/ 2) comparisoncell1_changes.units = /*units*/ ctx[1];
    			if (dirty & /*data*/ 1) comparisoncell1_changes.data = /*data*/ ctx[0].column2;
    			comparisoncell1.$set(comparisoncell1_changes);

    			if (/*hasGraph*/ ctx[4]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*hasGraph*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$V(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, t3);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const comparisondeviations_changes = {};
    			if (dirty & /*data*/ 1) comparisondeviations_changes.data = /*data*/ ctx[0];
    			comparisondeviations.$set(comparisondeviations_changes);

    			if (dirty & /*hasDeviations*/ 8) {
    				toggle_class(div, "txcm-comparisonRow-has-deviations", /*hasDeviations*/ ctx[3]);
    			}

    			if (dirty & /*hasGraph*/ 16) {
    				toggle_class(div, "txcm-comparisonRow-has-graph", /*hasGraph*/ ctx[4]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisonlabel.$$.fragment, local);
    			transition_in(comparisoncell0.$$.fragment, local);
    			transition_in(comparisoncell1.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(comparisondeviations.$$.fragment, local);

    			if (local) {
    				add_render_callback(() => {
    					if (!div_transition) div_transition = create_bidirectional_transition(div, shiftVertical, { height: /*height*/ ctx[2] }, true);
    					div_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisonlabel.$$.fragment, local);
    			transition_out(comparisoncell0.$$.fragment, local);
    			transition_out(comparisoncell1.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(comparisondeviations.$$.fragment, local);

    			if (local) {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, shiftVertical, { height: /*height*/ ctx[2] }, false);
    				div_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(comparisonlabel);
    			destroy_component(comparisoncell0);
    			destroy_component(comparisoncell1);
    			if (if_block) if_block.d();
    			destroy_component(comparisondeviations);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const BASE_HEIGHT$1 = 110;
    const DEVIATION_HEIGHT$1 = 32;

    function calculateHeight$1(data) {
    	let height = BASE_HEIGHT$1;
    	height += data.formatDeviations ? DEVIATION_HEIGHT$1 : 0;
    	height += data.regionDeviations ? DEVIATION_HEIGHT$1 : 0;
    	return height;
    }

    function instance$2N($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { units = 0 } = $$props;
    	const writable_props = ["data", "units"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonRow> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonRow", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("units" in $$props) $$invalidate(1, units = $$props.units);
    	};

    	$$self.$capture_state = () => ({
    		BASE_HEIGHT: BASE_HEIGHT$1,
    		DEVIATION_HEIGHT: DEVIATION_HEIGHT$1,
    		calculateHeight: calculateHeight$1,
    		shiftVertical,
    		ComparisonLabel,
    		ComparisonCell,
    		ComparisonGraph,
    		ComparisonDeviations,
    		data,
    		units,
    		height,
    		hasDeviations,
    		hasGraph
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("units" in $$props) $$invalidate(1, units = $$props.units);
    		if ("height" in $$props) $$invalidate(2, height = $$props.height);
    		if ("hasDeviations" in $$props) $$invalidate(3, hasDeviations = $$props.hasDeviations);
    		if ("hasGraph" in $$props) $$invalidate(4, hasGraph = $$props.hasGraph);
    	};

    	let height;
    	let hasDeviations;
    	let hasGraph;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 1) {
    			 $$invalidate(2, height = calculateHeight$1(data));
    		}

    		if ($$self.$$.dirty & /*data*/ 1) {
    			 $$invalidate(3, hasDeviations = data.regionDeviations || data.formatDeviation);
    		}

    		if ($$self.$$.dirty & /*data*/ 1) {
    			 $$invalidate(4, hasGraph = data.graph);
    		}
    	};

    	return [data, units, height, hasDeviations, hasGraph];
    }

    class ComparisonRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2N, create_fragment$2N, safe_not_equal, { data: 0, units: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonRow",
    			options,
    			id: create_fragment$2N.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<ComparisonRow> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<ComparisonRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<ComparisonRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<ComparisonRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<ComparisonRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comparisons/ComparisonsContent.svelte generated by Svelte v3.24.0 */

    function get_each_context$z(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (22:0) {#each active as activeComparisonIndicator (activeComparisonIndicator.id)}
    function create_each_block$z(key_1, ctx) {
    	let first;
    	let comparisonrow;
    	let current;

    	comparisonrow = new ComparisonRow({
    			props: {
    				data: /*activeComparisonIndicator*/ ctx[6]
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(comparisonrow.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(comparisonrow, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comparisonrow_changes = {};
    			if (dirty & /*active*/ 1) comparisonrow_changes.data = /*activeComparisonIndicator*/ ctx[6];
    			comparisonrow.$set(comparisonrow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisonrow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisonrow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(comparisonrow, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$z.name,
    		type: "each",
    		source: "(22:0) {#each active as activeComparisonIndicator (activeComparisonIndicator.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2O(ctx) {
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let each_1_anchor;
    	let current;
    	let each_value = /*active*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*activeComparisonIndicator*/ ctx[6].id;
    	validate_each_keys(ctx, each_value, get_each_context$z, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$z(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$z(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*active*/ 1) {
    				const each_value = /*active*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$z, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$z, each_1_anchor, get_each_context$z);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d(detaching);
    			}

    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2O($$self, $$props, $$invalidate) {
    	let $activeComparisonIndicators;
    	let { data } = $$props;
    	const activeComparisonIndicators = getActiveComparisonIndicatorsState();
    	validate_store(activeComparisonIndicators, "activeComparisonIndicators");
    	component_subscribe($$self, activeComparisonIndicators, value => $$invalidate(3, $activeComparisonIndicators = value));
    	let active = [];

    	function findActiveComparisonIndicator(option) {
    		return $activeComparisonIndicators.find(id => `${option.id}` === `${id}`);
    	}

    	function updateActive() {
    		if (data) $$invalidate(0, active = data.filter(findActiveComparisonIndicator));
    	}

    	const writable_props = ["data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComparisonsContent> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ComparisonsContent", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(2, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		getActiveComparisonIndicatorsState,
    		ComparisonRow,
    		data,
    		activeComparisonIndicators,
    		active,
    		findActiveComparisonIndicator,
    		updateActive,
    		$activeComparisonIndicators
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(2, data = $$props.data);
    		if ("active" in $$props) $$invalidate(0, active = $$props.active);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$activeComparisonIndicators, data*/ 12) {
    			 updateActive();
    		}
    	};

    	return [active, activeComparisonIndicators, data];
    }

    class ComparisonsContent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2O, create_fragment$2O, safe_not_equal, { data: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComparisonsContent",
    			options,
    			id: create_fragment$2O.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[2] === undefined && !("data" in props)) {
    			console.warn("<ComparisonsContent> was created without expected prop 'data'");
    		}
    	}

    	get data() {
    		throw new Error("<ComparisonsContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<ComparisonsContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/comparisons/Comparisons.svelte generated by Svelte v3.24.0 */

    const { Object: Object_1$5 } = globals;
    const file$2k = "src/js/components/comparisons/Comparisons.svelte";

    // (64:4) {#if comparisonData}
    function create_if_block$W(ctx) {
    	let div;
    	let kpirow;
    	let t;
    	let sectionScroll_action;
    	let current;
    	let mounted;
    	let dispose;

    	kpirow = new KPIRow({
    			props: {
    				indicator: /*findIndicator*/ ctx[3](/*indicator*/ ctx[0]),
    				data: /*comparisonData*/ ctx[1]
    			},
    			$$inline: true
    		});

    	let if_block = /*comparisonIndicators*/ ctx[2] && create_if_block_1$h(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(kpirow.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "txcm-comparisonsRows");
    			add_location(div, file$2k, 64, 6, 1789);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(kpirow, div, null);
    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			current = true;

    			if (!mounted) {
    				dispose = action_destroyer(sectionScroll_action = sectionScroll.call(null, div, true));
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const kpirow_changes = {};
    			if (dirty & /*indicator*/ 1) kpirow_changes.indicator = /*findIndicator*/ ctx[3](/*indicator*/ ctx[0]);
    			if (dirty & /*comparisonData*/ 2) kpirow_changes.data = /*comparisonData*/ ctx[1];
    			kpirow.$set(kpirow_changes);

    			if (/*comparisonIndicators*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*comparisonIndicators*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(kpirow.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(kpirow.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(kpirow);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$W.name,
    		type: "if",
    		source: "(64:4) {#if comparisonData}",
    		ctx
    	});

    	return block;
    }

    // (71:10) {#if comparisonIndicators}
    function create_if_block_1$h(ctx) {
    	let comparisonscontent;
    	let current;

    	comparisonscontent = new ComparisonsContent({
    			props: { data: /*comparisonIndicators*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(comparisonscontent.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(comparisonscontent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comparisonscontent_changes = {};
    			if (dirty & /*comparisonIndicators*/ 4) comparisonscontent_changes.data = /*comparisonIndicators*/ ctx[2];
    			comparisonscontent.$set(comparisonscontent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisonscontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisonscontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(comparisonscontent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(71:10) {#if comparisonIndicators}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2P(ctx) {
    	let section;
    	let comparisonstableheader;
    	let t0;
    	let comparisonindicators;
    	let t1;
    	let current;
    	comparisonstableheader = new ComparisonsTableHeader({ $$inline: true });
    	comparisonindicators = new ComparisonIndicators({ $$inline: true });
    	let if_block = /*comparisonData*/ ctx[1] && create_if_block$W(ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			create_component(comparisonstableheader.$$.fragment);
    			t0 = space();
    			create_component(comparisonindicators.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			attr_dev(section, "class", "txcm-comparisonsSection");
    			add_location(section, file$2k, 59, 0, 1654);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			mount_component(comparisonstableheader, section, null);
    			append_dev(section, t0);
    			mount_component(comparisonindicators, section, null);
    			append_dev(section, t1);
    			if (if_block) if_block.m(section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*comparisonData*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*comparisonData*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$W(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(section, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisonstableheader.$$.fragment, local);
    			transition_in(comparisonindicators.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisonstableheader.$$.fragment, local);
    			transition_out(comparisonindicators.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(comparisonstableheader);
    			destroy_component(comparisonindicators);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function flattenIndicators$2(results, option) {
    	return { ...results, [option.id]: option };
    }

    function flattenCategories$2(results, group) {
    	return {
    		...results,
    		...group.indicators.reduce(flattenIndicators$2, {})
    	};
    }

    function instance$2P($$self, $$props, $$invalidate) {
    	let { data = null } = $$props;
    	let { indicator } = $$props;
    	const config = getContext("config").getIndicatorsConfig();
    	const indicators = Object.values(config).reduce(flattenCategories$2, {});
    	let comparisonData;
    	let comparisonIndicators;

    	setContext("comparisonsConfig", {
    		getComparisonIndicatorsConfig: () => comparisonIndicators
    	});

    	onDestroy(destroy);

    	function initComparisonIndicatorsState() {
    		if (comparisonIndicators) initComparisonIndicators(comparisonIndicators);
    	}

    	function findIndicator() {
    		return Object.values(indicators).find(option => option.url === indicator);
    	}

    	function updateData() {
    		$$invalidate(1, comparisonData = data || null);
    		$$invalidate(2, comparisonIndicators = data && data.comparisons ? data.comparisons : null);
    		initComparisonIndicatorsState();
    	}

    	function destroy() {
    		destroyComparisons();
    	}

    	const writable_props = ["data", "indicator"];

    	Object_1$5.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Comparisons> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Comparisons", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(4, data = $$props.data);
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		setContext,
    		onDestroy,
    		initComparisonIndicators,
    		destroyComparisons,
    		sectionScroll,
    		KPIRow,
    		ComparisonIndicators,
    		ComparisonsTableHeader,
    		ComparisonsContent,
    		data,
    		indicator,
    		config,
    		indicators,
    		comparisonData,
    		comparisonIndicators,
    		flattenIndicators: flattenIndicators$2,
    		flattenCategories: flattenCategories$2,
    		initComparisonIndicatorsState,
    		findIndicator,
    		updateData,
    		destroy
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(4, data = $$props.data);
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    		if ("comparisonData" in $$props) $$invalidate(1, comparisonData = $$props.comparisonData);
    		if ("comparisonIndicators" in $$props) $$invalidate(2, comparisonIndicators = $$props.comparisonIndicators);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*data*/ 16) {
    			 updateData();
    		}
    	};

    	return [indicator, comparisonData, comparisonIndicators, findIndicator, data];
    }

    class Comparisons extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2P, create_fragment$2P, safe_not_equal, { data: 4, indicator: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Comparisons",
    			options,
    			id: create_fragment$2P.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*indicator*/ ctx[0] === undefined && !("indicator" in props)) {
    			console.warn("<Comparisons> was created without expected prop 'indicator'");
    		}
    	}

    	get data() {
    		throw new Error("<Comparisons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Comparisons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<Comparisons>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<Comparisons>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/exportSlice/ExportSlice.svelte generated by Svelte v3.24.0 */
    const file$2l = "src/js/components/exportSlice/ExportSlice.svelte";

    function get_each_context$A(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[32] = list[i];
    	child_ctx[34] = i;
    	return child_ctx;
    }

    // (159:12) {#each filtered as option, optionIndex (renderID(slice.value, optionIndex))}
    function create_each_block$A(key_1, ctx) {
    	let input;
    	let input_id_value;
    	let input_value_value;
    	let t0;
    	let label_1;
    	let int;
    	let t1;
    	let svg;
    	let use;
    	let t2;
    	let label_1_for_value;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*option*/ ctx[32].label },
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			input = element("input");
    			t0 = space();
    			label_1 = element("label");
    			create_component(int.$$.fragment);
    			t1 = space();
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t2 = space();
    			attr_dev(input, "class", "txcm-exportSliceOptionInput");
    			attr_dev(input, "id", input_id_value = renderID(`export-${/*slice*/ ctx[0].value}`, /*optionIndex*/ ctx[34]));
    			attr_dev(input, "type", "checkbox");
    			input.__value = input_value_value = /*option*/ ctx[32].value;
    			input.value = input.__value;
    			/*$$binding_groups*/ ctx[16][0].push(input);
    			add_location(input, file$2l, 159, 14, 3911);
    			xlink_attr(use, "xlink:href", "#txspt-icons-checkmark");
    			add_location(use, file$2l, 172, 22, 4461);
    			attr_dev(svg, "class", "txcm-exportSliceOptionLabelIcon");
    			add_location(svg, file$2l, 170, 18, 4373);
    			attr_dev(label_1, "class", "txcm-exportSliceOptionLabel");
    			attr_dev(label_1, "for", label_1_for_value = renderID(`export-${/*slice*/ ctx[0].value}`, /*optionIndex*/ ctx[34]));
    			add_location(label_1, file$2l, 165, 14, 4161);
    			this.first = input;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			input.checked = ~/*options*/ ctx[2].indexOf(input.__value);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, label_1, anchor);
    			mount_component(int, label_1, null);
    			append_dev(label_1, t1);
    			append_dev(label_1, svg);
    			append_dev(svg, use);
    			append_dev(label_1, t2);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "change", /*input_change_handler*/ ctx[15]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty[0] & /*slice, filtered*/ 65 && input_id_value !== (input_id_value = renderID(`export-${/*slice*/ ctx[0].value}`, /*optionIndex*/ ctx[34]))) {
    				attr_dev(input, "id", input_id_value);
    			}

    			if (!current || dirty[0] & /*filtered*/ 64 && input_value_value !== (input_value_value = /*option*/ ctx[32].value)) {
    				prop_dev(input, "__value", input_value_value);
    				input.value = input.__value;
    			}

    			if (dirty[0] & /*options*/ 4) {
    				input.checked = ~/*options*/ ctx[2].indexOf(input.__value);
    			}

    			const int_changes = {};
    			if (dirty[0] & /*filtered*/ 64) int_changes.key = /*option*/ ctx[32].label;
    			int.$set(int_changes);

    			if (!current || dirty[0] & /*slice, filtered*/ 65 && label_1_for_value !== (label_1_for_value = renderID(`export-${/*slice*/ ctx[0].value}`, /*optionIndex*/ ctx[34]))) {
    				attr_dev(label_1, "for", label_1_for_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			/*$$binding_groups*/ ctx[16][0].splice(/*$$binding_groups*/ ctx[16][0].indexOf(input), 1);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(label_1);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$A.name,
    		type: "each",
    		source: "(159:12) {#each filtered as option, optionIndex (renderID(slice.value, optionIndex))}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2Q(ctx) {
    	let div3;
    	let div0;
    	let int0;
    	let t0;
    	let button0;
    	let int1;
    	let t1;
    	let button1;
    	let int2;
    	let t2;
    	let svg;
    	let use;
    	let t3;
    	let div2;
    	let listfilter;
    	let updating_value;
    	let t4;
    	let button2;
    	let span0;
    	let int3;
    	let t5;
    	let span1;
    	let int4;
    	let t6;
    	let button3;
    	let int5;
    	let t7;
    	let div1;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowresize*/ ctx[13]);

    	int0 = new Int({
    			props: { key: /*slice*/ ctx[0].label },
    			$$inline: true
    		});

    	int1 = new Int({
    			props: { key: "Удалить" },
    			$$inline: true
    		});

    	int2 = new Int({
    			props: { key: /*label*/ ctx[5] },
    			$$inline: true
    		});

    	function listfilter_value_binding(value) {
    		/*listfilter_value_binding*/ ctx[14].call(null, value);
    	}

    	let listfilter_props = { theme: "txcm-listFilter-slice" };

    	if (/*filter*/ ctx[1] !== void 0) {
    		listfilter_props.value = /*filter*/ ctx[1];
    	}

    	listfilter = new ListFilter({ props: listfilter_props, $$inline: true });
    	binding_callbacks.push(() => bind(listfilter, "value", listfilter_value_binding));

    	int3 = new Int({
    			props: { key: "Выбрать все" },
    			$$inline: true
    		});

    	int4 = new Int({ props: { key: "Все" }, $$inline: true });

    	int5 = new Int({
    			props: { key: "Сбросить" },
    			$$inline: true
    		});

    	let each_value = /*filtered*/ ctx[6];
    	validate_each_argument(each_value);
    	const get_key = ctx => renderID(/*slice*/ ctx[0].value, /*optionIndex*/ ctx[34]);
    	validate_each_keys(ctx, each_value, get_each_context$A, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$A(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$A(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			create_component(int0.$$.fragment);
    			t0 = space();
    			button0 = element("button");
    			create_component(int1.$$.fragment);
    			t1 = space();
    			button1 = element("button");
    			create_component(int2.$$.fragment);
    			t2 = space();
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t3 = space();
    			div2 = element("div");
    			create_component(listfilter.$$.fragment);
    			t4 = space();
    			button2 = element("button");
    			span0 = element("span");
    			create_component(int3.$$.fragment);
    			t5 = space();
    			span1 = element("span");
    			create_component(int4.$$.fragment);
    			t6 = space();
    			button3 = element("button");
    			create_component(int5.$$.fragment);
    			t7 = space();
    			div1 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "txcm-exportSiceHeader");
    			add_location(div0, file$2l, 107, 4, 2413);
    			attr_dev(button0, "class", "txcm-exportSliceRemove");
    			add_location(button0, file$2l, 112, 4, 2514);
    			xlink_attr(use, "xlink:href", "#txspt-icons-angleArrow");
    			add_location(use, file$2l, 126, 12, 2891);
    			attr_dev(svg, "class", "txcm-exportSliceToggleIcon");
    			add_location(svg, file$2l, 124, 8, 2828);
    			attr_dev(button1, "class", "txcm-exportSliceToggle");
    			toggle_class(button1, "txcm-exportSliceToggle-is-active", /*isActive*/ ctx[3]);
    			add_location(button1, file$2l, 118, 4, 2649);
    			attr_dev(span0, "class", "txcm-exportSliceSelectAllText");
    			add_location(span0, file$2l, 139, 12, 3288);
    			attr_dev(span1, "class", "txcm-exportSliceSelectAllMobileText");
    			add_location(span1, file$2l, 144, 12, 3439);
    			attr_dev(button2, "class", "txcm-exportSliceSelectAll");
    			add_location(button2, file$2l, 136, 8, 3185);
    			attr_dev(button3, "class", "txcm-exportSliceClear");
    			add_location(button3, file$2l, 150, 8, 3602);
    			attr_dev(div1, "class", "txcm-exportSliceOptions");
    			add_location(div1, file$2l, 156, 8, 3760);
    			attr_dev(div2, "class", "txcm-exportSliceContent");
    			toggle_class(div2, "txcm-exportSliceContent-is-active", /*isActive*/ ctx[3]);
    			add_location(div2, file$2l, 130, 4, 2983);
    			attr_dev(div3, "class", "txcm-exportSlice");
    			toggle_class(div3, "txcm-exportSlice-is-switching", /*isSwitching*/ ctx[8]);
    			add_location(div3, file$2l, 104, 0, 2324);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			mount_component(int0, div0, null);
    			append_dev(div3, t0);
    			append_dev(div3, button0);
    			mount_component(int1, button0, null);
    			append_dev(div3, t1);
    			append_dev(div3, button1);
    			mount_component(int2, button1, null);
    			append_dev(button1, t2);
    			append_dev(button1, svg);
    			append_dev(svg, use);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			mount_component(listfilter, div2, null);
    			append_dev(div2, t4);
    			append_dev(div2, button2);
    			append_dev(button2, span0);
    			mount_component(int3, span0, null);
    			append_dev(button2, t5);
    			append_dev(button2, span1);
    			mount_component(int4, span1, null);
    			append_dev(div2, t6);
    			append_dev(div2, button3);
    			mount_component(int5, button3, null);
    			append_dev(div2, t7);
    			append_dev(div2, div1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div1, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "resize", /*onwindowresize*/ ctx[13]),
    					listen_dev(button0, "click", /*onRemoveClick*/ ctx[9], false, false, false),
    					listen_dev(button1, "click", /*onToggleClick*/ ctx[12], false, false, false),
    					listen_dev(button2, "click", /*onSelectAllClick*/ ctx[10], false, false, false),
    					listen_dev(button3, "click", /*onClearClick*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const int0_changes = {};
    			if (dirty[0] & /*slice*/ 1) int0_changes.key = /*slice*/ ctx[0].label;
    			int0.$set(int0_changes);
    			const int2_changes = {};
    			if (dirty[0] & /*label*/ 32) int2_changes.key = /*label*/ ctx[5];
    			int2.$set(int2_changes);

    			if (dirty[0] & /*isActive*/ 8) {
    				toggle_class(button1, "txcm-exportSliceToggle-is-active", /*isActive*/ ctx[3]);
    			}

    			const listfilter_changes = {};

    			if (!updating_value && dirty[0] & /*filter*/ 2) {
    				updating_value = true;
    				listfilter_changes.value = /*filter*/ ctx[1];
    				add_flush_callback(() => updating_value = false);
    			}

    			listfilter.$set(listfilter_changes);

    			if (dirty[0] & /*slice, filtered, options*/ 69) {
    				const each_value = /*filtered*/ ctx[6];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$A, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div1, outro_and_destroy_block, create_each_block$A, null, get_each_context$A);
    				check_outros();
    			}

    			if (dirty[0] & /*isActive*/ 8) {
    				toggle_class(div2, "txcm-exportSliceContent-is-active", /*isActive*/ ctx[3]);
    			}

    			if (dirty[0] & /*isSwitching*/ 256) {
    				toggle_class(div3, "txcm-exportSlice-is-switching", /*isSwitching*/ ctx[8]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			transition_in(int2.$$.fragment, local);
    			transition_in(listfilter.$$.fragment, local);
    			transition_in(int3.$$.fragment, local);
    			transition_in(int4.$$.fragment, local);
    			transition_in(int5.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			transition_out(int2.$$.fragment, local);
    			transition_out(listfilter.$$.fragment, local);
    			transition_out(int3.$$.fragment, local);
    			transition_out(int4.$$.fragment, local);
    			transition_out(int5.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_component(int0);
    			destroy_component(int1);
    			destroy_component(int2);
    			destroy_component(listfilter);
    			destroy_component(int3);
    			destroy_component(int4);
    			destroy_component(int5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const ORIENTATION_THRESHOLD = 768;
    const LABEL_COUNT = 2;

    function instance$2Q($$self, $$props, $$invalidate) {
    	let $slicesFilter;
    	let { slice } = $$props;
    	const slicesFilter = getExportState("slicesFilter");
    	validate_store(slicesFilter, "slicesFilter");
    	component_subscribe($$self, slicesFilter, value => $$invalidate(18, $slicesFilter = value));
    	const dispatch = createEventDispatcher();
    	let filter = "";
    	let options = generateAll();
    	let isActive;
    	let isSwitching;
    	let innerWidth;

    	function updateFilter() {
    		return { ...$slicesFilter, [slice.value]: options };
    	}

    	function detectOrientation() {
    		switchOrientation = innerWidth <= ORIENTATION_THRESHOLD;
    	}

    	function generateLabel(value) {
    		return slice.options.find(sliceOption => sliceOption.value === value).label;
    	}

    	function generateLabels(values) {
    		return values.map(generateLabel);
    	}

    	function generateToggleLabel() {
    		if (isActive || options.length === 0) return "Добавить";
    		if (options.length <= LABEL_COUNT) return generateLabels(options).join(", ");
    		const remainder = options.length - LABEL_COUNT;
    		const optionsText = generateLabels(options.slice(0, LABEL_COUNT)).join(", ");
    		if (remainder > 0) return `${optionsText} и еще ${remainder}`;
    		return optionsText;
    	}

    	function generateAll() {
    		return slice.options.map(option => option.value);
    	}

    	function pickAll() {
    		$$invalidate(2, options = generateAll());
    	}

    	function drop() {
    		$$invalidate(2, options = []);
    	}

    	function hide() {
    		$$invalidate(3, isActive = false);
    	}

    	function show() {
    		$$invalidate(3, isActive = true);
    	}

    	function toggle() {
    		if (isActive) hide(); else show();
    	}

    	function removeSlice() {
    		dispatch("removeslice", { id: slice.value });
    	}

    	function onRemoveClick() {
    		removeSlice();
    	}

    	function onSelectAllClick() {
    		pickAll();
    	}

    	function onClearClick() {
    		drop();
    	}

    	function onToggleClick() {
    		toggle();
    	}

    	const writable_props = ["slice"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ExportSlice> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ExportSlice", $$slots, []);
    	const $$binding_groups = [[]];

    	function onwindowresize() {
    		$$invalidate(4, innerWidth = window.innerWidth);
    	}

    	function listfilter_value_binding(value) {
    		filter = value;
    		$$invalidate(1, filter);
    	}

    	function input_change_handler() {
    		options = get_binding_group_value($$binding_groups[0], this.__value, this.checked);
    		$$invalidate(2, options);
    	}

    	$$self.$set = $$props => {
    		if ("slice" in $$props) $$invalidate(0, slice = $$props.slice);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		getExportState,
    		renderID,
    		filterSelectOptions,
    		Int,
    		ListFilter,
    		ORIENTATION_THRESHOLD,
    		LABEL_COUNT,
    		slice,
    		slicesFilter,
    		dispatch,
    		filter,
    		options,
    		isActive,
    		isSwitching,
    		innerWidth,
    		updateFilter,
    		detectOrientation,
    		generateLabel,
    		generateLabels,
    		generateToggleLabel,
    		generateAll,
    		pickAll,
    		drop,
    		hide,
    		show,
    		toggle,
    		removeSlice,
    		onRemoveClick,
    		onSelectAllClick,
    		onClearClick,
    		onToggleClick,
    		switchOrientation,
    		label,
    		filtered,
    		$slicesFilter
    	});

    	$$self.$inject_state = $$props => {
    		if ("slice" in $$props) $$invalidate(0, slice = $$props.slice);
    		if ("filter" in $$props) $$invalidate(1, filter = $$props.filter);
    		if ("options" in $$props) $$invalidate(2, options = $$props.options);
    		if ("isActive" in $$props) $$invalidate(3, isActive = $$props.isActive);
    		if ("isSwitching" in $$props) $$invalidate(8, isSwitching = $$props.isSwitching);
    		if ("innerWidth" in $$props) $$invalidate(4, innerWidth = $$props.innerWidth);
    		if ("switchOrientation" in $$props) switchOrientation = $$props.switchOrientation;
    		if ("label" in $$props) $$invalidate(5, label = $$props.label);
    		if ("filtered" in $$props) $$invalidate(6, filtered = $$props.filtered);
    	};

    	let switchOrientation;
    	let label;
    	let filtered;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*innerWidth*/ 16) {
    			 switchOrientation = detectOrientation();
    		}

    		if ($$self.$$.dirty[0] & /*isActive, options*/ 12) {
    			 $$invalidate(5, label = generateToggleLabel());
    		}

    		if ($$self.$$.dirty[0] & /*slice, filter*/ 3) {
    			 $$invalidate(6, filtered = filterSelectOptions(slice.options, filter));
    		}

    		if ($$self.$$.dirty[0] & /*options*/ 4) {
    			 set_store_value(slicesFilter, $slicesFilter = updateFilter());
    		}
    	};

    	return [
    		slice,
    		filter,
    		options,
    		isActive,
    		innerWidth,
    		label,
    		filtered,
    		slicesFilter,
    		isSwitching,
    		onRemoveClick,
    		onSelectAllClick,
    		onClearClick,
    		onToggleClick,
    		onwindowresize,
    		listfilter_value_binding,
    		input_change_handler,
    		$$binding_groups
    	];
    }

    class ExportSlice extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2Q, create_fragment$2Q, safe_not_equal, { slice: 0 }, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ExportSlice",
    			options,
    			id: create_fragment$2Q.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*slice*/ ctx[0] === undefined && !("slice" in props)) {
    			console.warn("<ExportSlice> was created without expected prop 'slice'");
    		}
    	}

    	get slice() {
    		throw new Error("<ExportSlice>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set slice(value) {
    		throw new Error("<ExportSlice>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/exportSlices/ExportSlicesRow.svelte generated by Svelte v3.24.0 */
    const file$2m = "src/js/components/exportSlices/ExportSlicesRow.svelte";

    function get_each_context$B(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    // (9:4) {#each slices as slice (slice.value)}
    function create_each_block$B(key_1, ctx) {
    	let first;
    	let exportslice;
    	let current;

    	exportslice = new ExportSlice({
    			props: { slice: /*slice*/ ctx[3] },
    			$$inline: true
    		});

    	exportslice.$on("removeslice", /*removeslice_handler*/ ctx[1]);
    	exportslice.$on("switchslices", /*switchslices_handler*/ ctx[2]);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(exportslice.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(exportslice, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const exportslice_changes = {};
    			if (dirty & /*slices*/ 1) exportslice_changes.slice = /*slice*/ ctx[3];
    			exportslice.$set(exportslice_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(exportslice.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(exportslice.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(exportslice, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$B.name,
    		type: "each",
    		source: "(9:4) {#each slices as slice (slice.value)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2R(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value = /*slices*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*slice*/ ctx[3].value;
    	validate_each_keys(ctx, each_value, get_each_context$B, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$B(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$B(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-exportSlicesRow");
    			add_location(div, file$2m, 6, 0, 113);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*slices*/ 1) {
    				const each_value = /*slices*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$B, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$B, null, get_each_context$B);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2R($$self, $$props, $$invalidate) {
    	let { slices } = $$props;
    	const writable_props = ["slices"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ExportSlicesRow> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ExportSlicesRow", $$slots, []);

    	function removeslice_handler(event) {
    		bubble($$self, event);
    	}

    	function switchslices_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("slices" in $$props) $$invalidate(0, slices = $$props.slices);
    	};

    	$$self.$capture_state = () => ({ ExportSlice, slices });

    	$$self.$inject_state = $$props => {
    		if ("slices" in $$props) $$invalidate(0, slices = $$props.slices);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [slices, removeslice_handler, switchslices_handler];
    }

    class ExportSlicesRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2R, create_fragment$2R, safe_not_equal, { slices: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ExportSlicesRow",
    			options,
    			id: create_fragment$2R.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*slices*/ ctx[0] === undefined && !("slices" in props)) {
    			console.warn("<ExportSlicesRow> was created without expected prop 'slices'");
    		}
    	}

    	get slices() {
    		throw new Error("<ExportSlicesRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set slices(value) {
    		throw new Error("<ExportSlicesRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/exportSlices/ExportSlices.svelte generated by Svelte v3.24.0 */
    const file$2n = "src/js/components/exportSlices/ExportSlices.svelte";

    function create_fragment$2S(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let int;
    	let t0;
    	let controlledselect;
    	let updating_pick;
    	let t1;
    	let exportslicesrow;
    	let current;
    	int = new Int({ props: { key: "Срезы" }, $$inline: true });

    	function controlledselect_pick_binding(value) {
    		/*controlledselect_pick_binding*/ ctx[9].call(null, value);
    	}

    	let controlledselect_props = {
    		name: "exportSlices",
    		label: "Добавить",
    		acceptLabel: "Добавить",
    		options: /*options*/ ctx[2]
    	};

    	if (/*pick*/ ctx[0] !== void 0) {
    		controlledselect_props.pick = /*pick*/ ctx[0];
    	}

    	controlledselect = new ControlledSelect({
    			props: controlledselect_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(controlledselect, "pick", controlledselect_pick_binding));

    	exportslicesrow = new ExportSlicesRow({
    			props: { slices: /*$slices*/ ctx[1] },
    			$$inline: true
    		});

    	exportslicesrow.$on("removeslice", /*onRemoveSlice*/ ctx[5]);
    	exportslicesrow.$on("switchslices", /*onSwitchSlices*/ ctx[6]);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(int.$$.fragment);
    			t0 = space();
    			create_component(controlledselect.$$.fragment);
    			t1 = space();
    			create_component(exportslicesrow.$$.fragment);
    			attr_dev(div0, "class", "txcm-exportHeader");
    			add_location(div0, file$2n, 125, 8, 3325);
    			attr_dev(div1, "class", "txcm-exportColumnControls");
    			add_location(div1, file$2n, 123, 4, 3271);
    			attr_dev(div2, "class", "txcm-exportSlices");
    			add_location(div2, file$2n, 121, 0, 3233);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			mount_component(int, div0, null);
    			append_dev(div1, t0);
    			mount_component(controlledselect, div1, null);
    			append_dev(div2, t1);
    			mount_component(exportslicesrow, div2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const controlledselect_changes = {};

    			if (!updating_pick && dirty & /*pick*/ 1) {
    				updating_pick = true;
    				controlledselect_changes.pick = /*pick*/ ctx[0];
    				add_flush_callback(() => updating_pick = false);
    			}

    			controlledselect.$set(controlledselect_changes);
    			const exportslicesrow_changes = {};
    			if (dirty & /*$slices*/ 2) exportslicesrow_changes.slices = /*$slices*/ ctx[1];
    			exportslicesrow.$set(exportslicesrow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			transition_in(controlledselect.$$.fragment, local);
    			transition_in(exportslicesrow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			transition_out(controlledselect.$$.fragment, local);
    			transition_out(exportslicesrow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(int);
    			destroy_component(controlledselect);
    			destroy_component(exportslicesrow);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function filterSavedPicks(id, picksRemoved) {
    	return picksRemoved.every(removedID => removedID !== id);
    }

    function instance$2S($$self, $$props, $$invalidate) {
    	let $slices;
    	let $slicesValue;
    	let { dashboard } = $$props;
    	let { data } = $$props;
    	const { export: options } = getContext("app").getAppConfig().dashboards[dashboard];
    	const bits = options.map(option => option.bit);
    	const slices = getExportState("slices");
    	validate_store(slices, "slices");
    	component_subscribe($$self, slices, value => $$invalidate(1, $slices = value));
    	const slicesValue = getExportState("slicesValue");
    	validate_store(slicesValue, "slicesValue");
    	component_subscribe($$self, slicesValue, value => $$invalidate(11, $slicesValue = value));
    	let pick = [];
    	let order = [];
    	drop();
    	onDestroy(drop);

    	function drop() {
    		updateExport({
    			slicesFilter: options.reduce(
    				(result, option) => {
    					const fiter = result;
    					fiter[option.value] = [];
    					return fiter;
    				},
    				{}
    			)
    		});
    	}

    	function updateSliceValue() {
    		set_store_value(slicesValue, $slicesValue = bits.reduce(
    			(value, bit) => {
    				const status = $slices.some(slice => slice.bit === bit) ? "1" : "0";
    				value.splice(bit, 1, status);
    				return value;
    			},
    			$slicesValue.split("").reverse()
    		).reverse().join(""));
    	}

    	function pickSliceOptions(value) {
    		const { data: sliceOptions } = data.find(slice => slice.key === value);
    		return sliceOptions;
    	}

    	function filterAddedPicks() {
    		return pick.filter(id => $slices.every(slice => slice.value !== id));
    	}

    	function filterRemovedPick(result, slice) {
    		const shouldRemove = pick.every(id => slice.value !== id);
    		if (shouldRemove) result.push(slice.value);
    		return result;
    	}

    	function filterRemovedPicks() {
    		return $slices.reduce(filterRemovedPick, []);
    	}

    	function generateNewOrder(picksAdded, picksRemoved) {
    		let newOrder = order.slice();
    		if (picksRemoved.length > 0) newOrder = order.filter(id => filterSavedPicks(id, picksRemoved));
    		if (picksAdded.length > 0) newOrder.push(...picksAdded);
    		return newOrder;
    	}

    	function updateOrder() {
    		const picksAdded = filterAddedPicks();
    		const picksRemoved = filterRemovedPicks();
    		const newOrder = generateNewOrder(picksAdded, picksRemoved);
    		$$invalidate(10, order = newOrder);
    	}

    	function removePick(id) {
    		const index = pick.indexOf(id);
    		pick.splice(index, 1);
    		$$invalidate(0, pick);
    	}

    	function updateSlice(value) {
    		const index = findIndex(options, value);
    		const slice = options[index];
    		const sliceOptions = pickSliceOptions(value);
    		return { ...slice, options: sliceOptions };
    	}

    	function updateSlices() {
    		set_store_value(slices, $slices = order.map(updateSlice));
    	}

    	function switchOrder({ id, shift }) {
    		const index = order.indexOf(id);
    		const newOrder = order.slice();
    		newOrder.splice(index, 1);
    		newOrder.splice(index + shift, 0, id);
    		$$invalidate(10, order = newOrder);
    	}

    	function onRemoveSlice({ detail }) {
    		removePick(detail.id);
    	}

    	function onSwitchSlices({ detail }) {
    		switchOrder(detail);
    	}

    	const writable_props = ["dashboard", "data"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ExportSlices> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ExportSlices", $$slots, []);

    	function controlledselect_pick_binding(value) {
    		pick = value;
    		$$invalidate(0, pick);
    	}

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(7, dashboard = $$props.dashboard);
    		if ("data" in $$props) $$invalidate(8, data = $$props.data);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		onDestroy,
    		getExportState,
    		updateExport,
    		findIndex,
    		Int,
    		ControlledSelect,
    		ExportSlicesRow,
    		dashboard,
    		data,
    		options,
    		bits,
    		slices,
    		slicesValue,
    		pick,
    		order,
    		drop,
    		updateSliceValue,
    		pickSliceOptions,
    		filterAddedPicks,
    		filterRemovedPick,
    		filterRemovedPicks,
    		filterSavedPicks,
    		generateNewOrder,
    		updateOrder,
    		removePick,
    		updateSlice,
    		updateSlices,
    		switchOrder,
    		onRemoveSlice,
    		onSwitchSlices,
    		$slices,
    		$slicesValue
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(7, dashboard = $$props.dashboard);
    		if ("data" in $$props) $$invalidate(8, data = $$props.data);
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    		if ("order" in $$props) $$invalidate(10, order = $$props.order);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*pick*/ 1) {
    			 updateOrder();
    		}

    		if ($$self.$$.dirty & /*order*/ 1024) {
    			 updateSlices();
    		}

    		if ($$self.$$.dirty & /*$slices*/ 2) {
    			 updateSliceValue();
    		}
    	};

    	return [
    		pick,
    		$slices,
    		options,
    		slices,
    		slicesValue,
    		onRemoveSlice,
    		onSwitchSlices,
    		dashboard,
    		data,
    		controlledselect_pick_binding
    	];
    }

    class ExportSlices extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2S, create_fragment$2S, safe_not_equal, { dashboard: 7, data: 8 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ExportSlices",
    			options,
    			id: create_fragment$2S.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[7] === undefined && !("dashboard" in props)) {
    			console.warn("<ExportSlices> was created without expected prop 'dashboard'");
    		}

    		if (/*data*/ ctx[8] === undefined && !("data" in props)) {
    			console.warn("<ExportSlices> was created without expected prop 'data'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<ExportSlices>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<ExportSlices>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get data() {
    		throw new Error("<ExportSlices>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<ExportSlices>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/exportIndicator/ExportIndicator.svelte generated by Svelte v3.24.0 */
    const file$2o = "src/js/components/exportIndicator/ExportIndicator.svelte";

    function create_fragment$2T(ctx) {
    	let div1;
    	let div0;
    	let int0;
    	let t;
    	let button;
    	let int1;
    	let current;
    	let mounted;
    	let dispose;

    	int0 = new Int({
    			props: { key: /*indicator*/ ctx[0].label },
    			$$inline: true
    		});

    	int1 = new Int({
    			props: { key: "Удалить" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(int0.$$.fragment);
    			t = space();
    			button = element("button");
    			create_component(int1.$$.fragment);
    			attr_dev(button, "class", "txcm-exportIndicatorRemove");
    			add_location(button, file$2o, 20, 8, 450);
    			attr_dev(div0, "class", "txcm-exportIndicatorLabel");
    			add_location(div0, file$2o, 16, 4, 348);
    			attr_dev(div1, "class", "txcm-exportIndicator");
    			add_location(div1, file$2o, 14, 0, 307);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(int0, div0, null);
    			append_dev(div0, t);
    			append_dev(div0, button);
    			mount_component(int1, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onRemoveClick*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const int0_changes = {};
    			if (dirty & /*indicator*/ 1) int0_changes.key = /*indicator*/ ctx[0].label;
    			int0.$set(int0_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(int0);
    			destroy_component(int1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2T($$self, $$props, $$invalidate) {
    	let { index } = $$props;
    	let { indicator } = $$props;
    	const dispatch = createEventDispatcher();

    	function onRemoveClick() {
    		dispatch("removeindicator", { index });
    	}

    	const writable_props = ["index", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ExportIndicator> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ExportIndicator", $$slots, []);

    	$$self.$set = $$props => {
    		if ("index" in $$props) $$invalidate(2, index = $$props.index);
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		Int,
    		index,
    		indicator,
    		dispatch,
    		onRemoveClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("index" in $$props) $$invalidate(2, index = $$props.index);
    		if ("indicator" in $$props) $$invalidate(0, indicator = $$props.indicator);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [indicator, onRemoveClick, index];
    }

    class ExportIndicator extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2T, create_fragment$2T, safe_not_equal, { index: 2, indicator: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ExportIndicator",
    			options,
    			id: create_fragment$2T.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*index*/ ctx[2] === undefined && !("index" in props)) {
    			console.warn("<ExportIndicator> was created without expected prop 'index'");
    		}

    		if (/*indicator*/ ctx[0] === undefined && !("indicator" in props)) {
    			console.warn("<ExportIndicator> was created without expected prop 'indicator'");
    		}
    	}

    	get index() {
    		throw new Error("<ExportIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set index(value) {
    		throw new Error("<ExportIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<ExportIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<ExportIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/exportIndicators/ExportIndicatorsRow.svelte generated by Svelte v3.24.0 */
    const file$2p = "src/js/components/exportIndicators/ExportIndicatorsRow.svelte";

    function get_each_context$C(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	child_ctx[4] = i;
    	return child_ctx;
    }

    // (9:4) {#each indicators as indicator, index (indicator.id)}
    function create_each_block$C(key_1, ctx) {
    	let first;
    	let exportindicator;
    	let current;

    	exportindicator = new ExportIndicator({
    			props: {
    				index: /*index*/ ctx[4],
    				indicator: /*indicator*/ ctx[2]
    			},
    			$$inline: true
    		});

    	exportindicator.$on("removeindicator", /*removeindicator_handler*/ ctx[1]);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(exportindicator.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(exportindicator, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const exportindicator_changes = {};
    			if (dirty & /*indicators*/ 1) exportindicator_changes.index = /*index*/ ctx[4];
    			if (dirty & /*indicators*/ 1) exportindicator_changes.indicator = /*indicator*/ ctx[2];
    			exportindicator.$set(exportindicator_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(exportindicator.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(exportindicator.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(exportindicator, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$C.name,
    		type: "each",
    		source: "(9:4) {#each indicators as indicator, index (indicator.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2U(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value = /*indicators*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*indicator*/ ctx[2].id;
    	validate_each_keys(ctx, each_value, get_each_context$C, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$C(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$C(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "txcm-exportIndicatorsRow");
    			add_location(div, file$2p, 6, 0, 129);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*indicators*/ 1) {
    				const each_value = /*indicators*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$C, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$C, null, get_each_context$C);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2U($$self, $$props, $$invalidate) {
    	let { indicators } = $$props;
    	const writable_props = ["indicators"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ExportIndicatorsRow> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ExportIndicatorsRow", $$slots, []);

    	function removeindicator_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$set = $$props => {
    		if ("indicators" in $$props) $$invalidate(0, indicators = $$props.indicators);
    	};

    	$$self.$capture_state = () => ({ ExportIndicator, indicators });

    	$$self.$inject_state = $$props => {
    		if ("indicators" in $$props) $$invalidate(0, indicators = $$props.indicators);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [indicators, removeindicator_handler];
    }

    class ExportIndicatorsRow extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2U, create_fragment$2U, safe_not_equal, { indicators: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ExportIndicatorsRow",
    			options,
    			id: create_fragment$2U.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*indicators*/ ctx[0] === undefined && !("indicators" in props)) {
    			console.warn("<ExportIndicatorsRow> was created without expected prop 'indicators'");
    		}
    	}

    	get indicators() {
    		throw new Error("<ExportIndicatorsRow>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicators(value) {
    		throw new Error("<ExportIndicatorsRow>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/exportIndicators/ExportIndicators.svelte generated by Svelte v3.24.0 */
    const file$2q = "src/js/components/exportIndicators/ExportIndicators.svelte";

    function create_fragment$2V(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let int;
    	let t0;
    	let controlledselect;
    	let updating_pick;
    	let t1;
    	let exportindicatorsrow;
    	let current;

    	int = new Int({
    			props: { key: "Показатели" },
    			$$inline: true
    		});

    	function controlledselect_pick_binding(value) {
    		/*controlledselect_pick_binding*/ ctx[6].call(null, value);
    	}

    	let controlledselect_props = {
    		name: "exportSlices",
    		label: "Добавить",
    		acceptLabel: "Добавить",
    		grouped: true,
    		options: /*options*/ ctx[3]
    	};

    	if (/*pick*/ ctx[0] !== void 0) {
    		controlledselect_props.pick = /*pick*/ ctx[0];
    	}

    	controlledselect = new ControlledSelect({
    			props: controlledselect_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(controlledselect, "pick", controlledselect_pick_binding));

    	exportindicatorsrow = new ExportIndicatorsRow({
    			props: { indicators: /*$indicators*/ ctx[1] },
    			$$inline: true
    		});

    	exportindicatorsrow.$on("removeindicator", /*onRemoveIndicator*/ ctx[4]);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			create_component(int.$$.fragment);
    			t0 = space();
    			create_component(controlledselect.$$.fragment);
    			t1 = space();
    			create_component(exportindicatorsrow.$$.fragment);
    			attr_dev(div0, "class", "txcm-exportHeader");
    			add_location(div0, file$2q, 72, 8, 1847);
    			attr_dev(div1, "class", "txcm-exportColumnControls");
    			add_location(div1, file$2q, 70, 4, 1793);
    			attr_dev(div2, "class", "txcm-exportIndicators");
    			add_location(div2, file$2q, 68, 0, 1751);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			mount_component(int, div0, null);
    			append_dev(div1, t0);
    			mount_component(controlledselect, div1, null);
    			append_dev(div2, t1);
    			mount_component(exportindicatorsrow, div2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const controlledselect_changes = {};

    			if (!updating_pick && dirty & /*pick*/ 1) {
    				updating_pick = true;
    				controlledselect_changes.pick = /*pick*/ ctx[0];
    				add_flush_callback(() => updating_pick = false);
    			}

    			controlledselect.$set(controlledselect_changes);
    			const exportindicatorsrow_changes = {};
    			if (dirty & /*$indicators*/ 2) exportindicatorsrow_changes.indicators = /*$indicators*/ ctx[1];
    			exportindicatorsrow.$set(exportindicatorsrow_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			transition_in(controlledselect.$$.fragment, local);
    			transition_in(exportindicatorsrow.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			transition_out(controlledselect.$$.fragment, local);
    			transition_out(exportindicatorsrow.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(int);
    			destroy_component(controlledselect);
    			destroy_component(exportindicatorsrow);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function updateOption({ label, id }) {
    	return { label, value: id };
    }

    function updateOptions({ label, indicators: indicatorOptions }) {
    	return {
    		label,
    		options: indicatorOptions.map(updateOption)
    	};
    }

    function instance$2V($$self, $$props, $$invalidate) {
    	let $indicators;
    	let { dashboard } = $$props;
    	const indicators = getExportState("indicators");
    	validate_store(indicators, "indicators");
    	component_subscribe($$self, indicators, value => $$invalidate(1, $indicators = value));
    	const config = getContext("app").getAppConfig();
    	const { indicators: financialOptions } = config.dashboards.financial;
    	const { indicators: operationalOptions } = config.dashboards.operational;
    	const options = pickOptions();
    	const flatIndicators = flattenOptions();
    	let pick = [];

    	function flattenOptions() {
    		return options.reduce((result, option) => [...result, ...option.options], []);
    	}

    	function updateIndicator(id) {
    		const indicator = flatIndicators.find(indicatorOption => indicatorOption.value === id);
    		return { id, label: indicator.label };
    	}

    	function updateIndicators() {
    		set_store_value(indicators, $indicators = pick.map(updateIndicator));
    	}

    	function pickOptions() {
    		const options = [];

    		operationalOptions.map(updateOptions).forEach(item => {
    			item.options.forEach(opt => options.push(opt));
    		});

    		return [{ label: "", options }];
    	}

    	function removeIndicator(index) {
    		pick.splice(index, 1);
    		$$invalidate(0, pick);
    	}

    	function onRemoveIndicator({ detail }) {
    		removeIndicator(detail.index);
    	}

    	const writable_props = ["dashboard"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ExportIndicators> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ExportIndicators", $$slots, []);

    	function controlledselect_pick_binding(value) {
    		pick = value;
    		$$invalidate(0, pick);
    	}

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(5, dashboard = $$props.dashboard);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		getExportState,
    		Int,
    		ControlledSelect,
    		ExportIndicatorsRow,
    		dashboard,
    		indicators,
    		config,
    		financialOptions,
    		operationalOptions,
    		options,
    		flatIndicators,
    		pick,
    		flattenOptions,
    		updateIndicator,
    		updateIndicators,
    		updateOption,
    		updateOptions,
    		pickOptions,
    		removeIndicator,
    		onRemoveIndicator,
    		$indicators
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(5, dashboard = $$props.dashboard);
    		if ("pick" in $$props) $$invalidate(0, pick = $$props.pick);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*pick*/ 1) {
    			 updateIndicators();
    		}
    	};

    	return [
    		pick,
    		$indicators,
    		indicators,
    		options,
    		onRemoveIndicator,
    		dashboard,
    		controlledselect_pick_binding
    	];
    }

    class ExportIndicators extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2V, create_fragment$2V, safe_not_equal, { dashboard: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ExportIndicators",
    			options,
    			id: create_fragment$2V.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[5] === undefined && !("dashboard" in props)) {
    			console.warn("<ExportIndicators> was created without expected prop 'dashboard'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<ExportIndicators>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<ExportIndicators>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    let currentRequest$1;

    function dispatchRequestEvent$1() {
      const event = new CustomEvent('exportrequest', currentRequest$1);
      window.dispatchEvent(event);
    }

    function resetRequest$1() {
      currentRequest$1 = null;
    }

    function requestExport(dashboard, config, filters, prevFilters) {
      const promise = new Promise((resolve, reject) => {
        function onExportResponse(response) {
          window.removeEventListener('exportresponse', onExportResponse);
          window.removeEventListener('error', onExportError);
          resetRequest$1();
          resolve(response.detail);
        }

        function onExportError() {
          window.removeEventListener('exportresponse', onExportResponse);
          window.removeEventListener('error', onExportError);
          resetRequest$1();
          reject(new Error('an error occured while exporting data'));
        }

        window.addEventListener('exportresponse', onExportResponse);
        window.addEventListener('error', onExportError);
      });

      currentRequest$1 = { detail: { dashboard, config, filters, prevFilters } };
      dispatchRequestEvent$1();
      return promise;
    }

    /* src/js/components/export/ExportControls.svelte generated by Svelte v3.24.0 */

    const { Object: Object_1$6 } = globals;
    const file$2r = "src/js/components/export/ExportControls.svelte";

    function create_fragment$2W(ctx) {
    	let div;
    	let button;
    	let int;
    	let button_disabled_value;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: "Скачать" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			create_component(int.$$.fragment);
    			attr_dev(button, "class", "txcm-exportDownload");
    			button.disabled = button_disabled_value = /*checkDisabled*/ ctx[10](/*$downloading*/ ctx[0], /*$slicesFilter*/ ctx[2], /*$indicators*/ ctx[1]);
    			add_location(button, file$2r, 91, 4, 2868);
    			attr_dev(div, "class", "txcm-exportControls");
    			add_location(div, file$2r, 89, 0, 2828);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onDownloadClick*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$downloading, $slicesFilter, $indicators*/ 7 && button_disabled_value !== (button_disabled_value = /*checkDisabled*/ ctx[10](/*$downloading*/ ctx[0], /*$slicesFilter*/ ctx[2], /*$indicators*/ ctx[1]))) {
    				prop_dev(button, "disabled", button_disabled_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function updateOption$1({ label, id, configName }) {
    	return { label, value: id, configName };
    }

    function updateOptions$1({ label, indicators: indicatorOptions }) {
    	return {
    		label,
    		options: indicatorOptions.map(updateOption$1)
    	};
    }

    function instance$2W($$self, $$props, $$invalidate) {
    	let $downloading;
    	let $indicators;
    	let $date;
    	let $datePrecision;
    	let $datePoP;
    	let $slicesFilter;
    	let { dashboard } = $$props;
    	let { conditions } = $$props;
    	const config = getContext("app").getAppConfig();
    	const { export: options, indicators: operationalOptions } = getContext("app").getAppConfig().dashboards[dashboard];
    	const downloading = getExportState("downloading");
    	validate_store(downloading, "downloading");
    	component_subscribe($$self, downloading, value => $$invalidate(0, $downloading = value));
    	const slicesFilter = getExportState("slicesFilter");
    	validate_store(slicesFilter, "slicesFilter");
    	component_subscribe($$self, slicesFilter, value => $$invalidate(2, $slicesFilter = value));
    	const indicators = getExportState("indicators");
    	validate_store(indicators, "indicators");
    	component_subscribe($$self, indicators, value => $$invalidate(1, $indicators = value));
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(14, $date = value));
    	const datePoP = getDashboardState("datePoP");
    	validate_store(datePoP, "datePoP");
    	component_subscribe($$self, datePoP, value => $$invalidate(16, $datePoP = value));
    	const datePrecision = getDashboardState("datePrecision");
    	validate_store(datePrecision, "datePrecision");
    	component_subscribe($$self, datePrecision, value => $$invalidate(15, $datePrecision = value));

    	function disable() {
    		set_store_value(downloading, $downloading += 1);
    	}

    	function enable() {
    		set_store_value(downloading, $downloading -= 1);
    	}

    	function flatOperationalOptions() {
    		const options = [];

    		operationalOptions.map(updateOptions$1).forEach(item => {
    			item.options.forEach(opt => options.push(opt));
    		});

    		return options;
    	}

    	async function downloadExport(url) {
    		const label = $indicators.length === 1
    		? $indicators[0].label
    		: `${$indicators.length} показателя`;

    		const name1 = renderPreciseCellDate($date, $datePrecision);
    		const name2 = renderPreciseCellDate($datePoP, $datePrecision);
    		let response = await fetch(url);
    		let blob = await response.blob();
    		let a = document.createElement("a");
    		a.href = window.URL.createObjectURL(blob);
    		a.download = `${label} ${name1} ${name2}.xlsx`;
    		a.click();
    	}

    	function onDownloadClick() {
    		disable();
    		const a1 = Object.entries($slicesFilter).filter(([key, value]) => value.length > 0).map(([key, value]) => options.find(item => item.value === key).label);
    		const a2 = $indicators.map(item => item.label).map(item => flattenOperationalOptions.find(item2 => item2.label === item).configName).filter(item => item);
    		const config = [...a1, ...a2].join(".") + ".";

    		requestExport(dashboard, config, $slicesFilter, conditions).then(async url => {
    			await downloadExport(url);
    		}).then(enable).catch(enable);
    	}

    	function checkDisabled() {
    		return $downloading > 0 || $indicators.length === 0;
    	}

    	const writable_props = ["dashboard", "conditions"];

    	Object_1$6.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ExportControls> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("ExportControls", $$slots, []);

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(11, dashboard = $$props.dashboard);
    		if ("conditions" in $$props) $$invalidate(12, conditions = $$props.conditions);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		getExportState,
    		getDashboardState,
    		requestExport,
    		renderMonthLong,
    		renderPreciseCellDate,
    		Int,
    		dashboard,
    		conditions,
    		config,
    		options,
    		operationalOptions,
    		downloading,
    		slicesFilter,
    		indicators,
    		date,
    		datePoP,
    		datePrecision,
    		disable,
    		enable,
    		flatOperationalOptions,
    		updateOption: updateOption$1,
    		updateOptions: updateOptions$1,
    		downloadExport,
    		onDownloadClick,
    		checkDisabled,
    		flattenOperationalOptions,
    		$downloading,
    		$indicators,
    		$date,
    		$datePrecision,
    		$datePoP,
    		$slicesFilter
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(11, dashboard = $$props.dashboard);
    		if ("conditions" in $$props) $$invalidate(12, conditions = $$props.conditions);
    		if ("flattenOperationalOptions" in $$props) flattenOperationalOptions = $$props.flattenOperationalOptions;
    	};

    	let flattenOperationalOptions;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	 flattenOperationalOptions = flatOperationalOptions();

    	return [
    		$downloading,
    		$indicators,
    		$slicesFilter,
    		downloading,
    		slicesFilter,
    		indicators,
    		date,
    		datePoP,
    		datePrecision,
    		onDownloadClick,
    		checkDisabled,
    		dashboard,
    		conditions
    	];
    }

    class ExportControls extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2W, create_fragment$2W, safe_not_equal, { dashboard: 11, conditions: 12 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ExportControls",
    			options,
    			id: create_fragment$2W.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[11] === undefined && !("dashboard" in props)) {
    			console.warn("<ExportControls> was created without expected prop 'dashboard'");
    		}

    		if (/*conditions*/ ctx[12] === undefined && !("conditions" in props)) {
    			console.warn("<ExportControls> was created without expected prop 'conditions'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<ExportControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<ExportControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get conditions() {
    		throw new Error("<ExportControls>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set conditions(value) {
    		throw new Error("<ExportControls>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/export/Export.svelte generated by Svelte v3.24.0 */
    const file$2s = "src/js/components/export/Export.svelte";

    function create_fragment$2X(ctx) {
    	let section;
    	let exportslices;
    	let t0;
    	let exportindicators;
    	let t1;
    	let exportcontrols;
    	let current;

    	exportslices = new ExportSlices({
    			props: {
    				data: /*data*/ ctx[0],
    				dashboard: /*dashboard*/ ctx[1]
    			},
    			$$inline: true
    		});

    	exportindicators = new ExportIndicators({
    			props: { dashboard: /*dashboard*/ ctx[1] },
    			$$inline: true
    		});

    	exportcontrols = new ExportControls({
    			props: {
    				dashboard: /*dashboard*/ ctx[1],
    				conditions: /*conditions*/ ctx[2]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			section = element("section");
    			create_component(exportslices.$$.fragment);
    			t0 = space();
    			create_component(exportindicators.$$.fragment);
    			t1 = space();
    			create_component(exportcontrols.$$.fragment);
    			attr_dev(section, "class", "txcm-exportSection");
    			add_location(section, file$2s, 10, 0, 305);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			mount_component(exportslices, section, null);
    			append_dev(section, t0);
    			mount_component(exportindicators, section, null);
    			append_dev(section, t1);
    			mount_component(exportcontrols, section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const exportslices_changes = {};
    			if (dirty & /*data*/ 1) exportslices_changes.data = /*data*/ ctx[0];
    			if (dirty & /*dashboard*/ 2) exportslices_changes.dashboard = /*dashboard*/ ctx[1];
    			exportslices.$set(exportslices_changes);
    			const exportindicators_changes = {};
    			if (dirty & /*dashboard*/ 2) exportindicators_changes.dashboard = /*dashboard*/ ctx[1];
    			exportindicators.$set(exportindicators_changes);
    			const exportcontrols_changes = {};
    			if (dirty & /*dashboard*/ 2) exportcontrols_changes.dashboard = /*dashboard*/ ctx[1];
    			if (dirty & /*conditions*/ 4) exportcontrols_changes.conditions = /*conditions*/ ctx[2];
    			exportcontrols.$set(exportcontrols_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(exportslices.$$.fragment, local);
    			transition_in(exportindicators.$$.fragment, local);
    			transition_in(exportcontrols.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(exportslices.$$.fragment, local);
    			transition_out(exportindicators.$$.fragment, local);
    			transition_out(exportcontrols.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			destroy_component(exportslices);
    			destroy_component(exportindicators);
    			destroy_component(exportcontrols);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2X($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { dashboard } = $$props;
    	let { conditions } = $$props;
    	const writable_props = ["data", "dashboard", "conditions"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Export> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Export", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("dashboard" in $$props) $$invalidate(1, dashboard = $$props.dashboard);
    		if ("conditions" in $$props) $$invalidate(2, conditions = $$props.conditions);
    	};

    	$$self.$capture_state = () => ({
    		ExportSlices,
    		ExportIndicators,
    		ExportControls,
    		data,
    		dashboard,
    		conditions
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("dashboard" in $$props) $$invalidate(1, dashboard = $$props.dashboard);
    		if ("conditions" in $$props) $$invalidate(2, conditions = $$props.conditions);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [data, dashboard, conditions];
    }

    class Export extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2X, create_fragment$2X, safe_not_equal, { data: 0, dashboard: 1, conditions: 2 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Export",
    			options,
    			id: create_fragment$2X.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<Export> was created without expected prop 'data'");
    		}

    		if (/*dashboard*/ ctx[1] === undefined && !("dashboard" in props)) {
    			console.warn("<Export> was created without expected prop 'dashboard'");
    		}

    		if (/*conditions*/ ctx[2] === undefined && !("conditions" in props)) {
    			console.warn("<Export> was created without expected prop 'conditions'");
    		}
    	}

    	get data() {
    		throw new Error("<Export>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Export>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dashboard() {
    		throw new Error("<Export>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<Export>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get conditions() {
    		throw new Error("<Export>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set conditions(value) {
    		throw new Error("<Export>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/dashboard/DashboardContent.svelte generated by Svelte v3.24.0 */

    // (39:0) {:else}
    function create_else_block_1(ctx) {
    	let overview;
    	let current;

    	overview = new Overview({
    			props: {
    				dashboard: /*dashboard*/ ctx[3],
    				units: /*units*/ ctx[2],
    				data: /*data*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(overview.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(overview, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const overview_changes = {};
    			if (dirty & /*dashboard*/ 8) overview_changes.dashboard = /*dashboard*/ ctx[3];
    			if (dirty & /*units*/ 4) overview_changes.units = /*units*/ ctx[2];
    			if (dirty & /*data*/ 1) overview_changes.data = /*data*/ ctx[0];
    			overview.$set(overview_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(overview.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(overview.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(overview, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(39:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (34:20) 
    function create_if_block_3$1(ctx) {
    	let slices;
    	let current;

    	slices = new Slices({
    			props: {
    				dashboard: /*dashboard*/ ctx[3],
    				indicator: /*indicator*/ ctx[4],
    				data: /*data*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(slices.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(slices, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const slices_changes = {};
    			if (dirty & /*dashboard*/ 8) slices_changes.dashboard = /*dashboard*/ ctx[3];
    			if (dirty & /*indicator*/ 16) slices_changes.indicator = /*indicator*/ ctx[4];
    			if (dirty & /*data*/ 1) slices_changes.data = /*data*/ ctx[0];
    			slices.$set(slices_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(slices.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(slices.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(slices, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(34:20) ",
    		ctx
    	});

    	return block;
    }

    // (29:33) 
    function create_if_block_2$6(ctx) {
    	let export_1;
    	let current;

    	export_1 = new Export({
    			props: {
    				data: /*filterData*/ ctx[1],
    				dashboard: /*dashboard*/ ctx[3],
    				conditions: /*conditions*/ ctx[6]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(export_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(export_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const export_1_changes = {};
    			if (dirty & /*filterData*/ 2) export_1_changes.data = /*filterData*/ ctx[1];
    			if (dirty & /*dashboard*/ 8) export_1_changes.dashboard = /*dashboard*/ ctx[3];
    			if (dirty & /*conditions*/ 64) export_1_changes.conditions = /*conditions*/ ctx[6];
    			export_1.$set(export_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(export_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(export_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(export_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(29:33) ",
    		ctx
    	});

    	return block;
    }

    // (18:0) {#if detail}
    function create_if_block$X(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$i, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*detail*/ ctx[5] === "comparisons") return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$X.name,
    		type: "if",
    		source: "(18:0) {#if detail}",
    		ctx
    	});

    	return block;
    }

    // (23:2) {:else}
    function create_else_block$9(ctx) {
    	let factors;
    	let current;

    	factors = new Factors({
    			props: {
    				indicator: /*indicator*/ ctx[4],
    				dashboard: /*dashboard*/ ctx[3],
    				data: /*data*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(factors.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(factors, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const factors_changes = {};
    			if (dirty & /*indicator*/ 16) factors_changes.indicator = /*indicator*/ ctx[4];
    			if (dirty & /*dashboard*/ 8) factors_changes.dashboard = /*dashboard*/ ctx[3];
    			if (dirty & /*data*/ 1) factors_changes.data = /*data*/ ctx[0];
    			factors.$set(factors_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(factors.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(factors.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(factors, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(23:2) {:else}",
    		ctx
    	});

    	return block;
    }

    // (19:2) {#if detail === 'comparisons'}
    function create_if_block_1$i(ctx) {
    	let comparisons;
    	let current;

    	comparisons = new Comparisons({
    			props: {
    				indicator: /*indicator*/ ctx[4],
    				data: /*data*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(comparisons.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(comparisons, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comparisons_changes = {};
    			if (dirty & /*indicator*/ 16) comparisons_changes.indicator = /*indicator*/ ctx[4];
    			if (dirty & /*data*/ 1) comparisons_changes.data = /*data*/ ctx[0];
    			comparisons.$set(comparisons_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comparisons.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comparisons.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(comparisons, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$i.name,
    		type: "if",
    		source: "(19:2) {#if detail === 'comparisons'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2Y(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$X, create_if_block_2$6, create_if_block_3$1, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*detail*/ ctx[5]) return 0;
    		if (/*indicator*/ ctx[4] === "export") return 1;
    		if (/*indicator*/ ctx[4]) return 2;
    		return 3;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2Y($$self, $$props, $$invalidate) {
    	let { data } = $$props;
    	let { filterData } = $$props;
    	let { units } = $$props;
    	let { dashboard } = $$props;
    	let { indicator } = $$props;
    	let { detail } = $$props;
    	let { conditions } = $$props;

    	const writable_props = [
    		"data",
    		"filterData",
    		"units",
    		"dashboard",
    		"indicator",
    		"detail",
    		"conditions"
    	];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DashboardContent> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DashboardContent", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("filterData" in $$props) $$invalidate(1, filterData = $$props.filterData);
    		if ("units" in $$props) $$invalidate(2, units = $$props.units);
    		if ("dashboard" in $$props) $$invalidate(3, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(4, indicator = $$props.indicator);
    		if ("detail" in $$props) $$invalidate(5, detail = $$props.detail);
    		if ("conditions" in $$props) $$invalidate(6, conditions = $$props.conditions);
    	};

    	$$self.$capture_state = () => ({
    		Factors,
    		Overview,
    		Slices,
    		Comparisons,
    		Export,
    		data,
    		filterData,
    		units,
    		dashboard,
    		indicator,
    		detail,
    		conditions
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("filterData" in $$props) $$invalidate(1, filterData = $$props.filterData);
    		if ("units" in $$props) $$invalidate(2, units = $$props.units);
    		if ("dashboard" in $$props) $$invalidate(3, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(4, indicator = $$props.indicator);
    		if ("detail" in $$props) $$invalidate(5, detail = $$props.detail);
    		if ("conditions" in $$props) $$invalidate(6, conditions = $$props.conditions);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [data, filterData, units, dashboard, indicator, detail, conditions];
    }

    class DashboardContent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$2Y, create_fragment$2Y, safe_not_equal, {
    			data: 0,
    			filterData: 1,
    			units: 2,
    			dashboard: 3,
    			indicator: 4,
    			detail: 5,
    			conditions: 6
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DashboardContent",
    			options,
    			id: create_fragment$2Y.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<DashboardContent> was created without expected prop 'data'");
    		}

    		if (/*filterData*/ ctx[1] === undefined && !("filterData" in props)) {
    			console.warn("<DashboardContent> was created without expected prop 'filterData'");
    		}

    		if (/*units*/ ctx[2] === undefined && !("units" in props)) {
    			console.warn("<DashboardContent> was created without expected prop 'units'");
    		}

    		if (/*dashboard*/ ctx[3] === undefined && !("dashboard" in props)) {
    			console.warn("<DashboardContent> was created without expected prop 'dashboard'");
    		}

    		if (/*indicator*/ ctx[4] === undefined && !("indicator" in props)) {
    			console.warn("<DashboardContent> was created without expected prop 'indicator'");
    		}

    		if (/*detail*/ ctx[5] === undefined && !("detail" in props)) {
    			console.warn("<DashboardContent> was created without expected prop 'detail'");
    		}

    		if (/*conditions*/ ctx[6] === undefined && !("conditions" in props)) {
    			console.warn("<DashboardContent> was created without expected prop 'conditions'");
    		}
    	}

    	get data() {
    		throw new Error("<DashboardContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<DashboardContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterData() {
    		throw new Error("<DashboardContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterData(value) {
    		throw new Error("<DashboardContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get units() {
    		throw new Error("<DashboardContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set units(value) {
    		throw new Error("<DashboardContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get dashboard() {
    		throw new Error("<DashboardContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<DashboardContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<DashboardContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<DashboardContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get detail() {
    		throw new Error("<DashboardContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set detail(value) {
    		throw new Error("<DashboardContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get conditions() {
    		throw new Error("<DashboardContent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set conditions(value) {
    		throw new Error("<DashboardContent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    var getRandomValues;
    var rnds8 = new Uint8Array(16);
    function rng() {
      // lazy load so that environments that need to polyfill have a chance to do so
      if (!getRandomValues) {
        // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation. Also,
        // find the complete implementation of crypto (msCrypto) on IE11.
        getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);

        if (!getRandomValues) {
          throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
        }
      }

      return getRandomValues(rnds8);
    }

    var REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;

    function validate(uuid) {
      return typeof uuid === 'string' && REGEX.test(uuid);
    }

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    var byteToHex = [];

    for (var i = 0; i < 256; ++i) {
      byteToHex.push((i + 0x100).toString(16).substr(1));
    }

    function stringify(arr) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      // Note: Be careful editing this code!  It's been tuned for performance
      // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
      var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
      // of the following:
      // - One or more input array values don't map to a hex octet (leading to
      // "undefined" in the uuid)
      // - Invalid input values for the RFC `version` or `variant` fields

      if (!validate(uuid)) {
        throw TypeError('Stringified UUID is invalid');
      }

      return uuid;
    }

    function v4(options, buf, offset) {
      options = options || {};
      var rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

      rnds[6] = rnds[6] & 0x0f | 0x40;
      rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

      if (buf) {
        offset = offset || 0;

        for (var i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }

        return buf;
      }

      return stringify(rnds);
    }

    async function executeRequest(key, data) {  
      const uuid = v4();
      const promise = new Promise((resolve, reject) => {
        window.addEventListener(uuid, ({detail}) => {
          if (detail.hasOwnProperty('error')) {
            reject(detail.error);
            return;
          }
          resolve(detail);
        }, { once: true });    
      });  
      const event = new CustomEvent('eventrequest', {detail: { key, uuid, ...data }});
      window.dispatchEvent(event);  
      return await promise;
    }

    var sortedFRMTOptions = [
    	"ММ",
    	"МК",
    	"ГМ",
    	"МС",
    	"МО",
    	"МА",
    	"ПР",
    	"ВМ",
    	"СИА",
    	"Без формата"
    ];

    function sortFilterOptions(data) {
        let arr = [];

        sortedFRMTOptions.forEach(i => {
            arr.push(data.find(j => j.label === i));
        });

        arr = arr.filter(item => item);

        return [...new Set([...arr, ...data])]
    }

    /* src/js/components/dashboard/Dashboard.svelte generated by Svelte v3.24.0 */

    const { Object: Object_1$7, console: console_1$3 } = globals;

    // (457:0) {#if loading}
    function create_if_block_3$2(ctx) {
    	let loader;
    	let current;
    	loader = new Loader({ props: { shift: "-69" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loader.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(loader, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loader, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(457:0) {#if loading}",
    		ctx
    	});

    	return block;
    }

    // (461:0) {#if shouldRenderContent(dashboardData, indicator)}
    function create_if_block_1$j(ctx) {
    	let t;
    	let dashboardcontent;
    	let current;
    	let if_block = !/*indicator*/ ctx[1] && create_if_block_2$7(ctx);

    	dashboardcontent = new DashboardContent({
    			props: {
    				data: /*dashboardData*/ ctx[5],
    				filterData: /*dashboardFilterData*/ ctx[6],
    				units: /*$units*/ ctx[10],
    				dashboard: /*dashboard*/ ctx[0],
    				indicator: /*indicator*/ ctx[1],
    				detail: /*detail*/ ctx[2],
    				conditions: /*conditions*/ ctx[7]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();
    			create_component(dashboardcontent.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dashboardcontent, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!/*indicator*/ ctx[1]) {
    				if (if_block) {
    					if (dirty[0] & /*indicator*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(t.parentNode, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const dashboardcontent_changes = {};
    			if (dirty[0] & /*dashboardData*/ 32) dashboardcontent_changes.data = /*dashboardData*/ ctx[5];
    			if (dirty[0] & /*dashboardFilterData*/ 64) dashboardcontent_changes.filterData = /*dashboardFilterData*/ ctx[6];
    			if (dirty[0] & /*$units*/ 1024) dashboardcontent_changes.units = /*$units*/ ctx[10];
    			if (dirty[0] & /*dashboard*/ 1) dashboardcontent_changes.dashboard = /*dashboard*/ ctx[0];
    			if (dirty[0] & /*indicator*/ 2) dashboardcontent_changes.indicator = /*indicator*/ ctx[1];
    			if (dirty[0] & /*detail*/ 4) dashboardcontent_changes.detail = /*detail*/ ctx[2];
    			if (dirty[0] & /*conditions*/ 128) dashboardcontent_changes.conditions = /*conditions*/ ctx[7];
    			dashboardcontent.$set(dashboardcontent_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(dashboardcontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(dashboardcontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dashboardcontent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$j.name,
    		type: "if",
    		source: "(461:0) {#if shouldRenderContent(dashboardData, indicator)}",
    		ctx
    	});

    	return block;
    }

    // (462:2) {#if !indicator}
    function create_if_block_2$7(ctx) {
    	let indicators;
    	let current;
    	indicators = new Indicators({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(indicators.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(indicators, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(indicators.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(indicators.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(indicators, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(462:2) {#if !indicator}",
    		ctx
    	});

    	return block;
    }

    // (474:0) {#if reloadNeeded}
    function create_if_block$Y(ctx) {
    	let reload;
    	let current;
    	reload = new Reload({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(reload.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(reload, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(reload.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(reload.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(reload, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$Y.name,
    		type: "if",
    		source: "(474:0) {#if reloadNeeded}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2Z(ctx) {
    	let filter;
    	let t0;
    	let t1;
    	let show_if = /*shouldRenderContent*/ ctx[22](/*dashboardData*/ ctx[5], /*indicator*/ ctx[1]);
    	let t2;
    	let if_block2_anchor;
    	let current;

    	filter = new Filter({
    			props: {
    				disabled: /*$updating*/ ctx[8] > 0 || /*$downloading*/ ctx[9] > 0,
    				data: /*dashboardFilterData*/ ctx[6]
    			},
    			$$inline: true
    		});

    	let if_block0 = /*loading*/ ctx[3] && create_if_block_3$2(ctx);
    	let if_block1 = show_if && create_if_block_1$j(ctx);
    	let if_block2 = /*reloadNeeded*/ ctx[4] && create_if_block$Y(ctx);

    	const block = {
    		c: function create() {
    			create_component(filter.$$.fragment);
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(filter, target, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const filter_changes = {};
    			if (dirty[0] & /*$updating, $downloading*/ 768) filter_changes.disabled = /*$updating*/ ctx[8] > 0 || /*$downloading*/ ctx[9] > 0;
    			if (dirty[0] & /*dashboardFilterData*/ 64) filter_changes.data = /*dashboardFilterData*/ ctx[6];
    			filter.$set(filter_changes);

    			if (/*loading*/ ctx[3]) {
    				if (if_block0) {
    					if (dirty[0] & /*loading*/ 8) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (dirty[0] & /*dashboardData, indicator*/ 34) show_if = /*shouldRenderContent*/ ctx[22](/*dashboardData*/ ctx[5], /*indicator*/ ctx[1]);

    			if (show_if) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*dashboardData, indicator*/ 34) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$j(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(t2.parentNode, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*reloadNeeded*/ ctx[4]) {
    				if (if_block2) {
    					if (dirty[0] & /*reloadNeeded*/ 16) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$Y(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(filter.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(filter.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(filter, detaching);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function updateFilterKeyState(update, option) {
    	if (option.picked) update.push(option.value);
    	return update;
    }

    function updateFilterState(update, option) {
    	return {
    		...update,
    		[option.key]: option.data.reduce(updateFilterKeyState, [])
    	};
    }

    function zipOperationalOverview({ filter, precision, dates }, data) {
    	return { dates, filter, precision, data };
    }

    function zipOperationalOverviewData(idIndicator, block1, block2, charts, formats, regions) {
    	const newData = {
    		id: idIndicator,
    		name: block1 ? block1.name : "",
    		units: block1 ? block1.units : "",
    		column1: block1 ? block1.block : {},
    		column2: block2 ? block2.block : {},
    		loaded: !!block1,
    		allLoaded: !!block1 && !!charts,
    		graphs: {
    			id: idIndicator,
    			name: block1 ? block1.name : "",
    			series: charts ? charts.series : [],
    			loaded: !!charts
    		},
    		formatDeviations: {
    			id: idIndicator,
    			name: block1 ? block1.name : "",
    			column1: formats ? formats.block1 : [],
    			column2: formats ? formats.block2 : [],
    			countDeviation: formats && formats.count ? formats.count.qNum : 0
    		},
    		regionDeviations: {
    			id: idIndicator,
    			name: block1 ? block1.name : "",
    			column1: regions ? regions.block1 : [],
    			column2: regions ? regions.block2 : [],
    			countDeviation: regions && regions.count ? regions.count.qNum : 0
    		}
    	};

    	return newData;
    }

    function zipOperationalSlicesData(indicator, slices, graphs) {
    	const [block1, block2] = slices ? slices : [null, null];
    	const [format1, region1, group1] = block1 ? block1 : [null, null, null];
    	const [format2, region2, group2] = block2 ? block2 : [null, null, null];
    	const [regionGraphs, formatGraphs, groupGraphs] = graphs ? graphs : [null, null, null];

    	const formats = format1
    	? (format1.items || []).map((item, index) => {
    			return {
    				name: item.name,
    				column1: { ...item },
    				column2: format2 && format2.items
    				? { ...format2.items[index] }
    				: {},
    				graphs: formatGraphs && formatGraphs.groups
    				? formatGraphs.groups[index]
    				: null
    			};
    		})
    	: [];

    	const regions = region1
    	? (region1.items || []).map((item, index) => {
    			return {
    				name: item.name,
    				column1: { ...item },
    				column2: region2 && region1.items
    				? { ...region2.items[index] }
    				: {},
    				graphs: regionGraphs && regionGraphs.groups
    				? regionGraphs.groups[index]
    				: null
    			};
    		})
    	: [];

    	const groups = group1
    	? (group1.items || []).map((item, index) => {
    			return {
    				name: item.name,
    				column1: { ...item },
    				column2: group2 && group2.items ? { ...group2.items[index] } : {},
    				graphs: groupGraphs && groupGraphs.groups
    				? groupGraphs.groups[index]
    				: null
    			};
    		})
    	: [];

    	const newData = {
    		loaded: !!slices,
    		allLoaded: !!slices && !!graphs,
    		units: indicator.units,
    		indicator: { ...indicator },
    		formats,
    		regions,
    		groups
    	};

    	return newData;
    }

    function zipOperationalFactors(results, bridges) {
    	const newData = { results, bridges };
    	return newData;
    }

    function instance$2Z($$self, $$props, $$invalidate) {
    	let $date;
    	let $datePrecision;
    	let $columnPrecision;
    	let $dynamics;
    	let $datePoP;
    	let $kind;
    	let $templateUpdate;
    	let $activeIndicators;
    	let $updating;
    	let $downloading;
    	let $units;
    	let { dashboard } = $$props;
    	let { indicator } = $$props;
    	let { detail } = $$props;
    	let { location } = $$props;
    	let { filterConfig } = $$props;
    	let { indicatorsConfig } = $$props;
    	let { columnConfig } = $$props;
    	const { graphs: graphConfig } = getContext("app").getAppConfig();
    	let initial = true;
    	let noUpdate = false;
    	let loading = false;
    	let reloadNeeded = false;
    	initFilter(filterConfig);
    	initGraphs(graphConfig, dashboard);
    	initIndicators(indicatorsConfig);

    	updateDashboard({
    		column: columnConfig[0].indicators[0].value
    	});

    	const updating = getUIState("updating");
    	validate_store(updating, "updating");
    	component_subscribe($$self, updating, value => $$invalidate(8, $updating = value));
    	const downloading = getExportState("downloading");
    	validate_store(downloading, "downloading");
    	component_subscribe($$self, downloading, value => $$invalidate(9, $downloading = value));
    	const dynamics = getGraphsState("dynamics");
    	validate_store(dynamics, "dynamics");
    	component_subscribe($$self, dynamics, value => $$invalidate(35, $dynamics = value));
    	const kind = getGraphsState("kind");
    	validate_store(kind, "kind");
    	component_subscribe($$self, kind, value => $$invalidate(37, $kind = value));
    	const date = getDashboardState("date");
    	validate_store(date, "date");
    	component_subscribe($$self, date, value => $$invalidate(32, $date = value));
    	const datePoP = getDashboardState("datePoP");
    	validate_store(datePoP, "datePoP");
    	component_subscribe($$self, datePoP, value => $$invalidate(36, $datePoP = value));
    	const datePrecision = getDashboardState("datePrecision");
    	validate_store(datePrecision, "datePrecision");
    	component_subscribe($$self, datePrecision, value => $$invalidate(33, $datePrecision = value));
    	const columnPrecision = getDashboardState("columnPrecision");
    	validate_store(columnPrecision, "columnPrecision");
    	component_subscribe($$self, columnPrecision, value => $$invalidate(34, $columnPrecision = value));
    	const units = getDashboardState("units");
    	validate_store(units, "units");
    	component_subscribe($$self, units, value => $$invalidate(10, $units = value));
    	const templateUpdate = getUIState("templateUpdate");
    	validate_store(templateUpdate, "templateUpdate");
    	component_subscribe($$self, templateUpdate, value => $$invalidate(38, $templateUpdate = value));
    	const activeIndicators = getActiveIndicatorsState();
    	validate_store(activeIndicators, "activeIndicators");
    	component_subscribe($$self, activeIndicators, value => $$invalidate(39, $activeIndicators = value));
    	let dashboardData = null;
    	let dashboardFilterData = null;
    	let dashboardMetaData = null;
    	let fetchingData = false;
    	let conditions = {};

    	setContext("config", {
    		getDashboard: () => dashboard,
    		getFilterConfig: () => filterConfig,
    		getIndicatorsConfig: () => indicatorsConfig,
    		getColumnConfig: () => columnConfig
    	});

    	const unsubscribeFilter = subscribeFilterAll(onFilterUpdate);

    	function shouldRenderContent() {
    		return dashboardData || indicator === "export";
    	}

    	function updateDynamicOptions() {
    		return graphConfig.dynamics;
    	}

    	function onFilterUpdate(key, update) {
    		const shouldUpdate = Object.prototype.hasOwnProperty.call(conditions, key);
    		$$invalidate(7, conditions[key] = update, conditions);
    		if (shouldUpdate) $$invalidate(7, conditions);
    	}

    	function unsubscribe() {
    		unsubscribeFilter.forEach(unsubscribeKey => {
    			unsubscribeKey();
    		});
    	}

    	function saveUpdate({ data, filter, precision, dates }) {
    		$$invalidate(5, dashboardData = data);
    		$$invalidate(6, dashboardFilterData = filter);
    		dashboardMetaData = { filter, precision, dates };
    	}

    	function updateExportState({ slices, expressions }) {
    		updateExport({
    			slicesValue: slices,
    			expressionsValue: expressions
    		});
    	}

    	function updateOperationalPrecision(columnPrecisionData, graphPrecisionData) {
    		set_store_value(columnPrecision, $columnPrecision = columnPrecisionData - 1);
    		set_store_value(dynamics, $dynamics = dynamicsOptions[graphPrecisionData - 1].value);
    	}

    	function updatePrecision(update) {
    		const { columnPrecision: columnPrecisionData, graphPrecision: graphPrecisionData } = update.precision;
    		updateOperationalPrecision(columnPrecisionData, graphPrecisionData);
    	}

    	function convertFinancialColumnPrecision() {
    		return $columnPrecision - 1;
    	}

    	function convertOperationalColumnPrecision() {
    		return Math.max($columnPrecision, Math.min($datePrecision + 1, 4)) + 1;
    	}

    	function convertColumnPrecision() {
    		if (dashboard === "financial") return convertFinancialColumnPrecision();
    		return convertOperationalColumnPrecision();
    	}

    	function convertFinancialDatePrecision() {
    		return $datePrecision - 1;
    	}

    	function convertOperationalDatePrecision() {
    		return $datePrecision + 1;
    	}

    	function convertDatePrecision() {
    		if (dashboard === "financial") return convertFinancialDatePrecision();
    		return convertOperationalDatePrecision();
    	}

    	function convertFinancialDynamics() {
    		return dynamicsOptions.findIndex(dynamicsOption => dynamicsOption.value === $dynamics) + 1;
    	}

    	function convertOperationalDynamics() {
    		const index = dynamicsOptions.findIndex(dynamicsOption => dynamicsOption.value === $dynamics);
    		if ($datePrecision == 0 || $datePrecision == 1 || $datePrecision == 2) return index + 1;

    		if ($datePrecision == 3 || $datePrecision == 4) {
    			if (index < 3) return 3;
    		}

    		return index + 1;
    	}

    	function convertDynamics() {
    		if (dashboard === "financial") return convertFinancialDynamics();
    		return convertOperationalDynamics();
    	}

    	function updateFiltersState() {
    		const update = dashboardFilterData.reduce(updateFilterState, {});
    		if (initial || noUpdate) updateFilter(update);
    	}

    	function hydrateDashboard(update) {
    		console.log("UPDATE", update, indicator);
    		if (update) saveUpdate(update);
    		if (update.export) updateExportState(update.update);
    		if (update.filter) updateFiltersState();
    		updatePrecision(update);

    		set_store_value(kind, $kind = !indicator || indicator !== "average-check-lfl"
    		? 0
    		: $kind);

    		initial = false;
    		noUpdate = false;
    	}

    	function dropData() {
    		$$invalidate(5, dashboardData = null);
    	}

    	function showLoader() {
    		$$invalidate(3, loading = true);
    	}

    	function hideLoader() {
    		$$invalidate(3, loading = false);
    	}

    	function startUpdating() {
    		set_store_value(updating, $updating += 1);
    	}

    	function stopUpdating() {
    		set_store_value(updating, $updating -= 1);
    	}

    	async function renderDashboard(overview) {
    		await hydrateDashboard(overview);
    		await tick();
    	}

    	async function renderOperationalOverview(idIndicator, block1, block2, charts, formats, regions) {
    		if (!dashboardData) return;
    		const item = zipOperationalOverviewData(idIndicator, block1, block2, charts, formats, regions);
    		const index = dashboardData.findIndex(item => item.id == idIndicator);
    		if (index === -1) dashboardData.push(item); else $$invalidate(5, dashboardData[index] = item, dashboardData);
    		const overview = zipOperationalOverview(dashboardMetaData, dashboardData);
    		await renderDashboard(overview);
    	}

    	async function renderOperationalSlices(indicator, slices, graphs) {
    		if (!dashboardData) return;
    		const data = zipOperationalSlicesData(indicator, slices, graphs);
    		const overview = zipOperationalOverview(dashboardMetaData, data);
    		await renderDashboard(overview);
    	}

    	async function renderOperationalFactors(results, bridges) {
    		if (!dashboardData) return;
    		const data = zipOperationalFactors(results, bridges);
    		const overview = zipOperationalOverview(dashboardMetaData, data);
    		await renderDashboard(overview);
    	}

    	async function renderMeta() {
    		const filters = getFilters();

    		//const meta = mockOverviewMeta;
    		const meta = await requestUpdate(dashboard, indicator, detail, filters, "meta");

    		const FRMT = meta.filter.find(item => item.key === "FRMT");
    		if (FRMT) FRMT.data = sortFilterOptions(FRMT.data);
    		console.log("RENDER META", meta);
    		const overview = zipOperationalOverview(meta, []);
    		await renderDashboard(overview);
    	}

    	function getFilters() {
    		const dateValue = calculateDatesForValue(new Date($date), $datePrecision, "date");
    		const datePoPValue = calculateDatesForValue(new Date($datePoP), $datePrecision, "datePoP");

    		return {
    			initial,
    			noUpdate,
    			conditions,
    			date: dateValue,
    			datePoP: datePoPValue,
    			columnPrecision: convertColumnPrecision(),
    			datePrecision: convertDatePrecision(),
    			dynamics: convertDynamics(),
    			kind: $kind
    		};
    	}

    	async function fetchUpdateData() {
    		if (!dashboardData) return;
    		const filters = getFilters();
    		const tasks = [];

    		if (detail === "factors") {
    			//await renderDashboard(mockInflationFactorsData);
    			//return;
    			tasks.push(executeRequest("factors", {
    				dashboard,
    				indicator,
    				detail,
    				filters,
    				type: "data"
    			}).then(async data => {
    				await renderOperationalFactors(data[0], data[1]);
    			}));
    		} else if (indicator) {
    			//await renderDashboard(mockAverageData);
    			//return;
    			tasks.push(executeRequest("slices", {
    				dashboard,
    				indicator,
    				detail,
    				filters,
    				type: "data"
    			}).then(async data => {
    				if (data.length === 3) {
    					const overviewData = zipOperationalOverviewData(indicator, data[0], data[1], data[2]);
    					await renderOperationalSlices(overviewData);

    					const slices = await executeRequest("slices", {
    						dashboard,
    						indicator,
    						detail,
    						filters,
    						type: "slices"
    					});

    					await renderOperationalSlices(overviewData, slices[0]);

    					const charts = await executeRequest("slices", {
    						dashboard,
    						indicator,
    						detail,
    						filters,
    						type: "charts"
    					});

    					await renderOperationalSlices(overviewData, slices[0], charts[0]);
    				}
    			}));
    		} else {
    			//await renderDashboard(mockData);
    			//return;
    			const indicators = $activeIndicators.filter(id => dashboardData.findIndex(item => item.id == id) === -1);

    			for (let i = 0; i < indicators.length; ++i) {
    				const idIndicator = indicators[i];
    				await renderOperationalOverview(idIndicator);

    				tasks.push(executeRequest("overview", {
    					dashboard,
    					indicator,
    					detail,
    					filters,
    					type: "data",
    					idIndicator
    				}).then(async data => {
    					await renderOperationalOverview(idIndicator, data[0], data[1]);

    					const charts = await executeRequest("overview", {
    						dashboard,
    						indicator,
    						detail,
    						filters,
    						type: "charts",
    						idIndicator
    					});

    					await renderOperationalOverview(idIndicator, data[0], data[1], charts[0]);
    				})); //const deviations = await executeRequest("overview", { dashboard, indicator, detail, filters, type: 'deviations', idIndicator });
    				//await renderOperationalOverview(idIndicator, data[0], data[1], charts[0], deviations[0], deviations[1]);
    			}
    		}

    		startUpdating();
    		await Promise.all(tasks);
    		stopUpdating();
    	}

    	async function updateData() {
    		try {
    			if (!fetchingData) {
    				fetchingData = true;
    				startUpdating();
    				showLoader();
    				dropData();
    				if (initial) await renderMeta(); // fetch params
    				await renderMeta(); // update params
    				hideLoader();
    				await fetchUpdateData();
    				stopUpdating();
    				fetchingData = false;
    			}
    		} catch(e) {
    			console.log("ERROR", e);
    			$$invalidate(4, reloadNeeded = true);
    		}
    	}

    	async function updateDataTemplate() {
    		if ($templateUpdate && $templateUpdate > 0) {
    			noUpdate = true;
    			await updateData();
    		}
    	}

    	onDestroy(unsubscribe);

    	const writable_props = [
    		"dashboard",
    		"indicator",
    		"detail",
    		"location",
    		"filterConfig",
    		"indicatorsConfig",
    		"columnConfig"
    	];

    	Object_1$7.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<Dashboard> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Dashboard", $$slots, []);

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("detail" in $$props) $$invalidate(2, detail = $$props.detail);
    		if ("location" in $$props) $$invalidate(23, location = $$props.location);
    		if ("filterConfig" in $$props) $$invalidate(24, filterConfig = $$props.filterConfig);
    		if ("indicatorsConfig" in $$props) $$invalidate(25, indicatorsConfig = $$props.indicatorsConfig);
    		if ("columnConfig" in $$props) $$invalidate(26, columnConfig = $$props.columnConfig);
    	};

    	$$self.$capture_state = () => ({
    		setContext,
    		getContext,
    		onDestroy,
    		tick,
    		initFilter,
    		updateFilter,
    		subscribeFilterAll,
    		initIndicators,
    		initGraphs,
    		getGraphsState,
    		updateDashboard,
    		getDashboardState,
    		updateExport,
    		getExportState,
    		getUIState,
    		requestUpdate,
    		CONFIG,
    		getActiveIndicatorsState,
    		Filter,
    		Loader,
    		Reload,
    		Indicators,
    		DashboardContent,
    		executeRequest,
    		calculateDatesForValue,
    		sortFilterOptions,
    		dashboard,
    		indicator,
    		detail,
    		location,
    		filterConfig,
    		indicatorsConfig,
    		columnConfig,
    		graphConfig,
    		initial,
    		noUpdate,
    		loading,
    		reloadNeeded,
    		updating,
    		downloading,
    		dynamics,
    		kind,
    		date,
    		datePoP,
    		datePrecision,
    		columnPrecision,
    		units,
    		templateUpdate,
    		activeIndicators,
    		dashboardData,
    		dashboardFilterData,
    		dashboardMetaData,
    		fetchingData,
    		conditions,
    		unsubscribeFilter,
    		shouldRenderContent,
    		updateDynamicOptions,
    		onFilterUpdate,
    		unsubscribe,
    		saveUpdate,
    		updateExportState,
    		updateOperationalPrecision,
    		updatePrecision,
    		convertFinancialColumnPrecision,
    		convertOperationalColumnPrecision,
    		convertColumnPrecision,
    		convertFinancialDatePrecision,
    		convertOperationalDatePrecision,
    		convertDatePrecision,
    		convertFinancialDynamics,
    		convertOperationalDynamics,
    		convertDynamics,
    		updateFilterKeyState,
    		updateFilterState,
    		updateFiltersState,
    		hydrateDashboard,
    		dropData,
    		showLoader,
    		hideLoader,
    		startUpdating,
    		stopUpdating,
    		zipOperationalOverview,
    		zipOperationalOverviewData,
    		renderDashboard,
    		renderOperationalOverview,
    		zipOperationalSlicesData,
    		renderOperationalSlices,
    		zipOperationalFactors,
    		renderOperationalFactors,
    		renderMeta,
    		getFilters,
    		fetchUpdateData,
    		updateData,
    		updateDataTemplate,
    		dynamicsOptions,
    		$date,
    		$datePrecision,
    		$columnPrecision,
    		$dynamics,
    		$datePoP,
    		$kind,
    		$templateUpdate,
    		$activeIndicators,
    		$updating,
    		$downloading,
    		$units
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("detail" in $$props) $$invalidate(2, detail = $$props.detail);
    		if ("location" in $$props) $$invalidate(23, location = $$props.location);
    		if ("filterConfig" in $$props) $$invalidate(24, filterConfig = $$props.filterConfig);
    		if ("indicatorsConfig" in $$props) $$invalidate(25, indicatorsConfig = $$props.indicatorsConfig);
    		if ("columnConfig" in $$props) $$invalidate(26, columnConfig = $$props.columnConfig);
    		if ("initial" in $$props) initial = $$props.initial;
    		if ("noUpdate" in $$props) noUpdate = $$props.noUpdate;
    		if ("loading" in $$props) $$invalidate(3, loading = $$props.loading);
    		if ("reloadNeeded" in $$props) $$invalidate(4, reloadNeeded = $$props.reloadNeeded);
    		if ("dashboardData" in $$props) $$invalidate(5, dashboardData = $$props.dashboardData);
    		if ("dashboardFilterData" in $$props) $$invalidate(6, dashboardFilterData = $$props.dashboardFilterData);
    		if ("dashboardMetaData" in $$props) dashboardMetaData = $$props.dashboardMetaData;
    		if ("fetchingData" in $$props) fetchingData = $$props.fetchingData;
    		if ("conditions" in $$props) $$invalidate(7, conditions = $$props.conditions);
    		if ("dynamicsOptions" in $$props) dynamicsOptions = $$props.dynamicsOptions;
    	};

    	let dynamicsOptions;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*dashboard*/ 1) {
    			 dynamicsOptions = updateDynamicOptions();
    		}

    		if ($$self.$$.dirty[0] & /*location, conditions*/ 8388736 | $$self.$$.dirty[1] & /*$date, $datePrecision, $columnPrecision, $dynamics, $datePoP, $kind*/ 126) {
    			 updateData();
    		}

    		if ($$self.$$.dirty[1] & /*$templateUpdate*/ 128) {
    			 updateDataTemplate();
    		}

    		if ($$self.$$.dirty[1] & /*$activeIndicators*/ 256) {
    			 fetchUpdateData();
    		}
    	};

    	return [
    		dashboard,
    		indicator,
    		detail,
    		loading,
    		reloadNeeded,
    		dashboardData,
    		dashboardFilterData,
    		conditions,
    		$updating,
    		$downloading,
    		$units,
    		updating,
    		downloading,
    		dynamics,
    		kind,
    		date,
    		datePoP,
    		datePrecision,
    		columnPrecision,
    		units,
    		templateUpdate,
    		activeIndicators,
    		shouldRenderContent,
    		location,
    		filterConfig,
    		indicatorsConfig,
    		columnConfig
    	];
    }

    class Dashboard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$2Z,
    			create_fragment$2Z,
    			safe_not_equal,
    			{
    				dashboard: 0,
    				indicator: 1,
    				detail: 2,
    				location: 23,
    				filterConfig: 24,
    				indicatorsConfig: 25,
    				columnConfig: 26
    			},
    			[-1, -1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dashboard",
    			options,
    			id: create_fragment$2Z.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[0] === undefined && !("dashboard" in props)) {
    			console_1$3.warn("<Dashboard> was created without expected prop 'dashboard'");
    		}

    		if (/*indicator*/ ctx[1] === undefined && !("indicator" in props)) {
    			console_1$3.warn("<Dashboard> was created without expected prop 'indicator'");
    		}

    		if (/*detail*/ ctx[2] === undefined && !("detail" in props)) {
    			console_1$3.warn("<Dashboard> was created without expected prop 'detail'");
    		}

    		if (/*location*/ ctx[23] === undefined && !("location" in props)) {
    			console_1$3.warn("<Dashboard> was created without expected prop 'location'");
    		}

    		if (/*filterConfig*/ ctx[24] === undefined && !("filterConfig" in props)) {
    			console_1$3.warn("<Dashboard> was created without expected prop 'filterConfig'");
    		}

    		if (/*indicatorsConfig*/ ctx[25] === undefined && !("indicatorsConfig" in props)) {
    			console_1$3.warn("<Dashboard> was created without expected prop 'indicatorsConfig'");
    		}

    		if (/*columnConfig*/ ctx[26] === undefined && !("columnConfig" in props)) {
    			console_1$3.warn("<Dashboard> was created without expected prop 'columnConfig'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get detail() {
    		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set detail(value) {
    		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get location() {
    		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set location(value) {
    		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filterConfig() {
    		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filterConfig(value) {
    		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicatorsConfig() {
    		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicatorsConfig(value) {
    		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get columnConfig() {
    		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set columnConfig(value) {
    		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/dashboard/financial/DashboardFinancial.svelte generated by Svelte v3.24.0 */

    function create_fragment$2_(ctx) {
    	let dashboard;
    	let current;

    	const dashboard_spread_levels = [
    		/*options*/ ctx[0],
    		{ filterConfig: /*filterConfig*/ ctx[1] },
    		{
    			indicatorsConfig: /*indicatorsConfig*/ ctx[2]
    		},
    		{ columnConfig: /*columnConfig*/ ctx[3] }
    	];

    	let dashboard_props = {};

    	for (let i = 0; i < dashboard_spread_levels.length; i += 1) {
    		dashboard_props = assign(dashboard_props, dashboard_spread_levels[i]);
    	}

    	dashboard = new Dashboard({ props: dashboard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(dashboard.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(dashboard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const dashboard_changes = (dirty & /*options, filterConfig, indicatorsConfig, columnConfig*/ 15)
    			? get_spread_update(dashboard_spread_levels, [
    					dirty & /*options*/ 1 && get_spread_object(/*options*/ ctx[0]),
    					dirty & /*filterConfig*/ 2 && { filterConfig: /*filterConfig*/ ctx[1] },
    					dirty & /*indicatorsConfig*/ 4 && {
    						indicatorsConfig: /*indicatorsConfig*/ ctx[2]
    					},
    					dirty & /*columnConfig*/ 8 && { columnConfig: /*columnConfig*/ ctx[3] }
    				])
    			: {};

    			dashboard.$set(dashboard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dashboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dashboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dashboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2_($$self, $$props, $$invalidate) {
    	let { options } = $$props;
    	const { filter: filterConfig, indicators: indicatorsConfig, column: columnConfig } = getContext("app").getAppConfig().dashboards.financial;
    	const writable_props = ["options"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DashboardFinancial> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DashboardFinancial", $$slots, []);

    	$$self.$set = $$props => {
    		if ("options" in $$props) $$invalidate(0, options = $$props.options);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		Dashboard,
    		options,
    		filterConfig,
    		indicatorsConfig,
    		columnConfig
    	});

    	$$self.$inject_state = $$props => {
    		if ("options" in $$props) $$invalidate(0, options = $$props.options);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [options, filterConfig, indicatorsConfig, columnConfig];
    }

    class DashboardFinancial extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2_, create_fragment$2_, safe_not_equal, { options: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DashboardFinancial",
    			options,
    			id: create_fragment$2_.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*options*/ ctx[0] === undefined && !("options" in props)) {
    			console.warn("<DashboardFinancial> was created without expected prop 'options'");
    		}
    	}

    	get options() {
    		throw new Error("<DashboardFinancial>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<DashboardFinancial>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/dashboard/operational/DashboardOperational.svelte generated by Svelte v3.24.0 */

    function create_fragment$2$(ctx) {
    	let dashboard;
    	let current;

    	const dashboard_spread_levels = [
    		/*options*/ ctx[0],
    		{ filterConfig: /*filterConfig*/ ctx[1] },
    		{
    			indicatorsConfig: /*indicatorsConfig*/ ctx[2]
    		},
    		{ columnConfig: /*columnConfig*/ ctx[3] }
    	];

    	let dashboard_props = {};

    	for (let i = 0; i < dashboard_spread_levels.length; i += 1) {
    		dashboard_props = assign(dashboard_props, dashboard_spread_levels[i]);
    	}

    	dashboard = new Dashboard({ props: dashboard_props, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(dashboard.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(dashboard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const dashboard_changes = (dirty & /*options, filterConfig, indicatorsConfig, columnConfig*/ 15)
    			? get_spread_update(dashboard_spread_levels, [
    					dirty & /*options*/ 1 && get_spread_object(/*options*/ ctx[0]),
    					dirty & /*filterConfig*/ 2 && { filterConfig: /*filterConfig*/ ctx[1] },
    					dirty & /*indicatorsConfig*/ 4 && {
    						indicatorsConfig: /*indicatorsConfig*/ ctx[2]
    					},
    					dirty & /*columnConfig*/ 8 && { columnConfig: /*columnConfig*/ ctx[3] }
    				])
    			: {};

    			dashboard.$set(dashboard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dashboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dashboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dashboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2$($$self, $$props, $$invalidate) {
    	let { options } = $$props;
    	const { filter: filterConfig, indicators: indicatorsConfig, column: columnConfig } = getContext("app").getAppConfig().dashboards.operational;
    	const writable_props = ["options"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DashboardOperational> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DashboardOperational", $$slots, []);

    	$$self.$set = $$props => {
    		if ("options" in $$props) $$invalidate(0, options = $$props.options);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		Dashboard,
    		options,
    		filterConfig,
    		indicatorsConfig,
    		columnConfig
    	});

    	$$self.$inject_state = $$props => {
    		if ("options" in $$props) $$invalidate(0, options = $$props.options);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [options, filterConfig, indicatorsConfig, columnConfig];
    }

    class DashboardOperational extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2$, create_fragment$2$, safe_not_equal, { options: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DashboardOperational",
    			options,
    			id: create_fragment$2$.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*options*/ ctx[0] === undefined && !("options" in props)) {
    			console.warn("<DashboardOperational> was created without expected prop 'options'");
    		}
    	}

    	get options() {
    		throw new Error("<DashboardOperational>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set options(value) {
    		throw new Error("<DashboardOperational>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/header/HeaderDashboardToggle.svelte generated by Svelte v3.24.0 */
    const file$2t = "src/js/components/header/HeaderDashboardToggle.svelte";

    // (40:4) {#if !indicator || indicator === 'export'}
    function create_if_block_1$k(ctx) {
    	let span;
    	let int;
    	let current;

    	int = new Int({
    			props: { key: /*label*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(int.$$.fragment);
    			attr_dev(span, "class", "txcm-dashboardToggleText");
    			add_location(span, file$2t, 40, 6, 943);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(int, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*label*/ 4) int_changes.key = /*label*/ ctx[2];
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$k.name,
    		type: "if",
    		source: "(40:4) {#if !indicator || indicator === 'export'}",
    		ctx
    	});

    	return block;
    }

    // (48:0) {#if indicator && indicator !== 'export'}
    function create_if_block$Z(ctx) {
    	let navlink;
    	let current;

    	navlink = new NavLink({
    			props: {
    				to: `/dashboard/${/*dashboard*/ ctx[0]}`,
    				linkClass: "txcm-dashboardToggleLink",
    				$$slots: { default: [create_default_slot$K] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navlink.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navlink, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navlink_changes = {};
    			if (dirty & /*dashboard*/ 1) navlink_changes.to = `/dashboard/${/*dashboard*/ ctx[0]}`;

    			if (dirty & /*$$scope, label*/ 516) {
    				navlink_changes.$$scope = { dirty, ctx };
    			}

    			navlink.$set(navlink_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navlink.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navlink.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navlink, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$Z.name,
    		type: "if",
    		source: "(48:0) {#if indicator && indicator !== 'export'}",
    		ctx
    	});

    	return block;
    }

    // (49:2) <NavLink     to={`/dashboard/${dashboard}`}     linkClass="txcm-dashboardToggleLink">
    function create_default_slot$K(ctx) {
    	let int;
    	let current;

    	int = new Int({
    			props: { key: /*label*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(int.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(int, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*label*/ 4) int_changes.key = /*label*/ ctx[2];
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(int, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$K.name,
    		type: "slot",
    		source: "(49:2) <NavLink     to={`/dashboard/${dashboard}`}     linkClass=\\\"txcm-dashboardToggleLink\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$30(ctx) {
    	let button;
    	let svg;
    	let use;
    	let t0;
    	let t1;
    	let if_block1_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = (!/*indicator*/ ctx[1] || /*indicator*/ ctx[1] === "export") && create_if_block_1$k(ctx);
    	let if_block1 = /*indicator*/ ctx[1] && /*indicator*/ ctx[1] !== "export" && create_if_block$Z(ctx);

    	const block = {
    		c: function create() {
    			button = element("button");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			xlink_attr(use, "xlink:href", "#txspt-icons-drawer");
    			add_location(use, file$2t, 36, 8, 828);
    			attr_dev(svg, "class", "txcm-dashboardToggleIcon");
    			add_location(svg, file$2t, 34, 4, 775);
    			attr_dev(button, "class", "txcm-dashboardToggle");
    			add_location(button, file$2t, 31, 0, 704);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, svg);
    			append_dev(svg, use);
    			append_dev(button, t0);
    			if (if_block0) if_block0.m(button, null);
    			insert_dev(target, t1, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onToggleClick*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*indicator*/ ctx[1] || /*indicator*/ ctx[1] === "export") {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*indicator*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$k(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(button, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*indicator*/ ctx[1] && /*indicator*/ ctx[1] !== "export") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*indicator*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$Z(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (if_block0) if_block0.d();
    			if (detaching) detach_dev(t1);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$30.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$30($$self, $$props, $$invalidate) {
    	let $aside;

    	const LABELS = {
    		financial: "Финансовый дашборд",
    		operational: "Операционный дашборд"
    	};

    	let { dashboard } = $$props;
    	let { indicator } = $$props;
    	const aside = getUIState("aside");
    	validate_store(aside, "aside");
    	component_subscribe($$self, aside, value => $$invalidate(5, $aside = value));

    	function renderLabel() {
    		if (indicator && indicator === "export") return "Выгрузка данных";
    		return LABELS[dashboard];
    	}

    	function show() {
    		updateUI({ aside: true });
    	}

    	function onToggleClick() {
    		if (!$aside) setTimeout(show, 5);
    	}

    	const writable_props = ["dashboard", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HeaderDashboardToggle> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("HeaderDashboardToggle", $$slots, []);

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		NavLink,
    		getUIState,
    		updateUI,
    		LABELS,
    		dashboard,
    		indicator,
    		aside,
    		renderLabel,
    		show,
    		onToggleClick,
    		label,
    		$aside
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("label" in $$props) $$invalidate(2, label = $$props.label);
    	};

    	let label;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*dashboard, indicator*/ 3) {
    			 $$invalidate(2, label = renderLabel());
    		}
    	};

    	return [dashboard, indicator, label, aside, onToggleClick];
    }

    class HeaderDashboardToggle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$30, create_fragment$30, safe_not_equal, { dashboard: 0, indicator: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HeaderDashboardToggle",
    			options,
    			id: create_fragment$30.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[0] === undefined && !("dashboard" in props)) {
    			console.warn("<HeaderDashboardToggle> was created without expected prop 'dashboard'");
    		}

    		if (/*indicator*/ ctx[1] === undefined && !("indicator" in props)) {
    			console.warn("<HeaderDashboardToggle> was created without expected prop 'indicator'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<HeaderDashboardToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<HeaderDashboardToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<HeaderDashboardToggle>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<HeaderDashboardToggle>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/header/HeaderTabs.svelte generated by Svelte v3.24.0 */

    const file$2u = "src/js/components/header/HeaderTabs.svelte";

    // (22:4) <NavLink       linkClass="txcm-headerTab"       to={`/dashboard/${dashboard}/${indicator}`}>
    function create_default_slot_1$e(ctx) {
    	let int;
    	let current;
    	int = new Int({ props: { key: "Срезы" }, $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(int.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(int, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(int, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$e.name,
    		type: "slot",
    		source: "(22:4) <NavLink       linkClass=\\\"txcm-headerTab\\\"       to={`/dashboard/${dashboard}/${indicator}`}>",
    		ctx
    	});

    	return block;
    }

    // (28:4) {#if indicatorId === '1' || indicatorId === '20'}
    function create_if_block$_(ctx) {
    	let navlink;
    	let current;

    	navlink = new NavLink({
    			props: {
    				linkClass: "txcm-headerTab",
    				to: `/dashboard/${/*dashboard*/ ctx[0]}/${/*indicator*/ ctx[1]}/factors`,
    				$$slots: { default: [create_default_slot$L] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navlink.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navlink, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navlink_changes = {};
    			if (dirty & /*dashboard, indicator*/ 3) navlink_changes.to = `/dashboard/${/*dashboard*/ ctx[0]}/${/*indicator*/ ctx[1]}/factors`;

    			if (dirty & /*$$scope*/ 32) {
    				navlink_changes.$$scope = { dirty, ctx };
    			}

    			navlink.$set(navlink_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navlink.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navlink.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navlink, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$_.name,
    		type: "if",
    		source: "(28:4) {#if indicatorId === '1' || indicatorId === '20'}",
    		ctx
    	});

    	return block;
    }

    // (29:6) <NavLink         linkClass="txcm-headerTab"         to={`/dashboard/${dashboard}/${indicator}/factors`}>
    function create_default_slot$L(ctx) {
    	let int;
    	let current;

    	int = new Int({
    			props: { key: "Факторы" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(int.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(int, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(int, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$L.name,
    		type: "slot",
    		source: "(29:6) <NavLink         linkClass=\\\"txcm-headerTab\\\"         to={`/dashboard/${dashboard}/${indicator}/factors`}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$31(ctx) {
    	let nav;
    	let navlink;
    	let t;
    	let current;

    	navlink = new NavLink({
    			props: {
    				linkClass: "txcm-headerTab",
    				to: `/dashboard/${/*dashboard*/ ctx[0]}/${/*indicator*/ ctx[1]}`,
    				$$slots: { default: [create_default_slot_1$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = (/*indicatorId*/ ctx[2] === "1" || /*indicatorId*/ ctx[2] === "20") && create_if_block$_(ctx);

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			create_component(navlink.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(nav, "class", "txcm-headerTabs");
    			add_location(nav, file$2u, 19, 0, 564);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			mount_component(navlink, nav, null);
    			append_dev(nav, t);
    			if (if_block) if_block.m(nav, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navlink_changes = {};
    			if (dirty & /*dashboard, indicator*/ 3) navlink_changes.to = `/dashboard/${/*dashboard*/ ctx[0]}/${/*indicator*/ ctx[1]}`;

    			if (dirty & /*$$scope*/ 32) {
    				navlink_changes.$$scope = { dirty, ctx };
    			}

    			navlink.$set(navlink_changes);

    			if (/*indicatorId*/ ctx[2] === "1" || /*indicatorId*/ ctx[2] === "20") {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*indicatorId*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$_(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(nav, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navlink.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navlink.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			destroy_component(navlink);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$31.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$31($$self, $$props, $$invalidate) {
    	const INDICATORS = indicators.reduce((result, group) => [...result, ...group.indicators], []);
    	let { dashboard } = $$props;
    	let { indicator } = $$props;

    	function findIndicator(indicator) {
    		const id = INDICATORS.find(option => option.url === indicator).id;
    		return id;
    	}

    	const writable_props = ["dashboard", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HeaderTabs> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("HeaderTabs", $$slots, []);

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		NavLink,
    		indicators,
    		INDICATORS,
    		dashboard,
    		indicator,
    		findIndicator,
    		indicatorId
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("indicatorId" in $$props) $$invalidate(2, indicatorId = $$props.indicatorId);
    	};

    	let indicatorId;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*indicator*/ 2) {
    			 $$invalidate(2, indicatorId = findIndicator(indicator));
    		}
    	};

    	return [dashboard, indicator, indicatorId];
    }

    class HeaderTabs extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$31, create_fragment$31, safe_not_equal, { dashboard: 0, indicator: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HeaderTabs",
    			options,
    			id: create_fragment$31.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[0] === undefined && !("dashboard" in props)) {
    			console.warn("<HeaderTabs> was created without expected prop 'dashboard'");
    		}

    		if (/*indicator*/ ctx[1] === undefined && !("indicator" in props)) {
    			console.warn("<HeaderTabs> was created without expected prop 'indicator'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<HeaderTabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<HeaderTabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<HeaderTabs>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<HeaderTabs>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/header/HeaderNavigation.svelte generated by Svelte v3.24.0 */
    const file$2v = "src/js/components/header/HeaderNavigation.svelte";

    // (20:4) {#if !disabled}
    function create_if_block$$(ctx) {
    	let navlink;
    	let current;

    	navlink = new NavLink({
    			props: {
    				linkClass: "txcm-navigationExportLink",
    				to: `/dashboard/${/*dashboard*/ ctx[0]}/export`,
    				$$slots: { default: [create_default_slot$M] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(navlink.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navlink, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const navlink_changes = {};
    			if (dirty & /*dashboard*/ 1) navlink_changes.to = `/dashboard/${/*dashboard*/ ctx[0]}/export`;

    			if (dirty & /*$$scope*/ 32) {
    				navlink_changes.$$scope = { dirty, ctx };
    			}

    			navlink.$set(navlink_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navlink.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navlink.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navlink, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$$.name,
    		type: "if",
    		source: "(20:4) {#if !disabled}",
    		ctx
    	});

    	return block;
    }

    // (21:6) <NavLink         linkClass="txcm-navigationExportLink"         to={`/dashboard/${dashboard}/export`}>
    function create_default_slot$M(ctx) {
    	let svg;
    	let use;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			use = svg_element("use");
    			xlink_attr(use, "xlink:href", "#txspt-icons-export");
    			add_location(use, file$2v, 25, 14, 539);
    			attr_dev(svg, "class", "txcm-navigationExportIcon");
    			add_location(svg, file$2v, 23, 10, 473);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, use);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$M.name,
    		type: "slot",
    		source: "(21:6) <NavLink         linkClass=\\\"txcm-navigationExportLink\\\"         to={`/dashboard/${dashboard}/export`}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$32(ctx) {
    	let nav;
    	let t;
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = !/*disabled*/ ctx[2] && create_if_block$$(ctx);

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			if (if_block) if_block.c();
    			t = space();
    			button = element("button");
    			button.disabled = /*disabled*/ ctx[2];
    			attr_dev(button, "class", "txcm-navigationExportBack");
    			toggle_class(button, "txcm-navigationExportBack-is-active", /*indicator*/ ctx[1] === "export");
    			add_location(button, file$2v, 30, 4, 644);
    			attr_dev(nav, "class", "txcm-navigation");
    			add_location(nav, file$2v, 17, 0, 303);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			if (if_block) if_block.m(nav, null);
    			append_dev(nav, t);
    			append_dev(nav, button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", onBackClick, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*disabled*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*disabled*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$$(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(nav, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*disabled*/ 4) {
    				prop_dev(button, "disabled", /*disabled*/ ctx[2]);
    			}

    			if (dirty & /*indicator*/ 2) {
    				toggle_class(button, "txcm-navigationExportBack-is-active", /*indicator*/ ctx[1] === "export");
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$32.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function onBackClick() {
    	history.back();
    }

    function instance$32($$self, $$props, $$invalidate) {
    	let $updating;
    	let { dashboard } = $$props;
    	let { indicator } = $$props;
    	const updating = getUIState("updating");
    	validate_store(updating, "updating");
    	component_subscribe($$self, updating, value => $$invalidate(4, $updating = value));
    	const writable_props = ["dashboard", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HeaderNavigation> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("HeaderNavigation", $$slots, []);

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		NavLink,
    		getUIState,
    		dashboard,
    		indicator,
    		updating,
    		onBackClick,
    		disabled,
    		$updating
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("disabled" in $$props) $$invalidate(2, disabled = $$props.disabled);
    	};

    	let disabled;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$updating*/ 16) {
    			 $$invalidate(2, disabled = $updating > 0);
    		}
    	};

    	return [dashboard, indicator, disabled, updating];
    }

    class HeaderNavigation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$32, create_fragment$32, safe_not_equal, { dashboard: 0, indicator: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HeaderNavigation",
    			options,
    			id: create_fragment$32.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[0] === undefined && !("dashboard" in props)) {
    			console.warn("<HeaderNavigation> was created without expected prop 'dashboard'");
    		}

    		if (/*indicator*/ ctx[1] === undefined && !("indicator" in props)) {
    			console.warn("<HeaderNavigation> was created without expected prop 'indicator'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<HeaderNavigation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<HeaderNavigation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<HeaderNavigation>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<HeaderNavigation>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/header/Header.svelte generated by Svelte v3.24.0 */
    const file$2w = "src/js/components/header/Header.svelte";

    // (18:4) {#if isTabsActive}
    function create_if_block$10(ctx) {
    	let headertabs;
    	let current;

    	headertabs = new HeaderTabs({
    			props: {
    				dashboard: /*dashboard*/ ctx[0],
    				indicator: /*indicator*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(headertabs.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(headertabs, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const headertabs_changes = {};
    			if (dirty & /*dashboard*/ 1) headertabs_changes.dashboard = /*dashboard*/ ctx[0];
    			if (dirty & /*indicator*/ 2) headertabs_changes.indicator = /*indicator*/ ctx[1];
    			headertabs.$set(headertabs_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(headertabs.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(headertabs.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(headertabs, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$10.name,
    		type: "if",
    		source: "(18:4) {#if isTabsActive}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$33(ctx) {
    	let header;
    	let t0;
    	let headerdashboardtoggle;
    	let t1;
    	let headerfilter;
    	let t2;
    	let headernavigation;
    	let current;
    	let if_block = /*isTabsActive*/ ctx[2] && create_if_block$10(ctx);

    	headerdashboardtoggle = new HeaderDashboardToggle({
    			props: {
    				dashboard: /*dashboard*/ ctx[0],
    				indicator: /*indicator*/ ctx[1]
    			},
    			$$inline: true
    		});

    	headerfilter = new HeaderFilter({
    			props: {
    				variant: "header",
    				dashboard: /*dashboard*/ ctx[0]
    			},
    			$$inline: true
    		});

    	headernavigation = new HeaderNavigation({
    			props: {
    				dashboard: /*dashboard*/ ctx[0],
    				indicator: /*indicator*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			header = element("header");
    			if (if_block) if_block.c();
    			t0 = space();
    			create_component(headerdashboardtoggle.$$.fragment);
    			t1 = space();
    			create_component(headerfilter.$$.fragment);
    			t2 = space();
    			create_component(headernavigation.$$.fragment);
    			attr_dev(header, "class", "txcm-header");
    			add_location(header, file$2w, 15, 0, 462);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header, anchor);
    			if (if_block) if_block.m(header, null);
    			append_dev(header, t0);
    			mount_component(headerdashboardtoggle, header, null);
    			append_dev(header, t1);
    			mount_component(headerfilter, header, null);
    			append_dev(header, t2);
    			mount_component(headernavigation, header, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*isTabsActive*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*isTabsActive*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$10(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(header, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const headerdashboardtoggle_changes = {};
    			if (dirty & /*dashboard*/ 1) headerdashboardtoggle_changes.dashboard = /*dashboard*/ ctx[0];
    			if (dirty & /*indicator*/ 2) headerdashboardtoggle_changes.indicator = /*indicator*/ ctx[1];
    			headerdashboardtoggle.$set(headerdashboardtoggle_changes);
    			const headerfilter_changes = {};
    			if (dirty & /*dashboard*/ 1) headerfilter_changes.dashboard = /*dashboard*/ ctx[0];
    			headerfilter.$set(headerfilter_changes);
    			const headernavigation_changes = {};
    			if (dirty & /*dashboard*/ 1) headernavigation_changes.dashboard = /*dashboard*/ ctx[0];
    			if (dirty & /*indicator*/ 2) headernavigation_changes.indicator = /*indicator*/ ctx[1];
    			headernavigation.$set(headernavigation_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(headerdashboardtoggle.$$.fragment, local);
    			transition_in(headerfilter.$$.fragment, local);
    			transition_in(headernavigation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(headerdashboardtoggle.$$.fragment, local);
    			transition_out(headerfilter.$$.fragment, local);
    			transition_out(headernavigation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    			if (if_block) if_block.d();
    			destroy_component(headerdashboardtoggle);
    			destroy_component(headerfilter);
    			destroy_component(headernavigation);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$33.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$33($$self, $$props, $$invalidate) {
    	let $updating;
    	const updating = getUIState("updating");
    	validate_store(updating, "updating");
    	component_subscribe($$self, updating, value => $$invalidate(4, $updating = value));
    	let { dashboard } = $$props;
    	let { indicator } = $$props;
    	const writable_props = ["dashboard", "indicator"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Header> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Header", $$slots, []);

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    	};

    	$$self.$capture_state = () => ({
    		HeaderDashboardToggle,
    		HeaderTabs,
    		HeaderFilter,
    		HeaderNavigation,
    		getUIState,
    		updating,
    		dashboard,
    		indicator,
    		isTabsActive,
    		$updating
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("isTabsActive" in $$props) $$invalidate(2, isTabsActive = $$props.isTabsActive);
    	};

    	let isTabsActive;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*indicator, $updating*/ 18) {
    			 $$invalidate(2, isTabsActive = !!indicator && indicator !== "export" && $updating <= 0);
    		}
    	};

    	return [dashboard, indicator, isTabsActive, updating];
    }

    class Header extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$33, create_fragment$33, safe_not_equal, { dashboard: 0, indicator: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Header",
    			options,
    			id: create_fragment$33.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[0] === undefined && !("dashboard" in props)) {
    			console.warn("<Header> was created without expected prop 'dashboard'");
    		}

    		if (/*indicator*/ ctx[1] === undefined && !("indicator" in props)) {
    			console.warn("<Header> was created without expected prop 'indicator'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<Header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<Header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/menu/MenuToggle.svelte generated by Svelte v3.24.0 */
    const file$2x = "src/js/components/menu/MenuToggle.svelte";

    function create_fragment$34(ctx) {
    	let button;
    	let int;
    	let current;
    	let mounted;
    	let dispose;
    	int = new Int({ props: { key: "Меню" }, $$inline: true });

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(int.$$.fragment);
    			attr_dev(button, "class", "txcm-menuToggle");
    			add_location(button, file$2x, 16, 0, 340);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onToggleClick*/ ctx[1], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$34.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$34($$self, $$props, $$invalidate) {
    	let $menu;
    	const menu = getUIState("menu");
    	validate_store(menu, "menu");
    	component_subscribe($$self, menu, value => $$invalidate(2, $menu = value));

    	function show() {
    		updateUI({ menu: true });
    		updateUI({ menuDashNav: false });
    	}

    	function onToggleClick() {
    		if (!$menu) setTimeout(show, 5);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MenuToggle> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("MenuToggle", $$slots, []);

    	$$self.$capture_state = () => ({
    		Int,
    		getUIState,
    		updateUI,
    		menu,
    		show,
    		onToggleClick,
    		$menu
    	});

    	return [menu, onToggleClick];
    }

    class MenuToggle extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$34, create_fragment$34, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MenuToggle",
    			options,
    			id: create_fragment$34.name
    		});
    	}
    }

    function dispatchRequestEvent$2(request) {
      const event = new CustomEvent('templateactionrequest', { detail: request });
      window.dispatchEvent(event);
    }

    function requestTemplateAction(request) {
      const promise = new Promise((resolve, reject) => {
        function onRequestResponse(response) {
          window.removeEventListener('templateactionresponse', onRequestResponse);
          window.removeEventListener('error', onRequestError);
          resolve(response.detail);
        }

        function onRequestError() {
          window.removeEventListener('templateactionresponse', onRequestResponse);
          window.removeEventListener('error', onRequestError);
          reject(new Error('An error occured while making this request'));
        }

        window.addEventListener('templateactionresponse', onRequestResponse);
        window.addEventListener('error', onRequestError);
      });
      dispatchRequestEvent$2(request);
      return promise;
    }

    /* src/js/components/template/Template.svelte generated by Svelte v3.24.0 */
    const file$2y = "src/js/components/template/Template.svelte";

    function create_fragment$35(ctx) {
    	let li;
    	let button0;
    	let int;
    	let t0;
    	let button1;
    	let t1_value = /*data*/ ctx[0].label + "";
    	let t1;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { alt: "Удалить" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			button0 = element("button");
    			create_component(int.$$.fragment);
    			t0 = space();
    			button1 = element("button");
    			t1 = text(t1_value);
    			attr_dev(button0, "class", "txcm-templateDelete");
    			button0.disabled = /*isDisabled*/ ctx[1];
    			add_location(button0, file$2y, 82, 4, 1793);
    			attr_dev(button1, "class", "txcm-template");
    			button1.disabled = /*isDisabled*/ ctx[1];
    			add_location(button1, file$2y, 89, 4, 1961);
    			attr_dev(li, "class", "txcm-templateOption");
    			add_location(li, file$2y, 80, 0, 1754);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, button0);
    			mount_component(int, button0, null);
    			append_dev(li, t0);
    			append_dev(li, button1);
    			append_dev(button1, t1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*onTemplateDeleteClick*/ ctx[6], false, false, false),
    					listen_dev(button1, "click", /*onTemplateClick*/ ctx[5], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*isDisabled*/ 2) {
    				prop_dev(button0, "disabled", /*isDisabled*/ ctx[1]);
    			}

    			if ((!current || dirty & /*data*/ 1) && t1_value !== (t1_value = /*data*/ ctx[0].label + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*isDisabled*/ 2) {
    				prop_dev(button1, "disabled", /*isDisabled*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(int);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$35.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$35($$self, $$props, $$invalidate) {
    	let $updatingMeta;
    	let $templates;
    	let $templateUpdate;
    	let { data } = $$props;
    	let { isDisabled } = $$props;
    	const templates = getUIState("templates");
    	validate_store(templates, "templates");
    	component_subscribe($$self, templates, value => $$invalidate(8, $templates = value));
    	const templateUpdate = getUIState("templateUpdate");
    	validate_store(templateUpdate, "templateUpdate");
    	component_subscribe($$self, templateUpdate, value => $$invalidate(9, $templateUpdate = value));
    	const updating = getUIState("updating");
    	const updatingMeta = getUIState("updatingMeta");
    	validate_store(updatingMeta, "updatingMeta");
    	component_subscribe($$self, updatingMeta, value => $$invalidate(7, $updatingMeta = value));

    	function enable() {
    		set_store_value(updatingMeta, $updatingMeta -= 1);
    	}

    	function updateStateRemove(status) {
    		if (status) {
    			const copy = $templates.slice();
    			const index = copy.findIndex(template => template.id === data.id);
    			copy.splice(index, 1);
    			set_store_value(templates, $templates = copy);
    		}
    	}

    	function removeTemplate() {
    		const request = { action: "remove", data: { id: data.id } };
    		requestTemplateAction(request).then(updateStateRemove).then(enable).catch(enable);
    	}

    	function tryRemoveTemplate() {
    		updateUI({
    			updatingMeta: $updatingMeta + 1,
    			confirmation: {
    				header: `Удалить шаблон "${data.label}"?`,
    				message: "Вы действительно хотите удалить шаблон?",
    				action: removeTemplate,
    				cancel: enable
    			}
    		});
    	}

    	function updateStateApplly(status) {
    		if (status) {
    			set_store_value(templateUpdate, $templateUpdate = Date.now());
    		}
    	}

    	function applyTemplate() {
    		set_store_value(updatingMeta, $updatingMeta += 1);
    		const action = { action: "apply", data: { id: data.id } };
    		requestTemplateAction(action).then(updateStateApplly).then(enable).catch(enable);
    	}

    	function onTemplateClick() {
    		applyTemplate();
    	}

    	function onTemplateDeleteClick() {
    		tryRemoveTemplate();
    	}

    	const writable_props = ["data", "isDisabled"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Template> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Template", $$slots, []);

    	$$self.$set = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("isDisabled" in $$props) $$invalidate(1, isDisabled = $$props.isDisabled);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		getUIState,
    		updateUI,
    		requestTemplateAction,
    		data,
    		isDisabled,
    		templates,
    		templateUpdate,
    		updating,
    		updatingMeta,
    		enable,
    		updateStateRemove,
    		removeTemplate,
    		tryRemoveTemplate,
    		updateStateApplly,
    		applyTemplate,
    		onTemplateClick,
    		onTemplateDeleteClick,
    		$updatingMeta,
    		$templates,
    		$templateUpdate
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) $$invalidate(0, data = $$props.data);
    		if ("isDisabled" in $$props) $$invalidate(1, isDisabled = $$props.isDisabled);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		data,
    		isDisabled,
    		templates,
    		templateUpdate,
    		updatingMeta,
    		onTemplateClick,
    		onTemplateDeleteClick
    	];
    }

    class Template extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$35, create_fragment$35, safe_not_equal, { data: 0, isDisabled: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Template",
    			options,
    			id: create_fragment$35.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*data*/ ctx[0] === undefined && !("data" in props)) {
    			console.warn("<Template> was created without expected prop 'data'");
    		}

    		if (/*isDisabled*/ ctx[1] === undefined && !("isDisabled" in props)) {
    			console.warn("<Template> was created without expected prop 'isDisabled'");
    		}
    	}

    	get data() {
    		throw new Error("<Template>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set data(value) {
    		throw new Error("<Template>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get isDisabled() {
    		throw new Error("<Template>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isDisabled(value) {
    		throw new Error("<Template>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/templates/TemplatesForm.svelte generated by Svelte v3.24.0 */
    const file$2z = "src/js/components/templates/TemplatesForm.svelte";

    function create_fragment$36(ctx) {
    	let form;
    	let input_1;
    	let t;
    	let button;
    	let int;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: "Добавить в шаблоны" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			form = element("form");
    			input_1 = element("input");
    			t = space();
    			button = element("button");
    			create_component(int.$$.fragment);
    			attr_dev(input_1, "class", "txcm-templateInput");
    			attr_dev(input_1, "placeholder", "Новый шаблон");
    			input_1.disabled = /*isDisabled*/ ctx[0];
    			add_location(input_1, file$2z, 85, 4, 1575);
    			attr_dev(form, "class", "txcm-templateForm");
    			toggle_class(form, "txcm-templateForm-is-active", /*isActive*/ ctx[3]);
    			add_location(form, file$2z, 81, 0, 1443);
    			attr_dev(button, "class", "txcm-templateAdd");
    			button.disabled = /*isDisabled*/ ctx[0];
    			add_location(button, file$2z, 92, 0, 1726);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			append_dev(form, input_1);
    			/*input_1_binding*/ ctx[8](input_1);
    			set_input_value(input_1, /*value*/ ctx[2]);
    			insert_dev(target, t, anchor);
    			insert_dev(target, button, anchor);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input_1, "input", /*input_1_input_handler*/ ctx[9]),
    					listen_dev(form, "submit", prevent_default(/*onTemplateSubmit*/ ctx[7]), false, true, false),
    					listen_dev(button, "click", /*onAddClick*/ ctx[6], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*isDisabled*/ 1) {
    				prop_dev(input_1, "disabled", /*isDisabled*/ ctx[0]);
    			}

    			if (dirty & /*value*/ 4 && input_1.value !== /*value*/ ctx[2]) {
    				set_input_value(input_1, /*value*/ ctx[2]);
    			}

    			if (dirty & /*isActive*/ 8) {
    				toggle_class(form, "txcm-templateForm-is-active", /*isActive*/ ctx[3]);
    			}

    			if (!current || dirty & /*isDisabled*/ 1) {
    				prop_dev(button, "disabled", /*isDisabled*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			/*input_1_binding*/ ctx[8](null);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(button);
    			destroy_component(int);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$36.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$36($$self, $$props, $$invalidate) {
    	let $updatingMeta;
    	let $templates;
    	let { isDisabled } = $$props;
    	const templates = getUIState("templates");
    	validate_store(templates, "templates");
    	component_subscribe($$self, templates, value => $$invalidate(11, $templates = value));
    	const updatingMeta = getUIState("updatingMeta");
    	validate_store(updatingMeta, "updatingMeta");
    	component_subscribe($$self, updatingMeta, value => $$invalidate(10, $updatingMeta = value));
    	let input;
    	let value = "";
    	let isActive;

    	function resetValue() {
    		$$invalidate(2, value = "");
    	}

    	async function show() {
    		$$invalidate(3, isActive = true);
    		await tick();
    		input.focus();
    	}

    	function hide() {
    		resetValue();
    		input.blur();
    		$$invalidate(3, isActive = false);
    	}

    	function enable() {
    		set_store_value(updatingMeta, $updatingMeta -= 1);
    	}

    	function disable() {
    		set_store_value(updatingMeta, $updatingMeta += 1);
    	}

    	function updateState(id) {
    		if (id) {
    			const template = { id, label: value, description: "" };
    			const copy = $templates.slice();
    			copy.push(template);
    			set_store_value(templates, $templates = copy);
    		}
    	}

    	function addTemplate() {
    		const request = {
    			action: "add",
    			data: { name: value, description: "" }
    		};

    		requestTemplateAction(request).then(updateState).then(hide).then(enable);
    	}

    	function createTemplate() {
    		addTemplate();
    		disable();
    	}

    	function onAddClick() {
    		if (isActive && value) createTemplate(); else if (!isActive) show();
    	}

    	function onTemplateSubmit() {
    		createTemplate();
    	}

    	const writable_props = ["isDisabled"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<TemplatesForm> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("TemplatesForm", $$slots, []);

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			input = $$value;
    			$$invalidate(1, input);
    		});
    	}

    	function input_1_input_handler() {
    		value = this.value;
    		$$invalidate(2, value);
    	}

    	$$self.$set = $$props => {
    		if ("isDisabled" in $$props) $$invalidate(0, isDisabled = $$props.isDisabled);
    	};

    	$$self.$capture_state = () => ({
    		tick,
    		getUIState,
    		requestTemplateAction,
    		Int,
    		isDisabled,
    		templates,
    		updatingMeta,
    		input,
    		value,
    		isActive,
    		resetValue,
    		show,
    		hide,
    		enable,
    		disable,
    		updateState,
    		addTemplate,
    		createTemplate,
    		onAddClick,
    		onTemplateSubmit,
    		$updatingMeta,
    		$templates
    	});

    	$$self.$inject_state = $$props => {
    		if ("isDisabled" in $$props) $$invalidate(0, isDisabled = $$props.isDisabled);
    		if ("input" in $$props) $$invalidate(1, input = $$props.input);
    		if ("value" in $$props) $$invalidate(2, value = $$props.value);
    		if ("isActive" in $$props) $$invalidate(3, isActive = $$props.isActive);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		isDisabled,
    		input,
    		value,
    		isActive,
    		templates,
    		updatingMeta,
    		onAddClick,
    		onTemplateSubmit,
    		input_1_binding,
    		input_1_input_handler
    	];
    }

    class TemplatesForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$36, create_fragment$36, safe_not_equal, { isDisabled: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TemplatesForm",
    			options,
    			id: create_fragment$36.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*isDisabled*/ ctx[0] === undefined && !("isDisabled" in props)) {
    			console.warn("<TemplatesForm> was created without expected prop 'isDisabled'");
    		}
    	}

    	get isDisabled() {
    		throw new Error("<TemplatesForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set isDisabled(value) {
    		throw new Error("<TemplatesForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/templates/Templates.svelte generated by Svelte v3.24.0 */
    const file$2A = "src/js/components/templates/Templates.svelte";

    function get_each_context$D(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (18:0) {#if $templates}
    function create_if_block$11(ctx) {
    	let div1;
    	let div0;
    	let int;
    	let t0;
    	let ul;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let templatesform;
    	let current;

    	int = new Int({
    			props: { key: "Шаблоны" },
    			$$inline: true
    		});

    	let each_value = /*$templates*/ ctx[1];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*template*/ ctx[8].id;
    	validate_each_keys(ctx, each_value, get_each_context$D, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$D(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$D(key, child_ctx));
    	}

    	templatesform = new TemplatesForm({
    			props: { isDisabled: /*isDisabled*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(int.$$.fragment);
    			t0 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(templatesform.$$.fragment);
    			attr_dev(div0, "class", "txcm-templatesHeader");
    			add_location(div0, file$2A, 20, 6, 585);
    			attr_dev(ul, "class", "txcm-templateList");
    			add_location(ul, file$2A, 25, 6, 691);
    			attr_dev(div1, "class", "txcm-templates");
    			add_location(div1, file$2A, 18, 2, 546);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(int, div0, null);
    			append_dev(div1, t0);
    			append_dev(div1, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(div1, t1);
    			mount_component(templatesform, div1, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$templates, isDisabled*/ 3) {
    				const each_value = /*$templates*/ ctx[1];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$D, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$D, null, get_each_context$D);
    				check_outros();
    			}

    			const templatesform_changes = {};
    			if (dirty & /*isDisabled*/ 1) templatesform_changes.isDisabled = /*isDisabled*/ ctx[0];
    			templatesform.$set(templatesform_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(templatesform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(templatesform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(int);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			destroy_component(templatesform);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$11.name,
    		type: "if",
    		source: "(18:0) {#if $templates}",
    		ctx
    	});

    	return block;
    }

    // (28:10) {#each $templates as template (template.id)}
    function create_each_block$D(key_1, ctx) {
    	let first;
    	let template;
    	let current;

    	template = new Template({
    			props: {
    				data: /*template*/ ctx[8],
    				isDisabled: /*isDisabled*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(template.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(template, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const template_changes = {};
    			if (dirty & /*$templates*/ 2) template_changes.data = /*template*/ ctx[8];
    			if (dirty & /*isDisabled*/ 1) template_changes.isDisabled = /*isDisabled*/ ctx[0];
    			template.$set(template_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(template.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(template.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(template, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$D.name,
    		type: "each",
    		source: "(28:10) {#each $templates as template (template.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$37(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$templates*/ ctx[1] && create_if_block$11(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$templates*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$templates*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$11(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$37.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$37($$self, $$props, $$invalidate) {
    	let $updatingMeta;
    	let $updating;
    	let $templates;
    	const templates = getUIState("templates");
    	validate_store(templates, "templates");
    	component_subscribe($$self, templates, value => $$invalidate(1, $templates = value));
    	const updating = getUIState("updating");
    	validate_store(updating, "updating");
    	component_subscribe($$self, updating, value => $$invalidate(6, $updating = value));
    	const updatingMeta = getUIState("updatingMeta");
    	validate_store(updatingMeta, "updatingMeta");
    	component_subscribe($$self, updatingMeta, value => $$invalidate(5, $updatingMeta = value));

    	function checkDisabled() {
    		return $updatingMeta > 0 || $updating > 0;
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Templates> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Templates", $$slots, []);

    	$$self.$capture_state = () => ({
    		getUIState,
    		Int,
    		Template,
    		TemplatesForm,
    		templates,
    		updating,
    		updatingMeta,
    		checkDisabled,
    		isDisabled,
    		$updatingMeta,
    		$updating,
    		$templates
    	});

    	$$self.$inject_state = $$props => {
    		if ("isDisabled" in $$props) $$invalidate(0, isDisabled = $$props.isDisabled);
    	};

    	let isDisabled;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$updatingMeta, $updating*/ 96) {
    			 $$invalidate(0, isDisabled = checkDisabled());
    		}
    	};

    	return [isDisabled, $templates, templates, updating, updatingMeta];
    }

    class Templates extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$37, create_fragment$37, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Templates",
    			options,
    			id: create_fragment$37.name
    		});
    	}
    }

    /* src/js/components/menu/MenuLanguage.svelte generated by Svelte v3.24.0 */
    const file$2B = "src/js/components/menu/MenuLanguage.svelte";

    function create_fragment$38(ctx) {
    	let button;
    	let int;
    	let current;
    	let mounted;
    	let dispose;

    	int = new Int({
    			props: { key: /*label*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			button = element("button");
    			create_component(int.$$.fragment);
    			attr_dev(button, "class", "txcm-menuDrawerLocale");
    			add_location(button, file$2B, 22, 0, 541);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onLocaleClick*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const int_changes = {};
    			if (dirty & /*label*/ 1) int_changes.key = /*label*/ ctx[0];
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$38.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$38($$self, $$props, $$invalidate) {
    	let $locale;
    	const dispatch = createEventDispatcher();
    	const locale = getUIState("locale");
    	validate_store(locale, "locale");
    	component_subscribe($$self, locale, value => $$invalidate(3, $locale = value));

    	function updateLabel() {
    		if ($locale === "ru") return "en";
    		return "ru";
    	}

    	function onLocaleClick() {
    		if ($locale === "ru") set_store_value(locale, $locale = "en"); else set_store_value(locale, $locale = "ru");
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MenuLanguage> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("MenuLanguage", $$slots, []);

    	$$self.$capture_state = () => ({
    		createEventDispatcher,
    		getUIState,
    		Int,
    		dispatch,
    		locale,
    		updateLabel,
    		onLocaleClick,
    		label,
    		$locale
    	});

    	$$self.$inject_state = $$props => {
    		if ("label" in $$props) $$invalidate(0, label = $$props.label);
    	};

    	let label;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$locale*/ 8) {
    			 $$invalidate(0, label = updateLabel());
    		}

    		if ($$self.$$.dirty & /*$locale*/ 8) {
    			 dispatch("localechange", { locale: $locale });
    		}
    	};

    	return [label, locale, onLocaleClick];
    }

    class MenuLanguage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$38, create_fragment$38, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MenuLanguage",
    			options,
    			id: create_fragment$38.name
    		});
    	}
    }

    /* src/js/components/menu/MenuNavigation.svelte generated by Svelte v3.24.0 */
    const file$2C = "src/js/components/menu/MenuNavigation.svelte";

    function create_fragment$39(ctx) {
    	let nav;
    	let a;
    	let int;
    	let current;

    	int = new Int({
    			props: { key: "Финансовый дашборд" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			a = element("a");
    			create_component(int.$$.fragment);
    			attr_dev(a, "class", "txcm-menuDrawerNavLink");
    			attr_dev(a, "href", "https://qsense.corp.tander.ru/extensions/Financial/Financial.html#/dashboard/financial");
    			add_location(a, file$2C, 7, 4, 199);
    			attr_dev(nav, "class", "txcm-menuDrawerNavigation");
    			add_location(nav, file$2C, 5, 0, 153);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			append_dev(nav, a);
    			mount_component(int, a, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			destroy_component(int);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$39.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$39($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MenuNavigation> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("MenuNavigation", $$slots, []);
    	$$self.$capture_state = () => ({ Int, NavLink });
    	return [];
    }

    class MenuNavigation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$39, create_fragment$39, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MenuNavigation",
    			options,
    			id: create_fragment$39.name
    		});
    	}
    }

    /* src/js/components/aside/AsideGroup.svelte generated by Svelte v3.24.0 */
    const file$2D = "src/js/components/aside/AsideGroup.svelte";

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    function get_each_context$E(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (30:8) <NavLink           linkClass="txcm-asideNavGroupLink"           to={!$location.endsWith('factors') || (indicator.id !== '1' && indicator.id !== '24' && indicator.id !== '20')           ? renderURL(dashboard, indicator.url) : renderURL(dashboard, `${indicator.url}/factors`)}           on:click={handleNavLinkClick(renderURL(dashboard, indicator.url))}           partial={true}>
    function create_default_slot_1$f(ctx) {
    	let int;
    	let t;
    	let svg;
    	let use;
    	let current;

    	int = new Int({
    			props: { key: /*indicator*/ ctx[11].label },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(int.$$.fragment);
    			t = space();
    			svg = svg_element("svg");
    			use = svg_element("use");
    			xlink_attr(use, "xlink:href", "#txspt-icons-checkmark");
    			add_location(use, file$2D, 39, 16, 1353);
    			attr_dev(svg, "class", "txcm-asideNavGroupLinkIcon");
    			add_location(svg, file$2D, 37, 12, 1282);
    		},
    		m: function mount(target, anchor) {
    			mount_component(int, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, svg, anchor);
    			append_dev(svg, use);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const int_changes = {};
    			if (dirty & /*filtered*/ 4) int_changes.key = /*indicator*/ ctx[11].label;
    			int.$set(int_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(int, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$f.name,
    		type: "slot",
    		source: "(30:8) <NavLink           linkClass=\\\"txcm-asideNavGroupLink\\\"           to={!$location.endsWith('factors') || (indicator.id !== '1' && indicator.id !== '24' && indicator.id !== '20')           ? renderURL(dashboard, indicator.url) : renderURL(dashboard, `${indicator.url}/factors`)}           on:click={handleNavLinkClick(renderURL(dashboard, indicator.url))}           partial={true}>",
    		ctx
    	});

    	return block;
    }

    // (29:6) {#each group.indicators as indicator}
    function create_each_block_1$5(ctx) {
    	let navlink;
    	let current;

    	navlink = new NavLink({
    			props: {
    				linkClass: "txcm-asideNavGroupLink",
    				to: !/*$location*/ ctx[3].endsWith("factors") || /*indicator*/ ctx[11].id !== "1" && /*indicator*/ ctx[11].id !== "24" && /*indicator*/ ctx[11].id !== "20"
    				? renderURL(/*dashboard*/ ctx[0], /*indicator*/ ctx[11].url)
    				: renderURL(/*dashboard*/ ctx[0], `${/*indicator*/ ctx[11].url}/factors`),
    				partial: true,
    				$$slots: { default: [create_default_slot_1$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	navlink.$on("click", function () {
    		if (is_function(/*handleNavLinkClick*/ ctx[5](renderURL(/*dashboard*/ ctx[0], /*indicator*/ ctx[11].url)))) /*handleNavLinkClick*/ ctx[5](renderURL(/*dashboard*/ ctx[0], /*indicator*/ ctx[11].url)).apply(this, arguments);
    	});

    	const block = {
    		c: function create() {
    			create_component(navlink.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(navlink, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const navlink_changes = {};

    			if (dirty & /*$location, filtered, dashboard*/ 13) navlink_changes.to = !/*$location*/ ctx[3].endsWith("factors") || /*indicator*/ ctx[11].id !== "1" && /*indicator*/ ctx[11].id !== "24" && /*indicator*/ ctx[11].id !== "20"
    			? renderURL(/*dashboard*/ ctx[0], /*indicator*/ ctx[11].url)
    			: renderURL(/*dashboard*/ ctx[0], `${/*indicator*/ ctx[11].url}/factors`);

    			if (dirty & /*$$scope, filtered*/ 16388) {
    				navlink_changes.$$scope = { dirty, ctx };
    			}

    			navlink.$set(navlink_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navlink.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navlink.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(navlink, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(29:6) {#each group.indicators as indicator}",
    		ctx
    	});

    	return block;
    }

    // (24:2) <ListGroup     label={group.label}     count={filtered.length}     length={group.length}     {filter}>
    function create_default_slot$N(ctx) {
    	let t;
    	let current;
    	let each_value_1 = /*group*/ ctx[8].indicators;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$location, filtered, renderURL, dashboard, handleNavLinkClick*/ 45) {
    				each_value_1 = /*group*/ ctx[8].indicators;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(t.parentNode, t);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$N.name,
    		type: "slot",
    		source: "(24:2) <ListGroup     label={group.label}     count={filtered.length}     length={group.length}     {filter}>",
    		ctx
    	});

    	return block;
    }

    // (23:0) {#each filtered as group}
    function create_each_block$E(ctx) {
    	let listgroup;
    	let current;

    	listgroup = new ListGroup({
    			props: {
    				label: /*group*/ ctx[8].label,
    				count: /*filtered*/ ctx[2].length,
    				length: /*group*/ ctx[8].length,
    				filter: /*filter*/ ctx[1],
    				$$slots: { default: [create_default_slot$N] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(listgroup.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(listgroup, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const listgroup_changes = {};
    			if (dirty & /*filtered*/ 4) listgroup_changes.label = /*group*/ ctx[8].label;
    			if (dirty & /*filtered*/ 4) listgroup_changes.count = /*filtered*/ ctx[2].length;
    			if (dirty & /*filtered*/ 4) listgroup_changes.length = /*group*/ ctx[8].length;
    			if (dirty & /*filter*/ 2) listgroup_changes.filter = /*filter*/ ctx[1];

    			if (dirty & /*$$scope, filtered, $location, dashboard*/ 16397) {
    				listgroup_changes.$$scope = { dirty, ctx };
    			}

    			listgroup.$set(listgroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(listgroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(listgroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(listgroup, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$E.name,
    		type: "each",
    		source: "(23:0) {#each filtered as group}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3a(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value = /*filtered*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$E(get_each_context$E(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*filtered, filter, $location, renderURL, dashboard, handleNavLinkClick*/ 47) {
    				each_value = /*filtered*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$E(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$E(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3a($$self, $$props, $$invalidate) {
    	let $drawer;
    	let $location;
    	validate_store(location, "location");
    	component_subscribe($$self, location, $$value => $$invalidate(3, $location = $$value));
    	const drawer = getUIState("aside");
    	validate_store(drawer, "drawer");
    	component_subscribe($$self, drawer, value => $$invalidate(7, $drawer = value));
    	let { dashboard } = $$props;
    	let { categories } = $$props;
    	let { filter } = $$props;

    	function handleNavLinkClick() {
    		set_store_value(drawer, $drawer = false);
    	}

    	const writable_props = ["dashboard", "categories", "filter"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AsideGroup> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("AsideGroup", $$slots, []);

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("categories" in $$props) $$invalidate(6, categories = $$props.categories);
    		if ("filter" in $$props) $$invalidate(1, filter = $$props.filter);
    	};

    	$$self.$capture_state = () => ({
    		Int,
    		ListGroup,
    		NavLink,
    		filterNavigationCategories,
    		renderURL,
    		getUIState,
    		location,
    		drawer,
    		dashboard,
    		categories,
    		filter,
    		handleNavLinkClick,
    		filtered,
    		$drawer,
    		$location
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("categories" in $$props) $$invalidate(6, categories = $$props.categories);
    		if ("filter" in $$props) $$invalidate(1, filter = $$props.filter);
    		if ("filtered" in $$props) $$invalidate(2, filtered = $$props.filtered);
    	};

    	let filtered;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*categories, filter*/ 66) {
    			 $$invalidate(2, filtered = filterNavigationCategories(categories, filter));
    		}
    	};

    	return [dashboard, filter, filtered, $location, drawer, handleNavLinkClick, categories];
    }

    class AsideGroup extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3a, create_fragment$3a, safe_not_equal, { dashboard: 0, categories: 6, filter: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AsideGroup",
    			options,
    			id: create_fragment$3a.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[0] === undefined && !("dashboard" in props)) {
    			console.warn("<AsideGroup> was created without expected prop 'dashboard'");
    		}

    		if (/*categories*/ ctx[6] === undefined && !("categories" in props)) {
    			console.warn("<AsideGroup> was created without expected prop 'categories'");
    		}

    		if (/*filter*/ ctx[1] === undefined && !("filter" in props)) {
    			console.warn("<AsideGroup> was created without expected prop 'filter'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<AsideGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<AsideGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get categories() {
    		throw new Error("<AsideGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set categories(value) {
    		throw new Error("<AsideGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get filter() {
    		throw new Error("<AsideGroup>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filter(value) {
    		throw new Error("<AsideGroup>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/aside/operational/AsideNavigationOperational.svelte generated by Svelte v3.24.0 */
    const file$2E = "src/js/components/aside/operational/AsideNavigationOperational.svelte";

    // (14:4) <NavLink       linkClass="txcm-asideNavLink"       to="/dashboard/operational">
    function create_default_slot$O(ctx) {
    	let int;
    	let t;
    	let svg;
    	let use;
    	let current;

    	int = new Int({
    			props: { key: "Операционный дашборд" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(int.$$.fragment);
    			t = space();
    			svg = svg_element("svg");
    			use = svg_element("use");
    			xlink_attr(use, "xlink:href", "#txspt-icons-checkmark");
    			add_location(use, file$2E, 20, 12, 606);
    			attr_dev(svg, "class", "txcm-asideNavLinkIcon");
    			add_location(svg, file$2E, 18, 8, 548);
    		},
    		m: function mount(target, anchor) {
    			mount_component(int, target, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, svg, anchor);
    			append_dev(svg, use);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(int, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$O.name,
    		type: "slot",
    		source: "(14:4) <NavLink       linkClass=\\\"txcm-asideNavLink\\\"       to=\\\"/dashboard/operational\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3b(ctx) {
    	let div;
    	let navlink;
    	let t;
    	let asidegroup;
    	let current;

    	navlink = new NavLink({
    			props: {
    				linkClass: "txcm-asideNavLink",
    				to: "/dashboard/operational",
    				$$slots: { default: [create_default_slot$O] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	asidegroup = new AsideGroup({
    			props: {
    				dashboard: "operational",
    				categories: /*config*/ ctx[1],
    				filter: /*filter*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(navlink.$$.fragment);
    			t = space();
    			create_component(asidegroup.$$.fragment);
    			attr_dev(div, "class", "txcm-asideNavGroup");
    			add_location(div, file$2E, 11, 0, 368);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(navlink, div, null);
    			append_dev(div, t);
    			mount_component(asidegroup, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const navlink_changes = {};

    			if (dirty & /*$$scope*/ 4) {
    				navlink_changes.$$scope = { dirty, ctx };
    			}

    			navlink.$set(navlink_changes);
    			const asidegroup_changes = {};
    			if (dirty & /*filter*/ 1) asidegroup_changes.filter = /*filter*/ ctx[0];
    			asidegroup.$set(asidegroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(navlink.$$.fragment, local);
    			transition_in(asidegroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(navlink.$$.fragment, local);
    			transition_out(asidegroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(navlink);
    			destroy_component(asidegroup);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3b($$self, $$props, $$invalidate) {
    	let { filter } = $$props;
    	const { indicators: config } = getContext("app").getAppConfig().dashboards.operational;
    	const writable_props = ["filter"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AsideNavigationOperational> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("AsideNavigationOperational", $$slots, []);

    	$$self.$set = $$props => {
    		if ("filter" in $$props) $$invalidate(0, filter = $$props.filter);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		Int,
    		NavLink,
    		AsideGroup,
    		filter,
    		config
    	});

    	$$self.$inject_state = $$props => {
    		if ("filter" in $$props) $$invalidate(0, filter = $$props.filter);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [filter, config];
    }

    class AsideNavigationOperational extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3b, create_fragment$3b, safe_not_equal, { filter: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AsideNavigationOperational",
    			options,
    			id: create_fragment$3b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*filter*/ ctx[0] === undefined && !("filter" in props)) {
    			console.warn("<AsideNavigationOperational> was created without expected prop 'filter'");
    		}
    	}

    	get filter() {
    		throw new Error("<AsideNavigationOperational>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set filter(value) {
    		throw new Error("<AsideNavigationOperational>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/aside/AsideNavigation.svelte generated by Svelte v3.24.0 */
    const file$2F = "src/js/components/aside/AsideNavigation.svelte";

    function create_fragment$3c(ctx) {
    	let nav;
    	let div0;
    	let int;
    	let t0;
    	let listfilter;
    	let updating_value;
    	let t1;
    	let div1;
    	let asidenavigationoperational;
    	let current;

    	int = new Int({
    			props: { key: "Перейти в показатель" },
    			$$inline: true
    		});

    	function listfilter_value_binding(value) {
    		/*listfilter_value_binding*/ ctx[1].call(null, value);
    	}

    	let listfilter_props = {};

    	if (/*filter*/ ctx[0] !== void 0) {
    		listfilter_props.value = /*filter*/ ctx[0];
    	}

    	listfilter = new ListFilter({ props: listfilter_props, $$inline: true });
    	binding_callbacks.push(() => bind(listfilter, "value", listfilter_value_binding));

    	asidenavigationoperational = new AsideNavigationOperational({
    			props: { filter: /*filter*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			div0 = element("div");
    			create_component(int.$$.fragment);
    			t0 = space();
    			create_component(listfilter.$$.fragment);
    			t1 = space();
    			div1 = element("div");
    			create_component(asidenavigationoperational.$$.fragment);
    			attr_dev(div0, "class", "txcm-asideNavigationHeader");
    			add_location(div0, file$2F, 10, 4, 319);
    			attr_dev(div1, "class", "txcm-asideNavigationGroups");
    			add_location(div1, file$2F, 17, 4, 479);
    			attr_dev(nav, "class", "txcm-asideNavigation");
    			add_location(nav, file$2F, 8, 0, 278);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			append_dev(nav, div0);
    			mount_component(int, div0, null);
    			append_dev(nav, t0);
    			mount_component(listfilter, nav, null);
    			append_dev(nav, t1);
    			append_dev(nav, div1);
    			mount_component(asidenavigationoperational, div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const listfilter_changes = {};

    			if (!updating_value && dirty & /*filter*/ 1) {
    				updating_value = true;
    				listfilter_changes.value = /*filter*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			listfilter.$set(listfilter_changes);
    			const asidenavigationoperational_changes = {};
    			if (dirty & /*filter*/ 1) asidenavigationoperational_changes.filter = /*filter*/ ctx[0];
    			asidenavigationoperational.$set(asidenavigationoperational_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int.$$.fragment, local);
    			transition_in(listfilter.$$.fragment, local);
    			transition_in(asidenavigationoperational.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int.$$.fragment, local);
    			transition_out(listfilter.$$.fragment, local);
    			transition_out(asidenavigationoperational.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			destroy_component(int);
    			destroy_component(listfilter);
    			destroy_component(asidenavigationoperational);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3c($$self, $$props, $$invalidate) {
    	let filter = "";
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AsideNavigation> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("AsideNavigation", $$slots, []);

    	function listfilter_value_binding(value) {
    		filter = value;
    		$$invalidate(0, filter);
    	}

    	$$self.$capture_state = () => ({
    		Int,
    		ListFilter,
    		AsideNavigationOperational,
    		filter
    	});

    	$$self.$inject_state = $$props => {
    		if ("filter" in $$props) $$invalidate(0, filter = $$props.filter);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [filter, listfilter_value_binding];
    }

    class AsideNavigation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3c, create_fragment$3c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AsideNavigation",
    			options,
    			id: create_fragment$3c.name
    		});
    	}
    }

    /* src/js/components/menu/MenuDashboardNavigation.svelte generated by Svelte v3.24.0 */
    const file$2G = "src/js/components/menu/MenuDashboardNavigation.svelte";

    function create_fragment$3d(ctx) {
    	let div;
    	let asidenavigation;
    	let t;
    	let button;
    	let int;
    	let current;
    	let mounted;
    	let dispose;
    	asidenavigation = new AsideNavigation({ $$inline: true });

    	int = new Int({
    			props: { key: "Закрыть" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(asidenavigation.$$.fragment);
    			t = space();
    			button = element("button");
    			create_component(int.$$.fragment);
    			attr_dev(button, "class", "txcm-drawerClose");
    			add_location(button, file$2G, 18, 4, 460);
    			attr_dev(div, "class", "txcm-menuDrawerDashboardNav");
    			toggle_class(div, "txcm-menuDrawerDashboardNav-is-active", /*isActive*/ ctx[0]);
    			add_location(div, file$2G, 14, 0, 331);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(asidenavigation, div, null);
    			append_dev(div, t);
    			append_dev(div, button);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*onCloseClick*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*isActive*/ 1) {
    				toggle_class(div, "txcm-menuDrawerDashboardNav-is-active", /*isActive*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(asidenavigation.$$.fragment, local);
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(asidenavigation.$$.fragment, local);
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(asidenavigation);
    			destroy_component(int);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3d($$self, $$props, $$invalidate) {
    	let $dashNav;
    	const dashNav = getUIState("menuDashNav");
    	validate_store(dashNav, "dashNav");
    	component_subscribe($$self, dashNav, value => $$invalidate(3, $dashNav = value));

    	function onCloseClick() {
    		set_store_value(dashNav, $dashNav = false);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MenuDashboardNavigation> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("MenuDashboardNavigation", $$slots, []);

    	$$self.$capture_state = () => ({
    		getUIState,
    		Int,
    		AsideNavigation,
    		dashNav,
    		onCloseClick,
    		isActive,
    		$dashNav
    	});

    	$$self.$inject_state = $$props => {
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    	};

    	let isActive;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$dashNav*/ 8) {
    			 $$invalidate(0, isActive = $dashNav);
    		}
    	};

    	return [isActive, dashNav, onCloseClick];
    }

    class MenuDashboardNavigation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3d, create_fragment$3d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MenuDashboardNavigation",
    			options,
    			id: create_fragment$3d.name
    		});
    	}
    }

    /* src/js/components/menu/MenuDrawer.svelte generated by Svelte v3.24.0 */
    const file$2H = "src/js/components/menu/MenuDrawer.svelte";

    // (34:0) <Overlay   {isActive}   on:overlayclose={onOverayClose}>
    function create_default_slot$P(ctx) {
    	let div;
    	let svg;
    	let use;
    	let t0;
    	let menulanguage;
    	let t1;
    	let menunavigation;
    	let t2;
    	let templates;
    	let t3;
    	let menudashboardnavigation;
    	let t4;
    	let button;
    	let int;
    	let current;
    	let mounted;
    	let dispose;
    	menulanguage = new MenuLanguage({ $$inline: true });
    	menunavigation = new MenuNavigation({ $$inline: true });
    	templates = new Templates({ $$inline: true });
    	menudashboardnavigation = new MenuDashboardNavigation({ $$inline: true });

    	int = new Int({
    			props: { key: "Закрыть" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			svg = svg_element("svg");
    			use = svg_element("use");
    			t0 = space();
    			create_component(menulanguage.$$.fragment);
    			t1 = space();
    			create_component(menunavigation.$$.fragment);
    			t2 = space();
    			create_component(templates.$$.fragment);
    			t3 = space();
    			create_component(menudashboardnavigation.$$.fragment);
    			t4 = space();
    			button = element("button");
    			create_component(int.$$.fragment);
    			xlink_attr(use, "xlink:href", "#txspt-icons-logo");
    			add_location(use, file$2H, 42, 12, 1087);
    			attr_dev(svg, "class", "txcm-menuLogo");
    			add_location(svg, file$2H, 40, 8, 1037);
    			attr_dev(button, "class", "txcm-drawerClose");
    			add_location(button, file$2H, 49, 8, 1273);
    			attr_dev(div, "class", "txcm-menuDrawer");
    			toggle_class(div, "txcm-menuDrawer-is-active", /*isActive*/ ctx[0]);
    			add_location(div, file$2H, 36, 4, 913);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, svg);
    			append_dev(svg, use);
    			append_dev(div, t0);
    			mount_component(menulanguage, div, null);
    			append_dev(div, t1);
    			mount_component(menunavigation, div, null);
    			append_dev(div, t2);
    			mount_component(templates, div, null);
    			append_dev(div, t3);
    			mount_component(menudashboardnavigation, div, null);
    			append_dev(div, t4);
    			append_dev(div, button);
    			mount_component(int, button, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button, "click", /*onCloseClick*/ ctx[3], false, false, false),
    					listen_dev(div, "click", stop_propagation(/*click_handler*/ ctx[5]), false, false, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*isActive*/ 1) {
    				toggle_class(div, "txcm-menuDrawer-is-active", /*isActive*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menulanguage.$$.fragment, local);
    			transition_in(menunavigation.$$.fragment, local);
    			transition_in(templates.$$.fragment, local);
    			transition_in(menudashboardnavigation.$$.fragment, local);
    			transition_in(int.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menulanguage.$$.fragment, local);
    			transition_out(menunavigation.$$.fragment, local);
    			transition_out(templates.$$.fragment, local);
    			transition_out(menudashboardnavigation.$$.fragment, local);
    			transition_out(int.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(menulanguage);
    			destroy_component(menunavigation);
    			destroy_component(templates);
    			destroy_component(menudashboardnavigation);
    			destroy_component(int);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$P.name,
    		type: "slot",
    		source: "(34:0) <Overlay   {isActive}   on:overlayclose={onOverayClose}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3e(ctx) {
    	let overlay;
    	let current;

    	overlay = new Overlay({
    			props: {
    				isActive: /*isActive*/ ctx[0],
    				$$slots: { default: [create_default_slot$P] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	overlay.$on("overlayclose", /*onOverayClose*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(overlay.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(overlay, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const overlay_changes = {};
    			if (dirty & /*isActive*/ 1) overlay_changes.isActive = /*isActive*/ ctx[0];

    			if (dirty & /*$$scope, isActive*/ 1025) {
    				overlay_changes.$$scope = { dirty, ctx };
    			}

    			overlay.$set(overlay_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(overlay.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(overlay.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(overlay, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3e($$self, $$props, $$invalidate) {
    	let $menu;
    	let $templateUpdate;
    	const menu = getUIState("menu");
    	validate_store(menu, "menu");
    	component_subscribe($$self, menu, value => $$invalidate(7, $menu = value));
    	const templateUpdate = getUIState("templateUpdate");
    	validate_store(templateUpdate, "templateUpdate");
    	component_subscribe($$self, templateUpdate, value => $$invalidate(8, $templateUpdate = value));
    	let isMounted = false;
    	onMount(() => $$invalidate(6, isMounted = true));

    	function close() {
    		set_store_value(menu, $menu = false);
    	}

    	function onCloseClick() {
    		close();
    	}

    	function onOverayClose() {
    		close();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MenuDrawer> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("MenuDrawer", $$slots, []);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	$$self.$capture_state = () => ({
    		onMount,
    		getUIState,
    		Int,
    		Overlay,
    		Templates,
    		MenuLanguage,
    		MenuNavigation,
    		MenuDashboardNavigation,
    		menu,
    		templateUpdate,
    		isMounted,
    		close,
    		onCloseClick,
    		onOverayClose,
    		isActive,
    		$menu,
    		$templateUpdate
    	});

    	$$self.$inject_state = $$props => {
    		if ("isMounted" in $$props) $$invalidate(6, isMounted = $$props.isMounted);
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    	};

    	let isActive;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$menu*/ 128) {
    			 $$invalidate(0, isActive = $menu);
    		}

    		if ($$self.$$.dirty & /*isMounted, $templateUpdate*/ 320) {
    			 if (isMounted && $templateUpdate) setTimeout(close, 5);
    		}
    	};

    	return [isActive, menu, templateUpdate, onCloseClick, onOverayClose, click_handler];
    }

    class MenuDrawer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3e, create_fragment$3e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MenuDrawer",
    			options,
    			id: create_fragment$3e.name
    		});
    	}
    }

    /* src/js/components/menu/Menu.svelte generated by Svelte v3.24.0 */

    function create_fragment$3f(ctx) {
    	let menutoggle;
    	let t;
    	let menudrawer;
    	let current;
    	menutoggle = new MenuToggle({ $$inline: true });
    	menudrawer = new MenuDrawer({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(menutoggle.$$.fragment);
    			t = space();
    			create_component(menudrawer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(menutoggle, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(menudrawer, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menutoggle.$$.fragment, local);
    			transition_in(menudrawer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menutoggle.$$.fragment, local);
    			transition_out(menudrawer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menutoggle, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(menudrawer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3f($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Menu> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Menu", $$slots, []);
    	$$self.$capture_state = () => ({ MenuToggle, MenuDrawer });
    	return [];
    }

    class Menu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3f, create_fragment$3f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Menu",
    			options,
    			id: create_fragment$3f.name
    		});
    	}
    }

    /* src/js/components/title/Title.svelte generated by Svelte v3.24.0 */

    const { Object: Object_1$8 } = globals;

    function create_fragment$3g(ctx) {
    	let title_value;
    	document.title = title_value = "\n    " + /*title*/ ctx[0] + "\n  ";

    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*title*/ 1 && title_value !== (title_value = "\n    " + /*title*/ ctx[0] + "\n  ")) {
    				document.title = title_value;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3g($$self, $$props, $$invalidate) {
    	const config = getContext("app").getAppConfig().dashboards;
    	const { indicators: financialIndicatorsConfig } = config.financial;
    	const { indicators: operationalIndicatorsConfig } = config.operational;

    	const LABELS = {
    		financial: "Финансовый дашборд",
    		operational: "Операционный дашборд"
    	};

    	const INDICATORS = {
    		financial: financialIndicatorsConfig,
    		operational: operationalIndicatorsConfig
    	};

    	let { dashboard } = $$props;
    	let { indicator } = $$props;
    	let { detail } = $$props;

    	function findIndicatorLabel() {
    		if (indicator === "export") return `${LABELS[dashboard]}`;
    		let result;

    		Object.values(INDICATORS[dashboard]).some(({ indicators }) => {
    			const condition = indicators.find(option => option.url === indicator);
    			if (condition) result = condition.label;
    			return condition;
    		});

    		return result;
    	}

    	function findDetailLabel() {
    		if (indicator === "export") return "Выгрузка данных";

    		if (detail) {
    			if (detail === "comparisons") return "Сравнения";
    			return "Факторы";
    		}

    		return "Срезы";
    	}

    	function renderTitle() {
    		if (!indicator) return LABELS[dashboard];
    		const indicatorLabel = findIndicatorLabel();
    		const detailLabel = findDetailLabel();
    		return `${indicatorLabel} – ${detailLabel}`;
    	}

    	const writable_props = ["dashboard", "indicator", "detail"];

    	Object_1$8.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Title> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Title", $$slots, []);

    	$$self.$set = $$props => {
    		if ("dashboard" in $$props) $$invalidate(1, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(2, indicator = $$props.indicator);
    		if ("detail" in $$props) $$invalidate(3, detail = $$props.detail);
    	};

    	$$self.$capture_state = () => ({
    		getContext,
    		config,
    		financialIndicatorsConfig,
    		operationalIndicatorsConfig,
    		LABELS,
    		INDICATORS,
    		dashboard,
    		indicator,
    		detail,
    		findIndicatorLabel,
    		findDetailLabel,
    		renderTitle,
    		title
    	});

    	$$self.$inject_state = $$props => {
    		if ("dashboard" in $$props) $$invalidate(1, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(2, indicator = $$props.indicator);
    		if ("detail" in $$props) $$invalidate(3, detail = $$props.detail);
    		if ("title" in $$props) $$invalidate(0, title = $$props.title);
    	};

    	let title;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*dashboard, indicator, detail*/ 14) {
    			 $$invalidate(0, title = renderTitle());
    		}
    	};

    	return [title, dashboard, indicator, detail];
    }

    class Title extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3g, create_fragment$3g, safe_not_equal, { dashboard: 1, indicator: 2, detail: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Title",
    			options,
    			id: create_fragment$3g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*dashboard*/ ctx[1] === undefined && !("dashboard" in props)) {
    			console.warn("<Title> was created without expected prop 'dashboard'");
    		}

    		if (/*indicator*/ ctx[2] === undefined && !("indicator" in props)) {
    			console.warn("<Title> was created without expected prop 'indicator'");
    		}

    		if (/*detail*/ ctx[3] === undefined && !("detail" in props)) {
    			console.warn("<Title> was created without expected prop 'detail'");
    		}
    	}

    	get dashboard() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set dashboard(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get indicator() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set indicator(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get detail() {
    		throw new Error("<Title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set detail(value) {
    		throw new Error("<Title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/tooltip/Tooltip.svelte generated by Svelte v3.24.0 */
    const file$2I = "src/js/components/tooltip/Tooltip.svelte";

    // (57:6) {#if $tooltip && $tooltip.content}
    function create_if_block$12(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$l, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$tooltip*/ ctx[2].content.component) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$12.name,
    		type: "if",
    		source: "(57:6) {#if $tooltip && $tooltip.content}",
    		ctx
    	});

    	return block;
    }

    // (62:8) {:else}
    function create_else_block$a(ctx) {
    	let t_value = /*$tooltip*/ ctx[2].content + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$tooltip*/ 4 && t_value !== (t_value = /*$tooltip*/ ctx[2].content + "")) set_data_dev(t, t_value);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(62:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (58:8) {#if $tooltip.content.component}
    function create_if_block_1$l(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = /*$tooltip*/ ctx[2].content.component;

    	function switch_props(ctx) {
    		return {
    			props: { data: /*$tooltip*/ ctx[2].content.data },
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = {};
    			if (dirty & /*$tooltip*/ 4) switch_instance_changes.data = /*$tooltip*/ ctx[2].content.data;

    			if (switch_value !== (switch_value = /*$tooltip*/ ctx[2].content.component)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$l.name,
    		type: "if",
    		source: "(58:8) {#if $tooltip.content.component}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3h(ctx) {
    	let div1;
    	let div0;
    	let div1_class_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*$tooltip*/ ctx[2] && /*$tooltip*/ ctx[2].content && create_if_block$12(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div0, "class", "txcm-tooltipContent");
    			add_location(div0, file$2I, 55, 4, 1283);
    			attr_dev(div1, "class", div1_class_value = `txcm-tooltip${/*renderSideClass*/ ctx[5](/*isActive*/ ctx[0])}${/*renderThemeClass*/ ctx[6](/*isActive*/ ctx[0])}`);
    			attr_dev(div1, "style", /*style*/ ctx[1]);
    			toggle_class(div1, "txcm-tooltip-is-active", /*isActive*/ ctx[0]);
    			add_location(div1, file$2I, 51, 0, 1139);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			if (if_block) if_block.m(div0, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(window, "scroll", /*onScroll*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$tooltip*/ ctx[2] && /*$tooltip*/ ctx[2].content) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$tooltip*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$12(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div0, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*isActive*/ 1 && div1_class_value !== (div1_class_value = `txcm-tooltip${/*renderSideClass*/ ctx[5](/*isActive*/ ctx[0])}${/*renderThemeClass*/ ctx[6](/*isActive*/ ctx[0])}`)) {
    				attr_dev(div1, "class", div1_class_value);
    			}

    			if (!current || dirty & /*style*/ 2) {
    				attr_dev(div1, "style", /*style*/ ctx[1]);
    			}

    			if (dirty & /*isActive, isActive*/ 1) {
    				toggle_class(div1, "txcm-tooltip-is-active", /*isActive*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3h($$self, $$props, $$invalidate) {
    	let $tooltip;
    	let $scrollY;
    	const tooltip = getUIState("tooltip");
    	validate_store(tooltip, "tooltip");
    	component_subscribe($$self, tooltip, value => $$invalidate(2, $tooltip = value));
    	const scrollY = getUIState("scrollY");
    	validate_store(scrollY, "scrollY");
    	component_subscribe($$self, scrollY, value => $$invalidate(9, $scrollY = value));
    	let isActive;
    	let showTimeout;

    	function show() {
    		showTimeout = setTimeout(
    			() => {
    				$$invalidate(0, isActive = true);
    			},
    			100
    		);
    	}

    	function hide() {
    		$$invalidate(0, isActive = false);
    	}

    	function updateStatus() {
    		clearTimeout(showTimeout);
    		if ($tooltip) show(); else hide();
    	}

    	function updateStyle() {
    		if ($tooltip) return `transform: translate(${$tooltip.position.x}px, ${$tooltip.position.y + $scrollY}px)`;
    		return "";
    	}

    	function renderSideClass() {
    		if (isActive) {
    			if ($tooltip.side === "bottom") return " txcm-tooltip-is-bottom"; else if ($tooltip.side === "right") return " txcm-tooltip-is-right"; else if ($tooltip.side === "left") return " txcm-tooltip-is-left";
    			return " txcm-tooltip-is-top";
    		}

    		return "";
    	}

    	function renderThemeClass() {
    		if (isActive && $tooltip.theme) return ` ${$tooltip.theme}`;
    		return "";
    	}

    	function onScroll() {
    		hide();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tooltip> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Tooltip", $$slots, []);

    	$$self.$capture_state = () => ({
    		getUIState,
    		tooltip,
    		scrollY,
    		isActive,
    		showTimeout,
    		show,
    		hide,
    		updateStatus,
    		updateStyle,
    		renderSideClass,
    		renderThemeClass,
    		onScroll,
    		style,
    		$tooltip,
    		$scrollY
    	});

    	$$self.$inject_state = $$props => {
    		if ("isActive" in $$props) $$invalidate(0, isActive = $$props.isActive);
    		if ("showTimeout" in $$props) showTimeout = $$props.showTimeout;
    		if ("style" in $$props) $$invalidate(1, style = $$props.style);
    	};

    	let style;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$tooltip*/ 4) {
    			 $$invalidate(1, style = updateStyle());
    		}

    		if ($$self.$$.dirty & /*$tooltip*/ 4) {
    			 updateStatus();
    		}
    	};

    	return [
    		isActive,
    		style,
    		$tooltip,
    		tooltip,
    		scrollY,
    		renderSideClass,
    		renderThemeClass,
    		onScroll
    	];
    }

    class Tooltip extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3h, create_fragment$3h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tooltip",
    			options,
    			id: create_fragment$3h.name
    		});
    	}
    }

    /* src/js/components/aside/AsideMenu.svelte generated by Svelte v3.24.0 */

    // (6:0) <Drawer   store="aside">
    function create_default_slot$Q(ctx) {
    	let asidenavigation;
    	let current;
    	asidenavigation = new AsideNavigation({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(asidenavigation.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(asidenavigation, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(asidenavigation.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(asidenavigation.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(asidenavigation, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$Q.name,
    		type: "slot",
    		source: "(6:0) <Drawer   store=\\\"aside\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3i(ctx) {
    	let drawer;
    	let current;

    	drawer = new Drawer({
    			props: {
    				store: "aside",
    				$$slots: { default: [create_default_slot$Q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(drawer.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(drawer, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const drawer_changes = {};

    			if (dirty & /*$$scope*/ 1) {
    				drawer_changes.$$scope = { dirty, ctx };
    			}

    			drawer.$set(drawer_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(drawer.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(drawer.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(drawer, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3i($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<AsideMenu> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("AsideMenu", $$slots, []);
    	$$self.$capture_state = () => ({ Drawer, AsideNavigation });
    	return [];
    }

    class AsideMenu extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3i, create_fragment$3i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AsideMenu",
    			options,
    			id: create_fragment$3i.name
    		});
    	}
    }

    /* src/js/components/scroll/Scroll.svelte generated by Svelte v3.24.0 */

    function create_fragment$3j(ctx) {
    	let scrolling = false;

    	let clear_scrolling = () => {
    		scrolling = false;
    	};

    	let scrolling_timeout;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowscroll*/ ctx[1]);

    	const block = {
    		c: noop,
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (!mounted) {
    				dispose = listen_dev(window, "scroll", () => {
    					scrolling = true;
    					clearTimeout(scrolling_timeout);
    					scrolling_timeout = setTimeout(clear_scrolling, 100);
    					/*onwindowscroll*/ ctx[1]();
    				});

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*scrollY*/ 1 && !scrolling) {
    				scrolling = true;
    				clearTimeout(scrolling_timeout);
    				scrollTo(window.pageXOffset, /*scrollY*/ ctx[0]);
    				scrolling_timeout = setTimeout(clear_scrolling, 100);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3j($$self, $$props, $$invalidate) {
    	let scrollY;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Scroll> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Scroll", $$slots, []);

    	function onwindowscroll() {
    		$$invalidate(0, scrollY = window.pageYOffset);
    	}

    	$$self.$capture_state = () => ({ updateUI, scrollY });

    	$$self.$inject_state = $$props => {
    		if ("scrollY" in $$props) $$invalidate(0, scrollY = $$props.scrollY);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*scrollY*/ 1) {
    			 updateUI({ scrollY });
    		}
    	};

    	return [scrollY, onwindowscroll];
    }

    class Scroll extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3j, create_fragment$3j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Scroll",
    			options,
    			id: create_fragment$3j.name
    		});
    	}
    }

    /* src/js/components/confirmation/Confirmation.svelte generated by Svelte v3.24.0 */
    const file$2J = "src/js/components/confirmation/Confirmation.svelte";

    // (41:0) <Overlay   {isActive}   on:overlayclose={onOverlayClose}>
    function create_default_slot$R(ctx) {
    	let div2;
    	let div0;
    	let int0;
    	let t0;
    	let div1;
    	let int1;
    	let t1;
    	let button0;
    	let int2;
    	let t2;
    	let button1;
    	let int3;
    	let current;
    	let mounted;
    	let dispose;

    	int0 = new Int({
    			props: { key: /*header*/ ctx[0] },
    			$$inline: true
    		});

    	int1 = new Int({
    			props: { key: /*message*/ ctx[1] },
    			$$inline: true
    		});

    	int2 = new Int({ props: { key: "Отмена" }, $$inline: true });

    	int3 = new Int({
    			props: { key: "Удалить" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			create_component(int0.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(int1.$$.fragment);
    			t1 = space();
    			button0 = element("button");
    			create_component(int2.$$.fragment);
    			t2 = space();
    			button1 = element("button");
    			create_component(int3.$$.fragment);
    			attr_dev(div0, "class", "txcm-confirmationHeader");
    			add_location(div0, file$2J, 47, 8, 971);
    			attr_dev(div1, "class", "txcm-confirmationMessage");
    			add_location(div1, file$2J, 52, 8, 1089);
    			attr_dev(button0, "class", "txcm-confirmationCancel");
    			add_location(button0, file$2J, 57, 8, 1209);
    			attr_dev(button1, "class", "txcm-confirmationAccept");
    			add_location(button1, file$2J, 64, 8, 1397);
    			attr_dev(div2, "class", "txcm-confirmation");
    			toggle_class(div2, "txcm-confirmation-is-active", /*isActive*/ ctx[3]);
    			add_location(div2, file$2J, 43, 4, 843);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			mount_component(int0, div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			mount_component(int1, div1, null);
    			append_dev(div2, t1);
    			append_dev(div2, button0);
    			mount_component(int2, button0, null);
    			/*button0_binding*/ ctx[9](button0);
    			append_dev(div2, t2);
    			append_dev(div2, button1);
    			mount_component(int3, button1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*onCancelClick*/ ctx[5], false, false, false),
    					listen_dev(button1, "click", /*onAcceptClick*/ ctx[6], false, false, false),
    					listen_dev(div2, "click", stop_propagation(/*click_handler*/ ctx[8]), false, false, true)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const int0_changes = {};
    			if (dirty & /*header*/ 1) int0_changes.key = /*header*/ ctx[0];
    			int0.$set(int0_changes);
    			const int1_changes = {};
    			if (dirty & /*message*/ 2) int1_changes.key = /*message*/ ctx[1];
    			int1.$set(int1_changes);

    			if (dirty & /*isActive*/ 8) {
    				toggle_class(div2, "txcm-confirmation-is-active", /*isActive*/ ctx[3]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(int0.$$.fragment, local);
    			transition_in(int1.$$.fragment, local);
    			transition_in(int2.$$.fragment, local);
    			transition_in(int3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(int0.$$.fragment, local);
    			transition_out(int1.$$.fragment, local);
    			transition_out(int2.$$.fragment, local);
    			transition_out(int3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(int0);
    			destroy_component(int1);
    			destroy_component(int2);
    			/*button0_binding*/ ctx[9](null);
    			destroy_component(int3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$R.name,
    		type: "slot",
    		source: "(41:0) <Overlay   {isActive}   on:overlayclose={onOverlayClose}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3k(ctx) {
    	let overlay;
    	let current;

    	overlay = new Overlay({
    			props: {
    				isActive: /*isActive*/ ctx[3],
    				$$slots: { default: [create_default_slot$R] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	overlay.$on("overlayclose", /*onOverlayClose*/ ctx[7]);

    	const block = {
    		c: function create() {
    			create_component(overlay.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(overlay, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const overlay_changes = {};
    			if (dirty & /*isActive*/ 8) overlay_changes.isActive = /*isActive*/ ctx[3];

    			if (dirty & /*$$scope, isActive, cancel, message, header*/ 8207) {
    				overlay_changes.$$scope = { dirty, ctx };
    			}

    			overlay.$set(overlay_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(overlay.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(overlay.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(overlay, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3k($$self, $$props, $$invalidate) {
    	let $confirmation;
    	const confirmation = getUIState("confirmation");
    	validate_store(confirmation, "confirmation");
    	component_subscribe($$self, confirmation, value => $$invalidate(10, $confirmation = value));
    	let header = "";
    	let message = "";
    	let cancel;

    	function updateUI() {
    		if (isActive) {
    			$$invalidate(0, { header, message } = $confirmation, header, $$invalidate(1, message));
    			if (cancel && isActive) cancel.focus();
    		}
    	}

    	function close() {
    		set_store_value(confirmation, $confirmation = null);
    	}

    	function onCancelClick() {
    		if ($confirmation.cancel) $confirmation.cancel();
    		close();
    	}

    	function onAcceptClick() {
    		$confirmation.action();
    		close();
    	}

    	function onOverlayClose() {
    		close();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Confirmation> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("Confirmation", $$slots, []);

    	function click_handler(event) {
    		bubble($$self, event);
    	}

    	function button0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			cancel = $$value;
    			$$invalidate(2, cancel);
    		});
    	}

    	$$self.$capture_state = () => ({
    		getUIState,
    		Int,
    		Overlay,
    		confirmation,
    		header,
    		message,
    		cancel,
    		updateUI,
    		close,
    		onCancelClick,
    		onAcceptClick,
    		onOverlayClose,
    		isActive,
    		$confirmation
    	});

    	$$self.$inject_state = $$props => {
    		if ("header" in $$props) $$invalidate(0, header = $$props.header);
    		if ("message" in $$props) $$invalidate(1, message = $$props.message);
    		if ("cancel" in $$props) $$invalidate(2, cancel = $$props.cancel);
    		if ("isActive" in $$props) $$invalidate(3, isActive = $$props.isActive);
    	};

    	let isActive;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$confirmation*/ 1024) {
    			 $$invalidate(3, isActive = !!$confirmation);
    		}

    		if ($$self.$$.dirty & /*isActive*/ 8) {
    			 updateUI();
    		}
    	};

    	return [
    		header,
    		message,
    		cancel,
    		isActive,
    		confirmation,
    		onCancelClick,
    		onAcceptClick,
    		onOverlayClose,
    		click_handler,
    		button0_binding
    	];
    }

    class Confirmation extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3k, create_fragment$3k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Confirmation",
    			options,
    			id: create_fragment$3k.name
    		});
    	}
    }

    /* src/js/components/page/DashboardPage.svelte generated by Svelte v3.24.0 */

    function create_fragment$3l(ctx) {
    	let header;
    	let t0;
    	let menu;
    	let t1;
    	let asidemenu;
    	let t2;
    	let switch_instance;
    	let t3;
    	let tooltip;
    	let t4;
    	let confirmation;
    	let t5;
    	let title;
    	let t6;
    	let scroll;
    	let current;

    	header = new Header({
    			props: {
    				dashboard: /*dashboard*/ ctx[0],
    				indicator: /*indicator*/ ctx[1]
    			},
    			$$inline: true
    		});

    	menu = new Menu({ $$inline: true });
    	asidemenu = new AsideMenu({ $$inline: true });
    	var switch_value = /*pickDashboard*/ ctx[3](/*dashboard*/ ctx[0]);

    	function switch_props(ctx) {
    		return {
    			props: {
    				options: {
    					dashboard: /*dashboard*/ ctx[0],
    					indicator: /*indicator*/ ctx[1],
    					detail: /*detail*/ ctx[2],
    					location
    				}
    			},
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props(ctx));
    	}

    	tooltip = new Tooltip({ $$inline: true });
    	confirmation = new Confirmation({ $$inline: true });

    	title = new Title({
    			props: {
    				dashboard: /*dashboard*/ ctx[0],
    				indicator: /*indicator*/ ctx[1],
    				detail: /*detail*/ ctx[2]
    			},
    			$$inline: true
    		});

    	scroll = new Scroll({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(header.$$.fragment);
    			t0 = space();
    			create_component(menu.$$.fragment);
    			t1 = space();
    			create_component(asidemenu.$$.fragment);
    			t2 = space();
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			t3 = space();
    			create_component(tooltip.$$.fragment);
    			t4 = space();
    			create_component(confirmation.$$.fragment);
    			t5 = space();
    			create_component(title.$$.fragment);
    			t6 = space();
    			create_component(scroll.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(header, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(menu, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(asidemenu, target, anchor);
    			insert_dev(target, t2, anchor);

    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, t3, anchor);
    			mount_component(tooltip, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(confirmation, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(title, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(scroll, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const header_changes = {};
    			if (dirty & /*dashboard*/ 1) header_changes.dashboard = /*dashboard*/ ctx[0];
    			if (dirty & /*indicator*/ 2) header_changes.indicator = /*indicator*/ ctx[1];
    			header.$set(header_changes);
    			const switch_instance_changes = {};

    			if (dirty & /*dashboard, indicator, detail*/ 7) switch_instance_changes.options = {
    				dashboard: /*dashboard*/ ctx[0],
    				indicator: /*indicator*/ ctx[1],
    				detail: /*detail*/ ctx[2],
    				location
    			};

    			if (switch_value !== (switch_value = /*pickDashboard*/ ctx[3](/*dashboard*/ ctx[0]))) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props(ctx));
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, t3.parentNode, t3);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}

    			const title_changes = {};
    			if (dirty & /*dashboard*/ 1) title_changes.dashboard = /*dashboard*/ ctx[0];
    			if (dirty & /*indicator*/ 2) title_changes.indicator = /*indicator*/ ctx[1];
    			if (dirty & /*detail*/ 4) title_changes.detail = /*detail*/ ctx[2];
    			title.$set(title_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(header.$$.fragment, local);
    			transition_in(menu.$$.fragment, local);
    			transition_in(asidemenu.$$.fragment, local);
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			transition_in(tooltip.$$.fragment, local);
    			transition_in(confirmation.$$.fragment, local);
    			transition_in(title.$$.fragment, local);
    			transition_in(scroll.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(header.$$.fragment, local);
    			transition_out(menu.$$.fragment, local);
    			transition_out(asidemenu.$$.fragment, local);
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			transition_out(tooltip.$$.fragment, local);
    			transition_out(confirmation.$$.fragment, local);
    			transition_out(title.$$.fragment, local);
    			transition_out(scroll.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(header, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(menu, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(asidemenu, detaching);
    			if (detaching) detach_dev(t2);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(tooltip, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(confirmation, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(title, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(scroll, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3l($$self, $$props, $$invalidate) {
    	const DASHBOARDS = {
    		financial: DashboardFinancial,
    		operational: DashboardOperational
    	};

    	let { params = {} } = $$props;
    	initExport();
    	initDashboard(params.dashboard);

    	function pickDashboard(key) {
    		return DASHBOARDS.operational;
    	}

    	const writable_props = ["params"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DashboardPage> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DashboardPage", $$slots, []);

    	$$self.$set = $$props => {
    		if ("params" in $$props) $$invalidate(4, params = $$props.params);
    	};

    	$$self.$capture_state = () => ({
    		initDashboard,
    		initExport,
    		DashboardFinancial,
    		DashboardOperational,
    		Header,
    		Menu,
    		Title,
    		Tooltip,
    		AsideMenu,
    		Scroll,
    		Confirmation,
    		location,
    		DASHBOARDS,
    		params,
    		pickDashboard,
    		dashboard,
    		indicator,
    		detail
    	});

    	$$self.$inject_state = $$props => {
    		if ("params" in $$props) $$invalidate(4, params = $$props.params);
    		if ("dashboard" in $$props) $$invalidate(0, dashboard = $$props.dashboard);
    		if ("indicator" in $$props) $$invalidate(1, indicator = $$props.indicator);
    		if ("detail" in $$props) $$invalidate(2, detail = $$props.detail);
    	};

    	let dashboard;
    	let indicator;
    	let detail;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*params*/ 16) {
    			 $$invalidate(0, dashboard = params.dashboard);
    		}

    		if ($$self.$$.dirty & /*params*/ 16) {
    			 $$invalidate(1, [indicator, detail] = params.wild ? params.wild.split("/") : [null, null], indicator, ($$invalidate(2, detail), $$invalidate(4, params)));
    		}
    	};

    	return [dashboard, indicator, detail, pickDashboard, params];
    }

    class DashboardPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3l, create_fragment$3l, safe_not_equal, { params: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DashboardPage",
    			options,
    			id: create_fragment$3l.name
    		});
    	}

    	get params() {
    		throw new Error("<DashboardPage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set params(value) {
    		throw new Error("<DashboardPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/page/DefaultPage.svelte generated by Svelte v3.24.0 */

    function create_fragment$3m(ctx) {
    	const block = {
    		c: function create() {
    			document.title = "\n    Редирект...\n  ";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: noop,
    		p: noop,
    		i: noop,
    		o: noop,
    		d: noop
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3m($$self, $$props, $$invalidate) {
    	let { location } = $$props;
    	onMount(() => replace("/dashboard/operational"));
    	const writable_props = ["location"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DefaultPage> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("DefaultPage", $$slots, []);

    	$$self.$set = $$props => {
    		if ("location" in $$props) $$invalidate(0, location = $$props.location);
    	};

    	$$self.$capture_state = () => ({ onMount, replace, location });

    	$$self.$inject_state = $$props => {
    		if ("location" in $$props) $$invalidate(0, location = $$props.location);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [location];
    }

    class DefaultPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3m, create_fragment$3m, safe_not_equal, { location: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DefaultPage",
    			options,
    			id: create_fragment$3m.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*location*/ ctx[0] === undefined && !("location" in props)) {
    			console.warn("<DefaultPage> was created without expected prop 'location'");
    		}
    	}

    	get location() {
    		throw new Error("<DefaultPage>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set location(value) {
    		throw new Error("<DefaultPage>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src/js/components/page/InitializationPage.svelte generated by Svelte v3.24.0 */

    function create_fragment$3n(ctx) {
    	let loader;
    	let t;
    	let current;
    	loader = new Loader({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(loader.$$.fragment);
    			t = space();
    			document.title = "\n    Инициализация...\n  ";
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(loader, target, anchor);
    			insert_dev(target, t, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(loader.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(loader.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(loader, detaching);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3n($$self, $$props, $$invalidate) {
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<InitializationPage> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("InitializationPage", $$slots, []);
    	$$self.$capture_state = () => ({ Loader });
    	return [];
    }

    class InitializationPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3n, create_fragment$3n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InitializationPage",
    			options,
    			id: create_fragment$3n.name
    		});
    	}
    }

    /* src/js/components/App.svelte generated by Svelte v3.24.0 */

    // (27:0) {:else}
    function create_else_block$b(ctx) {
    	let router;
    	let current;

    	router = new Router({
    			props: { routes: /*routes*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(27:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (25:0) {#if !$initialized}
    function create_if_block$13(ctx) {
    	let initializationpage;
    	let current;
    	initializationpage = new InitializationPage({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(initializationpage.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(initializationpage, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(initializationpage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(initializationpage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(initializationpage, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$13.name,
    		type: "if",
    		source: "(25:0) {#if !$initialized}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3o(ctx) {
    	let defs;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	defs = new Defs({ $$inline: true });
    	const if_block_creators = [create_if_block$13, create_else_block$b];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*$initialized*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			create_component(defs.$$.fragment);
    			t = space();
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(defs, target, anchor);
    			insert_dev(target, t, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(defs.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(defs.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(defs, detaching);
    			if (detaching) detach_dev(t);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3o($$self, $$props, $$invalidate) {
    	let $initialized;
    	const initialized = getUIState("initialized");
    	validate_store(initialized, "initialized");
    	component_subscribe($$self, initialized, value => $$invalidate(0, $initialized = value));

    	const routes = {
    		"/dashboard/:dashboard": DashboardPage,
    		"/dashboard/:dashboard/*": DashboardPage,
    		"*": DefaultPage
    	};

    	setContext("app", { getAppConfig: () => CONFIG });
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	let { $$slots = {}, $$scope } = $$props;
    	validate_slots("App", $$slots, []);

    	$$self.$capture_state = () => ({
    		setContext,
    		Router,
    		CONFIG,
    		getUIState,
    		Defs,
    		DashboardPage,
    		DefaultPage,
    		InitializationPage,
    		initialized,
    		routes,
    		$initialized
    	});

    	return [$initialized, initialized, routes];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3o, create_fragment$3o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$3o.name
    		});
    	}
    }

    /* eslint no-new: 'off' */

    function calcualteMinDate([ dates ]) {
      const date = dates[0];
      return Date.UTC(date.year, (date.month - 1), date.day);
    }

    function calcualteMaxDate([ dates ]) {
      const date = dates[dates.length - 1];
      return Date.UTC(date.year, (date.month - 1), date.day);
    }

    function calculateStartDate([ dates ], dateMax) {
      const picked = dates
        .slice()
        .reverse()
        .find(date => date.picked);
      if (picked) return Date.UTC(picked.year, (picked.month - 1), picked.day);
      const exist = dates
        .slice()
        .reverse()
        .find(date => date.dateDataExist);
      if (exist) return Date.UTC(exist.year, (exist.month - 1), exist.day);
      return dateMax;
    }

    function initApp() {
      initUI();
    }

    function mountApp() {
      window.removeEventListener('proxyready', mountApp);
      initApp();
      new App({ target: document.body });
      requestMeta()
        .then(startApp);
    }

    function startApp([ templates, dates ]) {
      console.log("START APP", dates);
      const dateMin = calcualteMinDate(dates);
      const dateMax = calcualteMaxDate(dates);
      const dateStart = calculateStartDate(dates, dateMax);
      updateConfig({ dateMin, dateMax, dateStart, dates });
      updateUI({ templates, initialized: true });
    }

    window.addEventListener('proxyready', mountApp);

}());
//# sourceMappingURL=scripts.js.map
